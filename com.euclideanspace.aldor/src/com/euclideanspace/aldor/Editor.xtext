grammar com.euclideanspace.aldor.Editor hidden ()

import "http://www.eclipse.org/emf/2002/Ecore" as ecore

generate editor "http://www.euclideanspace.com/aldor/Editor"

/* Copyright 2014 Martin John Baker
 *
 * This file is part of EuclideanSpace.
 *
 * EuclideanSpace is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * EuclideanSpace is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with EuclideanSpace. If not, see <http://www.gnu.org/licenses/>.
 */

/*
 *
 * Here we are using a LL(*) recursive-descent parser generator and this
 * may not be able to exactly replicate axl.z which is a
 * LALR(1) conflict-free grammar for Aldor.
 */

/* from tokInfoTable[] in token.c: Lexical elements.
* The TokenTag enumeration must use this order.
*
* This table MUST be laid out so that all "symbol" tokens starting with
* the same character are contiguous.
*
* Be extra careful with fields F, G, H and K: if you get them wrong then
* the lineariser will delete end-of-statement tokens when it ought not
* to. This can lead to odd compiler behaviour that is hard to track down
* unless you know about this table.
*
* struct tok_info tokInfoTable[] = {
*
* [A] TokenTag tag
* [B] Symbol sym
* [C] String str
* [D] Byte hasString i.e. use val.str (vs val.sym)
* [E] Byte isComment i.e. ++ --
* [F] Byte isOpener i.e. ( [ { etc
* [G] Byte isCloser i.e. ) ] } etc
* [H] Byte isFollower i.e. then else always in etc
* [I] Byte isLangword i.e. if then etc
* [J] Byte isLeftAssoc i.e., associates left to right
* [K] Byte isMaybeInfix i.e., add, with, +
* [L] Byte precedence i.e., 0 is lowest, or don't know
* [M] Byte isDisabled i.e., non-zero means disabled
*
* [A] [B][C] [D][E] [F] [G] [H] [I] [J] [K] [L] [M]
*
        {TK_Blank, 0,"TK_Blank", 0, 0, 0, 0, 0, 0, 1, 0, 170, 0},
        {TK_FLOAT, 0,"TK_FLOAT", 1, 0, 0, 0, 0, 0, 1, 0, 170, 0},
        {TK_SysCmd, 0,"TK_SysCmd", 1, 1, 0, 0, 0, 0, 1, 0, 170, 0},
        {TK_Error, 0,"TK_Error", 1, 0, 0, 0, 0, 0, 1, 0, 0, 0},

        {KW_Add, 0,"add", 0, 0, 0, 0, 0, 1, 1, 0, 0, 0},
        {KW_And, 0,"and", 0, 0, 0, 0, 1, 1, 1, 1, 40, 0},
        {KW_Always, 0,"always", 0, 0, 0, 0, 1, 1, 1, 1, 0, 0},
        {KW_Assert, 0,"assert", 0, 0, 0, 0, 0, 1, 1, 0, 0, 0},
        {KW_Break, 0,"break", 0, 0, 0, 0, 0, 1, 1, 0, 0, 0},
        {KW_But, 0,"but", 0, 0, 0, 0, 1, 1, 1, 1, 0, 0},
        {KW_By, 0,"by", 0, 0, 0, 0, 0, 0, 1, 1, 110, 0},
        {KW_CASE, 0,"case", 0, 0, 0, 0, 0, 0, 1, 1, 0, 0},
        {KW_Catch, 0,"catch", 0, 0, 0, 0, 1, 1, 1, 1, 0, 0},
        {KW_Default, 0,"default", 0, 0, 0, 0, 0, 1, 1, 0, 0, 0},
        {KW_Define, 0,"define", 0, 0, 0, 0, 0, 1, 1, 0, 0, 0},
        {KW_Delay, 0,"delay", 0, 0, 0, 0, 0, 1, 1, 0, 0, 0},
        {KW_Do, 0,"do", 0, 0, 0, 0, 0, 1, 1, 0, 0, 0},
        {KW_Else, 0,"else", 0, 0, 0, 0, 1, 1, 1, 0, 0, 0},
        {KW_Except, 0,"except", 0, 0, 0, 0, 0, 1, 1, 1, 0, 0},
        {KW_Export, 0,"export", 0, 0, 0, 0, 0, 1, 1, 0, 0, 0},
        {KW_Exquo, 0,"exquo", 0, 0, 0, 0, 0, 0, 1, 1, 125, 0},
        {KW_Extend, 0,"extend", 0, 0, 0, 0, 0, 1, 1, 0, 0, 0},
        {KW_Finally, 0,"finally", 0, 0, 0, 0, 1, 1, 1, 1, 0, 0},
        {KW_Fix, 0,"fix", 0, 0, 0, 0, 0, 1, 1, 0, 0, 0},
        {KW_For, 0,"for", 0, 0, 0, 0, 0, 1, 1, 0, 0, 0},
        {KW_Fluid, 0,"fluid", 0, 0, 0, 0, 0, 1, 1, 0, 0, 0},
        {KW_Free, 0,"free", 0, 0, 0, 0, 0, 1, 1, 0, 0, 0},
        {KW_From, 0,"from", 0, 0, 0, 0, 1, 1, 1, 0, 0, 0},
        {KW_Generate, 0,"generate", 0, 0, 0, 0, 0, 1, 1, 0, 0, 0},
        {KW_Goto, 0,"goto", 0, 0, 0, 0, 0, 1, 1, 0, 0, 0},
        {KW_Has, 0,"has", 0, 0, 0, 0, 0, 0, 1, 1, 40, 0},
        {KW_If, 0,"if", 0, 0, 0, 0, 0, 1, 1, 0, 0, 0},
        {KW_Import, 0,"import", 0, 0, 0, 0, 0, 1, 1, 0, 0, 0},
        {KW_In, 0,"in", 0, 0, 0, 0, 1, 1, 1, 1, 0, 0},
        {KW_Inline, 0,"inline", 0, 0, 0, 0, 0, 1, 1, 0, 0, 0},
        {KW_IS, 0,"is", 0, 0, 0, 0, 0, 1, 1, 0, 0, 0},
        {KW_ISNT, 0,"isnt", 0, 0, 0, 0, 0, 1, 1, 0, 0, 0},
        {KW_Iterate, 0,"iterate", 0, 0, 0, 0, 0, 1, 1, 0, 0, 0},
        {KW_Let, 0,"let", 0, 0, 0, 0, 0, 1, 1, 0, 0, 0},
        {KW_Local, 0,"local", 0, 0, 0, 0, 0, 1, 1, 0, 0, 0},
        {KW_Macro, 0,"macro", 0, 0, 0, 0, 0, 1, 1, 0, 0, 0},
        {KW_Mod, 0,"mod", 0, 0, 0, 0, 0, 0, 1, 1, 125, 0},
        {KW_Never, 0,"never", 0, 0, 0, 0, 0, 1, 1, 0, 0, 0},
        {KW_Not, 0,"not", 0, 0, 0, 0, 0, 1, 1, 1, 150, 0},
        {KW_Of, 0,"of", 0, 0, 0, 0, 1, 1, 1, 1, 40, 0},
        {KW_Or, 0,"or", 0, 0, 0, 0, 1, 1, 1, 1, 40, 0},
        {KW_Pretend, 0,"pretend", 0, 0, 0, 0, 1, 1, 1, 1, 150, 0},
        {KW_Quo, 0,"quo", 0, 0, 0, 0, 0, 0, 1, 1, 125, 0},
        {KW_Reference, 0,"ref", 0, 0, 0, 0, 0, 1, 1, 0, 0, 0},
        {KW_Rem, 0,"rem", 0, 0, 0, 0, 0, 0, 1, 1, 125, 0},
        {KW_Repeat, 0,"repeat", 0, 0, 0, 0, 0, 1, 1, 0, 0, 0},
        {KW_Return, 0,"return", 0, 0, 0, 0, 0, 1, 1, 0, 0, 0},
        {KW_Rule, 0,"rule", 0, 0, 0, 0, 0, 1, 1, 0, 0, 0},
        {KW_Select, 0,"select", 0, 0, 0, 0, 0, 1, 1, 0, 0, 0},
        {KW_Then, 0,"then", 0, 0, 0, 0, 1, 1, 1, 0, 0, 0},
        {KW_Throw, 0,"throw", 0, 0, 0, 0, 0, 1, 1, 1, 0, 0},
        {KW_To, 0,"to", 0, 0, 0, 0, 1, 1, 1, 0, 0, 0},
        {KW_Try, 0,"try", 0, 0, 0, 0, 0, 1, 1, 0, 0, 0},
        {KW_Where, 0,"where", 0, 0, 0, 0, 1, 1, 1, 0, 0, 0},
        {KW_While, 0,"while", 0, 0, 0, 0, 0, 1, 1, 0, 0, 0},
        {KW_With, 0,"with", 0, 0, 0, 0, 0, 1, 1, 0, 0, 0},
        {KW_Yield, 0,"yield", 0, 0, 0, 0, 0, 1, 1, 0, 0, 0},

        {KW_Grave, 0,"`", 0, 0, 0, 0, 0, 0, 1, 0, 0, 0},
        

        {KW_LARROW, 0,"<-", 0, 0, 0, 0, 0, 0, 1, 1, 0, 0},



        {KW_STARtPile, 0,"#pile", 0, 0, 0, 0, 0, 0, 1, 0, 0, 0},
        {KW_EndPile, 0,"#endpile", 0, 0, 0, 0, 0, 0, 1, 0, 0, 0},
        {KW_SetTab, 0,"KW_SetTab", 0, 0, 0, 0, 0, 0, 1, 0, 0, 0},
        {KW_BackSet, 0,"KW_BackSet", 0, 0, 0, 0, 0, 0, 1, 0, 0, 0},
        {KW_BackTab, 0,"KW_BackTab", 0, 0, 0, 0, 0, 0, 1, 0, 0, 0},
        {KW_Juxtapose, 0,"KW_Juxtapose",0, 0, 0, 0, 0, 0, 0, 0, 170, 0},

        {TK_LIMIT, 0,"TK_LIMIT", 0, 0, 0, 0, 0, 0, 1, 0, 0, 0}
};
*/

/*
 * replaces Goal rule in Aldor grammar
 * 
 * #include is not in axl.z grammar, I assume the includes are
 * done before the grammar is called. So I have added include
 * support here.
 * 
 * Goal
 * : CurlyContents(Labeled)
 * { yypval = $$ = $1; }
 * ;
 * 
 */
Model hidden(WS,KW_NEWLINE):
  ('#include' insert+=TK_STRING)*
  cc=CurlyContents_Labeled
;


////////// start of lexer rules ///////////////

/* ID consists of alpha (upper or lower case) followed by alphanumeric
 * any other character can stand in for alpha if prefixed by '_'
 * for instance a multiply function is often named '_*'
 * IDs can also end with ? or ! where:
 * '?' indicates a function which returns a boolean value
 * '!' indicates a function which changes an existing domain value
 * (in a mutable domain)
        {TK_ID, 0,"TK_ID", 0, 0, 0, 0, 0, 0, 1, 0, 170, 0},
 */
terminal TK_ID : ('a'..'z'|'A'..'Z'|('_'.)) ('a'..'z'|'A'..'Z'|('_'.)|'0'..'9')*'!'?'?'?;

/* whitespace on single line overrides default whitespace
 * does not include newline unless it follows underscore.
 * I would have liked to do this as follows:
 * terminal WS : (' '|'\t'|'_'(('\r'|'\n')+))+;
 * problem: unfortunately use of underscore in this way masks the use of underscore
 * in ID. We therefore need to remove this type of underscore in a
 * preprocessor
 */
terminal WS : (' '|'\t')+;

/* at least one newline or carriage return character.
 * This is not included with WS because whitespace is significant in SPAD.
 * We usually absorb newlines like this: NL+ which absorbs any number of
 * blank lines and it also supports both the Linux and the Windows forms of
 * newlines.
 * {KW_NewLine, 0,"\n", 0, 0, 0, 0, 0, 0, 1, 0, 0, 0},
 */
terminal KW_NEWLINE: ('\r'|'\n') ;

/* overwriting TK_COMMENTS we do not want Java syntax (//) but spad syntax (--)
 * This absorbs everything from '--' or '++' to the end of the line (but not
 * including the newline or carriage return characters)
 * 
 *  {TK_PREDOC, 0,"TK_PREDOC", 1, 1, 0, 0, 0, 0, 1, 0, 170, 0},
    {TK_POSTDOC, 0,"TK_POSTDOC", 1, 1, 0, 0, 0, 0, 1, 0, 170, 0},
    {TK_COMMENT, 0,"TK_COMMENT", 1, 1, 0, 0, 0, 0, 1, 0, 170, 0},
 */
//terminal TK_COMMENT :
//  ('--'|'++') !('\n'|'\r')* ;//('\r'|'\n')?;

terminal TK_PREDOC :
  ('--') !('\n'|'\r')* ;//('\r'|'\n')?;

terminal TK_POSTDOC :
  ('++') !('\n'|'\r')* ;//('\r'|'\n')?;

/* Macro value can be anything until the end of line
 * Macro is really '==>' but the pre-processor inserts an extra '=' so
 * that we can distinguish from where ==> is used in 'with' or 'add' parts
 * It is difficult for a LL(*) parser to handle macros so we want to
 * substitute the macro in a pre-processor */
terminal MACROVALUE :
  '===>' !('\n'|'\r')*;

/* '==>' is used in 'with' or 'add' parts so is not really a macro?
 */
//terminal MACRO:
// '==>'
//;

/* string literals are enclosed in double quotes
 *         {TK_STRING, 0,"TK_STRING", 1, 0, 0, 0, 0, 0, 1, 0, 170, 0},
 
*/
terminal TK_STRING :
'"' ( !('"') )* '"'
;
/*
 * Integer
 *
 * {TK_INT, 0,"TK_INT", 1, 0, 0, 0, 0, 0, 1, 0, 170, 0},
 */
terminal TK_INT returns ecore::EInt: ('0'..'9')+;

/* grouping
* {KW_OBBrack, 0,"[|", 0, 0, 1, 0, 0, 0, 1, 0, 0, 0},
* {KW_OBCurly, 0,"{|", 0, 0, 1, 0, 0, 0, 1, 0, 0, 0},
* {KW_OBParen, 0,"(|", 0, 0, 1, 0, 0, 0, 1, 0, 0, 0},
* 
* {KW_CBBrack, 0,"|]", 0, 0, 0, 1, 0, 0, 1, 0, 0, 0},
* {KW_CBCurly, 0,"|}", 0, 0, 0, 1, 0, 0, 1, 0, 0, 0},
* {KW_CBParen, 0,"|)", 0, 0, 0, 1, 0, 0, 1, 0, 0, 0},
* {KW_2Bar, 0,"||", 0, 0, 0, 0, 0, 1, 1, 0, 0, 0},
* 
*/

/* '
* {KW_QUOTE, 0,"'", 0, 0, 0, 0, 0, 0, 1, 0, 0, 0},
*/
terminal KW_QUOTE: "'";
/* (
* {KW_OPAREN, 0,"(", 0, 0, 1, 0, 0, 0, 1, 0, 0, 0},
*/
terminal KW_OPAREN: '(';
/* )
* {KW_CPAREN, 0,")", 0, 0, 0, 1, 0, 0, 1, 0, 0, 0},
*/
terminal KW_CPAREN: ')';
/* {
* {KW_OCURLY, 0,"{", 0, 0, 1, 0, 0, 0, 1, 0, 0, 0},
*/
terminal KW_OCURLY: '{';
/* }
* {KW_CCURLY, 0,"}", 0, 0, 0, 1, 0, 0, 1, 0, 0, 0},
*/
terminal KW_CCURLY: '}';
/* [
* {KW_OBRACK, 0,"[", 0, 0, 1, 0, 0, 0, 1, 0, 0, 0},
*/
terminal KW_OBRACK: '[';
/* ]
* {KW_CBRACK, 0,"]", 0, 0, 0, 1, 0, 0, 1, 0, 0, 0},
*/
terminal KW_CBRACK: ']';
/*
terminal LBANANA '(|';
terminal RBANANA '|)';
terminal EBRACKET '[__]';
terminal EBRACKET2 '[]';
terminal EBRACE '{__}';
terminal EBRACE2 '{}';
terminal LBANANABRACKET '[|';
terminal RBANANABRACKET '|]';
terminal EBANANABRACKET '[|__|]';
terminal EBANANABRACKET2 '[||]';
terminal LBANANABRACE '{|';
terminal RBANANABRACE '|}';
terminal EBANANABRACE '{|__|}';
terminal EBANANABRACE2 '{||}'; */
/* <<
* {KW_2LT, 0,"<<", 0, 0, 0, 0, 0, 0, 1, 1, 100, 0},
*/
terminal KW_2LT: '<<';
/* >>
* {KW_2GT, 0,">>", 0, 0, 0, 0, 0, 0, 1, 1, 100, 0},
*/
terminal KW_2GT: '>>';
/*terminal QUOTE "'";
terminal BACKQUOTE "`";*/

// operators
/* ==> MDEF or MARROW
* {KW_MARROW, 0,"==>", 0, 0, 0, 0, 1, 0, 0, 1, 25, 0},
*/
terminal KW_MARROW: '==>';
/* |
* {KW_Bar, 0,"|", 0, 0, 0, 0, 0, 0, 1, 0, 0, 0},
*/
terminal KW_BAR: '|';
/* .
* {KW_DOT, 0,".", 0, 0, 0, 0, 1, 0, 1, 1, 170, 0},
*/
terminal KW_DOT: '.';
/* :: 2Colon or coerce
* {KW_2Colon, 0,"::", 0, 0, 0, 0, 1, 0, 1, 1, 150, 0},
*/
terminal KW_2COLON: '::';
/* :*
* {KW_ColonStar, 0,":*", 0, 0, 0, 0, 1, 0, 1, 1, 36, 0},
*/
terminal KW_COLONSTAR: ':*';
/* :
* {KW_Colon, 0,":", 0, 0, 0, 0, 1, 0, 1, 1, 36, 0},
*/
terminal KW_COLON: ':';
/* @
* {KW_At, 0,"@", 0, 0, 0, 0, 0, 0, 1, 1, 150, 0},
*/
terminal KW_AT: '@';
/* , 
 * {KW_Comma, 0,",", 0, 0, 0, 0, 1, 0, 1, 1, 11, 0},
 */
terminal KW_COMMA: ',';
/* ;
* {KW_SEMICOLON, 0,";", 0, 0, 0, 0, 0, 0, 1, 0, 10, 0},
*/
terminal KW_SEMICOLON: ';';
/* ** 2star or power
* {KW_2STAR, 0,"**", 0, 0, 0, 0, 0, 0, 1, 1, 140, 0},
*/
terminal KW_2STAR: '**';
/* * times or star
* {KW_STAR, 0,"*", 0, 0, 0, 0, 0, 0, 1, 1, 130, 0},
*/
terminal KW_STAR: '*';
/* + plus
* {KW_PLUS, 0,"+", 0, 0, 0, 0, 0, 0, 1, 1, 120, 0},
*/
terminal KW_PLUS: '+';
/* -
* {KW_MINUS, 0,"-", 0, 0, 0, 0, 0, 0, 1, 1, 120, 0},
*/
terminal KW_MINUS: '-';
/* +-
* {KW_PLUSMINUS, 0,"+-", 0, 0, 0, 0, 0, 0, 1, 1, 120, 0},
*/
terminal KW_PLUSMINUS: '+-';
/* <
* {KW_GT, 0,">", 0, 0, 0, 0, 0, 0, 1, 1, 100, 0},
* {KW_GE, 0,">=", 0, 0, 0, 0, 0, 0, 1, 1, 100, 0},
* {KW_LT, 0,"<", 0, 0, 0, 0, 0, 0, 1, 1, 100, 0},
* {KW_LE, 0,"<=", 0, 0, 0, 0, 0, 0, 1, 1, 100, 0},
*/
terminal KW_LT: '<';
/* > */
terminal KW_GT: '>';
/* <= */
terminal KW_LE: '<=';
/* >= */
terminal KW_GE: '>=';
/* = equal
* {KW_EQ, 0,"=", 0, 0, 0, 0, 0, 0, 1, 1, 100, 0},
*/
terminal KW_EQ: '=';
/* ~= not-equal or tilde-equal
 * {KW_TILDEE, 0,"~=", 0, 0, 0, 0, 0, 0, 1, 1, 90, 0},
 */
terminal KW_TILDEE: '~=';
/* ^= hat-equal
* {KW_HATE, 0,"^=", 0, 0, 0, 0, 0, 0, 1, 1, 90, 0},
*/
terminal KW_HATE: '^=';
/* ~
* {KW_TILDE, 0,"~", 0, 0, 0, 0, 0, 0, 0, 1, 150, 0},
*/
terminal KW_TILDE: '~';
/* ^ hat or carat
* {KW_HAT, 0,"^", 0, 0, 0, 0, 0, 0, 1, 1, 140, 0},
*/
terminal KW_HAT: '^';
/* .. 2Dot or seg
*{KW_2DOT, 0,"..", 0, 0, 0, 0, 0, 0, 1, 1, 110, 0},
* 
*/
terminal KW_2DOT: '..';
/* # Hash or Sharp
* {KW_SHARP, 0,"#", 0, 0, 0, 0, 0, 0, 1, 0, 0, 0},
*/
terminal KW_SHARP: '#';
/* &
* {KW_Ampersand, 0,"&", 0, 0, 0, 0, 0, 0, 1, 0, 160, 0},
*/
terminal KW_AMPERSAND: '&';
/* $
* {KW_DOLLAR, 0,"$", 0, 0, 0, 0, 1, 0, 0, 1, 70, 0},
*/
terminal KW_DOLLAR: '$';
/* /
* {KW_SLASH, 0,"/", 0, 0, 0, 0, 0, 0, 1, 1, 130, 0},
*/
terminal KW_SLASH: '/';
/*
 * {KW_BACKSLASH, 0,"\\", 0, 0, 0, 0, 0, 0, 1, 1, 130, 0},
 */
terminal KW_BACKSLASH: '\\';
terminal SLASHSLASH: '//';
terminal BACKSLASHBACKSLASH: '\\\\';
/* '/\\' SLASH-BACKSLASH or wedge
 * outer product or logical 'and'
* {KW_WEDGE, 0,"/\\", 0, 0, 0, 0, 0, 0, 1, 1, 40, 0},
*/
terminal KW_WEDGE: '/\\';
/* \\/ BACKSLASH-SLASH or vee
* inner product or logical 'or'
* {KW_VEE, 0,"\\/", 0, 0, 0, 0, 0, 0, 1, 1, 40, 0},
*/
terminal KW_VEE: '\\/';
/* *$ multiply with specific type*/
terminal TIMESDOLAR: '*$';
/* /$ divide with specific type*/
terminal DIVDOLAR: '/$';
/* +$ add with specific type*/
terminal PLUSDOLAR: '+$';
/* -$ subtract or minus with specific type*/
terminal MINUSDOLAR: '-$';
/* =$ equals with specific type*/
terminal EQUALSDOLAR: '=$';
/* '=>' implies or exit
* {KW_Implies, 0,"=>", 0, 0, 0, 0, 0, 0, 1, 1, 35, 0},
*/
terminal KW_IMPLIES: '=>';
/* := Assign or Becomes
* {KW_Assign, 0,":=", 0, 0, 0, 0, 1, 0, 0, 1, 20, 0},
*/
terminal KW_ASSIGN: ':=';
/* == 2eq or def
* {KW_2EQ, 0,"==", 0, 0, 0, 0, 1, 0, 0, 1, 25, 0},
*/
terminal KW_2EQ: '==';
/* -> right-arrow
* {KW_RARROW, 0,"->", 0, 0, 0, 0, 0, 0, 0, 1, 80, 0},
*/
terminal KW_RARROW: '->';
terminal KW_LARROW: '<-';
/* +-> gives or maps-to
* {KW_MAPSTO, 0,"+->", 0, 0, 0, 0, 1, 0, 1, 1, 30, 0},
*/
terminal KW_MAPSTO: '+->';
/* +->*
* {KW_MAPSTOStar, 0,"+->*", 0, 0, 0, 0, 1, 0, 1, 1, 30, 0},
*/
terminal KW_MAPSTOSTAR: '+->*';
/* ->* gives or maps-to
* {KW_MAPSTAR, 0,"->*", 0, 0, 0, 0, 0, 0, 0, 1, 80, 0},
*/
terminal KW_MAPSTAR: '->*';
/* % represents an instance of this type */
terminal PERCENT: '%';
/* '% */
terminal PRIMEPERCENT: "'%";
/* ... */
terminal ELLIPSIS: '...';
/* +/ takes the sum of a list */
terminal SUMLIST: '+/';
terminal ANY_OTHER: .;

////////// end of lexer rules ///////////////

/* error seems to be defined externally in Aldor grammar
 * so I have added this rule so it will compile
 */
error:
	'error'
;

Expression:
  enlist1a_Labeled_Semicolon_AB
;

/* An '.as' file is effectivly a list of 'Labeled' 
 * by semicolons*/
Labeled hidden(WS,KW_NEWLINE):
 Comma
| Declaration
| KW_AT Atom lab=Labeled?
;

Declaration hidden(WS,KW_NEWLINE):
 'macro' MacroBody
| 'extend' Sig
| 'local' Sig
| 'free' Sig
| 'fluid' Sig
| 'default' Sig
| 'define' Sig
| 'fix' Sig
| 'inline' Sig? fp=FromPart?
| 'import' Sig? fp=FromPart?
| ExportDecl
;

ExportDecl hidden(WS,KW_NEWLINE):
'export' Sig?
| =>('export' Sig? tp=ToPart)
| =>('export' Sig? fp=FromPart)
;

ToPart hidden(WS,KW_NEWLINE):
 'to' Infixed
;

FromPart hidden(WS,KW_NEWLINE):
 'from' enlist1_Infixed_Comma_AB
;

MacroBody hidden(WS,KW_NEWLINE):
Sig
| ExportDecl
| 'import' Sig fp=FromPart?
;

Sig hidden(WS,KW_NEWLINE):
 DeclBinding
| Block
;

DeclPart hidden(WS,KW_NEWLINE):
 KW_COLON Type
| KW_COLONSTAR Type
;

/*
 * Commas
 */
Comma hidden(WS,KW_NEWLINE):
  enlist1_CommaItem_Comma_AB
;

CommaItem hidden(WS,KW_NEWLINE):
 Binding_AnyStatement =>('where' ci=CommaItem)*
;

/*
 * DeclBinding
 */
DeclBinding hidden(WS,KW_NEWLINE):
  BindingR_InfixedExprsDecl_AnyStatement
;

InfixedExprsDecl hidden(WS,KW_NEWLINE):
 InfixedExprs dp+=DeclPart*
;

InfixedExprs hidden(WS,KW_NEWLINE):
 enlist1_InfixedExpr_Comma_AB
;

/*
 * Bindings
 * 
 * Substituted Rules in Xtext:
 * Binding_BalStatement
 * Binding_AnyStatement
 * Binding_BalStatement
 * Binding_InfixedExprsDecl
 * Binding_Collection
 * Binding(E)
 * : BindingL(Infixed,E)
 * ;
 */
Binding_AnyStatement hidden(WS,KW_NEWLINE):
  BindingL_Infixed_AnyStatement
;

Binding_BalStatement hidden(WS,KW_NEWLINE):
  BindingL_Infixed_BalStatement
;

Binding_Collection hidden(WS,KW_NEWLINE):
  BindingL_Infixed_Collection
;

/* Substituted Rules in Xtext:
 * BindingL(Infixed,E) where E is in Binding
 * BindingL(R,L)
 * : L
 * | R KW_Assign BindingL(R,L)
 * { $$ = abNewAssign(APOS($1),$1,$3); }
 * | R KW_2EQ BindingL(R,L)
 * { $$ = abNewDefine(APOS($1),$1,$3); }
 * | R KW_MARROW BindingL(R,L)
 * { $$ = abNewMDefine(APOS($1),$1,$3); }
 * | R KW_MAPSTO BindingL(R,L)
 * { $$ = abNewLambda(APOS($1),$1,abZip,$3); }
 * | R KW_MAPSTOStar BindingL(R,L)
 * { $$ = abNewPLambda(APOS($1),$1,abZip,$3); }
 * ;
 */
BindingL_Infixed_AnyStatement hidden(WS,KW_NEWLINE):
 AnyStatement
| Infixed 'assign' bia=BindingL_Infixed_AnyStatement
| Infixed KW_2EQ bia=BindingL_Infixed_AnyStatement
| Infixed KW_MARROW bia=BindingL_Infixed_AnyStatement
| Infixed KW_MAPSTO bia=BindingL_Infixed_AnyStatement
| Infixed KW_MAPSTOSTAR bia=BindingL_Infixed_AnyStatement
;

BindingL_Infixed_BalStatement hidden(WS,KW_NEWLINE):
 BalStatement
| Infixed 'assign' bib=BindingL_Infixed_BalStatement
| Infixed KW_2EQ bib=BindingL_Infixed_BalStatement
| Infixed KW_MARROW bib=BindingL_Infixed_BalStatement
| Infixed KW_MAPSTO bib=BindingL_Infixed_BalStatement
| Infixed KW_MAPSTOSTAR bib=BindingL_Infixed_BalStatement
;

BindingL_Infixed_Collection hidden(WS,KW_NEWLINE):
 Collection
| Infixed 'assign' bic=BindingL_Infixed_Collection
| Infixed KW_2EQ bic=BindingL_Infixed_Collection
| Infixed KW_MARROW bic=BindingL_Infixed_Collection
| Infixed KW_MAPSTO bic=BindingL_Infixed_Collection
| Infixed KW_MAPSTOSTAR bic=BindingL_Infixed_Collection
;

/* Substituted Rules in Xtext:
 * BindingR(InfixedExprsDecl,AnyStatement)
 * BindingR(R,L)
 * : R
 * | R KW_Assign Binding(L)
 * { $$ = abNewAssign(APOS($1),$1,$3); }
 * | R KW_2EQ Binding(L)
 * { $$ = abNewDefine(APOS($1),$1,$3); }
 * | R KW_MARROW Binding(L)
 * { $$ = abNewMDefine(APOS($1),$1,$3); }
 * | R KW_MAPSTO Binding(L)
 * { $$ = abNewLambda(APOS($1),$1,abZip,$3); }
 * | R KW_MAPSTOStar Binding(L)
 * { $$ = abNewPLambda(APOS($1),$1,abZip,$3); }
 * ;
 */
BindingR_InfixedExprsDecl_AnyStatement hidden(WS,KW_NEWLINE):
 InfixedExprsDecl
| => InfixedExprsDecl 'assign' bas=Binding_AnyStatement
| => InfixedExprsDecl KW_2EQ bas=Binding_AnyStatement
| => InfixedExprsDecl KW_MARROW bas=Binding_AnyStatement
| => InfixedExprsDecl KW_MAPSTO bas=Binding_AnyStatement
| => InfixedExprsDecl KW_MAPSTOSTAR bas=Binding_AnyStatement
;

/*
 * Statements
 *
 * It is easier to spot conflicts when explicitly handling dangling else.
 */
AnyStatement hidden(WS,KW_NEWLINE):
	'temp19'
// if we enable the following we get:
// 'A class may not be a super type of itself' error
// 'if' CommaItem 'then' bas=Binding_AnyStatement
//| Flow_AnyStatement
;

BalStatement hidden(WS,KW_NEWLINE):
	'temp20'
// Flow_BalStatement
;

/* Substituted Rules in Xtext:
Flow(XX) -> Flow_AnyStatement or Flow_BalStatement
//Flow(XX)
//: Collection
//| KW_If CommaItem KW_Then Binding_BalStatement KW_Else Binding(XX)
//{ $$ = abNewIf(TPOS($1), TEST($2),$4,$6); }
//| Collection KW_Implies Binding(XX)
//{ $$ = abNewExit(TPOS($2), TEST($1),$3); }
//| Iterators KW_Repeat Binding(XX)
//{ $$ = abNewRepeatOL(TPOS($2),$3,$1); listFree(AbSyn)($1); }
//| KW_Repeat Binding(XX)
//{ $$ = abNewRepeat0(TPOS($1),$2); }
//| KW_Try Binding_AnyStatement) KW_But ButExpr AlwaysPart(XX)
//{ (void)parseDeprecated(KW_But, abNewNothing(TPOS($3))); $$ = abNewTry(TPOS($1),$2,$4->abSequence.argv[0], $4->abSequence.argv[1],$5); }
//| KW_Try Binding_AnyStatement) KW_Catch ButExpr AlwaysPart(XX)
//{ $$ = abNewTry(TPOS($1),$2,$4->abSequence.argv[0], $4->abSequence.argv[1],$5); }
//| KW_Select Binding_AnyStatement) KW_In Cases
//{ $$ = abNewSelect(TPOS($1),$2,$4); }
//| KW_Do Binding(XX)
//{ $$ = abNewDo(TPOS($1),$2); }
//| KW_Delay Binding(XX)
//{ $$ = abNewDelay(TPOS($1),$2); }
//| KW_Reference Binding(XX)
//{ $$ = abNewReference(TPOS($1),$2); }
//| KW_Generate GenBound Binding(XX)
//{ $$ = abNewGenerate(TPOS($1),$2,$3); }
//| KW_Assert Binding(XX)
//{ $$ = abNewAssert(TPOS($1),TEST($2)); }
//| KW_Iterate opt(Name)
//{ $$ = abNewIterate(TPOS($1),$2); }
//| KW_Break opt(Name)
//{ $$ = abNewBreak(TPOS($1),$2); }
//| KW_Return opt(Collection)
//{ $$ = abNewReturn(TPOS($1),$2); }
//| KW_Yield Binding(XX)
//{ $$ = abNewYield(TPOS($1),$2); }
//| KW_Except Binding(XX)
//{ $$ = parseDeprecated(KW_Except, abNewRaise(TPOS($1),$2)); }
//| KW_Throw Binding(XX)
//{ $$ = abNewRaise(TPOS($1),$2); }
//| KW_Goto Id
//{ $$ = abNewGoto(TPOS($1),$2); }
//| KW_Never
//{ $$ = abNewNever(TPOS($1)); }
//;
*/
Flow_AnyStatement hidden(WS,KW_NEWLINE):
 Collection
| 'if' CommaItem 'then' bbs=Binding_BalStatement 'else' bas=Binding_AnyStatement
| Collection 'implies' bas2=Binding_AnyStatement
| Iterators 'repeat' bas3=Binding_AnyStatement
| 'repeat' Binding_AnyStatement
| 'try' Binding_AnyStatement 'but' be=ButExpr apa=AlwaysPart_AnyStatement
| 'try' Binding_AnyStatement 'catch' be=ButExpr apa=AlwaysPart_AnyStatement
| 'select' Binding_AnyStatement 'in' c=Cases
| 'do' Binding_AnyStatement
| 'delay' Binding_AnyStatement
| 'reference' Binding_AnyStatement
| 'generate' GenBound bas4=Binding_AnyStatement
| 'assert' Binding_AnyStatement
| 'iterate' Name?
| 'break' Name?
| 'return' Collection?
| 'yield' Binding_AnyStatement
| 'except' Binding_AnyStatement
| 'throw' Binding_AnyStatement
| 'goto' Id
| 'never'
;

Flow_BalStatement hidden(WS,KW_NEWLINE):
	Collection
| 'if' CommaItem 'then' bbs=Binding_BalStatement 'else' bbs2=Binding_BalStatement
| Collection 'implies' bbs3=Binding_BalStatement
| Iterators 'repeat' bbs4=Binding_BalStatement
| 'repeat' Binding_BalStatement
| 'try' Binding_AnyStatement 'but' be=ButExpr apb=AlwaysPart_BalStatement
| 'try' Binding_AnyStatement 'catch' be=ButExpr apb=AlwaysPart_BalStatement
| 'select' Binding_AnyStatement 'in' c=Cases
| 'do' Binding_BalStatement
| 'delay' Binding_BalStatement
| 'reference' Binding_BalStatement
| 'generate' GenBound bbs5=Binding_BalStatement
| 'assert' Binding_BalStatement
| 'iterate' Name?
| 'break' Name?
| 'return' Collection?
| 'yield' Binding_BalStatement
| 'except' Binding_BalStatement
| 'throw' Binding_BalStatement
| 'goto' Id
| 'never'
;

GenBound hidden(WS,KW_NEWLINE):
  ('to' CommaItem 'of')?
;

ButExpr hidden(WS,KW_NEWLINE):
  (db=DeclBinding 'in' ca=Cases)?
;

Cases hidden(WS,KW_NEWLINE):
 Binding_Collection
;

/* Substituted Rules in Xtext:
* AlwaysPart(XX) -> AlwaysPart_AnyStatement
*                or AlwaysPart_BalStatement
* AlwaysPart(XX)
* : KW_Always Binding(XX)
* { (void)parseDeprecated(KW_Always, abNewNothing(TPOS($1))); $$ = $2; }
* | KW_Finally Binding(XX)
* { $$ = $2; }
* | Nothing
//;
*/
AlwaysPart_AnyStatement hidden(WS,KW_NEWLINE):
 ('always' Binding_AnyStatement
| 'finally' Binding_AnyStatement)?
;

AlwaysPart_BalStatement hidden(WS,KW_NEWLINE):
( 'always' Binding_BalStatement
| 'finally' Binding_BalStatement)?
;

/*
 * Iterators
 */
Collection hidden(WS,KW_NEWLINE):
 Infixed i=Iterators?
;

Iterators hidden(WS,KW_NEWLINE):
 Iterators1
;

Iterators1 hidden(WS,KW_NEWLINE):
	'temp27'
// left recursive when following uncommented
// Iterator
//| Iterators1 itr=Iterator
;

Iterator
: 'for' ForLhs 'in' i=Infixed sp=SuchthatPart?
| 'while' Infixed
;

ForLhs
: Infixed
| 'free' Infixed
| 'local' Infixed
| 'fluid' Infixed
;

SuchthatPart hidden(WS,KW_NEWLINE):
	'temp30'
 KW_BAR Infixed
;

/*
 * Infixed Expressions
 */

Infixed hidden(WS,KW_NEWLINE):
	'temp31'
// causes constraint error when following is uncommented
// InfixedExpr DeclPart*
// | Block
;

InfixedExpr hidden(WS,KW_NEWLINE):
 E11_Op
| E3
;


E3 returns Expr hidden(WS,KW_NEWLINE):
  left=E4 ({E3.left=current}(op+='and'|op+='or'|op2 += LatticeOp) right=E4)*
;

E4 returns Expr hidden(WS,KW_NEWLINE):
 (left=E5 ({E4.left=current}(op+='has'|op2 += RelationOp) right=E5)*)
| RelationOp right=E5
;

E5 returns Expr hidden(WS,KW_NEWLINE):
=> (left=E6 ({E5.left=current}op5+=SegOp right=E6)*)
| left=E6 op5+=SegOp
;

/* If unary plus operation is enabled then we get error in
* InfixedExpr non-LL(*) decision  due to recursive rule invocations
* reachable from alts 1,2
* That is we can get a PlusOp from InfixedExpr in 2 ways */
E6 returns Expr hidden(WS,KW_NEWLINE):
 (left=E7 ({E6.left=current}op6+=PlusOp right=E7)*)
//| (op6+=PlusOp right=E7)
;

E7 returns Expr hidden(WS,KW_NEWLINE):
 left=E8 ({E7.left=current}op7+=QuotientOp right=E8)*
;

E8 returns Expr hidden(WS,KW_NEWLINE):
 left=E9 ({E8.left=current}op8+=TimesOp right=E9)*
;

E9 returns Expr hidden(WS,KW_NEWLINE):
 left=E11_E12 ({E9.left=current}op9+=PowerOp right=E11_E12)*
;

/* Substituted Rules in Xtext:
 * E11_E12
 * E11_Op
 * E11(X)
 * : X
 * | E11(X) KW_2Colon E12
 * { $$ = abNewCoerceTo(TPOS($2),$1,$3); }
 * | E11(X) KW_At E12
 * { $$ = abNewRestrictTo(TPOS($2),$1,$3); }
 * | E11(X) KW_Pretend E12
 * { $$ = abNewPretendTo(TPOS($2),$1,$3); }
 * ;
 */
E11_E12 returns Expr hidden(WS,KW_NEWLINE):
	(left=E12 ({E11_E12.left=current}(op+=KW_2COLON|op+=KW_AT|op+='pretend') right=E12)*)
;

E11_Op returns Expr hidden(WS,KW_NEWLINE):
	(left=Op ({E11_Op.left=current}(op+=KW_2COLON|op+=KW_AT|op+='pretend') right=E12)*)
;

Type hidden(WS,KW_NEWLINE):
	E11_E12
;

E12:
  (left=E13 ({E12.left=current}op+=ArrowOp right=E13)*)
;

E13:
  (left=E14 ({E13.left=current}op+=KW_DOLLAR right=QualTail)*)
;

QualTail:
 LeftJuxtaposed
| => LeftJuxtaposed KW_DOLLAR qt=QualTail
;

OpQualTail hidden(WS,KW_NEWLINE):
 name=Molecule
| => (name=Molecule KW_DOLLAR OpQualTail)
;

E14 hidden(WS,KW_NEWLINE):
 e15left=E15
| => e15left=E15? 'with' dm=DeclMolecule
| => e15left=E15? 'add' dm=DeclMolecule
| => e15left=E15 'except' e15right=E15
| => e15left=E15 'throw' e15right=E15
;

E15 hidden(WS,KW_NEWLINE):
  Application
;

/*
 * Infixed Operations
 */
Op hidden(WS,KW_NEWLINE):
 ArrowOp
| LatticeOp
| RelationOp
| SegOp
| PlusOp
| QuotientOp
| TimesOp
| PowerOp
;

NakedOp hidden(WS,KW_NEWLINE):
 UnqualOp_ArrowTok
| UnqualOp_LatticeTok
| UnqualOp_RelationTok
| UnqualOp_SegTok
| UnqualOp_PlusTok
| UnqualOp_QuotientTok
| UnqualOp_TimesTok
| UnqualOp_PowerTok
;

ArrowOp: QualOp_ArrowTok;
LatticeOp: QualOp_LatticeTok;
RelationOp: QualOp_RelationTok;
SegOp: QualOp_SegTok;
PlusOp: QualOp_PlusTok;
QuotientOp: QualOp_QuotientTok;
TimesOp: QualOp_TimesTok;
PowerOp: QualOp_PowerTok;

/* in Aldor grammar this is ArrowTok<tok> */
ArrowTok: KW_RARROW | KW_LARROW | KW_MAPSTAR ;
/* in Aldor grammar this is LatticeTok<tok> */
LatticeTok: KW_VEE | KW_WEDGE ;
/* in Aldor grammar this is RelationTok<tok> */
RelationTok:KW_EQ | KW_TILDEE | KW_HATE |
KW_GE | KW_GT | KW_2GT |
KW_LE | KW_LT | KW_2LT |
'is' | 'isnt' | 'case' ;
/* in Aldor grammar this is SegTok<tok> */
SegTok: KW_2DOT | 'by' ;
/* in Aldor grammar this is PlusTok<tok> */
PlusTok: KW_PLUS | KW_MINUS | KW_PLUSMINUS ;
/* in Aldor grammar this is QuotientTok<tok> */
QuotientTok:'mod' | 'quo' | 'rem' | 'exquo' ;
/* in Aldor grammar this is TimesTok<tok> */
TimesTok: KW_STAR | KW_SLASH | KW_BACKSLASH ;
/* in Aldor grammar this is PowerTok<tok> */
PowerTok: KW_2STAR | KW_HAT ;

/*
 * Juxtaposed Expressions
 * 
 * A prefix application typically has the following form:
 * 
 *  f(a1, ..., an)
 * 
 * There are two additional forms for specifying a prefix
 * application to one argument: juxtaposition and an infix dot.
 * 
 * f a
 * f.a
 * 
 * The second of these forms is completely equivalent to
 * f(a); the first is equivalent in a free-standing occurrence
 * but associates differently -- to the right, rather than
 * the left:
 * 
 *  f a b c      -- is equivalent to (f (a (b c)))
 *  f.a.b.c      -- is equivalent to (((f.a).b).c)
 *  f(a)(b)(c)   -- is equivalent to (((f(a))(b))(c))
 *
 */

Application hidden(WS,KW_NEWLINE):
 RightJuxtaposed
;

RightJuxtaposed hidden(WS,KW_NEWLINE):
 Jright_Molecule
;

LeftJuxtaposed hidden(WS,KW_NEWLINE):
//	'temp54'
 Jleft_Molecule
;

/* Substituted Rules in Xtext:
 * Jright(Molecule)
 * Jright(Atom)
 * Jright(H)
 * : Jleft(H)
 * | Jleft(H) Jright(Atom)
 * { $$ = parseMakeJuxtapose($1,$2); }
 * | 'not' Jright(Atom)
 * { $$ = abNewNot(TPOS($1),TEST($2)); }
 * ;
 */
/*
 * causes problems:
 * If first option is enabled;
 * Decision can match input such as "RULE_TK_STRING" using multiple
 * alternatives: 1, 2, 3, 4, 5
 * If second option is enabled:
 * Decision can match input such as "'not'" using multiple
 * alternatives
 */
Jright_Molecule hidden(WS,KW_NEWLINE):
	'temp56'
//	(Jleft_Molecule (right=Jright_Atom)?)
//	|
//  ('not' right=Jright_Atom)
;

Jright_Atom hidden(WS,KW_NEWLINE):
	(Jleft_Atom (right2=Jright_Atom)?)
	| 'not' right2=Jright_Atom
;

/* Substituted Rules in Xtext:
 * Jleft(Molecule)
 * Jleft(Atom)
 * Jleft(H)
 * : H
 * | 'not' BlockEnclosure
 * { $$ = abNewNot(TPOS($1),TEST($2)); }
 * | Jleft(H) BlockEnclosure
 * { $$ = parseMakeJuxtapose($1,$2); }
 * | Jleft(H) KW_DOT BlockMolecule
 * { $$ = abNewPrefix(TPOS($2),$1,$3); }
 * ;
 */
Jleft_Molecule hidden(WS,KW_NEWLINE):
'not' be=BlockEnclosure
| (m=Molecule (KW_DOT bm+=BlockMolecule)*)
;

Jleft_Atom hidden(WS,KW_NEWLINE):
'not' BlockEnclosure
| (Atom (KW_DOT bm4+=BlockMolecule)*)
;

/*
 * Indivisible Expressions
 */
Molecule hidden(WS,KW_NEWLINE):
Atom
| Enclosure
;

Enclosure hidden(WS,KW_NEWLINE):
	Parened
| Bracketed
| QuotedIds
;

DeclMolecule hidden(WS,KW_NEWLINE):
 a=Application?
| b=Block
;

BlockMolecule hidden(WS,KW_NEWLINE):
 Atom
| Enclosure
| Block
;

BlockEnclosure hidden(WS,KW_NEWLINE):
Enclosure
| Block
;

Block hidden(WS,KW_NEWLINE):
// Piled(Expression)|
  Curly_Labeled
;

Parened hidden(WS,KW_NEWLINE):
KW_OPAREN KW_CPAREN
| KW_OPAREN Expression KW_CPAREN
;

Bracketed hidden(WS,KW_NEWLINE):
KW_OBRACK KW_CBRACK
| KW_OBRACK Expression KW_CBRACK
;

QuotedIds hidden(WS,KW_NEWLINE):
KW_QUOTE KW_QUOTE
| KW_QUOTE Names KW_QUOTE
;

Names hidden(WS,KW_NEWLINE):
  firstName=TK_ID
  (KW_COMMA subsequentNames+=TK_ID)*
;

/*
 * Terminals
 */
Atom hidden(WS,KW_NEWLINE):
 id=Id
| lit=Literal
;

Name hidden(WS,KW_NEWLINE):
Id
| NakedOp
;

/* original Aldor grammar uses abNewOfToken which is defined
 * in Aldor file absyn.c: Abstract syntax construction and
 * manipulation.
 */
Id hidden(WS,KW_NEWLINE):
AB_Id=TK_ID
| op=KW_SHARP
| op=KW_TILDE
;

Literal hidden(WS,KW_NEWLINE):
TK_INT
//| TK_FLOAT
| TK_STRING
;

/*
 * Meta-rules
 */

/* Substituted Rules in Xtext:
 * UnqualOp(ArrowTok)
 * UnqualOp(LatticeTok)
 * UnqualOp(RelationTok)
 * UnqualOp(SegTok)
 * UnqualOp(PlusTok)
 * UnqualOp(QuotientTok)
 * UnqualOp(TimesTok)
 * UnqualOp(PowerTok)
 * UnqualOp(op)
 * : op
 * { $$ = abNewOfToken(AB_Id, $1); }
 * ;
 */
UnqualOp_ArrowTok hidden(WS,KW_NEWLINE):
ArrowTok{ ArrowTok }
;
UnqualOp_LatticeTok hidden(WS,KW_NEWLINE):
LatticeTok{ LatticeTok }
;
UnqualOp_RelationTok hidden(WS,KW_NEWLINE):
RelationTok{ RelationTok }
;
UnqualOp_SegTok hidden(WS,KW_NEWLINE):
SegTok{ SegTok }
;
UnqualOp_PlusTok hidden(WS,KW_NEWLINE):
PlusTok{ PlusTok }
;
UnqualOp_QuotientTok hidden(WS,KW_NEWLINE):
QuotientTok{ QuotientTok }
;
UnqualOp_TimesTok hidden(WS,KW_NEWLINE):
TimesTok{ TimesTok }
;
UnqualOp_PowerTok hidden(WS,KW_NEWLINE):
PowerTok{ PowerTok }
;

/* Substituted Rules in Xtext:
 * QualOp(ArrowTok)
 * QualOp(LatticeTok)
 * QualOp(RelationTok)
 * QualOp(SegTok)
 * QualOp(PlusTok)
 * QualOp(QuotientTok)
 * QualOp(TimesTok)
 * QualOp(PowerTok)
 * QualOp(op)
 * : op
 * { $$ = abNewOfToken(AB_Id, $1); }
 * | op KW_DOLLAR OpQualTail
 * { $$ = abNewQualify(TPOS($1), abNewOfToken(AB_Id, $1), $3); }
 * ;
 */

QualOp_ArrowTok hidden(WS,KW_NEWLINE):
ArrowTok
| ArrowTok KW_DOLLAR OpQualTail
;

QualOp_LatticeTok hidden(WS,KW_NEWLINE):
LatticeTok
| LatticeTok KW_DOLLAR OpQualTail
;

/*InfixedExpr has non-LL(*) decision due to recursive rule
* invocations reachable from alts 1,2.  Resolve by left-factoring
* or using syntactic predicates or using backtrack=true option.
* 
* RelationTok is KW_EQ | KW_TILDEE | KW_HATE |
* KW_GE | KW_GT | KW_2GT |
* KW_LE | KW_LT | KW_2LT |
* 'is' | 'isnt' | 'case' ;
 */
QualOp_RelationTok hidden(WS,KW_NEWLINE):
	'temp99'
//RelationTok (op+=KW_DOLLAR oqt=OpQualTail)?
;

QualOp_SegTok hidden(WS,KW_NEWLINE):
SegTok
| SegTok KW_DOLLAR OpQualTail
;

QualOp_PlusTok hidden(WS,KW_NEWLINE):
PlusTok
| PlusTok KW_DOLLAR OpQualTail
;

QualOp_QuotientTok hidden(WS,KW_NEWLINE):
QuotientTok
| QuotientTok KW_DOLLAR OpQualTail
;

QualOp_TimesTok hidden(WS,KW_NEWLINE):
TimesTok
| TimesTok KW_DOLLAR OpQualTail
;

QualOp_PowerTok hidden(WS,KW_NEWLINE):
PowerTok
| PowerTok KW_DOLLAR OpQualTail
;

/* ++ Doc. */

/* Substituted Rules in Xtext:
 * E is E from PileContents(E)
 */ 
//Doc(E)
//: PreDocument E PostDocument
//{
//$$ = $2;
//if($3) $$ = abNewDocumented(APOS($3),$$,$3);
//if($1) $$ = abNewDocumented(APOS($$),$$,$1);
//}
//;

//PreDocument hidden(WS,KW_NEWLINE):
//  PreDocumentList
//;

//PostDocument hidden(WS,KW_NEWLINE):
//  PostDocumentList
//;

/* list of lines starting with -- */
PreDocument:
  TK_PREDOC*
;

/* list of lines starting with ++ */
PostDocument:
  TK_POSTDOC*
;

/* Substituted Rules in Xtext:
* enlist1(Infixed, KW_Comma, `AB_Comma)
* enlist1(CommaItem, KW_Comma, `AB_Comma) enlist1_CommaItem_Comma_AB
* enlist1(InfixedExpr, KW_Comma, `AB_Comma)
* enlist1(Name, KW_Comma, `AB_Comma)
* 
*  E {sep E sep E}
* 
* enlist1(E,Sep,Tag)
* : enlister1(E, Sep)
* 
* { $$ = abOneOrNewOfList(Tag, $1); listFree(AbSyn)($1); }
* ;
*/
enlist1_CommaItem_Comma_AB hidden(WS,KW_NEWLINE):
  enlister1_CommaItem_Comma
;

enlist1_Infixed_Comma_AB hidden(WS,KW_NEWLINE):
  enlister1_Infixed_Comma
;

enlist1_InfixedExpr_Comma_AB hidden(WS,KW_NEWLINE):
  enlister1_InfixedExpr_Comma
;

/* not used
 * E sep E {sep E}
 */
//enlist2(E,Sep,Tag)
//: enlister1(E, Sep) Sep E
//{
//$1 = listCons(AbSyn)($3, $1);
//$$ = abOneOrNewOfList(Tag, $1);
//listFree(AbSyn)($1);
//}
//;

/* Substituted Rules in Xtext:
* enlister1(E, Sep)
* where E is E from enlist1 or enlist1a 
* enlister1(E, Sep)<ablist>
* : E
* { $$ = listCons(AbSyn)($1, listNil(AbSyn) ); }
* | enlister1(E, Sep) Sep E
* { $$ = listCons(AbSyn)($3, $1); }
* ;
*/
enlister1_CommaItem_Comma hidden(WS,KW_NEWLINE):
  CommaItem (KW_COMMA ci=CommaItem)*
;

enlister1_Infixed_Comma hidden(WS,KW_NEWLINE):
  Infixed (KW_COMMA i=Infixed)*
;

enlister1_InfixedExpr_Comma hidden(WS,KW_NEWLINE):
  InfixedExpr (KW_COMMA ie=InfixedExpr)*
;

/* Substituted Rules in Xtext:
* enlist1a(Labeled, KW_SEMICOLON, `AB_Sequence)
* 
* E {sep+ E sep+ E sep*} */
enlist1a_Labeled_Semicolon_AB hidden(WS,KW_NEWLINE):
  enlister1a_Labeled_Semicolon
;

/* Substituted Rules in Xtext:
* enlister1a(E, Sep) where E is from enlist1a
* 
*/
enlister1a_Labeled_Semicolon hidden(WS,KW_NEWLINE):
  statemnts += Labeled
  (KW_SEMICOLON statemnts += Labeled)
  KW_SEMICOLON?
//Labeled
//| enlister1a_Labeled_Semicolon KW_SEMICOLON Labeled
//| enlister1a_Labeled_Semicolon KW_SEMICOLON
;

/* Substituted Rules in Xtext:
* Piled(Expression)
* 
*/
/* Piled */
//Piled(E)
//: KW_SetTab PileContents(E) KW_BackTab
//{ $$ = abOneOrNewOfList(AB_Sequence,$2); listFree(AbSyn)($2); }
//;

/* Substituted Rules in Xtext:
* Curly(Labeled)
* 
*/
Curly_Labeled:
KW_OCURLY CurlyContents_Labeled KW_CCURLY
;

/* Substituted Rules in Xtext:
* PileContents(E) E is from piled
* 
*/
//PileContents(E)<ablist>
//: Doc(E)
//{ $$ = listCons(AbSyn)($1, listNil(AbSyn)); }
//| PileContents(E) KW_BackSet Doc(E)
//{ $$ = listCons(AbSyn)($3, $1); }
//| error KW_BackSet Doc(E)
//{ yyerrok; $$ = listCons(AbSyn)($3, listNil(AbSyn)); }
//;

/* Substituted Rules in Xtext:
* CurlyContents(Labeled)
* CurlyContents(E) E is from Curly
* 
* CurlyContents(E) : CurlyContentsList(E);
*/
CurlyContents_Labeled hidden(WS):
  CurlyContentsList_Labeled
;

/* Substituted Rules in Xtext:
* is CurlyContentsList(E)<ablist> in Aldor grammar
* CurlyContentsList(E) E is from CurlyContents(E)
* 
* CurlyContentsList(E)<ablist>:
* CurlyContent1(E)
* | CurlyContent1(E) CurlyContentB(E)
* ;
*/
CurlyContentsList_Labeled hidden(WS):
	statemts += CurlyContentB_Labeled
	(KW_SEMICOLON statemts += CurlyContentB_Labeled)*
	KW_SEMICOLON?
//CurlyContent1_Labeled
//| CurlyContent1_Labeled ccb=CurlyContentB_Labeled
;

/* CurlyContent1_Labeled
* this rule is used by CurlyContentsList_Labeled
*
* Substituted Rules in Xtext:
* CurlyContent1(E) E is form CurlyContentsList(E)
* 
* This rule is left recursive in the Aldor grammar so I have
* to change it here.
*/
//CurlyContent1_Labeled
//: Nothing
//| CurlyContent1_Labeled cca=CurlyContentA_Labeled
//;

/* Substituted Rules in Xtext:
* CurlyContentA(E) E is from CurlyContent1(E)
* 
*/
//CurlyContentA_Labeled
//: CurlyContentB_Labeled KW_SEMICOLON pd=PostDocument
//| error KW_SEMICOLON PostDocument
//;

/* Substituted Rules in Xtext:
* CurlyContentB(E) E is from CurlyContentA(E)
* or CurlyContentsList(E)
* 
*/
CurlyContentB_Labeled:
pred=PreDocument l=Labeled pd=PostDocument
;

///////// end of Aldor stuff

/*
 * longname and longname2 should both be ID and have the same value. Since the
 * runtime values can't be checked by the parser this must be checked later.
 */
//CategoryDef hidden(WS,KW_NEWLINE,TK_COMMENT):
//name='category' shortname=TK_ID longname=TK_ID
//longname2=TK_ID /*[CategoryDef]*/
//    (cp=TypeParameterList)?
//    KW_COLON 'Category' KW_2EQ
//    (
//    implName=TypeArguments? ((w=WithPart? a=AddPart?)| wh5=WherePart)
//    | KW_OCURLY KW_NEWLINE*
//      implName=TypeArguments ((w=WithPart? a=AddPart?)| wh5=WherePart)
//      KW_CCURLY KW_NEWLINE* a2=AddPart?
//    )
//;

/*
 * longname and longname2 should both be ID and have the same value. Since the
 * runtime values can't be checked by the parser this must be checked later.
 */
//PackageDef hidden(WS,KW_NEWLINE,TK_COMMENT):
//name='package' shortname=TK_ID longname=TK_ID
//longname2=TK_ID /*[PackageDef]*/
//    (cp=TypeParameterList)? KW_COLON
//    (
//     exportName=TK_ID KW_2EQ implName=TK_ID
//        (w=WithPart | wh5=WherePart)
//     |
//     w=WithPart
//     (KW_2EQ add2=AddPart)?
//    )
//;

/*
 * longname and longname2 should both be ID and have the same value. Since the
 * runtime values can't be checked by the parser this must be checked later.
 */
//DomainDef hidden(WS,KW_NEWLINE,TK_COMMENT):
//name='domain' shortname5=TK_ID longname5=TK_ID
//longname6=TK_ID /*[DomainDef]*/
//    (cp5=TypeParameterList)?
//    KW_COLON exportName=TK_ID (cp6=TypeParameterList)?
//    KW_2EQ implName5=TK_ID?
//    (w=WithPart | wh5=WherePart | a=AddPart)
//;

/*
 * both category and domain can have 'where' part which holds overall information
 * such as category/domain parameter information and general macros. This is
 * followed by export('with') and import ('add') information.
 * Forms allowed include:
 * Exports == PlottablePlaneCurveCategory with {
 * Exports ==> PlottablePlaneCurveCategory with {
 * Exports ==> with {
 */
//WherePart hidden(WS,TK_COMMENT):
//name='where' KW_NEWLINE* KW_OCURLY KW_NEWLINE*
//    (whereAssig +=WhereAssignments (KW_NEWLINE|KW_SEMICOLON)+)*
//    // with part
//    (longname8=TK_ID (KW_2EQ | KW_MARROW) (imp=TypeExpression2)? w8=WithPart)?
//    // add part
//    (
//     (longname9=TK_ID (KW_2EQ | KW_MARROW))?
//        ((fs=TK_ID KW_OPAREN par2=TK_ID? (KW_COMMA par3 += TK_ID)* KW_CPAREN)
//         | (fs=TK_ID f2=TK_ID)
//        )?
//        add=AddPart
//    )?
//    KW_CCURLY KW_NEWLINE+
//;

/* each one must be on a separate line or separated by ';'
 * need to add name=
 */
//WhereAssignments hidden(WS):
//VariableDeclaration
//| MacroDef |Import
//;

/*
 * the 'where' part contains a 'with' part which holds export information
 * such as function signatures (function declarations) but not function definitions.
 */
//WithPart hidden(WS,TK_COMMENT):
//name='with' KW_NEWLINE* KW_OCURLY KW_NEWLINE*
//    (fundec += VariableDeclaration (KW_NEWLINE|KW_SEMICOLON)+)*
//    KW_CCURLY KW_NEWLINE*
//;

/*
 * similar to 'WithPart' but no trailing NL
 */
//WithInline hidden(WS,TK_COMMENT):
//name='with' KW_NEWLINE* KW_OCURLY KW_NEWLINE*
//    (fundec += VariableDeclaration (KW_NEWLINE|KW_SEMICOLON)+)*
//    KW_CCURLY
//;

/*
 * the 'where' part contains a 'add' part which holds function and other
 * declarations.
 */
//AddPart hidden(WS,TK_COMMENT):
//name='add' KW_NEWLINE* KW_OCURLY KW_NEWLINE*
//    (t+=AddStatements (KW_NEWLINE|KW_SEMICOLON)+)* KW_CCURLY KW_NEWLINE*
//;

/*
 * The add section of domain or package may contain multiple lines
 *
 * Examples:
 * if (r := recip leadingCoefficient M) case "failed" then {
 * error "Modulus cannot be made monic"
 * }
 */
//AddStatements hidden(WS,TK_COMMENT):
//   VariableDeclarationAssign
//   | FunctionDefinition
//   | ('if' t1=Expression // expression has form 'x has y'
//      'then' t13=FunctionDefinitionBlock)
//   | 'else' t14=FunctionDefinitionBlock
//   | 'else' t15=AddStatements
//   | MacroDef
//   | Import
//;

/* function definition in add part (called by AddStatements)
 * has a form like:
 * name(params) == statement
 * or, option for single parameter without brackets:
 * name param == statement
 * or, option for zero parameters without brackets:
 * This does not always work at the moment, for instance, this does not work:
 * size == size$R ^ d
 * but this does
 * size() == size$R ^ d
 *
 * or, for infix operators,
 * a = b == statement
 * or, for multiple statements,
 * name(params) == {
 * statement
 * statement
 * }
 * some function definitions may be conditional like this:
 * if % has finiteAggregate then {
 * ... }
 */
//FunctionDefinition hidden(WS,TK_COMMENT):
//  ((
//par3=FunctionSignature
//    (KW_COLON par4=TypeExpression1)?
//    KW_2EQ par5=Statement
//   )|(
//    // this is case where FunctionSignature is just an identifier
//    fnNam=TK_ID KW_2EQ par5=Statement
//   ))
//;

/*
 * called by 'AddStatements' rule.
 * allows more add statements inside:
 * if a has y then 'more add statements'
 */
//FunctionDefinitionBlock hidden(WS,TK_COMMENT):
//    fnDecBr=KW_OCURLY KW_NEWLINE*
//      (
//       fnDecBk += FunctionDefinition (KW_NEWLINE|KW_SEMICOLON)+
//       |
//       vars+=VariableDeclarationAssign (KW_NEWLINE|KW_SEMICOLON)+
//     | ('if' t1+=Expression // expression has form 'x has y'
//        'then' t13+=FunctionDefinitionBlock (KW_NEWLINE|KW_SEMICOLON)+)
//     | ('else' t14+=FunctionDefinitionBlock (KW_NEWLINE|KW_SEMICOLON)+)
//     | i1+=Import (KW_NEWLINE|KW_SEMICOLON)+
//      )*
//      KW_CCURLY
//      | 'error' e=Expression
//      | KW_OCURLY KW_NEWLINE* 'error' e=Expression (KW_NEWLINE|KW_SEMICOLON)+ KW_CCURLY
//;

/* This is the first part of the function definition without the return type or
 * the function implementation. Usually the function signature has a form like:
 * name(params)
 * We allow a single parameter to be given without brackets:
 * name param
 *
 * We also allow some alternative forms to represent infix operators like:
 * a = b to represent _=(a,b)
 * or the following (this works but only for % we need it to work for every type)
 * s:% = t:%
 * or
 * a > b to represent _>(a,b)
 * 0 or 1 can be used as a function signature as a short form of
 * _0() or _1()
 */
//FunctionSignature hidden(WS,TK_COMMENT):
//  (
//fnNam=TK_ID
//    KW_OPAREN
//    par2=VariableTyped?
//    (KW_COMMA par3 += VariableTyped)*
//    KW_CPAREN
//  ) | (
//   // fnNam=ID par2=VariableDeclaration causes recursive definition so use:
//   fnNam=TK_ID par=TK_ID
//// ) | (
//// t4=ID // no parameters without brackets
//// commented out as it causes recursive rule invocation
//// with ruleAddStatements and ruleFunctionDefinitionBlock
//  ) | (
//   t4=TK_ID (KW_COLON (PERCENT | TK_ID))? //(COLON te1=TypeExpression)?
//   ( b1=KW_EQ | b1=KW_LT | b1=KW_GT | b1=KW_LE | b1=KW_GE |
//            b1=KW_PLUS | b1=KW_MINUS | b1=KW_STAR | b1=KW_SLASH | b1=KW_AMPERSAND |
//            b1=KW_BAR | b1=KW_HAT) t5=TK_ID
//  ) | (
//   b3=TK_INT // allows special form of function signature using '0' or '1'
//   // can't specify '0' or '1' explicitly as this would affect lex
//   // order
//  ) | (
//   b2=KW_MINUS t6=TK_ID
//  ) | (
//   b4=KW_TILDE t7=TK_ID
//  ) | (
//   b5='not' t8=TK_ID
//  ) | (
//   b6=KW_SHARP t8=TK_ID
//  )
//;

/* macros provide a general textual substitution
 * there are two forms:
 * name ==> body
 * and
 * name macro == body
 */
//MacroDef: macroname=TK_ID MACROVALUE ; //MACRO val=ID NL;

/*
 * import domain
 */
//Import hidden(WS):
//'import' (impname += TK_ID)+ (KW_OPAREN par22+=TypeExpression1
//(KW_COMMA par22+=TypeExpression1)* KW_CPAREN)?
//;

/* Variable declaration in where and with sections:
 * A 'variable' can be simple like:
 * x:Float
 * or something more complicated like:
 * x:Record(newPt: Pt,type: String)
 * or it can be a function like:
 * x:(Float,Integer) -> Float
 * or it can be conditional like:
 * if
 */
//VariableDeclarationBlock hidden(WS,TK_COMMENT):
//    vardecbr=KW_OCURLY KW_NEWLINE*
//      //=>(i1=Import NL*)?
//      (vardecBlk += VariableDeclaration (KW_NEWLINE|KW_SEMICOLON)+)*
//      KW_CCURLY
//;

/* Variable declaration in where and with sections:
 * A 'variable' can be simple like:
 * x:Float
 * or something more complicated like:
 * x:Record(newPt: Pt,type: String)
 * or it can be a function like:
 * x:(Float,Integer) -> Float
 * or it can be conditional like:
 * if
 */
//VariableDeclaration hidden(WS,TK_COMMENT):
////Import?
//    ('if' t1=Expression 'then')? // expression has form 'x has y'
//( v1=TypeWithName
//      | v2=VariableDeclarationBlock
//)
//;

/*
 * This rule is used where a type is expected like:
 * Float
 * but it may also have an optional name like:
 * x:Float
 */
//TypeWithName hidden(WS,TK_COMMENT):
//(
//(varName=TK_ID | varNameSt=TK_STRING) (KW_COMMA varName2=TK_ID)?
//KW_COLON
//)? typ=TypeExpression1
//;


/* Variable name with optional type. This is used in function signature
 * and also by VariableDeclaration:
 * A 'variable' can be simple like:
 * x:Float
 * or something more complicated like:
 * x:Record(newPt: Pt,type: String)
 * or it can be a function like:
 * x:(Float,Integer) -> Float
 * we can define multiple variables together:
 * i,j : Integer
 */
//VariableTyped hidden(WS,TK_COMMENT):
//(varName=TK_ID | varNameSt=TK_STRING)
//// =>(COMMA t2+=ID)* // multiple declarations in same line
//    (KW_COLON typ=TypeExpression1)?
//;

/* in add part we can declare and assign in same part
 * such as:
 * a := 3
 * a:Integer := 3
 * a := sin(x)
 *
 * There are two forms of multiple assignment:
 * a,b,c := 0@Integer
 * or:
 * a := b := c := 0@Integer
 */
//VariableDeclarationAssign hidden(WS):
//  varName=TK_ID // name of variable
//  // if I just use name=ID then, when the ui program is running, I get:
//  // Duplicate xxx 'coerce' in yyy
//  (
//    (KW_COMMA t12+=TK_ID)* // multiple declarations in same line
//    (KW_COLON typ=TypeExpression1)? // option to explicitly define type
//    (KW_ASSIGN (t4=Expression /* |(LBRACE NL* Expression NL* RBRACE) */))?
//    // we need block since we can't always detect continuation after ':='
//    // but this causes infinite loop
//  )// | (BECOMES t2+=ID)+ BECOMES t4=Expression
//;

/*
 * free variable allows us to declare a variable that is global
 */
//FreeVariable hidden(WS):
//'free' var=TK_ID
//;

/*
 * allows us to declare a variable that is not global
 */
//LocalVariable hidden(WS):
//'local' var=TK_ID
//;

/*
 * This is similar to Expression but known to be of type.
 * (Expression can also be of type) but if we know that
 * this is a type we can exclude some possibilities.
 *
 * A 'typeExpression' can be simple like:
 * Float
 * or something more complicated like:
 * Record(newPt: Pt,type: String)
 * or it can be a function like:
 * (Float,Integer) -> Float
 *
 * first we check for a function like: Integer -> Integer
 */
//TypeExpression1 returns TypeExpression hidden(WS):
//   =>(t2=TypeArguments KW_RARROW t3=TypeResult)
//   | TypePrimaryExpression1
//;

/*
 * This is the same as TypeExpression except it does not allow
 * the type to be extended by using a 'with' keyword. It is used
 * in the 'where' rule because the 'with' in that case has a
 * slightly different syntax.
 */
//TypeExpression2 returns TypeExpression hidden(WS):
//   =>(t92=TypeArguments KW_RARROW t93=TypeResult)
//   | TypePrimaryExpression2
//;

/*
 * we use a type parameter list for parameters of category, package or domains
 * Parameter list may be empty '()'.
 * in this case parameters may be just ID or they may be nameID:typeID
 *
 * examples are:
 * ()
 * (String)
 * (s:String)
 * (String,Integer)
 * (s:String,i:Integer)
 */
//TypeParameterList hidden(WS):
//tyname=KW_OPAREN par=TK_ID?
//(KW_COLON par21=TypeExpression1)?
//(KW_COMMA par2 += TK_ID (KW_COLON par22+=TypeExpression1)?)* KW_CPAREN;

/*
 * we use type arguments for first part of function type, that is
 * x in x-> y
 * usually this is enclosed in parenthesis
 * (x) in (x)-> y
 * but if x is a single argument (Including Record, Union, etc.) then it does
 * not need to be in parenthesis.
 */
//TypeArguments hidden(WS):
//  t=TypeLiteral |
//  t2=PERCENT |
//  t3='Type' |
//  // usually, but not always type arguments are in parenthesis, and empty
//  // parenthesis are allowed
//  b1 ?= KW_OPAREN ((TK_ID KW_COLON)? t4=TypeExpression1)?
//               ( KW_COMMA (TK_ID KW_COLON)? t16 +=TypeExpression1)* KW_CPAREN |
//  t5='Record' KW_OPAREN t6=TypeExpression1
//               (KW_COLON t22+=TypeExpression1)?
//               (KW_COMMA t21+=TypeExpression1 (KW_COLON t23+=TypeExpression1)?)*
//                KW_CPAREN |
//  t9='Union' KW_OPAREN t10=TypeExpression1
//              (KW_COLON t25+=TypeExpression1)?
//              (KW_COMMA t24+=TypeExpression1 (KW_COLON t26+=TypeExpression1)?)*
//              KW_CPAREN |
//  t11='Join' KW_OPAREN t12=TypeExpression1 (KW_COMMA t13+=TypeExpression1)* KW_CPAREN |
//  t15=TypeNameOrFunctionCall
//;

/*
 * we use type arguments for final part of function type, that is
 * y in x-> y
 */
//TypeResult hidden(WS):
//  t=TypeLiteral |
//  t2=PERCENT |
//  tyname='Type' |
//  tyname='Record' KW_OPAREN t7=TypeExpression1
//               (KW_COLON t8+=TypeExpression1)?
//               (KW_COMMA t21+=TypeExpression1 (KW_COLON t23+=TypeExpression1)?)*
//                KW_CPAREN |
//  tyname='Union' KW_OPAREN t10=TypeExpression1
//              (KW_COLON t11+=TypeExpression1)?
//              (KW_COMMA t24+=TypeExpression1 (KW_COLON t26+=TypeExpression1)?)*
//              KW_CPAREN |
//  tyname='Join' KW_OPAREN t12=TypeExpression1 (KW_COMMA t13+=TypeExpression1)* KW_CPAREN |
//  t15=TypeNameOrFunctionCall
//;

/*
 * this matches various specific types
 */
//TypePrimaryExpression1 returns TypePrimaryExpression hidden(WS):
// TypeLiteral
// | ({TypePrimaryExpression}t32=PERCENT)
// | ({TypePrimaryExpression}tyname='Type') // 'Type' is top of the category hierarchy
// | ({TypePrimaryExpression}tyname='Lisp') // 'Lisp' is used for native lisp function calls such as Say$Lisp
// | ({TypePrimaryExpression}KW_OPAREN t5=TypeExpression1 KW_CPAREN)
// | ({TypePrimaryExpression}tyname='Record' KW_OPAREN t7=TypeExpression1
//               (KW_COLON t8+=TypeExpression1)?
//               (KW_COMMA t21+=TypeExpression1 (KW_COLON t23+=TypeExpression1)?)*
//                KW_CPAREN)
// | ({TypePrimaryExpression}tyname='Union' KW_OPAREN t10=TypeExpression1
//              (KW_COLON t11+=TypeExpression1)?
//              (KW_COMMA t24+=TypeExpression1 (KW_COLON t26+=TypeExpression1)?)*
//              KW_CPAREN)
// | ({TypePrimaryExpression}tyname='Join'
//    KW_OPAREN t13=TypeExpression1 (KW_COMMA t14+=TypeExpression1)* KW_CPAREN)
// | TypeNameOrFunctionCall
// | => TupleDefinition
//;

/*
 * This is the same as TypePrimaryExpression except it does not allow
 * the type to be extended by using a 'with' keyword. It is used
 * in the 'where' rule because the 'with' in that case has a
 * slightly different syntax.
 */
//TypePrimaryExpression2 returns TypePrimaryExpression hidden(WS):
// TypeLiteral
// | ({TypePrimaryExpression}t32=PERCENT)
// | ({TypePrimaryExpression}tyname='Type') // 'Type' is top of the category hierarchy
// | ({TypePrimaryExpression}tyname='Lisp') // 'Lisp' is used for native lisp function calls such as Say$Lisp
// | ({TypePrimaryExpression}KW_OPAREN t5=TypeExpression1 KW_CPAREN)
// | ({TypePrimaryExpression}tyname='Record' KW_OPAREN t7=TypeExpression1
//               (KW_COLON t8+=TypeExpression1)?
//               (KW_COMMA t21+=TypeExpression1 (KW_COLON t23+=TypeExpression1)?)*
//                KW_CPAREN)
// | ({TypePrimaryExpression}tyname='Union' KW_OPAREN t10=TypeExpression1
//              (KW_COLON t11+=TypeExpression1)?
//              (KW_COMMA t24+=TypeExpression1 (KW_COLON t26+=TypeExpression1)?)*
//              KW_CPAREN)
// | ({TypePrimaryExpression}tyname='Join'
//    KW_OPAREN t13=TypeExpression1 (KW_COMMA t14+=TypeExpression1)* KW_CPAREN)
// | TypeNameOrFunctionCall2
// | => TupleDefinition
//;

/* This rule will match:
 * Float - an ID representation of a type
 * List(Float) - a type function call
 * List Float - a non-parenthesis form if only one parameter
 *
 * A type function is also known as a parameterised type or
 * functor (not necessarily a true
 * functor since it may not obey the axioms of a functor).
 * If there is only one parameter then the parenthesis are optional
 */
//TypeNameOrFunctionCall hidden(WS):
//  tfnname=TK_ID
//  (
//    (KW_OPAREN (TK_ID KW_COLON)? t4=TypeExpression1? (KW_COMMA (TK_ID KW_COLON)? t25+=TypeExpression1)* KW_CPAREN)
//    // optional curried function:
//    (KW_OPAREN t44+=StatementExpression? (KW_COMMA t45+=Expression)* KW_CPAREN)*
//    // option of no parenthesis for single parameter
//    | => t6=TypePrimaryExpression1
//    | => w=WithInline
//  )?
//;

//TypeNameOrFunctionCall2 hidden(WS):
//  tfnname=TK_ID
//  (
//    (KW_OPAREN (TK_ID KW_COLON)? t4=TypeExpression1? (KW_COMMA (TK_ID KW_COLON)? t25+=TypeExpression1)* KW_CPAREN)
//    // optional curried function:
//    (KW_OPAREN t44+=StatementExpression? (KW_COMMA t45+=Expression)* KW_CPAREN)*
//    // option of no parenthesis for single parameter
//    | => t6=TypePrimaryExpression1
//  )?
//;

/* This has a form like: (Integer,Float,String)
 * like an array where each entry can be of a different type
 */
//TupleDefinition hidden(WS):
//  (KW_OPAREN t4=TypeExpression1 (KW_COMMA t25+=TypeExpression1)* KW_CPAREN)
//;

/* Since SPAD supports dependent types then numbers and strings can occur here.
 * Outstanding issues:
 * 1) Float literals are parsed as elt(Int,Int) so we need to recognise this
 * and convert to float literal
 * 2) We need to be able to recognise exponent notation for floats
 * 3) Integers without '-' prefix can be converted to PI or NNI
 * 4) need to add hex or octal notation for integers (0xhhhh)
 * 5) String and Character literals need to have backslash "\" doubled to
 * "\\" otherwise xtext will interpret backslash as an escape character.
 * 6) values following immediately after string literal such as "abc"d should
 * represent an implied concat: concat("abc",d)
 */
//TypeLiteral hidden(WS):
//  t1=TK_INT |
//  t22=TK_STRING |
//// t3=FloatLiteral |
//  t34=CharacterLiteral |
//  t35=BooleanLiteral
//;

/* In FunctionDefinition the algorithm is defined by a sequence of the
 * following statements:
 */
//Statement hidden(WS,TK_COMMENT):
//    s1=Block |
//    s3= StatementExpression |
//    // 'if' can occur in an expression or in
//    // a statement so we use '=>' to choose
//    // expression if there is any ambiguity
//    s4=IfStatement |
//    s4b=IfElseStatement |
//// s4c=IfThenStatement |
//    s5=WhileStatement |
//    s6=DoStatement |
//    s7=ForStatement |
//    s8=BreakStatement |
//    s12=RepeatStatement |
//    s9= IterateStatement |
//// s11= ContinueStatement|
//    s10= ReturnStatement |
//// s11= Import |
//    'error' e=Expression
//;

/* allows multiple statements which are grouped by wrapping in
 * braces (curly brackets) */
//Block hidden(WS,TK_COMMENT):
//stname=KW_OCURLY KW_NEWLINE*
//    (statemBl += Statement (KW_NEWLINE|KW_SEMICOLON)+)*
//    KW_CCURLY
//;

/*
 * Gives a value or assigns a value to a variable or does conditional exit
 *
 * examples:
 * x
 * x:Int
 * x,y:INT -- multiple assignment
 * x:Int := 3
 *
 * x=y => 3
 */
//StatementExpression hidden(WS,TK_COMMENT):
//  //(ID COMMA)* // allow multiple assignment
//  t=ConditionExpression // was Expression but changed so that 'if' statement
//                        // does not clash with if-then-else expression
//// (COLON t2=TypeExpression)?
//// (BECOMES t3=Expression (BECOMES t33+=Expression)*)?
//    (KW_ASSIGN t5=Block)?
//    // breaks out of a block if predicate before '=>' is true then program
//    // control leaves the block.
//    // Put it here so that it can only occur at the top level of an expression.
//    // if inside some complicated expression then it must be terminated with ';'.
//    (KW_IMPLIES t4=Statement)?
//;

/*
 * for i in n..m repeat ... is 1
 * for i in n..m by s repeat ...
 * for i in list repeat ...
 * for i in list for i in 1..length() repeat ...
 * for i in list for i in 1.. repeat ...
 * for j in n..m repeat loopBody
 * for j in n..m | odd? j repeat
 *
 * To Do
 * -----
 * As a temporary measure we check for '..' as a suffix operator
 * here, but we should really put this into expression?
 *
 * We need to allow conditions using BAR '|'
 */
//ForStatement hidden(WS,TK_COMMENT):
//'for' (
//       stname=TK_ID 'in' t1=Expression KW_2DOT? //(=> '..' t2=Expression)?
//       ('by' by1=Expression)?
//// (=> BAR t2=PredicateOr)? // condition
//       ('for' stname2+=TK_ID
//        'in' t2+=Expression KW_2DOT?
//        ('by' by2+=Expression)?
//        )*
//       ('while' t2+=Expression)*
//) 'repeat' KW_NEWLINE? s1=Statement //('is' s2=Statement)?
//;

/*
 * while BoolExpr repeat loopBody
 */
//WhileStatement hidden(WS,TK_COMMENT):
//stname='while' (
//       t2=Expression /*PredicateOr*/
//) 'repeat' KW_NEWLINE? s1=Statement
//;

/*
 * do loopBody while BoolExpr
 */
//DoStatement hidden(WS,TK_COMMENT):
//stname='do' (
//       s1=Statement
//) 'while' KW_NEWLINE? t2=Expression /*PredicateOr*/
//;

/*
 * will repeat until we jump out. For instance by calling return.
 */
//RepeatStatement hidden(WS,TK_COMMENT):
//stname='repeat' (
//       s1=Statement
//)
//;

/*
 * iterate ...
 * skips over the remainder of a loop
 */
//IterateStatement hidden(WS,TK_COMMENT):
//stname='iterate'
//;

/*
 * break leave current loop
 */
//BreakStatement hidden(WS,TK_COMMENT):
//stname='break'
//;

/*
 * return leave current function
 */
//ReturnStatement hidden(WS):
//stname='return' t2=Expression
//;

/*
 * import - use 'Import' instead
 */
//ImportStatement hidden(WS):
// stname='import' t2=Expression
//;

/* 'if' statement allows program flow to be switched
 * forms:
 * if boolean then
 * if equation then
 * if ... not ... and ...or ... then
 * if ... then ... else ...
 * note1:
 * if ... then ... else ... always returns a value so we can use this
 * on the right hand side of an assignment
 * note2:
 * since there is an explicit 'then' keyword there is no need to put
 * the condition in brackets
 *
 * examples:
 * a:= if x >0 then x else -x
 * if R has Field then ...
 * if myUnion case mtType then ...
 *
 * we also need to allow a form like this:
 * if x >0 {
 * then x
 * else -x
 * }
 *
 * also this form (this requires IfElseStatement rule):
 * if x >0 then {
 * x
 * }
 * else {
 * -x
 * }
 */
//IfStatement hidden(WS,TK_COMMENT):
//  'if' t2=Expression
//// 'if' t2=ConditionExpression
//  (
//    'then' s1=Statement
//    (=> 'else' s2=Statement)?
//   |
//    b?=KW_OCURLY
//    KW_NEWLINE+ 'then' s11=Statement KW_NEWLINE*
//    (=>'else' s12=Statement KW_NEWLINE*)?
//    KW_CCURLY
//  )
//;

//IfElseStatement hidden(WS,TK_COMMENT):
//'else' s2=Statement
//;

///////////// Expression syntax follows //////////////

/* This is the top level for expressions
 *
 * This level handles special cases such as:
 * if x then y else z
 * (x,y) +-> z
 *
 * We can consider expressions as elements of statements
 * expressions contain no newlines unless preceded by underscore
 * (which is handled by WS)
 */
//Expression returns Expr hidden(WS,TK_COMMENT):
//  (ifname='if' ifpred=Expression 'then' thenexp=Expression 'else' elseexp=Expression)
//// | LPAREN t24=ConditionExpression (COMMA t25+=ConditionExpression)+ RPAREN (COLON rightType2 =TypeExpression)? GIVES ConditionExpression
//  | ExitExpression
//;

/*
 * condition '=>' expr1 ';' expr2
 */
//ExitExpression returns Expr hidden(WS,TK_COMMENT):
//  ConditionExpression
//  ({ExitExpression.left=current} op=KW_IMPLIES right = ConditionExpression KW_SEMICOLON r2=ConditionExpression)*
//;

/*
 * BAR "|" precedence: 108, 111
 */
//ConditionExpression returns Expr hidden(WS,TK_COMMENT):
//  OrExpression
//  ({ConditionExpression.left=current} op=KW_BAR right = OrExpression )*
//;

/*
 * COMMA"," precedence: 110, 111
 */
//CommaExpression returns Expr hidden(WS,TK_COMMENT):
// ConditionalAndExpression
// ({ConditionExpression.left=current} op=BAR right = ConditionalAndExpression )*
//;

/*
 * There is also another rule that looks for 'or' which is PredicateOr,
 * this version is used in a general expression and the other version is
 * used when we know we have a predicate.
 * "or", precedence: 200, 201
 */
//OrExpression returns Expr hidden(WS,TK_COMMENT):
//  AndExpression
//  ( {OrExpression.left=current} op='or' right = AndExpression)*
//;

/*
 * There is also another rule that looks for 'and' which is PredicateAnd,
 * this version is used in a general expression and the other version is
 * used when we know we have a predicate.
 * "and", precedence: 250, 251
 */
//AndExpression returns Expr hidden(WS,TK_COMMENT):
//  InnerProdExpression
//  ( {AndExpression.left=current} op='and' right = InnerProdExpression)*
//;

/*
 * This has multiple uses such as inner product and logical or.
 *
 * "\/", BACKSLASHSLASH precedence: 200, 201
 *
 * the backslash is duplicated here because it is the escape character for
 * strings, it will not be duplicated when used.
 */
//InnerProdExpression returns Expr hidden(WS,TK_COMMENT):
//  OuterProdExpression
//  ( {InnerProdExpression.left=current} op=KW_VEE right = OuterProdExpression)*
//;

/*
 * This has multiple uses such as outer product and logical and.
 *
 * "/\", SLASHBACKSLASH precedence: 250, 251
 *
 * the backslash is duplicated here because it is the escape character for
 * strings, it will not be duplicated when used.
 */
//OuterProdExpression returns Expr hidden(WS,TK_COMMENT):
//  HasExpression
//  ( {OuterProdExpression.left=current} op=KW_WEDGE right = HasExpression)*
//;

/* Predicate which returns true if preceding value is of a given type
 * example:
 * if R has Field then ..
 *
 * "has", precedence: 400, 400
 */
//HasExpression returns Expr hidden(WS,TK_COMMENT):
//  CaseExpression
//  ({HasExpression.left=current} op='has' rightType = TypeExpression1)*
//;

/* Select from Union values
 * example:
 * if myUnion case mtType then ...
 *
 * "case", precedence: 400, 400
 */
//CaseExpression returns Expr hidden(WS,TK_COMMENT):
//  EqualityExpression
//  ( {CaseExpression.left=current} op='case' right = EqualityExpression)?
//;

/* used in list comprehension
 *
 * "in", precedence: 400, 400
 */
/*InExpression returns Expr hidden(WS,TK_COMMENT):
  RelationalExpression
  ( {CaseExpression.left=current} op='in' right = RelationalExpression)?
;*/

/*
 * "~=", precedence: 400, 400
 * "^=", precedence: 400, 400
 * "=", precedence: 400, 400
 */
//EqualityExpression returns Expr hidden(WS,TK_COMMENT):
//  RelationalExpression
//// ambiguous because EQ can be in top level expression
//  ( {EqualityExpression.left=current}
//   ( op=KW_EQ | op=KW_TILDEE | op=KW_HATE | (op=EQUALSDOLAR te=TK_ID))
//   //(DOLAR te=ID)?
//   right = RelationalExpression
//  )*
//;

/*
 * ">=", precedence: 400, 400
 * "<=", precedence: 400, 400
 * ">>", precedence: 400, 400
 * "<<", precedence: 400, 400
 * ">", precedence: 400, 400
 * "<", precedence: 400, 400
 */
//RelationalExpression returns Expr hidden(WS,TK_COMMENT):
//  IsExpression
//  ( {RelationalExpression.left=current}
//   ( op=KW_LT | op=KW_GT | op=KW_LE | op=KW_GE )
//      right = IsExpression
//  )?
//;

/*
 *
 * "isnt", precedence: 400, 400
 * "is", precedence: 400, 400
 */
//IsExpression returns Expr hidden(WS,TK_COMMENT):
//  SegmentExpression
//  ({IsExpression.left=current} (op='is' | op='isnt') rightType = TypeExpression1)*
//;

/*
 * this is used to indicate a range:
 * 1..4 means the range from 1 to 4
 * 1.. means the range from 1 to infinity. This is used in cases where
 * no top bounds is necessary, when the end point is determined by other
 * means.
 * "..", "SEGMENT", precedence: 401, 699, ["parse_Seg"]
 */
//SegmentExpression returns Expr hidden(WS,TK_COMMENT):
//  AdditiveExpression
//  ( {SegmentExpression.left=current} op=KW_2DOT right = AdditiveExpression)*
//;

/*
 * add expression
 * we include both '+' and '-' in the same case as this allows a
 * multiple sequence like:
 * a + b + c - d + e -f
 *
 * "-", precedence: 700, 701
 * "+", precedence: 700, 701
 */
//AdditiveExpression returns Expr hidden(WS,TK_COMMENT):
//  ExquoExpression
//  ( {AdditiveExpression.left=current}
//    ( op=KW_PLUS | op=KW_MINUS | (op=PLUSDOLAR te=TK_ID) | (op=MINUSDOLAR te=TK_ID))
//    right = ExquoExpression
//  )*
//;

/*
 * "exquo", precedence: 800, 801
 */
//ExquoExpression returns Expr hidden(WS,TK_COMMENT):
//  DivisionExpression
//  ({ExquoExpression.left=current} op='exquo' right = DivisionExpression)*
//;

/*
 * division expression
 * "/", precedence: 800, 801
 */
//DivisionExpression returns Expr hidden(WS,TK_COMMENT):
//  QuoExpression
//  ( {DivisionExpression.left=current}
//   (op=KW_SLASH | (op=DIVDOLAR te=TK_ID))
//   right = QuoExpression
//  )*
//;

/*
 *"quo", precedence: 800, 801
 */
//QuoExpression returns Expr hidden(WS,TK_COMMENT):
//  ModExpression
//  ({QuoExpression.left=current} op='quo' right = ModExpression)*
//;

/*
 *"mod", precedence: 800, 801
 */
//ModExpression returns Expr hidden(WS,TK_COMMENT):
//  RemExpression
//  ({ModExpression.left=current} op='mod' right = RemExpression)*
//;

/*
 *"rem", precedence: 800, 801
 */
//RemExpression returns Expr hidden(WS,TK_COMMENT):
//  MultiplicativeExpression
//  ({RemExpression.left=current} op='rem' right = MultiplicativeExpression)*
//;

/*
 * multiplication expression
 * a * b * c
 *
 * "*", precedence: 800, 801
 */
//MultiplicativeExpression returns Expr hidden(WS,TK_COMMENT):
//  ExponentExpression
//  ( {MultiplicativeExpression.left=current}
//    (op=KW_STAR | (op=TIMESDOLAR te=TK_ID))
//    right = ExponentExpression
//  )*
//;

/*
 *
 * "^", precedence: 901, 900
 * "**", precedence: 901, 900
 */
//ExponentExpression returns Expr hidden(WS,TK_COMMENT):
//  MapDefinition
//  ({ExponentExpression.left=current} (op=KW_HAT | op=KW_2STAR) right = MapDefinition)*
//;

/* Map or Lambda expression
 * var +-> function
 *
 * +-> is an infix operator meaning 'maps-to'
 * It can be used to create a function literal (an anonymous function), so
 * instead of:
 * myFunct(x:Type):Type == if x >0 then x else -x
 * we can have forms such as:
 * x +-> if x >0 then x else -x
 * or:
 * (x,y) +-> if x >0 then y else -x
 *
 * fricas compatibility:
 * "+->", precedence: 995, 112
 */
//MapDefinition returns Expr hidden(WS,TK_COMMENT):
//// (PretendExpression | LPAREN PretendExpression (COMMA t25+=PretendExpression)+ RPAREN) (COLON rightType2 =TypeExpression)?
//  AssignExpression
//  ({MapDefinition.left=current}
//   op=KW_MAPSTO right = AssignExpression
//   (par = TK_ID)? // optional parameter which function
//                             // is applied to
//  )*
//;

/*
 * an assign expression like this:
 * x := y
 * can also be an inner assign like this:
 * x := (y := z)
 * or just:
 * x := y := z
 *
 * right is expression to allow forms like
 * x := if y<0 then -y else y
 */
//AssignExpression returns Expr hidden(WS,TK_COMMENT):
//  PretendExpression
//  ({AssignExpression.left=current} op=KW_ASSIGN (
//   right = PretendExpression
//   | ifname='if' ifpred=ConditionExpression 'then' thenexp=ConditionExpression 'else' elseexp=PretendExpression
//   )
//  )*
//;

/*
 * pretend Type: treat one type as another,
 * only works if they have the same internal structure.
 *
 * Not very safe and should be avoided, if possible, unfortunately
 * its not always possible to avoid.
 *
 * "pretend", precedence: 995, 996
 */
// PretendExpression returns Expr hidden(WS,TK_COMMENT):
//  CoerceExpression
//  ({PretendExpression.left=current} op='pretend' rightType = TypeExpression1)*
//;

/*
 * "::", precedence: 996, 997
 *
 * although '::' and '@' apparently have the same precidence we want
 * '@' to bind more tightly than '::'. As we can see in the following example:
 * "dictionary"@String :: OutputForm.
 */
//CoerceExpression returns Expr hidden(WS,TK_COMMENT):
//  HintTypeExpression
//  ({CoerceExpression.left=current} op=KW_2COLON rightType = TypeExpression1)*
//;

/*
 * "@", precedence: 996, 997
 */
//HintTypeExpression returns Expr hidden(WS,TK_COMMENT):
//  EltExpression
//  ( {HintTypeExpression.left=current} op=KW_AT rightType = TypeExpression1)?
//;

/* We treat these as part of the language
 * : indicates type
 * ! is part of name to indicate mutable
 *
 * ":", precedence: 996, 997
 * "!", precedence: 1002, 1001
 *
 */
/*BangExpression returns Expr hidden(WS,TK_COMMENT):
  EqualityExpression
  ({AndExpression.left=current} op=AMPERSAND right = EqualityExpression)*
;*/

/*
 * "with", precedence: 2000, 400, ["parse_InfixWith"]
 *
 */
/*WithExpression returns Expr hidden(WS,TK_COMMENT):
  EqualityExpression
  ({AndExpression.left=current} op='with' right = EqualityExpression)*
;*/


/* Elt is Lisp terminology for the use of '.' to select parameters
 * the left expression is something that has selectable elements such as
 * a list, array, string, Record or union, the right element should be a
 * non-negative integer.
 */
//EltExpression returns Expr hidden(WS,TK_COMMENT):
//  ExplicitTypeExpression
//  ( {EltExpression.left=current}
//   op=KW_DOT right = ExplicitTypeExpression
//  )*
//;

////////////// unary expressions ////////////////////


/*
 * '$'
 */
//ExplicitTypeExpression returns Expr hidden(WS,TK_COMMENT):
//  UnaryExpression
//  ({ExplicitTypeExpression.left=current} op=KW_DOLLAR rightType = TypeExpression1)?
//;

/* UnaryExpression
 * unary prefixes:
 * "~" TILDE : precedence 260, 259, nil
 * ":" COLON : precedence 194, 195
 * "-" MINUS : precedence 701, 700
 * "#" HASH : precedence 999, 998
 * "'" : precedence 999, 999, ["parse_Data"]
 * unary suffixes
 * ".." : range can be unary suffix
 */
//UnaryExpression returns Expr hidden(WS,TK_COMMENT):
//  PrimaryExpression |
//  ({UnaryExpression} uop=KW_TILDE expr=UnaryExpression) |
//// ({UnaryExpression} uop=COLON expr=UnaryExpression) |
//  ({UnaryExpression} uop=KW_MINUS expr=UnaryExpression) |
//  ({UnaryExpression} uop=MINUSDOLAR te=TK_ID expr=UnaryExpression) |
//  ({UnaryExpression} uop=KW_SHARP expr=UnaryExpression) |
//  ({UnaryExpression} uop='not' expr=PrimaryExpression) |
//  ({UnaryExpression} uop=SUMLIST expr=PrimaryExpression) |
//  ({UnaryExpression} uop=PRIMEPERCENT expr=PrimaryExpression) |
//   e2=PERCENT |
//  e3='Type' |
//  e5='Record' KW_OPAREN e6=TypeExpression1
//               (KW_COLON e22+=TypeExpression1)?
//               (KW_COMMA e21+=TypeExpression1 (KW_COLON e23+=TypeExpression1)?)*
//                KW_CPAREN |
//  e9='Union' KW_OPAREN e10=TypeExpression1
//              (KW_COLON e25+=TypeExpression1)?
//              (KW_COMMA e24+=TypeExpression1 (KW_COLON e26+=TypeExpression1)?)*
//              KW_CPAREN |
//  e11='Join' KW_OPAREN e12=TypeExpression1 (KW_COMMA e13+=TypeExpression1)* KW_CPAREN
//;

/*
 *
 */
/*UnaryExpressionHash returns Expr hidden(WS,TK_COMMENT):
// HASH? PrimaryExpression
  PrimaryExpression | ({UnaryExpressionHash} uop=HASH expr=UnaryExpressionHash)
;*/

/*
 *
 */
//PrimaryExpression returns Expr hidden(WS,TK_COMMENT):
//  PrimaryPrefix /* ( t2+=PrimarySuffix )* */
//;

/*
 * Can contain an expression in parenthesis, this expression is
 * 'StatementExpression' which means that it can contain an
 * inner assignment.
 *
 * The comma option allows us to define a tuple
 */
//PrimaryPrefix hidden(WS,TK_COMMENT):
// Literal
// | KW_OPAREN t4=Expression (KW_COMMA t25+=Expression)* KW_CPAREN =>(KW_COLON rightType3 =TypeExpression1)?
// | t7=NameOrFunctionCall
//;

/* function call such as List(Integer)
 * known as a parameterised type or functor (not necessarily a true functor since
 * it may not obey the axioms of a functor)
 * if there is only one parameter then the parenthesis are optional
 *
 * function binds most tightly
 */
//NameOrFunctionCall hidden(WS,TK_COMMENT):
//  (KW_QUOTE)?
//  fnname=TK_ID (=> lsp=KW_DOLLAR 'Lisp'/*t2=TypeExpression*/)?
//  // option for parameters in parenthesis
//  (
//// LPAREN t4=StatementExpression? (COMMA t5+=Expression)* RPAREN //(COLON rightType2 =TypeExpression)?
//    KW_OPAREN t4=Expression? (KW_COMMA t5+=Expression)* KW_CPAREN //(COLON rightType2 =TypeExpression)?
//    // optional curried function:
//    (KW_OPAREN t14+=Statement? (KW_COMMA t15+=Expression)* KW_CPAREN)*
//    // option of no parenthesis for single parameter
//    | => t6=PrimaryExpression
//  )?
//  => ((KW_COMMA TK_ID)* KW_COLON rightType2 =TypeExpression1)?
//  // allow multiple assignment
//  //=>(op=GIVES lambda = Expression 'xxx')?
///;

/* Literals are actual values of a given type
 * Outstanding issues:
 * 1) Float literals are parsed as elt(Int,Int) so we need to recognise this
 * and convert to float literal
 * 2) We need to be able to recognise exponent notation for floats
 * 3) Integers without '-' prefix can be converted to PI or NNI
 * 4) need to add hex or octal notation for integers (0xhhhh)
 * 5) String and Character literals need to have backslash "\" doubled to
 * "\\" otherwise xtext will interpret backslash as an escape character.
 * 6) values following immediately after string literal such as "abc"d should
 * represent an implied concat: concat("abc",d)
 */
//Literal hidden(WS,TK_COMMENT):
//  value=TK_INT
//  | t2=TK_STRING (=> e1=NameOrFunctionCall =>(t31+=TK_STRING (=> e4+=NameOrFunctionCall)?)*)?
// | t3=FloatLiteral // conflicts with use of '.' for elt
//  | ListLiteral
//  | CharacterLiteral
//  | BooleanLiteral
//;

/* Contains a single character whereas a string contains multiple
 * characters.
 */
//CharacterLiteral hidden(WS,TK_COMMENT):
// KW_QUOTE c1=ANY_OTHER KW_QUOTE
//;

/* This may not need to be specified here at the syntax level. Perhaps we
* should treat boolean as any other library defined type.
*/
//BooleanLiteral hidden(WS,TK_COMMENT):
// litname = 'true' | litname = 'false'
// | litname = 'true' KW_OPAREN KW_CPAREN
// | litname = 'false' KW_OPAREN KW_CPAREN
//;

/*
 * a list literal may consist of:
 * [] an empty list
 * [a] a single element
 * [a,b] multiple elements
 * [a for b in c] a list comprehension
 */
//ListLiteral hidden(WS,TK_COMMENT):
// litname = KW_OBRACK l2=Expression?
//     (KW_COMMA t3+=Expression)*
//     ('for' t14+=Expression 'in' l5+=Expression)?
//     KW_CBRACK
//;