grammar com.euclideanspace.aldor.Editor hidden ()

import "http://www.eclipse.org/emf/2002/Ecore" as ecore

generate editor "http://www.euclideanspace.com/aldor/Editor"

/* Copyright 2014 Martin John Baker
 *
 * This file is part of EuclideanSpace.
 *
 * EuclideanSpace is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * EuclideanSpace is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with EuclideanSpace. If not, see <http://www.gnu.org/licenses/>.
 */

/*
 *
 * Here we are using a LL(*) recursive-descent parser generator and this
 * may not be able to exactly replicate axl.z which is a
 * LALR(1) conflict-free grammar for Aldor.
 */

/* from tokInfoTable[] in token.c: Lexical elements.
* The TokenTag enumeration must use this order.
*
* This table MUST be laid out so that all "symbol" tokens starting with
* the same character are contiguous.
*
* Be extra careful with fields F, G, H and K: if you get them wrong then
* the lineariser will delete end-of-statement tokens when it ought not
* to. This can lead to odd compiler behaviour that is hard to track down
* unless you know about this table.
*
* struct tok_info tokInfoTable[] = {
*
* [A] TokenTag tag
* [B] Symbol sym
* [C] String str
* [D] Byte hasString i.e. use val.str (vs val.sym)
* [E] Byte isComment i.e. ++ --
* [F] Byte isOpener i.e. ( [ { etc
* [G] Byte isCloser i.e. ) ] } etc
* [H] Byte isFollower i.e. then else always in etc
* [I] Byte isLangword i.e. if then etc
* [J] Byte isLeftAssoc i.e., associates left to right
* [K] Byte isMaybeInfix i.e., add, with, +
* [L] Byte precedence i.e., 0 is lowest, or don't know
* [M] Byte isDisabled i.e., non-zero means disabled
*
* [A] [B][C] [D][E] [F] [G] [H] [I] [J] [K] [L] [M]
*
        {TK_Id, 0,"TK_Id", 0, 0, 0, 0, 0, 0, 1, 0, 170, 0},
        {TK_Blank, 0,"TK_Blank", 0, 0, 0, 0, 0, 0, 1, 0, 170, 0},
        {TK_Int, 0,"TK_Int", 1, 0, 0, 0, 0, 0, 1, 0, 170, 0},
        {TK_Float, 0,"TK_Float", 1, 0, 0, 0, 0, 0, 1, 0, 170, 0},
        {TK_String, 0,"TK_String", 1, 0, 0, 0, 0, 0, 1, 0, 170, 0},
        {TK_PreDoc, 0,"TK_PreDoc", 1, 1, 0, 0, 0, 0, 1, 0, 170, 0},
        {TK_PostDoc, 0,"TK_PostDoc", 1, 1, 0, 0, 0, 0, 1, 0, 170, 0},
        {TK_Comment, 0,"TK_Comment", 1, 1, 0, 0, 0, 0, 1, 0, 170, 0},
        {TK_SysCmd, 0,"TK_SysCmd", 1, 1, 0, 0, 0, 0, 1, 0, 170, 0},
        {TK_Error, 0,"TK_Error", 1, 0, 0, 0, 0, 0, 1, 0, 0, 0},

        {KW_Add, 0,"add", 0, 0, 0, 0, 0, 1, 1, 0, 0, 0},
        {KW_And, 0,"and", 0, 0, 0, 0, 1, 1, 1, 1, 40, 0},
        {KW_Always, 0,"always", 0, 0, 0, 0, 1, 1, 1, 1, 0, 0},
        {KW_Assert, 0,"assert", 0, 0, 0, 0, 0, 1, 1, 0, 0, 0},
        {KW_Break, 0,"break", 0, 0, 0, 0, 0, 1, 1, 0, 0, 0},
        {KW_But, 0,"but", 0, 0, 0, 0, 1, 1, 1, 1, 0, 0},
        {KW_By, 0,"by", 0, 0, 0, 0, 0, 0, 1, 1, 110, 0},
        {KW_Case, 0,"case", 0, 0, 0, 0, 0, 0, 1, 1, 0, 0},
        {KW_Catch, 0,"catch", 0, 0, 0, 0, 1, 1, 1, 1, 0, 0},
        {KW_Default, 0,"default", 0, 0, 0, 0, 0, 1, 1, 0, 0, 0},
        {KW_Define, 0,"define", 0, 0, 0, 0, 0, 1, 1, 0, 0, 0},
        {KW_Delay, 0,"delay", 0, 0, 0, 0, 0, 1, 1, 0, 0, 0},
        {KW_Do, 0,"do", 0, 0, 0, 0, 0, 1, 1, 0, 0, 0},
        {KW_Else, 0,"else", 0, 0, 0, 0, 1, 1, 1, 0, 0, 0},
        {KW_Except, 0,"except", 0, 0, 0, 0, 0, 1, 1, 1, 0, 0},
        {KW_Export, 0,"export", 0, 0, 0, 0, 0, 1, 1, 0, 0, 0},
        {KW_Exquo, 0,"exquo", 0, 0, 0, 0, 0, 0, 1, 1, 125, 0},
        {KW_Extend, 0,"extend", 0, 0, 0, 0, 0, 1, 1, 0, 0, 0},
        {KW_Finally, 0,"finally", 0, 0, 0, 0, 1, 1, 1, 1, 0, 0},
        {KW_Fix, 0,"fix", 0, 0, 0, 0, 0, 1, 1, 0, 0, 0},
        {KW_For, 0,"for", 0, 0, 0, 0, 0, 1, 1, 0, 0, 0},
        {KW_Fluid, 0,"fluid", 0, 0, 0, 0, 0, 1, 1, 0, 0, 0},
        {KW_Free, 0,"free", 0, 0, 0, 0, 0, 1, 1, 0, 0, 0},
        {KW_From, 0,"from", 0, 0, 0, 0, 1, 1, 1, 0, 0, 0},
        {KW_Generate, 0,"generate", 0, 0, 0, 0, 0, 1, 1, 0, 0, 0},
        {KW_Goto, 0,"goto", 0, 0, 0, 0, 0, 1, 1, 0, 0, 0},
        {KW_Has, 0,"has", 0, 0, 0, 0, 0, 0, 1, 1, 40, 0},
        {KW_If, 0,"if", 0, 0, 0, 0, 0, 1, 1, 0, 0, 0},
        {KW_Import, 0,"import", 0, 0, 0, 0, 0, 1, 1, 0, 0, 0},
        {KW_In, 0,"in", 0, 0, 0, 0, 1, 1, 1, 1, 0, 0},
        {KW_Inline, 0,"inline", 0, 0, 0, 0, 0, 1, 1, 0, 0, 0},
        {KW_Is, 0,"is", 0, 0, 0, 0, 0, 1, 1, 0, 0, 0},
        {KW_Isnt, 0,"isnt", 0, 0, 0, 0, 0, 1, 1, 0, 0, 0},
        {KW_Iterate, 0,"iterate", 0, 0, 0, 0, 0, 1, 1, 0, 0, 0},
        {KW_Let, 0,"let", 0, 0, 0, 0, 0, 1, 1, 0, 0, 0},
        {KW_Local, 0,"local", 0, 0, 0, 0, 0, 1, 1, 0, 0, 0},
        {KW_Macro, 0,"macro", 0, 0, 0, 0, 0, 1, 1, 0, 0, 0},
        {KW_Mod, 0,"mod", 0, 0, 0, 0, 0, 0, 1, 1, 125, 0},
        {KW_Never, 0,"never", 0, 0, 0, 0, 0, 1, 1, 0, 0, 0},
        {KW_Not, 0,"not", 0, 0, 0, 0, 0, 1, 1, 1, 150, 0},
        {KW_Of, 0,"of", 0, 0, 0, 0, 1, 1, 1, 1, 40, 0},
        {KW_Or, 0,"or", 0, 0, 0, 0, 1, 1, 1, 1, 40, 0},
        {KW_Pretend, 0,"pretend", 0, 0, 0, 0, 1, 1, 1, 1, 150, 0},
        {KW_Quo, 0,"quo", 0, 0, 0, 0, 0, 0, 1, 1, 125, 0},
        {KW_Reference, 0,"ref", 0, 0, 0, 0, 0, 1, 1, 0, 0, 0},
        {KW_Rem, 0,"rem", 0, 0, 0, 0, 0, 0, 1, 1, 125, 0},
        {KW_Repeat, 0,"repeat", 0, 0, 0, 0, 0, 1, 1, 0, 0, 0},
        {KW_Return, 0,"return", 0, 0, 0, 0, 0, 1, 1, 0, 0, 0},
        {KW_Rule, 0,"rule", 0, 0, 0, 0, 0, 1, 1, 0, 0, 0},
        {KW_Select, 0,"select", 0, 0, 0, 0, 0, 1, 1, 0, 0, 0},
        {KW_Then, 0,"then", 0, 0, 0, 0, 1, 1, 1, 0, 0, 0},
        {KW_Throw, 0,"throw", 0, 0, 0, 0, 0, 1, 1, 1, 0, 0},
        {KW_To, 0,"to", 0, 0, 0, 0, 1, 1, 1, 0, 0, 0},
        {KW_Try, 0,"try", 0, 0, 0, 0, 0, 1, 1, 0, 0, 0},
        {KW_Where, 0,"where", 0, 0, 0, 0, 1, 1, 1, 0, 0, 0},
        {KW_While, 0,"while", 0, 0, 0, 0, 0, 1, 1, 0, 0, 0},
        {KW_With, 0,"with", 0, 0, 0, 0, 0, 1, 1, 0, 0, 0},
        {KW_Yield, 0,"yield", 0, 0, 0, 0, 0, 1, 1, 0, 0, 0},

        {KW_Quote, 0,"'", 0, 0, 0, 0, 0, 0, 1, 0, 0, 0},
        {KW_Grave, 0,"`", 0, 0, 0, 0, 0, 0, 1, 0, 0, 0},
        {KW_Ampersand, 0,"&", 0, 0, 0, 0, 0, 0, 1, 0, 160, 0},
        {KW_Comma, 0,",", 0, 0, 0, 0, 1, 0, 1, 1, 11, 0},
        {KW_Semicolon, 0,";", 0, 0, 0, 0, 0, 0, 1, 0, 10, 0},
        {KW_Dollar, 0,"$", 0, 0, 0, 0, 1, 0, 0, 1, 70, 0},
        {KW_Sharp, 0,"#", 0, 0, 0, 0, 0, 0, 1, 0, 0, 0},
        {KW_At, 0,"@", 0, 0, 0, 0, 0, 0, 1, 1, 150, 0},

        {KW_Assign, 0,":=", 0, 0, 0, 0, 1, 0, 0, 1, 20, 0},
        {KW_Colon, 0,":", 0, 0, 0, 0, 1, 0, 1, 1, 36, 0},
        {KW_ColonStar, 0,":*", 0, 0, 0, 0, 1, 0, 1, 1, 36, 0},
        {KW_2Colon, 0,"::", 0, 0, 0, 0, 1, 0, 1, 1, 150, 0},

        {KW_Star, 0,"*", 0, 0, 0, 0, 0, 0, 1, 1, 130, 0},
        {KW_2Star, 0,"**", 0, 0, 0, 0, 0, 0, 1, 1, 140, 0},

        {KW_Dot, 0,".", 0, 0, 0, 0, 1, 0, 1, 1, 170, 0},
        {KW_2Dot, 0,"..", 0, 0, 0, 0, 0, 0, 1, 1, 110, 0},

        {KW_EQ, 0,"=", 0, 0, 0, 0, 0, 0, 1, 1, 100, 0},
        {KW_2EQ, 0,"==", 0, 0, 0, 0, 1, 0, 0, 1, 25, 0},
        {KW_MArrow, 0,"==>", 0, 0, 0, 0, 1, 0, 0, 1, 25, 0},
        {KW_Implies, 0,"=>", 0, 0, 0, 0, 0, 0, 1, 1, 35, 0},

        {KW_GT, 0,">", 0, 0, 0, 0, 0, 0, 1, 1, 100, 0},
        {KW_2GT, 0,">>", 0, 0, 0, 0, 0, 0, 1, 1, 100, 0},
        {KW_GE, 0,">=", 0, 0, 0, 0, 0, 0, 1, 1, 100, 0},

        {KW_LT, 0,"<", 0, 0, 0, 0, 0, 0, 1, 1, 100, 0},
        {KW_2LT, 0,"<<", 0, 0, 0, 0, 0, 0, 1, 1, 100, 0},
        {KW_LE, 0,"<=", 0, 0, 0, 0, 0, 0, 1, 1, 100, 0},
        {KW_LArrow, 0,"<-", 0, 0, 0, 0, 0, 0, 1, 1, 0, 0},

        {KW_Hat, 0,"^", 0, 0, 0, 0, 0, 0, 1, 1, 140, 0},
        {KW_HatE, 0,"^=", 0, 0, 0, 0, 0, 0, 1, 1, 90, 0},

        {KW_Tilde, 0,"~", 0, 0, 0, 0, 0, 0, 0, 1, 150, 0},
        {KW_TildeE, 0,"~=", 0, 0, 0, 0, 0, 0, 1, 1, 90, 0},

        {KW_Plus, 0,"+", 0, 0, 0, 0, 0, 0, 1, 1, 120, 0},
        {KW_PlusMinus, 0,"+-", 0, 0, 0, 0, 0, 0, 1, 1, 120, 0},
        {KW_MapsTo, 0,"+->", 0, 0, 0, 0, 1, 0, 1, 1, 30, 0},
        {KW_MapsToStar, 0,"+->*", 0, 0, 0, 0, 1, 0, 1, 1, 30, 0},

        {KW_Minus, 0,"-", 0, 0, 0, 0, 0, 0, 1, 1, 120, 0},
        {KW_RArrow, 0,"->", 0, 0, 0, 0, 0, 0, 0, 1, 80, 0},
        {KW_MapStar, 0,"->*", 0, 0, 0, 0, 0, 0, 0, 1, 80, 0},

        {KW_Slash, 0,"/", 0, 0, 0, 0, 0, 0, 1, 1, 130, 0},
        {KW_Wedge, 0,"/\\", 0, 0, 0, 0, 0, 0, 1, 1, 40, 0},

        {KW_Backslash, 0,"\\", 0, 0, 0, 0, 0, 0, 1, 1, 130, 0},
        {KW_Vee, 0,"\\/", 0, 0, 0, 0, 0, 0, 1, 1, 40, 0},

        {KW_OBrack, 0,"[", 0, 0, 1, 0, 0, 0, 1, 0, 0, 0},
        {KW_OBBrack, 0,"[|", 0, 0, 1, 0, 0, 0, 1, 0, 0, 0},
        {KW_OCurly, 0,"{", 0, 0, 1, 0, 0, 0, 1, 0, 0, 0},
        {KW_OBCurly, 0,"{|", 0, 0, 1, 0, 0, 0, 1, 0, 0, 0},
        {KW_OParen, 0,"(", 0, 0, 1, 0, 0, 0, 1, 0, 0, 0},
        {KW_OBParen, 0,"(|", 0, 0, 1, 0, 0, 0, 1, 0, 0, 0},

        {KW_CBrack, 0,"]", 0, 0, 0, 1, 0, 0, 1, 0, 0, 0},
        {KW_CCurly, 0,"}", 0, 0, 0, 1, 0, 0, 1, 0, 0, 0},
        {KW_CParen, 0,")", 0, 0, 0, 1, 0, 0, 1, 0, 0, 0},

        {KW_Bar, 0,"|", 0, 0, 0, 0, 0, 0, 1, 0, 0, 0},
        {KW_CBBrack, 0,"|]", 0, 0, 0, 1, 0, 0, 1, 0, 0, 0},
        {KW_CBCurly, 0,"|}", 0, 0, 0, 1, 0, 0, 1, 0, 0, 0},
        {KW_CBParen, 0,"|)", 0, 0, 0, 1, 0, 0, 1, 0, 0, 0},
        {KW_2Bar, 0,"||", 0, 0, 0, 0, 0, 1, 1, 0, 0, 0},

        {KW_NewLine, 0,"\n", 0, 0, 0, 0, 0, 0, 1, 0, 0, 0},
        {KW_StartPile, 0,"#pile", 0, 0, 0, 0, 0, 0, 1, 0, 0, 0},
        {KW_EndPile, 0,"#endpile", 0, 0, 0, 0, 0, 0, 1, 0, 0, 0},
        {KW_SetTab, 0,"KW_SetTab", 0, 0, 0, 0, 0, 0, 1, 0, 0, 0},
        {KW_BackSet, 0,"KW_BackSet", 0, 0, 0, 0, 0, 0, 1, 0, 0, 0},
        {KW_BackTab, 0,"KW_BackTab", 0, 0, 0, 0, 0, 0, 1, 0, 0, 0},
        {KW_Juxtapose, 0,"KW_Juxtapose",0, 0, 0, 0, 0, 0, 0, 0, 170, 0},

        {TK_LIMIT, 0,"TK_LIMIT", 0, 0, 0, 0, 0, 0, 1, 0, 0, 0}
};
*/

/*
 * Parser starts here
 * CategoryDef,PackageDef and DomainDef must end with newline to ensure that
 * only an '@' at the start of a line will be taken as the end.
 *
 * On this line whitespace (WS) is not hidden so is explicitly included.
 */
Model :
')abbrev' WS (c=CategoryDef | p=PackageDef | d=DomainDef) AT
;

////////// start of lexer rules ///////////////

/* ID consists of alpha (upper or lower case) followed by alphanumeric
 * any other character can stand in for alpha if prefixed by '_'
 * for instance a multiply function is often named '_*'
 * IDs can also end with ? or ! where:
 * '?' indicates a function which returns a boolean value
 * '!' indicates a function which changes an existing domain value
 * (in a mutable domain) */
terminal ID : ('a'..'z'|'A'..'Z'|('_'.)) ('a'..'z'|'A'..'Z'|('_'.)|'0'..'9')*'!'?'?'?;

/* whitespace on single line overrides default whitespace
 * does not include newline unless it follows underscore.
 * I would have liked to do this as follows:
 * terminal WS : (' '|'\t'|'_'(('\r'|'\n')+))+;
 * problem: unfortunately use of underscore in this way masks the use of underscore
 * in ID. We therefore need to remove this type of underscore in a
 * preprocessor
 */
terminal WS : (' '|'\t')+;

/* at least one newline or carriage return character.
 * This is not included with WS because whitespace is significant in SPAD.
 * We usually absorb newlines like this: NL+ which absorbs any number of
 * blank lines and it also supports both the Linux and the Windows forms of
 * newlines.
 */
terminal NL: ('\r'|'\n') ;

/* overwriting SL_COMMENTS we do not want Java syntax (//) but spad syntax (--)
 * This absorbs everything from '--' or '++' to the end of the line (but not
 * including the newline or carriage return characters)
 */
terminal SL_COMMENT :
  ('--'|'++') !('\n'|'\r')* ;//('\r'|'\n')?;

/* Macro value can be anything until the end of line
 * Macro is really '==>' but the pre-processor inserts an extra '=' so
 * that we can distinguish from where ==> is used in 'with' or 'add' parts
 * It is difficult for a LL(*) parser to handle macros so we want to
 * substitute the macro in a pre-processor */
terminal MACROVALUE :
  '===>' !('\n'|'\r')*;

/* '==>' is used in 'with' or 'add' parts so is not really a macro?
 */
//terminal MACRO:
// '==>'
//;

/* string literals are enclosed in double quotes
*/
terminal STRING :
'"' ( !('"') )* '"'
;

terminal INT returns ecore::EInt: ('0'..'9')+;

// grouping
/* ( */
terminal LPAREN: '(';
/* ) */
terminal RPAREN: ')';
/* { */
terminal LBRACE: '{';
/* } */
terminal RBRACE: '}';
/* [ */
terminal LBRACKET: '[';
/* ] */
terminal RBRACKET: ']';
/*
terminal LBANANA '(|';
terminal RBANANA '|)';
terminal EBRACKET '[__]';
terminal EBRACKET2 '[]';
terminal EBRACE '{__}';
terminal EBRACE2 '{}';
terminal LBANANABRACKET '[|';
terminal RBANANABRACKET '|]';
terminal EBANANABRACKET '[|__|]';
terminal EBANANABRACKET2 '[||]';
terminal LBANANABRACE '{|';
terminal RBANANABRACE '|}';
terminal EBANANABRACE '{|__|}';
terminal EBANANABRACE2 '{||}'; */
/* << */
terminal OANGLE: '<<';
/* >> */
terminal CANGLE: '>>';
/*terminal QUOTE "'";
terminal BACKQUOTE "`";*/

// operators
/* ==> */
terminal MDEF: '==>';
/* | */
terminal BAR: '|';
/* . */
terminal DOT: '.';
/* :: */
terminal COERCE: '::';
/* : */
terminal COLON: ':';
/* @ */
terminal AT: '@';
/* , */
terminal COMMA: ',';
/* ; */
terminal SEMICOLON: ';';
/* ** */
terminal POWER: '**';
/* * */
terminal TIMES: '*';
/* + */
terminal PLUS: '+';
/* - */
terminal MINUS: '-';
/* < */
terminal LT: '<';
/* > */
terminal GT: '>';
/* <= */
terminal LE: '<=';
/* >= */
terminal GE: '>=';
/* = */
terminal EQUAL: '=';
/* ~= */
terminal NOTEQUAL: '~=';
/* ~ */
terminal TILDE: '~';
/* ^ */
terminal CARAT: '^';
/* .. */
terminal SEG: '..';
/* # */
terminal HASH: '#';
/* & */
terminal AMPERSAND: '&';
/* $ */
terminal DOLAR: '$';
/* / */
terminal SLASH: '/';
terminal BACKSLASH: '\\';
terminal SLASHSLASH: '//';
terminal BACKSLASHBACKSLASH: '\\\\';
/* '/\\' outer product or logical and */
terminal SLASHBACKSLASH: '/\\';
/* \\/ inner product or logical or */
terminal BACKSLASHSLASH: '\\/';
/* *$ multiply with specific type*/
terminal TIMESDOLAR: '*$';
/* /$ divide with specific type*/
terminal DIVDOLAR: '/$';
/* +$ add with specific type*/
terminal PLUSDOLAR: '+$';
/* -$ subtract or minus with specific type*/
terminal MINUSDOLAR: '-$';
/* =$ equals with specific type*/
terminal EQUALSDOLAR: '=$';
/* '=>' */
terminal EXIT: '=>';
/* := */
terminal BECOMES: ':=';
/* == */
terminal DEF: '==';
/* -> */
terminal ARROW: '->';
terminal LARROW: '<-';
/* +-> */
terminal GIVES: '+->';
/* % represents an instance of this type */
terminal PERCENT: '%';
/* '% */
terminal PRIMEPERCENT: "'%";
/* ... */
terminal ELLIPSIS: '...';
/* +/ takes the sum of a list */
terminal SUMLIST: '+/';
terminal ANY_OTHER: .;

////////// end of lexer rules ///////////////

//Goal
//: CurlyContents(Labeled)
//{ yypval = $$ = $1; }
//;

//Expression
//: enlist1a(Labeled, KW_Semicolon, `AB_Sequence)
//;

//Labeled
//: Comma
//| Declaration
//| KW_At Atom opt(Labeled)
//{ $$ = abNewLabel(TPOS($1),$2,$3); }
//;

//Declaration
//: KW_Macro MacroBody
//{ $$ = abNewMacro(TPOS($1),$2); }
//| KW_Extend Sig
//{ $$ = abNewExtend(TPOS($1),$2); }
//| KW_Local Sig
//{ $$ = abNewLocal(TPOS($1),$2); }
//| KW_Free Sig
//{ $$ = abNewFree(TPOS($1),$2); }
//| KW_Fluid Sig
//{ $$ = abNewFluid(TPOS($1),$2); }
//| KW_Default Sig
//{ $$ = abNewDefault(TPOS($1),$2); }
//| KW_Define Sig
//{ $$ = abNewDDefine(TPOS($1),$2); }
//| KW_Fix Sig
//{ $$ = abNewFix(TPOS($1),$2); }
//| KW_Inline opt(Sig) opt(FromPart)
//{ $$ = abNewInline(TPOS($1),$2,$3); }
//| KW_Import opt(Sig) opt(FromPart)
//{ $$ = abNewImport(TPOS($1),$2,$3); }
//| ExportDecl
//;

//ExportDecl
//: KW_Export opt(Sig)
//{ $$ = abNewExport(TPOS($1),$2, abZip,abZip); }
//| KW_Export opt(Sig) ToPart
//{ $$ = abNewExport(TPOS($1),$2,abZip,$3); }
//| KW_Export opt(Sig) FromPart
//{ $$ = abNewExport(TPOS($1),$2,$3,abZip); }
//;

//ToPart
//: KW_To Infixed
//{ $$ = $2; }
//;

//FromPart
//: KW_From enlist1(Infixed, KW_Comma, `AB_Comma)
//{ $$ = $2; }
//;

//MacroBody
//: Sig
//| ExportDecl
//| KW_Import Sig opt(FromPart)
//{ $$ = abNewImport(TPOS($1),$2,$3); }
//;

//Sig
//: DeclBinding
//| Block
//;

//DeclPart
//: KW_Colon Type
//{ $$ = $2; }
//| KW_ColonStar Type
//{ $$ = abNewHide(TPOS($1), $2); }
//;

/*
 * Commas
 */
//Comma
//: enlist1(CommaItem, KW_Comma, `AB_Comma)
//;

//CommaItem
//: Binding(AnyStatement)
//| Binding(AnyStatement) KW_Where CommaItem
//{ $$ = abNewWhere(TPOS($2),$3,$1); }
//;

/*
 * DeclBinding
 */
//DeclBinding
//: BindingR(InfixedExprsDecl,AnyStatement)
//;

//InfixedExprsDecl
//: InfixedExprs
//| InfixedExprs DeclPart
//{ $$ = abNewDeclare(APOS($1),$1,$2); }
//;

//InfixedExprs
//: enlist1(InfixedExpr, KW_Comma, `AB_Comma)
//;


/*
 * Bindings
 */
//Binding(E)
//: BindingL(Infixed,E)
//;

//BindingL(R,L)
//: L
//| R KW_Assign BindingL(R,L)
//{ $$ = abNewAssign(APOS($1),$1,$3); }
//| R KW_2EQ BindingL(R,L)
//{ $$ = abNewDefine(APOS($1),$1,$3); }
//| R KW_MArrow BindingL(R,L)
//{ $$ = abNewMDefine(APOS($1),$1,$3); }
//| R KW_MapsTo BindingL(R,L)
//{ $$ = abNewLambda(APOS($1),$1,abZip,$3); }
//| R KW_MapsToStar BindingL(R,L)
//{ $$ = abNewPLambda(APOS($1),$1,abZip,$3); }
//;

//BindingR(R,L)
//: R
//| R KW_Assign Binding(L)
//{ $$ = abNewAssign(APOS($1),$1,$3); }
//| R KW_2EQ Binding(L)
//{ $$ = abNewDefine(APOS($1),$1,$3); }
//| R KW_MArrow Binding(L)
//{ $$ = abNewMDefine(APOS($1),$1,$3); }
//| R KW_MapsTo Binding(L)
//{ $$ = abNewLambda(APOS($1),$1,abZip,$3); }
//| R KW_MapsToStar Binding(L)
//{ $$ = abNewPLambda(APOS($1),$1,abZip,$3); }
//;

/*
 * Statements
 *
 * It is easier to spot conflicts when explicitly handling dangling else.
 */
//AnyStatement
//: KW_If CommaItem KW_Then Binding(AnyStatement)
//{ $$ = abNewIf(TPOS($1), TEST($2),$4,abZip); }
//| Flow(AnyStatement)
//;

//BalStatement
//: Flow(BalStatement)
//;

//Flow(XX)
//: Collection
//| KW_If CommaItem KW_Then Binding(BalStatement) KW_Else Binding(XX)
//{ $$ = abNewIf(TPOS($1), TEST($2),$4,$6); }
//| Collection KW_Implies Binding(XX)
//{ $$ = abNewExit(TPOS($2), TEST($1),$3); }
//| Iterators KW_Repeat Binding(XX)
//{ $$ = abNewRepeatOL(TPOS($2),$3,$1); listFree(AbSyn)($1); }
//| KW_Repeat Binding(XX)
//{ $$ = abNewRepeat0(TPOS($1),$2); }
//| KW_Try Binding(AnyStatement) KW_But ButExpr AlwaysPart(XX)
//{ (void)parseDeprecated(KW_But, abNewNothing(TPOS($3))); $$ = abNewTry(TPOS($1),$2,$4->abSequence.argv[0], $4->abSequence.argv[1],$5); }
//| KW_Try Binding(AnyStatement) KW_Catch ButExpr AlwaysPart(XX)
//{ $$ = abNewTry(TPOS($1),$2,$4->abSequence.argv[0], $4->abSequence.argv[1],$5); }
//| KW_Select Binding(AnyStatement) KW_In Cases
//{ $$ = abNewSelect(TPOS($1),$2,$4); }
//| KW_Do Binding(XX)
//{ $$ = abNewDo(TPOS($1),$2); }
//| KW_Delay Binding(XX)
//{ $$ = abNewDelay(TPOS($1),$2); }
//| KW_Reference Binding(XX)
//{ $$ = abNewReference(TPOS($1),$2); }
//| KW_Generate GenBound Binding(XX)
//{ $$ = abNewGenerate(TPOS($1),$2,$3); }
//| KW_Assert Binding(XX)
//{ $$ = abNewAssert(TPOS($1),TEST($2)); }
//| KW_Iterate opt(Name)
//{ $$ = abNewIterate(TPOS($1),$2); }
//| KW_Break opt(Name)
//{ $$ = abNewBreak(TPOS($1),$2); }
//| KW_Return opt(Collection)
//{ $$ = abNewReturn(TPOS($1),$2); }
//| KW_Yield Binding(XX)
//{ $$ = abNewYield(TPOS($1),$2); }
//| KW_Except Binding(XX)
//{ $$ = parseDeprecated(KW_Except, abNewRaise(TPOS($1),$2)); }
//| KW_Throw Binding(XX)
//{ $$ = abNewRaise(TPOS($1),$2); }
//| KW_Goto Id
//{ $$ = abNewGoto(TPOS($1),$2); }
//| KW_Never
//{ $$ = abNewNever(TPOS($1)); }
//;

//GenBound
//: Nothing
//| KW_To CommaItem KW_Of
//{ $$ = $2; }
//;

//ButExpr
//: Nothing
//{ $$ = abNew(AB_Sequence, APOS($1), 2, abZip, abZip); }
//| DeclBinding KW_In Cases
//{ $$ = abNew(AB_Sequence, APOS($1), 2, $1, $3); }
//;

//Cases
//: Binding(Collection)
//;

//AlwaysPart(XX)
//: KW_Always Binding(XX)
//{ (void)parseDeprecated(KW_Always, abNewNothing(TPOS($1))); $$ = $2; }
//| KW_Finally Binding(XX)
//{ $$ = $2; }
//| Nothing
//;

/*
 * Iterators
 */
//Collection
//: Infixed
//| Infixed Iterators
//{ $$ = abNewCollectOL(APOS($1),$1,$2); listFree(AbSyn)($2); }
//;

//Iterators<ablist>
//: Iterators1
//{ $$ = listNReverse(AbSyn)($1); }
//;

//Iterators1<ablist>
//: Iterator
//{ $$ = listCons(AbSyn)($1, NULL); }
//| Iterators1 Iterator
//{ $$ = listCons(AbSyn)($2, $1); }
//;

//Iterator
//: KW_For ForLhs KW_In Infixed opt(SuchthatPart)
//{ $$ = abNewFor(TPOS($1),$2,$4,$5); }
//| KW_While Infixed
//{ $$ = abNewWhile(TPOS($1),TEST($2)); }
//;

//ForLhs
//: Infixed
//| KW_Free Infixed
//{ $$ = abNewFree(TPOS($1), $2); }
//| KW_Local Infixed
//{ $$ = abNewLocal(TPOS($1), $2); }
//| KW_Fluid Infixed
//{ $$ = abNewFluid(TPOS($1), $2); }
//;

//SuchthatPart
//: KW_Bar Infixed
//{ $$ = TEST($2); }
//;

/*
 * Infixed Expressions
 */

//Infixed
//: InfixedExpr
//| InfixedExpr DeclPart
//{ $$ = abNewDeclare(APOS($1),$1,$2); }
//| Block
//;

//InfixedExpr
//: E11(Op)
//| E3
//;


//E3
//: E4
//| E3 KW_And E4
//{ $$ = abNewAnd(TPOS($2), TEST($1),TEST($3)); }
//| E3 KW_Or E4
//{ $$ = abNewOr(TPOS($2), TEST($1),TEST($3)); }
//| E3 LatticeOp E4
//{ $$ = abNewInfix(APOS($2),$2,$1,$3); }
//;

//E4
//: E5
//| E4 KW_Has E5
//{ $$ = abNewHas(TPOS($2),$1,$3); }
//| E4 RelationOp E5
//{ $$ = abNewInfix(APOS($2),$2,$1,$3); }
//| RelationOp E5
//{ $$ = abNewPrefix(APOS($1),$1,$2); }
//;

//E5
//: E6
//| E5 SegOp
//{ $$ = abNewPostfix(APOS($2),$2,$1); }
//| E5 SegOp E6
//{ $$ = abNewInfix(APOS($2),$2,$1,$3); }
//;

//E6
//: E7
//| E6 PlusOp E7
//{ $$ = abNewInfix(APOS($2),$2,$1,$3); }
//| PlusOp E7
//{ $$ = abNewPrefix(APOS($1),$1,$2); }
//;

//E7
//: E8
//| E7 QuotientOp E8
//{ $$ = abNewInfix(APOS($2),$2,$1,$3); }
//;

//E8
//: E9
//| E8 TimesOp E9
//{ $$ = abNewInfix(APOS($2),$2,$1,$3); }
//;

//E9
//: E11(E12)
//| E11(E12) PowerOp E9
//{ $$ = abNewInfix(APOS($2),$2,$1,$3); }
//;

//E11(X)
//: X
//| E11(X) KW_2Colon E12
//{ $$ = abNewCoerceTo(TPOS($2),$1,$3); }
//| E11(X) KW_At E12
//{ $$ = abNewRestrictTo(TPOS($2),$1,$3); }
//| E11(X) KW_Pretend E12
//{ $$ = abNewPretendTo(TPOS($2),$1,$3); }
//;

//Type
//: E11(E12)
//;

//E12
//: E13
//| E13 ArrowOp E12
//{ $$ = abNewInfix(APOS($2),$2,$1,$3); }
//;

//E13
//: E14
//| E14 KW_Dollar QualTail
//{ $$ = abNewQualify(TPOS($2),$1,$3); }
//;

//QualTail
//: LeftJuxtaposed
//| LeftJuxtaposed KW_Dollar QualTail
//{ $$ = abNewQualify(TPOS($2),$1,$3); }
//;

//OpQualTail
//: Molecule
//| Molecule KW_Dollar OpQualTail
//{ $$ = abNewQualify(TPOS($2),$1,$3); }
//;

//E14
//: E15
//| opt(E14) KW_With DeclMolecule
//{ $$ = abNewWith(TPOS($2),$1,$3); }
//| opt(E14) KW_Add DeclMolecule
//{ $$ = abNewAdd(TPOS($2),$1,$3); }
//| E14 KW_Except E15
//{ $$ = parseDeprecated(KW_Except, abNewExcept(TPOS($2),$1,$3)); }
//| E14 KW_Throw E15
//{ $$ = abNewExcept(TPOS($2),$1,$3); }
//;

//E15
//: Application
//;


/*
 * Infixed Operations
 */
//Op
//: ArrowOp
//| LatticeOp
//| RelationOp
//| SegOp
//| PlusOp
//| QuotientOp
//| TimesOp
//| PowerOp
//;

//NakedOp
//: UnqualOp(ArrowTok)
//| UnqualOp(LatticeTok)
//| UnqualOp(RelationTok)
//| UnqualOp(SegTok)
//| UnqualOp(PlusTok)
//| UnqualOp(QuotientTok)
//| UnqualOp(TimesTok)
//| UnqualOp(PowerTok)
//;


//ArrowOp: QualOp(ArrowTok);
//LatticeOp: QualOp(LatticeTok);
//RelationOp: QualOp(RelationTok);
//SegOp: QualOp(SegTok);
//PlusOp: QualOp(PlusTok);
//QuotientOp: QualOp(QuotientTok);
//TimesOp: QualOp(TimesTok);
//PowerOp: QualOp(PowerTok);

//ArrowTok<tok>: KW_RArrow | KW_LArrow | KW_MapStar ;
//LatticeTok<tok>: KW_Vee | KW_Wedge ;
//RelationTok<tok>:KW_EQ | KW_TildeE | KW_HatE |
//KW_GE | KW_GT | KW_2GT |
//KW_LE | KW_LT | KW_2LT |
//KW_Is | KW_Isnt | KW_Case ;
//SegTok<tok>: KW_2Dot | KW_By ;
//PlusTok<tok>: KW_Plus | KW_Minus | KW_PlusMinus ;
//QuotientTok<tok>:KW_Mod | KW_Quo | KW_Rem | KW_Exquo ;
//TimesTok<tok>: KW_Star | KW_Slash | KW_Backslash ;
//PowerTok<tok>: KW_2Star | KW_Hat ;

/*
 * Juxtaposed Expressions
 *
 * a b c d as(.(.(.)))
 * f(a).2(b)(c).x.y.(d).(e) as(((.).).)
 *
 */

//Application
//: RightJuxtaposed
//;

//RightJuxtaposed
//: Jright(Molecule)
//;

//LeftJuxtaposed
//: Jleft(Molecule)
//;

//Jright(H)
//: Jleft(H)
//| Jleft(H) Jright(Atom)
//{ $$ = parseMakeJuxtapose($1,$2); }
//| KW_Not Jright(Atom)
//{ $$ = abNewNot(TPOS($1),TEST($2)); }
//;

//Jleft(H)
//: H
//| KW_Not BlockEnclosure
//{ $$ = abNewNot(TPOS($1),TEST($2)); }
//| Jleft(H) BlockEnclosure
//{ $$ = parseMakeJuxtapose($1,$2); }
//| Jleft(H) KW_Dot BlockMolecule
//{ $$ = abNewPrefix(TPOS($2),$1,$3); }
//;

/*
 * Indivisible Expressions
 */
//Molecule
//: Atom
//| Enclosure
//;

//Enclosure
//: Parened
//| Bracketed
//| QuotedIds
//;

//DeclMolecule
//: opt(Application)
//| Block
//;

//BlockMolecule
//: Atom
//| Enclosure
//| Block
//;

//BlockEnclosure
//: Enclosure
//| Block
//;

//Block
//: Piled(Expression)
//| Curly(Labeled)
//;

//Parened
//: KW_OParen KW_CParen
//{
//$$ = abNewParen(TPOS($1), abNewComma0(TPOS($1)));
//abSetEnd($$, TEND($2));
//}
//| KW_OParen Expression KW_CParen
//{ $$ = abNewParen(TPOS($1), $2); abSetEnd($$, TEND($3)); }
//;

//Bracketed
//: KW_OBrack KW_CBrack
//{
//$$ = abNewMatchfix(TPOS($1),
//abNewId(TPOS($1),ssymBracket),
//abNewComma0(TPOS($1)));
//abSetEnd($$, TEND($2));
//}
//| KW_OBrack Expression KW_CBrack
//{
//$$ = abNewMatchfix(TPOS($1),
//abNewId(TPOS($1),ssymBracket),
//$2);
//abSetEnd($$, TEND($3));
//}
//;

//QuotedIds
//: KW_Quote KW_Quote
//{
//$$ = abNewMatchfix(TPOS($1),
//abNewId(TPOS($1),ssymEnum),
//abNewComma0(TPOS($1)));
//abSetEnd($$, TEND($2));
//}
//| KW_Quote Names KW_Quote
//{
//$$ = abNewMatchfix(TPOS($1),
//abNewId(TPOS($1),ssymEnum),
//$2);
//abSetEnd($$, TEND($3));
//}
//;
//Names
//: enlist1(Name, KW_Comma, `AB_Comma)
//;

/*
 * Terminals
 */
//Atom
//: Id
//| Literal
//;

//Name
//: Id
//| NakedOp
//;

//Id
//: TK_Id
//{ $$ = abNewOfToken(AB_Id, $1); }
//| KW_Sharp
//{ $$ = abNewOfToken(AB_Id, $1); }
//| KW_Tilde
//{ $$ = abNewOfToken(AB_Id, $1); }
//;

//Literal
//: TK_Int
//{ $$ = abNewOfToken(AB_LitInteger, $1); }
//| TK_Float
//{ $$ = abNewOfToken(AB_LitFloat, $1); }
//| TK_String
//{ $$ = abNewOfToken(AB_LitString, $1); }
//;

/*
 * Meta-rules
 */

//Nothing
//:
//{ $$ = abZip; }
//;

//UnqualOp(op)
//: op
//{ $$ = abNewOfToken(AB_Id, $1); }
//;

//QualOp(op)
//: op
//{ $$ = abNewOfToken(AB_Id, $1); }
//| op KW_Dollar OpQualTail
//{ $$ = abNewQualify(TPOS($1), abNewOfToken(AB_Id, $1), $3); }
//;

//opt(E)
//: Nothing
//| E
//;

/* ++ Doc. */

//Doc(E)
//: PreDocument E PostDocument
//{
//$$ = $2;
//if($3) $$ = abNewDocumented(APOS($3),$$,$3);
//if($1) $$ = abNewDocumented(APOS($$),$$,$1);
//}
//;

//PreDocument
//: PreDocumentList
//{ $$ = abNewDocTextOfList($1); listFree(Token)($1); }
//;

//PostDocument
//: PostDocumentList
//{ $$ = abNewDocTextOfList($1); listFree(Token)($1); }
//;

//PreDocumentList<toklist>
//: Nothing
//{ $$ = listNil(Token); }
//| TK_PreDoc PreDocumentList
//{ $$ = listCons(Token)($1, $2); }
//;

//PostDocumentList<toklist>
//: Nothing
//{ $$ = listNil(Token); }
//| TK_PostDoc PostDocumentList
//{ $$ = listCons(Token)($1, $2); }
//;

/* E {sep E sep E} */
//enlist1(E,Sep,Tag)
//: enlister1(E, Sep)
//
//{ $$ = abOneOrNewOfList(Tag, $1); listFree(AbSyn)($1); }
//;

/* E sep E {sep E} */
//enlist2(E,Sep,Tag)
//: enlister1(E, Sep) Sep E
//{
//$1 = listCons(AbSyn)($3, $1);
//$$ = abOneOrNewOfList(Tag, $1);
//listFree(AbSyn)($1);
//}
//;

//enlister1(E, Sep)<ablist>
//: E
//{ $$ = listCons(AbSyn)($1, listNil(AbSyn) ); }
//| enlister1(E, Sep) Sep E
//{ $$ = listCons(AbSyn)($3, $1); }
//;


/* E {sep+ E sep+ E sep*} */
//enlist1a(E,Sep,Tag)
//: enlister1a(E, Sep)
//{ $$ = abOneOrNewOfList(Tag, $1); listFree(AbSyn)($1); }
//;

//enlister1a(E, Sep)<ablist>
//: E
//{ $$ = listCons(AbSyn)($1, listNil(AbSyn) ); }
//| enlister1a(E, Sep) Sep E
//{ $$ = listCons(AbSyn)($3, $1); }
//| enlister1a(E, Sep) Sep
//{ $$ = $1; }
//;

/* Piled */
//Piled(E)
//: KW_SetTab PileContents(E) KW_BackTab
//{ $$ = abOneOrNewOfList(AB_Sequence,$2); listFree(AbSyn)($2); }
//;

//Curly(E)
//: KW_OCurly CurlyContents(E) KW_CCurly
//{ $$ = $2; abSetPos($$, TPOS($1)); abSetEnd($$, TEND($3)); }
//;

//PileContents(E)<ablist>
//: Doc(E)
//{ $$ = listCons(AbSyn)($1, listNil(AbSyn)); }
//| PileContents(E) KW_BackSet Doc(E)
//{ $$ = listCons(AbSyn)($3, $1); }
//| error KW_BackSet Doc(E)
//{ yyerrok; $$ = listCons(AbSyn)($3, listNil(AbSyn)); }
//;

//CurlyContents(E)
//: CurlyContentsList(E)
//{ $$ = abOneOrNewOfList(AB_Sequence,$1); listFree(AbSyn)($1); }
//;

//CurlyContentsList(E)<ablist>
//: CurlyContent1(E)
//| CurlyContent1(E) CurlyContentB(E)
//{ $$ = listCons(AbSyn)($2, $1); }
//;

//CurlyContent1(E)<ablist>
//: Nothing
//{ $$ = listNil(AbSyn); }
//| CurlyContent1(E) CurlyContentA(E)
//{ $$ = listCons(AbSyn)($2, $1); }
//;

//CurlyContentA(E)
//: CurlyContentB(E) KW_Semicolon PostDocument
//{ $$ = $1; if($3) $$ = abNewDocumented(APOS($3),$$,$3); }
//| error KW_Semicolon PostDocument
//{ yyerrok; $$ = abNewNothing(TPOS($2)); }
//;

//CurlyContentB(E)
//: PreDocument E PostDocument
//{
//$$ = $2;
//if($1) $$ = abNewDocumented(APOS($1),$$,$1);
//if($3) $$ = abNewDocumented(APOS($$),$$,$3);
//}
//;

///////// and of Aldor stuff

/*
 * longname and longname2 should both be ID and have the same value. Since the
 * runtime values can't be checked by the parser this must be checked later.
 */
CategoryDef hidden(WS,NL,SL_COMMENT):
name='category' shortname=ID longname=ID
longname2=ID /*[CategoryDef]*/
    (cp=TypeParameterList)?
    COLON 'Category' DEF
    (
    implName=TypeArguments? ((w=WithPart? a=AddPart?)| wh5=WherePart)
    | LBRACE NL*
      implName=TypeArguments ((w=WithPart? a=AddPart?)| wh5=WherePart)
      RBRACE NL* a2=AddPart?
    )
;

/*
 * longname and longname2 should both be ID and have the same value. Since the
 * runtime values can't be checked by the parser this must be checked later.
 */
PackageDef hidden(WS,NL,SL_COMMENT):
name='package' shortname=ID longname=ID
longname2=ID /*[PackageDef]*/
    (cp=TypeParameterList)? COLON
    (
     exportName=ID DEF implName=ID
        (w=WithPart | wh5=WherePart)
     |
     w=WithPart
     (DEF add2=AddPart)?
    )
;

/*
 * longname and longname2 should both be ID and have the same value. Since the
 * runtime values can't be checked by the parser this must be checked later.
 */
DomainDef hidden(WS,NL,SL_COMMENT):
name='domain' shortname5=ID longname5=ID
longname6=ID /*[DomainDef]*/
    (cp5=TypeParameterList)?
    COLON exportName=ID (cp6=TypeParameterList)?
    DEF implName5=ID?
    (w=WithPart | wh5=WherePart | a=AddPart)
;

/*
 * both category and domain can have 'where' part which holds overall information
 * such as category/domain parameter information and general macros. This is
 * followed by export('with') and import ('add') information.
 * Forms allowed include:
 * Exports == PlottablePlaneCurveCategory with {
 * Exports ==> PlottablePlaneCurveCategory with {
 * Exports ==> with {
 */
WherePart hidden(WS,SL_COMMENT):
name='where' NL* LBRACE NL*
    (whereAssig +=WhereAssignments (NL|SEMICOLON)+)*
    // with part
    (longname8=ID (DEF | MDEF) (imp=TypeExpression2)? w8=WithPart)?
    // add part
    (
     (longname9=ID (DEF | MDEF))?
        ((fs=ID LPAREN par2=ID? (COMMA par3 += ID)* RPAREN)
         | (fs=ID f2=ID)
        )?
        add=AddPart
    )?
    RBRACE NL+
;

/* each one must be on a separate line or separated by ';'
 * need to add name=
 */
WhereAssignments hidden(WS):
VariableDeclaration
| MacroDef |Import
;

/*
 * the 'where' part contains a 'with' part which holds export information
 * such as function signatures (function declarations) but not function definitions.
 */
WithPart hidden(WS,SL_COMMENT):
name='with' NL* LBRACE NL*
    (fundec += VariableDeclaration (NL|SEMICOLON)+)*
    RBRACE NL*
;

/*
 * similar to 'WithPart' but no trailing NL
 */
WithInline hidden(WS,SL_COMMENT):
name='with' NL* LBRACE NL*
    (fundec += VariableDeclaration (NL|SEMICOLON)+)*
    RBRACE
;

/*
 * the 'where' part contains a 'add' part which holds function and other
 * declarations.
 */
AddPart hidden(WS,SL_COMMENT):
name='add' NL* LBRACE NL*
    (t+=AddStatements (NL|SEMICOLON)+)* RBRACE NL*
;

/*
 * The add section of domain or package may contain multiple lines
 *
 * Examples:
 * if (r := recip leadingCoefficient M) case "failed" then {
 * error "Modulus cannot be made monic"
 * }
 */
AddStatements hidden(WS,SL_COMMENT):
   VariableDeclarationAssign
   | FunctionDefinition
   | ('if' t1=Expression // expression has form 'x has y'
      'then' t13=FunctionDefinitionBlock)
   | 'else' t14=FunctionDefinitionBlock
   | 'else' t15=AddStatements
   | MacroDef
   | Import
;

/* function definition in add part (called by AddStatements)
 * has a form like:
 * name(params) == statement
 * or, option for single parameter without brackets:
 * name param == statement
 * or, option for zero parameters without brackets:
 * This does not always work at the moment, for instance, this does not work:
 * size == size$R ^ d
 * but this does
 * size() == size$R ^ d
 *
 * or, for infix operators,
 * a = b == statement
 * or, for multiple statements,
 * name(params) == {
 * statement
 * statement
 * }
 * some function definitions may be conditional like this:
 * if % has finiteAggregate then {
 * ... }
 */
FunctionDefinition hidden(WS,SL_COMMENT):
  ((
par3=FunctionSignature
    (COLON par4=TypeExpression1)?
    DEF par5=Statement
   )|(
    // this is case where FunctionSignature is just an identifier
    fnNam=ID DEF par5=Statement
   ))
;

/*
 * called by 'AddStatements' rule.
 * allows more add statements inside:
 * if a has y then 'more add statements'
 */
FunctionDefinitionBlock hidden(WS,SL_COMMENT):
    fnDecBr=LBRACE NL*
      (
       fnDecBk += FunctionDefinition (NL|SEMICOLON)+
       |
       vars+=VariableDeclarationAssign (NL|SEMICOLON)+
     | ('if' t1+=Expression // expression has form 'x has y'
        'then' t13+=FunctionDefinitionBlock (NL|SEMICOLON)+)
     | ('else' t14+=FunctionDefinitionBlock (NL|SEMICOLON)+)
     | i1+=Import (NL|SEMICOLON)+
      )*
      RBRACE
      | 'error' e=Expression
      | LBRACE NL* 'error' e=Expression (NL|SEMICOLON)+ RBRACE
;

/* This is the first part of the function definition without the return type or
 * the function implementation. Usually the function signature has a form like:
 * name(params)
 * We allow a single parameter to be given without brackets:
 * name param
 *
 * We also allow some alternative forms to represent infix operators like:
 * a = b to represent _=(a,b)
 * or the following (this works but only for % we need it to work for every type)
 * s:% = t:%
 * or
 * a > b to represent _>(a,b)
 * 0 or 1 can be used as a function signature as a short form of
 * _0() or _1()
 */
FunctionSignature hidden(WS,SL_COMMENT):
  (
fnNam=ID
    LPAREN
    par2=VariableTyped?
    (COMMA par3 += VariableTyped)*
    RPAREN
  ) | (
   // fnNam=ID par2=VariableDeclaration causes recursive definition so use:
   fnNam=ID par=ID
// ) | (
// t4=ID // no parameters without brackets
// commented out as it causes recursive rule invocation
// with ruleAddStatements and ruleFunctionDefinitionBlock
  ) | (
   t4=ID (COLON (PERCENT | ID))? //(COLON te1=TypeExpression)?
   ( b1=EQUAL | b1=LT | b1=GT | b1=LE | b1=GE |
            b1=PLUS | b1=MINUS | b1=TIMES | b1=SLASH | b1=AMPERSAND |
            b1=BAR | b1=CARAT) t5=ID
  ) | (
   b3=INT // allows special form of function signature using '0' or '1'
   // can't specify '0' or '1' explicitly as this would affect lex
   // order
  ) | (
   b2=MINUS t6=ID
  ) | (
   b4=TILDE t7=ID
  ) | (
   b5='not' t8=ID
  ) | (
   b6=HASH t8=ID
  )
;

/* macros provide a general textual substitution
 * there are two forms:
 * name ==> body
 * and
 * name macro == body
 */
MacroDef: macroname=ID MACROVALUE ; //MACRO val=ID NL;

/*
 * import domain
 */
Import hidden(WS):
'import' (impname += ID)+ (LPAREN par22+=TypeExpression1
(COMMA par22+=TypeExpression1)* RPAREN)?
;

/* Variable declaration in where and with sections:
 * A 'variable' can be simple like:
 * x:Float
 * or something more complicated like:
 * x:Record(newPt: Pt,type: String)
 * or it can be a function like:
 * x:(Float,Integer) -> Float
 * or it can be conditional like:
 * if
 */
VariableDeclarationBlock hidden(WS,SL_COMMENT):
    vardecbr=LBRACE NL*
      //=>(i1=Import NL*)?
      (vardecBlk += VariableDeclaration (NL|SEMICOLON)+)*
      RBRACE
;

/* Variable declaration in where and with sections:
 * A 'variable' can be simple like:
 * x:Float
 * or something more complicated like:
 * x:Record(newPt: Pt,type: String)
 * or it can be a function like:
 * x:(Float,Integer) -> Float
 * or it can be conditional like:
 * if
 */
VariableDeclaration hidden(WS,SL_COMMENT):
//Import?
    ('if' t1=Expression 'then')? // expression has form 'x has y'
( v1=TypeWithName
      | v2=VariableDeclarationBlock
)
;

/*
 * This rule is used where a type is expected like:
 * Float
 * but it may also have an optional name like:
 * x:Float
 */
TypeWithName hidden(WS,SL_COMMENT):
(
(varName=ID | varNameSt=STRING) (COMMA varName2=ID)?
COLON
)? typ=TypeExpression1
;


/* Variable name with optional type. This is used in function signature
 * and also by VariableDeclaration:
 * A 'variable' can be simple like:
 * x:Float
 * or something more complicated like:
 * x:Record(newPt: Pt,type: String)
 * or it can be a function like:
 * x:(Float,Integer) -> Float
 * we can define multiple variables together:
 * i,j : Integer
 */
VariableTyped hidden(WS,SL_COMMENT):
(varName=ID | varNameSt=STRING)
// =>(COMMA t2+=ID)* // multiple declarations in same line
    (COLON typ=TypeExpression1)?
;

/* in add part we can declare and assign in same part
 * such as:
 * a := 3
 * a:Integer := 3
 * a := sin(x)
 *
 * There are two forms of multiple assignment:
 * a,b,c := 0@Integer
 * or:
 * a := b := c := 0@Integer
 */
VariableDeclarationAssign hidden(WS):
  varName=ID // name of variable
  // if I just use name=ID then, when the ui program is running, I get:
  // Duplicate xxx 'coerce' in yyy
  (
    (COMMA t12+=ID)* // multiple declarations in same line
    (COLON typ=TypeExpression1)? // option to explicitly define type
    (BECOMES (t4=Expression /* |(LBRACE NL* Expression NL* RBRACE) */))?
    // we need block since we can't always detect continuation after ':='
    // but this causes infinite loop
  )// | (BECOMES t2+=ID)+ BECOMES t4=Expression
;

/*
 * free variable allows us to declare a variable that is global
 */
FreeVariable hidden(WS):
'free' var=ID
;

/*
 * allows us to declare a variable that is not global
 */
LocalVariable hidden(WS):
'local' var=ID
;

/*
 * This is similar to Expression but known to be of type.
 * (Expression can also be of type) but if we know that
 * this is a type we can exclude some possibilities.
 *
 * A 'typeExpression' can be simple like:
 * Float
 * or something more complicated like:
 * Record(newPt: Pt,type: String)
 * or it can be a function like:
 * (Float,Integer) -> Float
 *
 * first we check for a function like: Integer -> Integer
 */
TypeExpression1 returns TypeExpression hidden(WS):
   =>(t2=TypeArguments ARROW t3=TypeResult)
   | TypePrimaryExpression1
;

/*
 * This is the same as TypeExpression except it does not allow
 * the type to be extended by using a 'with' keyword. It is used
 * in the 'where' rule because the 'with' in that case has a
 * slightly different syntax.
 */
TypeExpression2 returns TypeExpression hidden(WS):
   =>(t92=TypeArguments ARROW t93=TypeResult)
   | TypePrimaryExpression2
;

/*
 * we use a type parameter list for parameters of category, package or domains
 * Parameter list may be empty '()'.
 * in this case parameters may be just ID or they may be nameID:typeID
 *
 * examples are:
 * ()
 * (String)
 * (s:String)
 * (String,Integer)
 * (s:String,i:Integer)
 */
TypeParameterList hidden(WS):
tyname=LPAREN par=ID?
(COLON par21=TypeExpression1)?
(COMMA par2 += ID (COLON par22+=TypeExpression1)?)* RPAREN;

/*
 * we use type arguments for first part of function type, that is
 * x in x-> y
 * usually this is enclosed in parenthesis
 * (x) in (x)-> y
 * but if x is a single argument (Including Record, Union, etc.) then it does
 * not need to be in parenthesis.
 */
TypeArguments hidden(WS):
  t=TypeLiteral |
  t2=PERCENT |
  t3='Type' |
  // usually, but not always type arguments are in parenthesis, and empty
  // parenthesis are allowed
  b1 ?= LPAREN ((ID COLON)? t4=TypeExpression1)? ( COMMA (ID COLON)? t16 +=TypeExpression1)* RPAREN |
  t5='Record' LPAREN t6=TypeExpression1
               (COLON t22+=TypeExpression1)?
               (COMMA t21+=TypeExpression1 (COLON t23+=TypeExpression1)?)*
                RPAREN |
  t9='Union' LPAREN t10=TypeExpression1
              (COLON t25+=TypeExpression1)?
              (COMMA t24+=TypeExpression1 (COLON t26+=TypeExpression1)?)*
              RPAREN |
  t11='Join' LPAREN t12=TypeExpression1 (COMMA t13+=TypeExpression1)* RPAREN |
  t15=TypeNameOrFunctionCall
;

/*
 * we use type arguments for final part of function type, that is
 * y in x-> y
 */
TypeResult hidden(WS):
  t=TypeLiteral |
  t2=PERCENT |
  tyname='Type' |
  tyname='Record' LPAREN t7=TypeExpression1
               (COLON t8+=TypeExpression1)?
               (COMMA t21+=TypeExpression1 (COLON t23+=TypeExpression1)?)*
                RPAREN |
  tyname='Union' LPAREN t10=TypeExpression1
              (COLON t11+=TypeExpression1)?
              (COMMA t24+=TypeExpression1 (COLON t26+=TypeExpression1)?)*
              RPAREN |
  tyname='Join' LPAREN t12=TypeExpression1 (COMMA t13+=TypeExpression1)* RPAREN |
  t15=TypeNameOrFunctionCall
;

/*
 * this matches various specific types
 */
TypePrimaryExpression1 returns TypePrimaryExpression hidden(WS):
 TypeLiteral
 | ({TypePrimaryExpression}t32=PERCENT)
 | ({TypePrimaryExpression}tyname='Type') // 'Type' is top of the category hierarchy
 | ({TypePrimaryExpression}tyname='Lisp') // 'Lisp' is used for native lisp function calls such as Say$Lisp
 | ({TypePrimaryExpression}LPAREN t5=TypeExpression1 RPAREN)
 | ({TypePrimaryExpression}tyname='Record' LPAREN t7=TypeExpression1
               (COLON t8+=TypeExpression1)?
               (COMMA t21+=TypeExpression1 (COLON t23+=TypeExpression1)?)*
                RPAREN)
 | ({TypePrimaryExpression}tyname='Union' LPAREN t10=TypeExpression1
              (COLON t11+=TypeExpression1)?
              (COMMA t24+=TypeExpression1 (COLON t26+=TypeExpression1)?)*
              RPAREN)
 | ({TypePrimaryExpression}tyname='Join'
    LPAREN t13=TypeExpression1 (COMMA t14+=TypeExpression1)* RPAREN)
 | TypeNameOrFunctionCall
 | => TupleDefinition
;

/*
 * This is the same as TypePrimaryExpression except it does not allow
 * the type to be extended by using a 'with' keyword. It is used
 * in the 'where' rule because the 'with' in that case has a
 * slightly different syntax.
 */
TypePrimaryExpression2 returns TypePrimaryExpression hidden(WS):
 TypeLiteral
 | ({TypePrimaryExpression}t32=PERCENT)
 | ({TypePrimaryExpression}tyname='Type') // 'Type' is top of the category hierarchy
 | ({TypePrimaryExpression}tyname='Lisp') // 'Lisp' is used for native lisp function calls such as Say$Lisp
 | ({TypePrimaryExpression}LPAREN t5=TypeExpression1 RPAREN)
 | ({TypePrimaryExpression}tyname='Record' LPAREN t7=TypeExpression1
               (COLON t8+=TypeExpression1)?
               (COMMA t21+=TypeExpression1 (COLON t23+=TypeExpression1)?)*
                RPAREN)
 | ({TypePrimaryExpression}tyname='Union' LPAREN t10=TypeExpression1
              (COLON t11+=TypeExpression1)?
              (COMMA t24+=TypeExpression1 (COLON t26+=TypeExpression1)?)*
              RPAREN)
 | ({TypePrimaryExpression}tyname='Join'
    LPAREN t13=TypeExpression1 (COMMA t14+=TypeExpression1)* RPAREN)
 | TypeNameOrFunctionCall2
 | => TupleDefinition
;

/* This rule will match:
 * Float - an ID representation of a type
 * List(Float) - a type function call
 * List Float - a non-parenthesis form if only one parameter
 *
 * A type function is also known as a parameterised type or
 * functor (not necessarily a true
 * functor since it may not obey the axioms of a functor).
 * If there is only one parameter then the parenthesis are optional
 */
TypeNameOrFunctionCall hidden(WS):
  tfnname=ID
  (
    (LPAREN (ID COLON)? t4=TypeExpression1? (COMMA (ID COLON)? t25+=TypeExpression1)* RPAREN)
    // optional curried function:
    (LPAREN t44+=StatementExpression? (COMMA t45+=Expression)* RPAREN)*
    // option of no parenthesis for single parameter
    | => t6=TypePrimaryExpression1
    | => w=WithInline
  )?
;

TypeNameOrFunctionCall2 hidden(WS):
  tfnname=ID
  (
    (LPAREN (ID COLON)? t4=TypeExpression1? (COMMA (ID COLON)? t25+=TypeExpression1)* RPAREN)
    // optional curried function:
    (LPAREN t44+=StatementExpression? (COMMA t45+=Expression)* RPAREN)*
    // option of no parenthesis for single parameter
    | => t6=TypePrimaryExpression1
  )?
;

/* This has a form like: (Integer,Float,String)
 * like an array where each entry can be of a different type
 */
TupleDefinition hidden(WS):
  (LPAREN t4=TypeExpression1 (COMMA t25+=TypeExpression1)* RPAREN)
;

/* Since SPAD supports dependent types then numbers and strings can occur here.
 * Outstanding issues:
 * 1) Float literals are parsed as elt(Int,Int) so we need to recognise this
 * and convert to float literal
 * 2) We need to be able to recognise exponent notation for floats
 * 3) Integers without '-' prefix can be converted to PI or NNI
 * 4) need to add hex or octal notation for integers (0xhhhh)
 * 5) String and Character literals need to have backslash "\" doubled to
 * "\\" otherwise xtext will interpret backslash as an escape character.
 * 6) values following immediately after string literal such as "abc"d should
 * represent an implied concat: concat("abc",d)
 */
TypeLiteral hidden(WS):
  t1=INT |
  t22=STRING |
// t3=FloatLiteral |
  t34=CharacterLiteral |
  t35=BooleanLiteral
;

/* In FunctionDefinition the algorithm is defined by a sequence of the
 * following statements:
 */
Statement hidden(WS,SL_COMMENT):
    s1=Block |
    s3= StatementExpression |
    // 'if' can occur in an expression or in
    // a statement so we use '=>' to choose
    // expression if there is any ambiguity
    s4=IfStatement |
    s4b=IfElseStatement |
// s4c=IfThenStatement |
    s5=WhileStatement |
    s6=DoStatement |
    s7=ForStatement |
    s8=BreakStatement |
    s12=RepeatStatement |
    s9= IterateStatement |
// s11= ContinueStatement|
    s10= ReturnStatement |
// s11= Import |
    'error' e=Expression
;

/* allows multiple statements which are grouped by wrapping in
 * braces (curly brackets) */
Block hidden(WS,SL_COMMENT):
stname=LBRACE NL*
    (statemBl += Statement (NL|SEMICOLON)+)*
    RBRACE
;

/*
 * Gives a value or assigns a value to a variable or does conditional exit
 *
 * examples:
 * x
 * x:Int
 * x,y:INT -- multiple assignment
 * x:Int := 3
 *
 * x=y => 3
 */
StatementExpression hidden(WS,SL_COMMENT):
  //(ID COMMA)* // allow multiple assignment
  t=ConditionExpression // was Expression but changed so that 'if' statement
                        // does not clash with if-then-else expression
// (COLON t2=TypeExpression)?
// (BECOMES t3=Expression (BECOMES t33+=Expression)*)?
    (BECOMES t5=Block)?
    // breaks out of a block if predicate before '=>' is true then program
    // control leaves the block.
    // Put it here so that it can only occur at the top level of an expression.
    // if inside some complicated expression then it must be terminated with ';'.
    (EXIT t4=Statement)?
;

/*
 * for i in n..m repeat ... is 1
 * for i in n..m by s repeat ...
 * for i in list repeat ...
 * for i in list for i in 1..length() repeat ...
 * for i in list for i in 1.. repeat ...
 * for j in n..m repeat loopBody
 * for j in n..m | odd? j repeat
 *
 * To Do
 * -----
 * As a temporary measure we check for '..' as a suffix operator
 * here, but we should really put this into expression?
 *
 * We need to allow conditions using BAR '|'
 */
ForStatement hidden(WS,SL_COMMENT):
'for' (
       stname=ID 'in' t1=Expression SEG? //(=> '..' t2=Expression)?
       ('by' by1=Expression)?
// (=> BAR t2=PredicateOr)? // condition
       ('for' stname2+=ID
        'in' t2+=Expression SEG?
        ('by' by2+=Expression)?
        )*
       ('while' t2+=Expression)*
) 'repeat' NL? s1=Statement //('is' s2=Statement)?
;

/*
 * while BoolExpr repeat loopBody
 */
WhileStatement hidden(WS,SL_COMMENT):
stname='while' (
       t2=Expression /*PredicateOr*/
) 'repeat' NL? s1=Statement
;

/*
 * do loopBody while BoolExpr
 */
DoStatement hidden(WS,SL_COMMENT):
stname='do' (
       s1=Statement
) 'while' NL? t2=Expression /*PredicateOr*/
;

/*
 * will repeat until we jump out. For instance by calling return.
 */
RepeatStatement hidden(WS,SL_COMMENT):
stname='repeat' (
       s1=Statement
)
;

/*
 * iterate ...
 * skips over the remainder of a loop
 */
IterateStatement hidden(WS,SL_COMMENT):
stname='iterate'
;

/*
 * break leave current loop
 */
BreakStatement hidden(WS,SL_COMMENT):
stname='break'
;

/*
 * return leave current function
 */
ReturnStatement hidden(WS):
stname='return' t2=Expression
;

/*
 * import - use 'Import' instead
 */
//ImportStatement hidden(WS):
// stname='import' t2=Expression
//;

/* 'if' statement allows program flow to be switched
 * forms:
 * if boolean then
 * if equation then
 * if ... not ... and ...or ... then
 * if ... then ... else ...
 * note1:
 * if ... then ... else ... always returns a value so we can use this
 * on the right hand side of an assignment
 * note2:
 * since there is an explicit 'then' keyword there is no need to put
 * the condition in brackets
 *
 * examples:
 * a:= if x >0 then x else -x
 * if R has Field then ...
 * if myUnion case mtType then ...
 *
 * we also need to allow a form like this:
 * if x >0 {
 * then x
 * else -x
 * }
 *
 * also this form (this requires IfElseStatement rule):
 * if x >0 then {
 * x
 * }
 * else {
 * -x
 * }
 */
IfStatement hidden(WS,SL_COMMENT):
  'if' t2=Expression
// 'if' t2=ConditionExpression
  (
    'then' s1=Statement
    (=> 'else' s2=Statement)?
   |
    b?=LBRACE
    NL+ 'then' s11=Statement NL*
    (=>'else' s12=Statement NL*)?
    RBRACE
  )
;

IfElseStatement hidden(WS,SL_COMMENT):
'else' s2=Statement
;

///////////// Expression syntax follows //////////////

/* This is the top level for expressions
 *
 * This level handles special cases such as:
 * if x then y else z
 * (x,y) +-> z
 *
 * We can consider expressions as elements of statements
 * expressions contain no newlines unless preceded by underscore
 * (which is handled by WS)
 */
Expression returns Expr hidden(WS,SL_COMMENT):
  (ifname='if' ifpred=Expression 'then' thenexp=Expression 'else' elseexp=Expression)
// | LPAREN t24=ConditionExpression (COMMA t25+=ConditionExpression)+ RPAREN (COLON rightType2 =TypeExpression)? GIVES ConditionExpression
  | ExitExpression
;

/*
 * condition '=>' expr1 ';' expr2
 */
ExitExpression returns Expr hidden(WS,SL_COMMENT):
  ConditionExpression
  ({ExitExpression.left=current} op=EXIT right = ConditionExpression SEMICOLON r2=ConditionExpression)*
;

/*
 * BAR "|" precedence: 108, 111
 */
ConditionExpression returns Expr hidden(WS,SL_COMMENT):
  OrExpression
  ({ConditionExpression.left=current} op=BAR right = OrExpression )*
;

/*
 * COMMA"," precedence: 110, 111
 */
//CommaExpression returns Expr hidden(WS,SL_COMMENT):
// ConditionalAndExpression
// ({ConditionExpression.left=current} op=BAR right = ConditionalAndExpression )*
//;

/*
 * There is also another rule that looks for 'or' which is PredicateOr,
 * this version is used in a general expression and the other version is
 * used when we know we have a predicate.
 * "or", precedence: 200, 201
 */
OrExpression returns Expr hidden(WS,SL_COMMENT):
  AndExpression
  ( {OrExpression.left=current} op='or' right = AndExpression)*
;

/*
 * There is also another rule that looks for 'and' which is PredicateAnd,
 * this version is used in a general expression and the other version is
 * used when we know we have a predicate.
 * "and", precedence: 250, 251
 */
AndExpression returns Expr hidden(WS,SL_COMMENT):
  InnerProdExpression
  ( {AndExpression.left=current} op='and' right = InnerProdExpression)*
;

/*
 * This has multiple uses such as inner product and logical or.
 *
 * "\/", BACKSLASHSLASH precedence: 200, 201
 *
 * the backslash is duplicated here because it is the escape character for
 * strings, it will not be duplicated when used.
 */
InnerProdExpression returns Expr hidden(WS,SL_COMMENT):
  OuterProdExpression
  ( {InnerProdExpression.left=current} op=BACKSLASHSLASH right = OuterProdExpression)*
;

/*
 * This has multiple uses such as outer product and logical and.
 *
 * "/\", SLASHBACKSLASH precedence: 250, 251
 *
 * the backslash is duplicated here because it is the escape character for
 * strings, it will not be duplicated when used.
 */
OuterProdExpression returns Expr hidden(WS,SL_COMMENT):
  HasExpression
  ( {OuterProdExpression.left=current} op=SLASHBACKSLASH right = HasExpression)*
;

/* Predicate which returns true if preceding value is of a given type
 * example:
 * if R has Field then ..
 *
 * "has", precedence: 400, 400
 */
HasExpression returns Expr hidden(WS,SL_COMMENT):
  CaseExpression
  ({HasExpression.left=current} op='has' rightType = TypeExpression1)*
;

/* Select from Union values
 * example:
 * if myUnion case mtType then ...
 *
 * "case", precedence: 400, 400
 */
CaseExpression returns Expr hidden(WS,SL_COMMENT):
  EqualityExpression
  ( {CaseExpression.left=current} op='case' right = EqualityExpression)?
;

/* used in list comprehension
 *
 * "in", precedence: 400, 400
 */
/*InExpression returns Expr hidden(WS,SL_COMMENT):
  RelationalExpression
  ( {CaseExpression.left=current} op='in' right = RelationalExpression)?
;*/

/*
 * "~=", precedence: 400, 400
 * "^=", precedence: 400, 400
 * "=", precedence: 400, 400
 */
EqualityExpression returns Expr hidden(WS,SL_COMMENT):
  RelationalExpression
// ambiguous because EQ can be in top level expression
  ( {EqualityExpression.left=current}
   ( op=EQUAL | op=NOTEQUAL | op='^=' | (op=EQUALSDOLAR te=ID))
   //(DOLAR te=ID)?
   right = RelationalExpression
  )*
;

/*
 * ">=", precedence: 400, 400
 * "<=", precedence: 400, 400
 * ">>", precedence: 400, 400
 * "<<", precedence: 400, 400
 * ">", precedence: 400, 400
 * "<", precedence: 400, 400
 */
RelationalExpression returns Expr hidden(WS,SL_COMMENT):
  IsExpression
  ( {RelationalExpression.left=current}
   ( op=LT | op=GT | op=LE | op=GE )
      right = IsExpression
  )?
;

/*
 *
 * "isnt", precedence: 400, 400
 * "is", precedence: 400, 400
 */
IsExpression returns Expr hidden(WS,SL_COMMENT):
  SegmentExpression
  ({IsExpression.left=current} (op='is' | op='isnt') rightType = TypeExpression1)*
;

/*
 * this is used to indicate a range:
 * 1..4 means the range from 1 to 4
 * 1.. means the range from 1 to infinity. This is used in cases where
 * no top bounds is necessary, when the end point is determined by other
 * means.
 * "..", "SEGMENT", precedence: 401, 699, ["parse_Seg"]
 */
SegmentExpression returns Expr hidden(WS,SL_COMMENT):
  AdditiveExpression
  ( {SegmentExpression.left=current} op=SEG right = AdditiveExpression)*
;

/*
 * add expression
 * we include both '+' and '-' in the same case as this allows a
 * multiple sequence like:
 * a + b + c - d + e -f
 *
 * "-", precedence: 700, 701
 * "+", precedence: 700, 701
 */
AdditiveExpression returns Expr hidden(WS,SL_COMMENT):
  ExquoExpression
  ( {AdditiveExpression.left=current}
    ( op=PLUS | op=MINUS | (op=PLUSDOLAR te=ID) | (op=MINUSDOLAR te=ID))
    right = ExquoExpression
  )*
;

/*
 * "exquo", precedence: 800, 801
 */
ExquoExpression returns Expr hidden(WS,SL_COMMENT):
  DivisionExpression
  ({ExquoExpression.left=current} op='exquo' right = DivisionExpression)*
;

/*
 * division expression
 * "/", precedence: 800, 801
 */
DivisionExpression returns Expr hidden(WS,SL_COMMENT):
  QuoExpression
  ( {DivisionExpression.left=current}
   (op=SLASH | (op=DIVDOLAR te=ID))
   right = QuoExpression
  )*
;

/*
 *"quo", precedence: 800, 801
 */
QuoExpression returns Expr hidden(WS,SL_COMMENT):
  ModExpression
  ({QuoExpression.left=current} op='quo' right = ModExpression)*
;

/*
 *"mod", precedence: 800, 801
 */
ModExpression returns Expr hidden(WS,SL_COMMENT):
  RemExpression
  ({ModExpression.left=current} op='mod' right = RemExpression)*
;

/*
 *"rem", precedence: 800, 801
 */
RemExpression returns Expr hidden(WS,SL_COMMENT):
  MultiplicativeExpression
  ({RemExpression.left=current} op='rem' right = MultiplicativeExpression)*
;

/*
 * multiplication expression
 * a * b * c
 *
 * "*", precedence: 800, 801
 */
MultiplicativeExpression returns Expr hidden(WS,SL_COMMENT):
  ExponentExpression
  ( {MultiplicativeExpression.left=current}
    (op=TIMES | (op=TIMESDOLAR te=ID))
    right = ExponentExpression
  )*
;

/*
 *
 * "^", precedence: 901, 900
 * "**", precedence: 901, 900
 */
ExponentExpression returns Expr hidden(WS,SL_COMMENT):
  MapDefinition
  ({ExponentExpression.left=current} (op=CARAT | op=POWER) right = MapDefinition)*
;

/* Map or Lambda expression
 * var +-> function
 *
 * +-> is an infix operator meaning 'maps-to'
 * It can be used to create a function literal (an anonymous function), so
 * instead of:
 * myFunct(x:Type):Type == if x >0 then x else -x
 * we can have forms such as:
 * x +-> if x >0 then x else -x
 * or:
 * (x,y) +-> if x >0 then y else -x
 *
 * fricas compatibility:
 * "+->", precedence: 995, 112
 */
MapDefinition returns Expr hidden(WS,SL_COMMENT):
// (PretendExpression | LPAREN PretendExpression (COMMA t25+=PretendExpression)+ RPAREN) (COLON rightType2 =TypeExpression)?
  AssignExpression
  ({MapDefinition.left=current}
   op=GIVES right = AssignExpression
   (par = ID)? // optional parameter which function
                             // is applied to
  )*
;

/*
 * an assign expression like this:
 * x := y
 * can also be an inner assign like this:
 * x := (y := z)
 * or just:
 * x := y := z
 *
 * right is expression to allow forms like
 * x := if y<0 then -y else y
 */
AssignExpression returns Expr hidden(WS,SL_COMMENT):
  PretendExpression
  ({AssignExpression.left=current} op=BECOMES (
   right = PretendExpression
   | ifname='if' ifpred=ConditionExpression 'then' thenexp=ConditionExpression 'else' elseexp=PretendExpression
   )
  )*
;

/*
 * pretend Type: treat one type as another,
 * only works if they have the same internal structure.
 *
 * Not very safe and should be avoided, if possible, unfortunately
 * its not always possible to avoid.
 *
 * "pretend", precedence: 995, 996
 */
 PretendExpression returns Expr hidden(WS,SL_COMMENT):
  CoerceExpression
  ({PretendExpression.left=current} op='pretend' rightType = TypeExpression1)*
;

/*
 * "::", precedence: 996, 997
 *
 * although '::' and '@' apparently have the same precidence we want
 * '@' to bind more tightly than '::'. As we can see in the following example:
 * "dictionary"@String :: OutputForm.
 */
CoerceExpression returns Expr hidden(WS,SL_COMMENT):
  HintTypeExpression
  ({CoerceExpression.left=current} op=COERCE rightType = TypeExpression1)*
;

/*
 * "@", precedence: 996, 997
 */
HintTypeExpression returns Expr hidden(WS,SL_COMMENT):
  EltExpression
  ( {HintTypeExpression.left=current} op=AT rightType = TypeExpression1)?
;

/* We treat these as part of the language
 * : indicates type
 * ! is part of name to indicate mutable
 *
 * ":", precedence: 996, 997
 * "!", precedence: 1002, 1001
 *
 */
/*BangExpression returns Expr hidden(WS,SL_COMMENT):
  EqualityExpression
  ({AndExpression.left=current} op=AMPERSAND right = EqualityExpression)*
;*/

/*
 * "with", precedence: 2000, 400, ["parse_InfixWith"]
 *
 */
/*WithExpression returns Expr hidden(WS,SL_COMMENT):
  EqualityExpression
  ({AndExpression.left=current} op='with' right = EqualityExpression)*
;*/


/* Elt is Lisp terminology for the use of '.' to select parameters
 * the left expression is something that has selectable elements such as
 * a list, array, string, Record or union, the right element should be a
 * non-negative integer.
 */
EltExpression returns Expr hidden(WS,SL_COMMENT):
  ExplicitTypeExpression
  ( {EltExpression.left=current}
   op=DOT right = ExplicitTypeExpression
  )*
;

////////////// unary expressions ////////////////////


/*
 * '$'
 */
ExplicitTypeExpression returns Expr hidden(WS,SL_COMMENT):
  UnaryExpression
  ({ExplicitTypeExpression.left=current} op=DOLAR rightType = TypeExpression1)?
;

/* UnaryExpression
 * unary prefixes:
 * "~" TILDE : precedence 260, 259, nil
 * ":" COLON : precedence 194, 195
 * "-" MINUS : precedence 701, 700
 * "#" HASH : precedence 999, 998
 * "'" : precedence 999, 999, ["parse_Data"]
 * unary suffixes
 * ".." : range can be unary suffix
 */
UnaryExpression returns Expr hidden(WS,SL_COMMENT):
  PrimaryExpression |
  ({UnaryExpression} uop=TILDE expr=UnaryExpression) |
// ({UnaryExpression} uop=COLON expr=UnaryExpression) |
  ({UnaryExpression} uop=MINUS expr=UnaryExpression) |
  ({UnaryExpression} uop=MINUSDOLAR te=ID expr=UnaryExpression) |
  ({UnaryExpression} uop=HASH expr=UnaryExpression) |
  ({UnaryExpression} uop='not' expr=PrimaryExpression) |
  ({UnaryExpression} uop=SUMLIST expr=PrimaryExpression) |
  ({UnaryExpression} uop=PRIMEPERCENT expr=PrimaryExpression) |
   e2=PERCENT |
  e3='Type' |
  e5='Record' LPAREN e6=TypeExpression1
               (COLON e22+=TypeExpression1)?
               (COMMA e21+=TypeExpression1 (COLON e23+=TypeExpression1)?)*
                RPAREN |
  e9='Union' LPAREN e10=TypeExpression1
              (COLON e25+=TypeExpression1)?
              (COMMA e24+=TypeExpression1 (COLON e26+=TypeExpression1)?)*
              RPAREN |
  e11='Join' LPAREN e12=TypeExpression1 (COMMA e13+=TypeExpression1)* RPAREN
;

/*
 *
 */
/*UnaryExpressionHash returns Expr hidden(WS,SL_COMMENT):
// HASH? PrimaryExpression
  PrimaryExpression | ({UnaryExpressionHash} uop=HASH expr=UnaryExpressionHash)
;*/

/*
 *
 */
PrimaryExpression returns Expr hidden(WS,SL_COMMENT):
  PrimaryPrefix /* ( t2+=PrimarySuffix )* */
;

/*
 * Can contain an expression in parenthesis, this expression is
 * 'StatementExpression' which means that it can contain an
 * inner assignment.
 *
 * The comma option allows us to define a tuple
 */
PrimaryPrefix hidden(WS,SL_COMMENT):
 Literal
 | LPAREN t4=Expression (COMMA t25+=Expression)* RPAREN =>(COLON rightType3 =TypeExpression1)?
 | t7=NameOrFunctionCall
;

/* function call such as List(Integer)
 * known as a parameterised type or functor (not necessarily a true functor since
 * it may not obey the axioms of a functor)
 * if there is only one parameter then the parenthesis are optional
 *
 * function binds most tightly
 */
NameOrFunctionCall hidden(WS,SL_COMMENT):
  ("'")?
  fnname=ID (=> lsp=DOLAR 'Lisp'/*t2=TypeExpression*/)?
  // option for parameters in parenthesis
  (
// LPAREN t4=StatementExpression? (COMMA t5+=Expression)* RPAREN //(COLON rightType2 =TypeExpression)?
    LPAREN t4=Expression? (COMMA t5+=Expression)* RPAREN //(COLON rightType2 =TypeExpression)?
    // optional curried function:
    (LPAREN t14+=Statement? (COMMA t15+=Expression)* RPAREN)*
    // option of no parenthesis for single parameter
    | => t6=PrimaryExpression
  )?
  => ((COMMA ID)* COLON rightType2 =TypeExpression1)?
  // allow multiple assignment
  //=>(op=GIVES lambda = Expression 'xxx')?
;

/* Literals are actual values of a given type
 * Outstanding issues:
 * 1) Float literals are parsed as elt(Int,Int) so we need to recognise this
 * and convert to float literal
 * 2) We need to be able to recognise exponent notation for floats
 * 3) Integers without '-' prefix can be converted to PI or NNI
 * 4) need to add hex or octal notation for integers (0xhhhh)
 * 5) String and Character literals need to have backslash "\" doubled to
 * "\\" otherwise xtext will interpret backslash as an escape character.
 * 6) values following immediately after string literal such as "abc"d should
 * represent an implied concat: concat("abc",d)
 */
Literal hidden(WS,SL_COMMENT):
  value=INT
  | t2=STRING (=> e1=NameOrFunctionCall =>(t31+=STRING (=> e4+=NameOrFunctionCall)?)*)?
// | t3=FloatLiteral // conflicts with use of '.' for elt
  | ListLiteral
  | CharacterLiteral
  | BooleanLiteral
;

/* Contains a single character whereas a string contains multiple
 * characters.
 */
CharacterLiteral hidden(WS,SL_COMMENT):
 "'" c1=ANY_OTHER "'"
;

/* This may not need to be specified here at the syntax level. Perhaps we
* should treat boolean as any other library defined type.
*/
BooleanLiteral hidden(WS,SL_COMMENT):
 litname = 'true' | litname = 'false'
 | litname = 'true' LPAREN RPAREN
 | litname = 'false' LPAREN RPAREN
;

/*
 * a list literal may consist of:
 * [] an empty list
 * [a] a single element
 * [a,b] multiple elements
 * [a for b in c] a list comprehension
 */
ListLiteral hidden(WS,SL_COMMENT):
 litname = LBRACKET l2=Expression?
     (COMMA t3+=Expression)*
     ('for' t14+=Expression 'in' l5+=Expression)?
     RBRACKET
;