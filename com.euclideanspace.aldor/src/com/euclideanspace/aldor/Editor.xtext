grammar com.euclideanspace.aldor.Editor hidden ()

import "http://www.eclipse.org/emf/2002/Ecore" as ecore

generate editor "http://www.euclideanspace.com/aldor/Editor"

/* Copyright 2014 Martin John Baker
 *
 * This file is part of EuclideanSpace.
 *
 * EuclideanSpace is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * EuclideanSpace is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with EuclideanSpace. If not, see <http://www.gnu.org/licenses/>.
 */

/*
 *
 * Here we are using a LL(*) recursive-descent parser generator and this
 * may not be able to exactly replicate axl.z which is a
 * LALR(1) conflict-free grammar for Aldor.
 */

/* from tokInfoTable[] in token.c: Lexical elements.
* The TokenTag enumeration must use this order.
*
* This table MUST be laid out so that all "symbol" tokens starting with
* the same character are contiguous.
*
* Be extra careful with fields F, G, H and K: if you get them wrong then
* the lineariser will delete end-of-statement tokens when it ought not
* to. This can lead to odd compiler behaviour that is hard to track down
* unless you know about this table.
*
* struct tok_info tokInfoTable[] = {
*
* [A] TokenTag tag
* [B] Symbol sym
* [C] String str
* [D] Byte hasString i.e. use val.str (vs val.sym)
* [E] Byte isComment i.e. ++ --
* [F] Byte isOpener i.e. ( [ { etc
* [G] Byte isCloser i.e. ) ] } etc
* [H] Byte isFollower i.e. then else always in etc
* [I] Byte isLangword i.e. if then etc
* [J] Byte isLeftAssoc i.e., associates left to right
* [K] Byte isMaybeInfix i.e., add, with, +
* [L] Byte precedence i.e., 0 is lowest, or don't know
* [M] Byte isDisabled i.e., non-zero means disabled
*
* [A] [B][C] [D][E] [F] [G] [H] [I] [J] [K] [L] [M]
*
        {TK_Blank, 0,"TK_Blank", 0, 0, 0, 0, 0, 0, 1, 0, 170, 0},
        {TK_Float, 0,"TK_Float", 1, 0, 0, 0, 0, 0, 1, 0, 170, 0},
        {TK_SysCmd, 0,"TK_SysCmd", 1, 1, 0, 0, 0, 0, 1, 0, 170, 0},
        {TK_Error, 0,"TK_Error", 1, 0, 0, 0, 0, 0, 1, 0, 0, 0},

        {KW_Add, 0,"add", 0, 0, 0, 0, 0, 1, 1, 0, 0, 0},
        {KW_And, 0,"and", 0, 0, 0, 0, 1, 1, 1, 1, 40, 0},
        {KW_Always, 0,"always", 0, 0, 0, 0, 1, 1, 1, 1, 0, 0},
        {KW_Assert, 0,"assert", 0, 0, 0, 0, 0, 1, 1, 0, 0, 0},
        {KW_Break, 0,"break", 0, 0, 0, 0, 0, 1, 1, 0, 0, 0},
        {KW_But, 0,"but", 0, 0, 0, 0, 1, 1, 1, 1, 0, 0},
        {KW_By, 0,"by", 0, 0, 0, 0, 0, 0, 1, 1, 110, 0},
        {KW_Case, 0,"case", 0, 0, 0, 0, 0, 0, 1, 1, 0, 0},
        {KW_Catch, 0,"catch", 0, 0, 0, 0, 1, 1, 1, 1, 0, 0},
        {KW_Default, 0,"default", 0, 0, 0, 0, 0, 1, 1, 0, 0, 0},
        {KW_Define, 0,"define", 0, 0, 0, 0, 0, 1, 1, 0, 0, 0},
        {KW_Delay, 0,"delay", 0, 0, 0, 0, 0, 1, 1, 0, 0, 0},
        {KW_Do, 0,"do", 0, 0, 0, 0, 0, 1, 1, 0, 0, 0},
        {KW_Else, 0,"else", 0, 0, 0, 0, 1, 1, 1, 0, 0, 0},
        {KW_Except, 0,"except", 0, 0, 0, 0, 0, 1, 1, 1, 0, 0},
        {KW_Export, 0,"export", 0, 0, 0, 0, 0, 1, 1, 0, 0, 0},
        {KW_Exquo, 0,"exquo", 0, 0, 0, 0, 0, 0, 1, 1, 125, 0},
        {KW_Extend, 0,"extend", 0, 0, 0, 0, 0, 1, 1, 0, 0, 0},
        {KW_Finally, 0,"finally", 0, 0, 0, 0, 1, 1, 1, 1, 0, 0},
        {KW_Fix, 0,"fix", 0, 0, 0, 0, 0, 1, 1, 0, 0, 0},
        {KW_For, 0,"for", 0, 0, 0, 0, 0, 1, 1, 0, 0, 0},
        {KW_Fluid, 0,"fluid", 0, 0, 0, 0, 0, 1, 1, 0, 0, 0},
        {KW_Free, 0,"free", 0, 0, 0, 0, 0, 1, 1, 0, 0, 0},
        {KW_From, 0,"from", 0, 0, 0, 0, 1, 1, 1, 0, 0, 0},
        {KW_Generate, 0,"generate", 0, 0, 0, 0, 0, 1, 1, 0, 0, 0},
        {KW_Goto, 0,"goto", 0, 0, 0, 0, 0, 1, 1, 0, 0, 0},
        {KW_Has, 0,"has", 0, 0, 0, 0, 0, 0, 1, 1, 40, 0},
        {KW_If, 0,"if", 0, 0, 0, 0, 0, 1, 1, 0, 0, 0},
        {KW_Import, 0,"import", 0, 0, 0, 0, 0, 1, 1, 0, 0, 0},
        {KW_In, 0,"in", 0, 0, 0, 0, 1, 1, 1, 1, 0, 0},
        {KW_Inline, 0,"inline", 0, 0, 0, 0, 0, 1, 1, 0, 0, 0},
        {KW_Is, 0,"is", 0, 0, 0, 0, 0, 1, 1, 0, 0, 0},
        {KW_Isnt, 0,"isnt", 0, 0, 0, 0, 0, 1, 1, 0, 0, 0},
        {KW_Iterate, 0,"iterate", 0, 0, 0, 0, 0, 1, 1, 0, 0, 0},
        {KW_Let, 0,"let", 0, 0, 0, 0, 0, 1, 1, 0, 0, 0},
        {KW_Local, 0,"local", 0, 0, 0, 0, 0, 1, 1, 0, 0, 0},
        {KW_Macro, 0,"macro", 0, 0, 0, 0, 0, 1, 1, 0, 0, 0},
        {KW_Mod, 0,"mod", 0, 0, 0, 0, 0, 0, 1, 1, 125, 0},
        {KW_Never, 0,"never", 0, 0, 0, 0, 0, 1, 1, 0, 0, 0},
        {KW_Not, 0,"not", 0, 0, 0, 0, 0, 1, 1, 1, 150, 0},
        {KW_Of, 0,"of", 0, 0, 0, 0, 1, 1, 1, 1, 40, 0},
        {KW_Or, 0,"or", 0, 0, 0, 0, 1, 1, 1, 1, 40, 0},
        {KW_Pretend, 0,"pretend", 0, 0, 0, 0, 1, 1, 1, 1, 150, 0},
        {KW_Quo, 0,"quo", 0, 0, 0, 0, 0, 0, 1, 1, 125, 0},
        {KW_Reference, 0,"ref", 0, 0, 0, 0, 0, 1, 1, 0, 0, 0},
        {KW_Rem, 0,"rem", 0, 0, 0, 0, 0, 0, 1, 1, 125, 0},
        {KW_Repeat, 0,"repeat", 0, 0, 0, 0, 0, 1, 1, 0, 0, 0},
        {KW_Return, 0,"return", 0, 0, 0, 0, 0, 1, 1, 0, 0, 0},
        {KW_Rule, 0,"rule", 0, 0, 0, 0, 0, 1, 1, 0, 0, 0},
        {KW_Select, 0,"select", 0, 0, 0, 0, 0, 1, 1, 0, 0, 0},
        {KW_Then, 0,"then", 0, 0, 0, 0, 1, 1, 1, 0, 0, 0},
        {KW_Throw, 0,"throw", 0, 0, 0, 0, 0, 1, 1, 1, 0, 0},
        {KW_To, 0,"to", 0, 0, 0, 0, 1, 1, 1, 0, 0, 0},
        {KW_Try, 0,"try", 0, 0, 0, 0, 0, 1, 1, 0, 0, 0},
        {KW_Where, 0,"where", 0, 0, 0, 0, 1, 1, 1, 0, 0, 0},
        {KW_While, 0,"while", 0, 0, 0, 0, 0, 1, 1, 0, 0, 0},
        {KW_With, 0,"with", 0, 0, 0, 0, 0, 1, 1, 0, 0, 0},
        {KW_Yield, 0,"yield", 0, 0, 0, 0, 0, 1, 1, 0, 0, 0},

        {KW_Quote, 0,"'", 0, 0, 0, 0, 0, 0, 1, 0, 0, 0},
        {KW_Grave, 0,"`", 0, 0, 0, 0, 0, 0, 1, 0, 0, 0},
        
        {KW_ColonStar, 0,":*", 0, 0, 0, 0, 1, 0, 1, 1, 36, 0},

        {KW_LArrow, 0,"<-", 0, 0, 0, 0, 0, 0, 1, 1, 0, 0},

        {KW_PlusMinus, 0,"+-", 0, 0, 0, 0, 0, 0, 1, 1, 120, 0},
        {KW_MapsToStar, 0,"+->*", 0, 0, 0, 0, 1, 0, 1, 1, 30, 0},

        {KW_MapStar, 0,"->*", 0, 0, 0, 0, 0, 0, 0, 1, 80, 0},

        {KW_StartPile, 0,"#pile", 0, 0, 0, 0, 0, 0, 1, 0, 0, 0},
        {KW_EndPile, 0,"#endpile", 0, 0, 0, 0, 0, 0, 1, 0, 0, 0},
        {KW_SetTab, 0,"KW_SetTab", 0, 0, 0, 0, 0, 0, 1, 0, 0, 0},
        {KW_BackSet, 0,"KW_BackSet", 0, 0, 0, 0, 0, 0, 1, 0, 0, 0},
        {KW_BackTab, 0,"KW_BackTab", 0, 0, 0, 0, 0, 0, 1, 0, 0, 0},
        {KW_Juxtapose, 0,"KW_Juxtapose",0, 0, 0, 0, 0, 0, 0, 0, 170, 0},

        {TK_LIMIT, 0,"TK_LIMIT", 0, 0, 0, 0, 0, 0, 1, 0, 0, 0}
};
*/

/*
 * Parser starts here
 * CategoryDef,PackageDef and DomainDef must end with newline to ensure that
 * only an '@' at the start of a line will be taken as the end.
 *
 * On this line whitespace (WS) is not hidden so is explicitly included.
 */
Model :
')abbrev' WS (c=CategoryDef | p=PackageDef | d=DomainDef) KW_AT
;

////////// start of lexer rules ///////////////

/* ID consists of alpha (upper or lower case) followed by alphanumeric
 * any other character can stand in for alpha if prefixed by '_'
 * for instance a multiply function is often named '_*'
 * IDs can also end with ? or ! where:
 * '?' indicates a function which returns a boolean value
 * '!' indicates a function which changes an existing domain value
 * (in a mutable domain)
        {TK_ID, 0,"TK_ID", 0, 0, 0, 0, 0, 0, 1, 0, 170, 0},
 */
terminal TK_ID : ('a'..'z'|'A'..'Z'|('_'.)) ('a'..'z'|'A'..'Z'|('_'.)|'0'..'9')*'!'?'?'?;

/* whitespace on single line overrides default whitespace
 * does not include newline unless it follows underscore.
 * I would have liked to do this as follows:
 * terminal WS : (' '|'\t'|'_'(('\r'|'\n')+))+;
 * problem: unfortunately use of underscore in this way masks the use of underscore
 * in ID. We therefore need to remove this type of underscore in a
 * preprocessor
 */
terminal WS : (' '|'\t')+;

/* at least one newline or carriage return character.
 * This is not included with WS because whitespace is significant in SPAD.
 * We usually absorb newlines like this: NL+ which absorbs any number of
 * blank lines and it also supports both the Linux and the Windows forms of
 * newlines.
 * {KW_NewLine, 0,"\n", 0, 0, 0, 0, 0, 0, 1, 0, 0, 0},
 */
terminal KW_NEWLINE: ('\r'|'\n') ;

/* overwriting TK_COMMENTS we do not want Java syntax (//) but spad syntax (--)
 * This absorbs everything from '--' or '++' to the end of the line (but not
 * including the newline or carriage return characters)
 * 
 *  {TK_PreDoc, 0,"TK_PreDoc", 1, 1, 0, 0, 0, 0, 1, 0, 170, 0},
    {TK_PostDoc, 0,"TK_PostDoc", 1, 1, 0, 0, 0, 0, 1, 0, 170, 0},
    {TK_COMMENT, 0,"TK_COMMENT", 1, 1, 0, 0, 0, 0, 1, 0, 170, 0},
 */
terminal TK_COMMENT :
  ('--'|'++') !('\n'|'\r')* ;//('\r'|'\n')?;

/* Macro value can be anything until the end of line
 * Macro is really '==>' but the pre-processor inserts an extra '=' so
 * that we can distinguish from where ==> is used in 'with' or 'add' parts
 * It is difficult for a LL(*) parser to handle macros so we want to
 * substitute the macro in a pre-processor */
terminal MACROVALUE :
  '===>' !('\n'|'\r')*;

/* '==>' is used in 'with' or 'add' parts so is not really a macro?
 */
//terminal MACRO:
// '==>'
//;

/* string literals are enclosed in double quotes
 *         {TK_String, 0,"TK_String", 1, 0, 0, 0, 0, 0, 1, 0, 170, 0},
 
*/
terminal TK_STRING :
'"' ( !('"') )* '"'
;
/*
 * Integer
 *
 * {TK_Int, 0,"TK_Int", 1, 0, 0, 0, 0, 0, 1, 0, 170, 0},
 */
terminal TK_INT returns ecore::EInt: ('0'..'9')+;

/* grouping
* {KW_OBBrack, 0,"[|", 0, 0, 1, 0, 0, 0, 1, 0, 0, 0},
* {KW_OBCurly, 0,"{|", 0, 0, 1, 0, 0, 0, 1, 0, 0, 0},
* {KW_OBParen, 0,"(|", 0, 0, 1, 0, 0, 0, 1, 0, 0, 0},
* 
* {KW_CBBrack, 0,"|]", 0, 0, 0, 1, 0, 0, 1, 0, 0, 0},
* {KW_CBCurly, 0,"|}", 0, 0, 0, 1, 0, 0, 1, 0, 0, 0},
* {KW_CBParen, 0,"|)", 0, 0, 0, 1, 0, 0, 1, 0, 0, 0},
* {KW_2Bar, 0,"||", 0, 0, 0, 0, 0, 1, 1, 0, 0, 0},
* 
*/

/* (
* {KW_OParen, 0,"(", 0, 0, 1, 0, 0, 0, 1, 0, 0, 0},
*/
terminal KW_OPAREN: '(';
/* )
* {KW_CParen, 0,")", 0, 0, 0, 1, 0, 0, 1, 0, 0, 0},
*/
terminal KW_CPAREN: ')';
/* {
* {KW_OCurly, 0,"{", 0, 0, 1, 0, 0, 0, 1, 0, 0, 0},
*/
terminal KW_OCURLY: '{';
/* }
* {KW_CCurly, 0,"}", 0, 0, 0, 1, 0, 0, 1, 0, 0, 0},
*/
terminal KW_CCURLY: '}';
/* [
* {KW_OBrack, 0,"[", 0, 0, 1, 0, 0, 0, 1, 0, 0, 0},
*/
terminal KW_OBRACK: '[';
/* ]
* {KW_CBrack, 0,"]", 0, 0, 0, 1, 0, 0, 1, 0, 0, 0},
*/
terminal KW_CBRACK: ']';
/*
terminal LBANANA '(|';
terminal RBANANA '|)';
terminal EBRACKET '[__]';
terminal EBRACKET2 '[]';
terminal EBRACE '{__}';
terminal EBRACE2 '{}';
terminal LBANANABRACKET '[|';
terminal RBANANABRACKET '|]';
terminal EBANANABRACKET '[|__|]';
terminal EBANANABRACKET2 '[||]';
terminal LBANANABRACE '{|';
terminal RBANANABRACE '|}';
terminal EBANANABRACE '{|__|}';
terminal EBANANABRACE2 '{||}'; */
/* <<
* {KW_2LT, 0,"<<", 0, 0, 0, 0, 0, 0, 1, 1, 100, 0},
*/
terminal KW_2LT: '<<';
/* >>
* {KW_2GT, 0,">>", 0, 0, 0, 0, 0, 0, 1, 1, 100, 0},
*/
terminal KW_2GT: '>>';
/*terminal QUOTE "'";
terminal BACKQUOTE "`";*/

// operators
/* ==> MDEF or MARROW
* {KW_MArrow, 0,"==>", 0, 0, 0, 0, 1, 0, 0, 1, 25, 0},
*/
terminal KW_MARROW: '==>';
/* |
* {KW_Bar, 0,"|", 0, 0, 0, 0, 0, 0, 1, 0, 0, 0},
*/
terminal KW_BAR: '|';
/* .
* {KW_Dot, 0,".", 0, 0, 0, 0, 1, 0, 1, 1, 170, 0},
*/
terminal KW_DOT: '.';
/* :: 2Colon or coerce
* {KW_2Colon, 0,"::", 0, 0, 0, 0, 1, 0, 1, 1, 150, 0},
*/
terminal KW_2COLON: '::';
/* :
* {KW_Colon, 0,":", 0, 0, 0, 0, 1, 0, 1, 1, 36, 0},
*/
terminal KW_COLON: ':';
/* @
* {KW_At, 0,"@", 0, 0, 0, 0, 0, 0, 1, 1, 150, 0},
*/
terminal KW_AT: '@';
/* , 
 * {KW_Comma, 0,",", 0, 0, 0, 0, 1, 0, 1, 1, 11, 0},
 */
terminal KW_COMMA: ',';
/* ;
* {KW_Semicolon, 0,";", 0, 0, 0, 0, 0, 0, 1, 0, 10, 0},
*/
terminal KW_SEMICOLON: ';';
/* ** 2star or power
* {KW_2Star, 0,"**", 0, 0, 0, 0, 0, 0, 1, 1, 140, 0},
*/
terminal KW_2STAR: '**';
/* * times or star
* {KW_Star, 0,"*", 0, 0, 0, 0, 0, 0, 1, 1, 130, 0},
*/
terminal KW_STAR: '*';
/* + plus
* {KW_Plus, 0,"+", 0, 0, 0, 0, 0, 0, 1, 1, 120, 0},
*/
terminal KW_PLUS: '+';
/* -
* {KW_Minus, 0,"-", 0, 0, 0, 0, 0, 0, 1, 1, 120, 0},
*/
terminal KW_MINUS: '-';
/* <
* {KW_GT, 0,">", 0, 0, 0, 0, 0, 0, 1, 1, 100, 0},
* {KW_GE, 0,">=", 0, 0, 0, 0, 0, 0, 1, 1, 100, 0},
* {KW_LT, 0,"<", 0, 0, 0, 0, 0, 0, 1, 1, 100, 0},
* {KW_LE, 0,"<=", 0, 0, 0, 0, 0, 0, 1, 1, 100, 0},
*/
terminal KW_LT: '<';
/* > */
terminal KW_GT: '>';
/* <= */
terminal KW_LE: '<=';
/* >= */
terminal KW_GE: '>=';
/* = equal
* {KW_EQ, 0,"=", 0, 0, 0, 0, 0, 0, 1, 1, 100, 0},
*/
terminal KW_EQ: '=';
/* ~= not-equal or tilde-equal
 * {KW_TildeE, 0,"~=", 0, 0, 0, 0, 0, 0, 1, 1, 90, 0},
 */
terminal KW_TILDEE: '~=';
/* ^= hat-equal
* {KW_HatE, 0,"^=", 0, 0, 0, 0, 0, 0, 1, 1, 90, 0},
*/
terminal KW_HATE: '^=';
/* ~
* {KW_Tilde, 0,"~", 0, 0, 0, 0, 0, 0, 0, 1, 150, 0},
*/
terminal KW_TILDE: '~';
/* ^ hat or carat
* {KW_Hat, 0,"^", 0, 0, 0, 0, 0, 0, 1, 1, 140, 0},
*/
terminal KW_HAT: '^';
/* .. 2Dot or seg
*{KW_2Dot, 0,"..", 0, 0, 0, 0, 0, 0, 1, 1, 110, 0},
* 
*/
terminal KW_2DOT: '..';
/* # Hash or Sharp
* {KW_Sharp, 0,"#", 0, 0, 0, 0, 0, 0, 1, 0, 0, 0},
*/
terminal KW_SHARP: '#';
/* &
* {KW_Ampersand, 0,"&", 0, 0, 0, 0, 0, 0, 1, 0, 160, 0},
*/
terminal KW_AMPERSAND: '&';
/* $
* {KW_Dollar, 0,"$", 0, 0, 0, 0, 1, 0, 0, 1, 70, 0},
*/
terminal KW_DOLAR: '$';
/* /
* {KW_Slash, 0,"/", 0, 0, 0, 0, 0, 0, 1, 1, 130, 0},
*/
terminal KW_SLASH: '/';
/*
 * {KW_Backslash, 0,"\\", 0, 0, 0, 0, 0, 0, 1, 1, 130, 0},
 */
terminal KW_BACKSLASH: '\\';
terminal SLASHSLASH: '//';
terminal BACKSLASHBACKSLASH: '\\\\';
/* '/\\' SLASH-BACKSLASH or wedge
 * outer product or logical 'and'
* {KW_Wedge, 0,"/\\", 0, 0, 0, 0, 0, 0, 1, 1, 40, 0},
*/
terminal KW_WEDGE: '/\\';
/* \\/ BACKSLASH-SLASH or vee
* inner product or logical 'or'
* {KW_Vee, 0,"\\/", 0, 0, 0, 0, 0, 0, 1, 1, 40, 0},
*/
terminal KW_VEE: '\\/';
/* *$ multiply with specific type*/
terminal TIMESDOLAR: '*$';
/* /$ divide with specific type*/
terminal DIVDOLAR: '/$';
/* +$ add with specific type*/
terminal PLUSDOLAR: '+$';
/* -$ subtract or minus with specific type*/
terminal MINUSDOLAR: '-$';
/* =$ equals with specific type*/
terminal EQUALSDOLAR: '=$';
/* '=>' implies or exit
* {KW_Implies, 0,"=>", 0, 0, 0, 0, 0, 0, 1, 1, 35, 0},
*/
terminal KW_IMPLIES: '=>';
/* := Assign or Becomes
* {KW_Assign, 0,":=", 0, 0, 0, 0, 1, 0, 0, 1, 20, 0},
*/
terminal KW_ASSIGN: ':=';
/* == 2eq or def
* {KW_2EQ, 0,"==", 0, 0, 0, 0, 1, 0, 0, 1, 25, 0},
*/
terminal KW_2EQ: '==';
/* -> right-arrow
* {KW_RArrow, 0,"->", 0, 0, 0, 0, 0, 0, 0, 1, 80, 0},
*/
terminal KW_RARROW: '->';
terminal LARROW: '<-';
/* +-> gives or maps-to
* {KW_MapsTo, 0,"+->", 0, 0, 0, 0, 1, 0, 1, 1, 30, 0},
*/
terminal KW_MAPSTO: '+->';
/* % represents an instance of this type */
terminal PERCENT: '%';
/* '% */
terminal PRIMEPERCENT: "'%";
/* ... */
terminal ELLIPSIS: '...';
/* +/ takes the sum of a list */
terminal SUMLIST: '+/';
terminal ANY_OTHER: .;

////////// end of lexer rules ///////////////

//Goal
//: CurlyContents(Labeled)
//{ yypval = $$ = $1; }
//;

//Expression
//: enlist1a(Labeled, KW_Semicolon, `AB_Sequence)
//;

//Labeled
//: Comma
//| Declaration
//| KW_At Atom opt(Labeled)
//{ $$ = abNewLabel(TPOS($1),$2,$3); }
//;

//Declaration
//: KW_Macro MacroBody
//{ $$ = abNewMacro(TPOS($1),$2); }
//| KW_Extend Sig
//{ $$ = abNewExtend(TPOS($1),$2); }
//| KW_Local Sig
//{ $$ = abNewLocal(TPOS($1),$2); }
//| KW_Free Sig
//{ $$ = abNewFree(TPOS($1),$2); }
//| KW_Fluid Sig
//{ $$ = abNewFluid(TPOS($1),$2); }
//| KW_Default Sig
//{ $$ = abNewDefault(TPOS($1),$2); }
//| KW_Define Sig
//{ $$ = abNewDDefine(TPOS($1),$2); }
//| KW_Fix Sig
//{ $$ = abNewFix(TPOS($1),$2); }
//| KW_Inline opt(Sig) opt(FromPart)
//{ $$ = abNewInline(TPOS($1),$2,$3); }
//| KW_Import opt(Sig) opt(FromPart)
//{ $$ = abNewImport(TPOS($1),$2,$3); }
//| ExportDecl
//;

//ExportDecl
//: KW_Export opt(Sig)
//{ $$ = abNewExport(TPOS($1),$2, abZip,abZip); }
//| KW_Export opt(Sig) ToPart
//{ $$ = abNewExport(TPOS($1),$2,abZip,$3); }
//| KW_Export opt(Sig) FromPart
//{ $$ = abNewExport(TPOS($1),$2,$3,abZip); }
//;

//ToPart
//: KW_To Infixed
//{ $$ = $2; }
//;

//FromPart
//: KW_From enlist1(Infixed, KW_Comma, `AB_Comma)
//{ $$ = $2; }
//;

//MacroBody
//: Sig
//| ExportDecl
//| KW_Import Sig opt(FromPart)
//{ $$ = abNewImport(TPOS($1),$2,$3); }
//;

//Sig
//: DeclBinding
//| Block
//;

//DeclPart
//: KW_Colon Type
//{ $$ = $2; }
//| KW_ColonStar Type
//{ $$ = abNewHide(TPOS($1), $2); }
//;

/*
 * Commas
 */
//Comma
//: enlist1(CommaItem, KW_Comma, `AB_Comma)
//;

//CommaItem
//: Binding(AnyStatement)
//| Binding(AnyStatement) KW_Where CommaItem
//{ $$ = abNewWhere(TPOS($2),$3,$1); }
//;

/*
 * DeclBinding
 */
//DeclBinding
//: BindingR(InfixedExprsDecl,AnyStatement)
//;

//InfixedExprsDecl
//: InfixedExprs
//| InfixedExprs DeclPart
//{ $$ = abNewDeclare(APOS($1),$1,$2); }
//;

//InfixedExprs
//: enlist1(InfixedExpr, KW_Comma, `AB_Comma)
//;


/*
 * Bindings
 * 
 * Substituted Rules in Xtext:
 * Binding_BalStatement
 * Binding_AnyStatement
 * Binding_BalStatement
 * Binding_InfixedExprsDecl
 * Binding_Collection
 */
//Binding(E)
//: BindingL(Infixed,E)
//;

/* Substituted Rules in Xtext:
 * BindingL(Infixed,E) where E is in Binding
 */
//BindingL(R,L)
//: L
//| R KW_Assign BindingL(R,L)
//{ $$ = abNewAssign(APOS($1),$1,$3); }
//| R KW_2EQ BindingL(R,L)
//{ $$ = abNewDefine(APOS($1),$1,$3); }
//| R KW_MArrow BindingL(R,L)
//{ $$ = abNewMDefine(APOS($1),$1,$3); }
//| R KW_MapsTo BindingL(R,L)
//{ $$ = abNewLambda(APOS($1),$1,abZip,$3); }
//| R KW_MapsToStar BindingL(R,L)
//{ $$ = abNewPLambda(APOS($1),$1,abZip,$3); }
//;

/* Substituted Rules in Xtext:
 * BindingR(InfixedExprsDecl,AnyStatement)
 */
//BindingR(R,L)
//: R
//| R KW_Assign Binding(L)
//{ $$ = abNewAssign(APOS($1),$1,$3); }
//| R KW_2EQ Binding(L)
//{ $$ = abNewDefine(APOS($1),$1,$3); }
//| R KW_MArrow Binding(L)
//{ $$ = abNewMDefine(APOS($1),$1,$3); }
//| R KW_MapsTo Binding(L)
//{ $$ = abNewLambda(APOS($1),$1,abZip,$3); }
//| R KW_MapsToStar Binding(L)
//{ $$ = abNewPLambda(APOS($1),$1,abZip,$3); }
//;

/*
 * Statements
 *
 * It is easier to spot conflicts when explicitly handling dangling else.
 */
//AnyStatement
//: KW_If CommaItem KW_Then Binding(AnyStatement)
//{ $$ = abNewIf(TPOS($1), TEST($2),$4,abZip); }
//| Flow(AnyStatement)
//;

//BalStatement
//: Flow(BalStatement)
//;

/* Substituted Rules in Xtext:
Flow(XX) -> Flow_AnyStatement or Flow_BalStatement */
//Flow(XX)
//: Collection
//| KW_If CommaItem KW_Then Binding(BalStatement) KW_Else Binding(XX)
//{ $$ = abNewIf(TPOS($1), TEST($2),$4,$6); }
//| Collection KW_Implies Binding(XX)
//{ $$ = abNewExit(TPOS($2), TEST($1),$3); }
//| Iterators KW_Repeat Binding(XX)
//{ $$ = abNewRepeatOL(TPOS($2),$3,$1); listFree(AbSyn)($1); }
//| KW_Repeat Binding(XX)
//{ $$ = abNewRepeat0(TPOS($1),$2); }
//| KW_Try Binding(AnyStatement) KW_But ButExpr AlwaysPart(XX)
//{ (void)parseDeprecated(KW_But, abNewNothing(TPOS($3))); $$ = abNewTry(TPOS($1),$2,$4->abSequence.argv[0], $4->abSequence.argv[1],$5); }
//| KW_Try Binding(AnyStatement) KW_Catch ButExpr AlwaysPart(XX)
//{ $$ = abNewTry(TPOS($1),$2,$4->abSequence.argv[0], $4->abSequence.argv[1],$5); }
//| KW_Select Binding(AnyStatement) KW_In Cases
//{ $$ = abNewSelect(TPOS($1),$2,$4); }
//| KW_Do Binding(XX)
//{ $$ = abNewDo(TPOS($1),$2); }
//| KW_Delay Binding(XX)
//{ $$ = abNewDelay(TPOS($1),$2); }
//| KW_Reference Binding(XX)
//{ $$ = abNewReference(TPOS($1),$2); }
//| KW_Generate GenBound Binding(XX)
//{ $$ = abNewGenerate(TPOS($1),$2,$3); }
//| KW_Assert Binding(XX)
//{ $$ = abNewAssert(TPOS($1),TEST($2)); }
//| KW_Iterate opt(Name)
//{ $$ = abNewIterate(TPOS($1),$2); }
//| KW_Break opt(Name)
//{ $$ = abNewBreak(TPOS($1),$2); }
//| KW_Return opt(Collection)
//{ $$ = abNewReturn(TPOS($1),$2); }
//| KW_Yield Binding(XX)
//{ $$ = abNewYield(TPOS($1),$2); }
//| KW_Except Binding(XX)
//{ $$ = parseDeprecated(KW_Except, abNewRaise(TPOS($1),$2)); }
//| KW_Throw Binding(XX)
//{ $$ = abNewRaise(TPOS($1),$2); }
//| KW_Goto Id
//{ $$ = abNewGoto(TPOS($1),$2); }
//| KW_Never
//{ $$ = abNewNever(TPOS($1)); }
//;

//GenBound
//: Nothing
//| KW_To CommaItem KW_Of
//{ $$ = $2; }
//;

//ButExpr
//: Nothing
//{ $$ = abNew(AB_Sequence, APOS($1), 2, abZip, abZip); }
//| DeclBinding KW_In Cases
//{ $$ = abNew(AB_Sequence, APOS($1), 2, $1, $3); }
//;

//Cases
//: Binding(Collection)
//;

/* Substituted Rules in Xtext:
AlwaysPart(XX) -> AlwaysPart_AnyStatement
               or AlwaysPart_BalStatement */
//AlwaysPart(XX)
//: KW_Always Binding(XX)
//{ (void)parseDeprecated(KW_Always, abNewNothing(TPOS($1))); $$ = $2; }
//| KW_Finally Binding(XX)
//{ $$ = $2; }
//| Nothing
//;

/*
 * Iterators
 */
//Collection
//: Infixed
//| Infixed Iterators
//{ $$ = abNewCollectOL(APOS($1),$1,$2); listFree(AbSyn)($2); }
//;

//Iterators<ablist>
//: Iterators1
//{ $$ = listNReverse(AbSyn)($1); }
//;

//Iterators1<ablist>
//: Iterator
//{ $$ = listCons(AbSyn)($1, NULL); }
//| Iterators1 Iterator
//{ $$ = listCons(AbSyn)($2, $1); }
//;

//Iterator
//: KW_For ForLhs KW_In Infixed opt(SuchthatPart)
//{ $$ = abNewFor(TPOS($1),$2,$4,$5); }
//| KW_While Infixed
//{ $$ = abNewWhile(TPOS($1),TEST($2)); }
//;

//ForLhs
//: Infixed
//| KW_Free Infixed
//{ $$ = abNewFree(TPOS($1), $2); }
//| KW_Local Infixed
//{ $$ = abNewLocal(TPOS($1), $2); }
//| KW_Fluid Infixed
//{ $$ = abNewFluid(TPOS($1), $2); }
//;

//SuchthatPart
//: KW_Bar Infixed
//{ $$ = TEST($2); }
//;

/*
 * Infixed Expressions
 */

//Infixed
//: InfixedExpr
//| InfixedExpr DeclPart
//{ $$ = abNewDeclare(APOS($1),$1,$2); }
//| Block
//;

//InfixedExpr
//: E11(Op)
//| E3
//;


//E3
//: E4
//| E3 KW_And E4
//{ $$ = abNewAnd(TPOS($2), TEST($1),TEST($3)); }
//| E3 KW_Or E4
//{ $$ = abNewOr(TPOS($2), TEST($1),TEST($3)); }
//| E3 LatticeOp E4
//{ $$ = abNewInfix(APOS($2),$2,$1,$3); }
//;

//E4
//: E5
//| E4 KW_Has E5
//{ $$ = abNewHas(TPOS($2),$1,$3); }
//| E4 RelationOp E5
//{ $$ = abNewInfix(APOS($2),$2,$1,$3); }
//| RelationOp E5
//{ $$ = abNewPrefix(APOS($1),$1,$2); }
//;

//E5
//: E6
//| E5 SegOp
//{ $$ = abNewPostfix(APOS($2),$2,$1); }
//| E5 SegOp E6
//{ $$ = abNewInfix(APOS($2),$2,$1,$3); }
//;

//E6
//: E7
//| E6 PlusOp E7
//{ $$ = abNewInfix(APOS($2),$2,$1,$3); }
//| PlusOp E7
//{ $$ = abNewPrefix(APOS($1),$1,$2); }
//;

//E7
//: E8
//| E7 QuotientOp E8
//{ $$ = abNewInfix(APOS($2),$2,$1,$3); }
//;

//E8
//: E9
//| E8 TimesOp E9
//{ $$ = abNewInfix(APOS($2),$2,$1,$3); }
//;

//E9
//: E11(E12)
//| E11(E12) PowerOp E9
//{ $$ = abNewInfix(APOS($2),$2,$1,$3); }
//;

/* Substituted Rules in Xtext:
 * E11_E12
 * E11_Op
 */
//E11(X)
//: X
//| E11(X) KW_2Colon E12
//{ $$ = abNewCoerceTo(TPOS($2),$1,$3); }
//| E11(X) KW_At E12
//{ $$ = abNewRestrictTo(TPOS($2),$1,$3); }
//| E11(X) KW_Pretend E12
//{ $$ = abNewPretendTo(TPOS($2),$1,$3); }
//;

//Type
//: E11(E12)
//;

//E12
//: E13
//| E13 ArrowOp E12
//{ $$ = abNewInfix(APOS($2),$2,$1,$3); }
//;

//E13
//: E14
//| E14 KW_Dollar QualTail
//{ $$ = abNewQualify(TPOS($2),$1,$3); }
//;

//QualTail
//: LeftJuxtaposed
//| LeftJuxtaposed KW_Dollar QualTail
//{ $$ = abNewQualify(TPOS($2),$1,$3); }
//;

//OpQualTail
//: Molecule
//| Molecule KW_Dollar OpQualTail
//{ $$ = abNewQualify(TPOS($2),$1,$3); }
//;

//E14
//: E15
//| opt(E14) KW_With DeclMolecule
//{ $$ = abNewWith(TPOS($2),$1,$3); }
//| opt(E14) KW_Add DeclMolecule
//{ $$ = abNewAdd(TPOS($2),$1,$3); }
//| E14 KW_Except E15
//{ $$ = parseDeprecated(KW_Except, abNewExcept(TPOS($2),$1,$3)); }
//| E14 KW_Throw E15
//{ $$ = abNewExcept(TPOS($2),$1,$3); }
//;

//E15
//: Application
//;


/*
 * Infixed Operations
 */
//Op
//: ArrowOp
//| LatticeOp
//| RelationOp
//| SegOp
//| PlusOp
//| QuotientOp
//| TimesOp
//| PowerOp
//;

//NakedOp
//: UnqualOp(ArrowTok)
//| UnqualOp(LatticeTok)
//| UnqualOp(RelationTok)
//| UnqualOp(SegTok)
//| UnqualOp(PlusTok)
//| UnqualOp(QuotientTok)
//| UnqualOp(TimesTok)
//| UnqualOp(PowerTok)
//;


//ArrowOp: QualOp(ArrowTok);
//LatticeOp: QualOp(LatticeTok);
//RelationOp: QualOp(RelationTok);
//SegOp: QualOp(SegTok);
//PlusOp: QualOp(PlusTok);
//QuotientOp: QualOp(QuotientTok);
//TimesOp: QualOp(TimesTok);
//PowerOp: QualOp(PowerTok);

//ArrowTok<tok>: KW_RArrow | KW_LArrow | KW_MapStar ;
//LatticeTok<tok>: KW_Vee | KW_Wedge ;
//RelationTok<tok>:KW_EQ | KW_TildeE | KW_HatE |
//KW_GE | KW_GT | KW_2GT |
//KW_LE | KW_LT | KW_2LT |
//KW_Is | KW_Isnt | KW_Case ;
//SegTok<tok>: KW_2Dot | KW_By ;
//PlusTok<tok>: KW_Plus | KW_Minus | KW_PlusMinus ;
//QuotientTok<tok>:KW_Mod | KW_Quo | KW_Rem | KW_Exquo ;
//TimesTok<tok>: KW_Star | KW_Slash | KW_Backslash ;
//PowerTok<tok>: KW_2Star | KW_Hat ;

/*
 * Juxtaposed Expressions
 *
 * a b c d as(.(.(.)))
 * f(a).2(b)(c).x.y.(d).(e) as(((.).).)
 *
 */

//Application
//: RightJuxtaposed
//;

//RightJuxtaposed
//: Jright(Molecule)
//;

//LeftJuxtaposed
//: Jleft(Molecule)
//;

/* Substituted Rules in Xtext:
 * Jright(Molecule)
 * Jright(Atom)
 */
//Jright(H)
//: Jleft(H)
//| Jleft(H) Jright(Atom)
//{ $$ = parseMakeJuxtapose($1,$2); }
//| KW_Not Jright(Atom)
//{ $$ = abNewNot(TPOS($1),TEST($2)); }
//;

/* Substituted Rules in Xtext:
 * Jleft(Molecule)
 * Jleft(Atom)
 */
//Jleft(H)
//: H
//| KW_Not BlockEnclosure
//{ $$ = abNewNot(TPOS($1),TEST($2)); }
//| Jleft(H) BlockEnclosure
//{ $$ = parseMakeJuxtapose($1,$2); }
//| Jleft(H) KW_Dot BlockMolecule
//{ $$ = abNewPrefix(TPOS($2),$1,$3); }
//;

/*
 * Indivisible Expressions
 */
//Molecule
//: Atom
//| Enclosure
//;

//Enclosure
//: Parened
//| Bracketed
//| QuotedIds
//;

//DeclMolecule
//: opt(Application)
//| Block
//;

//BlockMolecule
//: Atom
//| Enclosure
//| Block
//;

//BlockEnclosure
//: Enclosure
//| Block
//;

//Block
//: Piled(Expression)
//| Curly(Labeled)
//;

//Parened
//: KW_OParen KW_CParen
//{
//$$ = abNewParen(TPOS($1), abNewComma0(TPOS($1)));
//abSetEnd($$, TEND($2));
//}
//| KW_OParen Expression KW_CParen
//{ $$ = abNewParen(TPOS($1), $2); abSetEnd($$, TEND($3)); }
//;

//Bracketed
//: KW_OBrack KW_CBrack
//{
//$$ = abNewMatchfix(TPOS($1),
//abNewId(TPOS($1),ssymBracket),
//abNewComma0(TPOS($1)));
//abSetEnd($$, TEND($2));
//}
//| KW_OBrack Expression KW_CBrack
//{
//$$ = abNewMatchfix(TPOS($1),
//abNewId(TPOS($1),ssymBracket),
//$2);
//abSetEnd($$, TEND($3));
//}
//;

//QuotedIds
//: KW_Quote KW_Quote
//{
//$$ = abNewMatchfix(TPOS($1),
//abNewId(TPOS($1),ssymEnum),
//abNewComma0(TPOS($1)));
//abSetEnd($$, TEND($2));
//}
//| KW_Quote Names KW_Quote
//{
//$$ = abNewMatchfix(TPOS($1),
//abNewId(TPOS($1),ssymEnum),
//$2);
//abSetEnd($$, TEND($3));
//}
//;
//Names
//: enlist1(Name, KW_Comma, `AB_Comma)
//;

/*
 * Terminals
 */
//Atom
//: Id
//| Literal
//;

//Name
//: Id
//| NakedOp
//;

//Id
//: TK_ID
//{ $$ = abNewOfToken(AB_Id, $1); }
//| KW_Sharp
//{ $$ = abNewOfToken(AB_Id, $1); }
//| KW_Tilde
//{ $$ = abNewOfToken(AB_Id, $1); }
//;

//Literal
//: TK_Int
//{ $$ = abNewOfToken(AB_LitInteger, $1); }
//| TK_Float
//{ $$ = abNewOfToken(AB_LitFloat, $1); }
//| TK_String
//{ $$ = abNewOfToken(AB_LitString, $1); }
//;

/*
 * Meta-rules
 */

//Nothing
//:
//{ $$ = abZip; }
//;

/* Substituted Rules in Xtext:
 * UnqualOp(ArrowTok)
 * UnqualOp(LatticeTok)
 * UnqualOp(RelationTok)
 * UnqualOp(SegTok)
 * UnqualOp(PlusTok)
 * UnqualOp(QuotientTok)
 * UnqualOp(TimesTok)
 * UnqualOp(PowerTok)
 */
//UnqualOp(op)
//: op
//{ $$ = abNewOfToken(AB_Id, $1); }
//;

/* Substituted Rules in Xtext:
 * QualOp(ArrowTok)
 * QualOp(LatticeTok)
 * QualOp(RelationTok)
 * QualOp(SegTok)
 * QualOp(PlusTok)
 * QualOp(QuotientTok)
 * QualOp(TimesTok)
 * QualOp(PowerTok)
 */
//QualOp(op)
//: op
//{ $$ = abNewOfToken(AB_Id, $1); }
//| op KW_Dollar OpQualTail
//{ $$ = abNewQualify(TPOS($1), abNewOfToken(AB_Id, $1), $3); }
//;

/* Substituted Rules in Xtext:
 * opt(Labeled)
 * opt(Sig)
 * opt(FromPart)
 * opt(Name)
 * opt(Collection)
 * opt(SuchthatPart))
 * opt(E14)
 * opt(Application)
*/
//opt(E)
//: Nothing
//| E
//;

/* ++ Doc. */

/* Substituted Rules in Xtext:
 * E is E from PileContents(E)
 */ 
//Doc(E)
//: PreDocument E PostDocument
//{
//$$ = $2;
//if($3) $$ = abNewDocumented(APOS($3),$$,$3);
//if($1) $$ = abNewDocumented(APOS($$),$$,$1);
//}
//;

//PreDocument
//: PreDocumentList
//{ $$ = abNewDocTextOfList($1); listFree(Token)($1); }
//;

//PostDocument
//: PostDocumentList
//{ $$ = abNewDocTextOfList($1); listFree(Token)($1); }
//;

//PreDocumentList<toklist>
//: Nothing
//{ $$ = listNil(Token); }
//| TK_PreDoc PreDocumentList
//{ $$ = listCons(Token)($1, $2); }
//;

//PostDocumentList<toklist>
//: Nothing
//{ $$ = listNil(Token); }
//| TK_PostDoc PostDocumentList
//{ $$ = listCons(Token)($1, $2); }
//;

/* Substituted Rules in Xtext:
* enlist1(Infixed, KW_Comma, `AB_Comma)
* enlist1(CommaItem, KW_Comma, `AB_Comma)
* enlist1(InfixedExpr, KW_Comma, `AB_Comma)
* enlist1(Name, KW_Comma, `AB_Comma)
* 
*  E {sep E sep E}
*/
//enlist1(E,Sep,Tag)
//: enlister1(E, Sep)
//
//{ $$ = abOneOrNewOfList(Tag, $1); listFree(AbSyn)($1); }
//;

/* not used
 * E sep E {sep E}
 */
//enlist2(E,Sep,Tag)
//: enlister1(E, Sep) Sep E
//{
//$1 = listCons(AbSyn)($3, $1);
//$$ = abOneOrNewOfList(Tag, $1);
//listFree(AbSyn)($1);
//}
//;

/* Substituted Rules in Xtext:
* enlister1(E, Sep)
* where E is E from enlist1 or enlist1a 
*/
//enlister1(E, Sep)<ablist>
//: E
//{ $$ = listCons(AbSyn)($1, listNil(AbSyn) ); }
//| enlister1(E, Sep) Sep E
//{ $$ = listCons(AbSyn)($3, $1); }
//;

/* Substituted Rules in Xtext:
* enlist1a(Labeled, KW_Semicolon, `AB_Sequence)
* 
* E {sep+ E sep+ E sep*} */
//enlist1a(E,Sep,Tag)
//: enlister1a(E, Sep)
//{ $$ = abOneOrNewOfList(Tag, $1); listFree(AbSyn)($1); }
//;

/* Substituted Rules in Xtext:
* enlister1a(E, Sep) where E is from enlist1a
* 
*/
//enlister1a(E, Sep)<ablist>
//: E
//{ $$ = listCons(AbSyn)($1, listNil(AbSyn) ); }
//| enlister1a(E, Sep) Sep E
//{ $$ = listCons(AbSyn)($3, $1); }
//| enlister1a(E, Sep) Sep
//{ $$ = $1; }
//;

/* Substituted Rules in Xtext:
* Piled(Expression)
* 
*/
/* Piled */
//Piled(E)
//: KW_SetTab PileContents(E) KW_BackTab
//{ $$ = abOneOrNewOfList(AB_Sequence,$2); listFree(AbSyn)($2); }
//;

/* Substituted Rules in Xtext:
* Curly(Labeled)
* 
*/
//Curly(E)
//: KW_OCurly CurlyContents(E) KW_CCurly
//{ $$ = $2; abSetPos($$, TPOS($1)); abSetEnd($$, TEND($3)); }
//;

/* Substituted Rules in Xtext:
* PileContents(E) E is from piled
* 
*/
//PileContents(E)<ablist>
//: Doc(E)
//{ $$ = listCons(AbSyn)($1, listNil(AbSyn)); }
//| PileContents(E) KW_BackSet Doc(E)
//{ $$ = listCons(AbSyn)($3, $1); }
//| error KW_BackSet Doc(E)
//{ yyerrok; $$ = listCons(AbSyn)($3, listNil(AbSyn)); }
//;

/* Substituted Rules in Xtext:
* CurlyContents(Labeled)
* CurlyContents(E) E is from Curly
* 
*/
//CurlyContents(E)
//: CurlyContentsList(E)
//{ $$ = abOneOrNewOfList(AB_Sequence,$1); listFree(AbSyn)($1); }
//;

/* Substituted Rules in Xtext:
* CurlyContentsList(E) E is from CurlyContents(E)
* 
*/
//CurlyContentsList(E)<ablist>
//: CurlyContent1(E)
//| CurlyContent1(E) CurlyContentB(E)
//{ $$ = listCons(AbSyn)($2, $1); }
//;

/* Substituted Rules in Xtext:
* CurlyContent1(E) E is form CurlyContentsList(E)
* 
*/
//CurlyContent1(E)<ablist>
//: Nothing
//{ $$ = listNil(AbSyn); }
//| CurlyContent1(E) CurlyContentA(E)
//{ $$ = listCons(AbSyn)($2, $1); }
//;

/* Substituted Rules in Xtext:
* CurlyContentA(E) E is from CurlyContent1(E)
* 
*/
//CurlyContentA(E)
//: CurlyContentB(E) KW_Semicolon PostDocument
//{ $$ = $1; if($3) $$ = abNewDocumented(APOS($3),$$,$3); }
//| error KW_Semicolon PostDocument
//{ yyerrok; $$ = abNewNothing(TPOS($2)); }
//;

/* Substituted Rules in Xtext:
* CurlyContentB(E) E is from CurlyContentA(E)
* or CurlyContentsList(E)
* 
*/
//CurlyContentB(E)
//: PreDocument E PostDocument
//{
//$$ = $2;
//if($1) $$ = abNewDocumented(APOS($1),$$,$1);
//if($3) $$ = abNewDocumented(APOS($$),$$,$3);
//}
//;

///////// and of Aldor stuff

/*
 * longname and longname2 should both be ID and have the same value. Since the
 * runtime values can't be checked by the parser this must be checked later.
 */
CategoryDef hidden(WS,KW_NEWLINE,TK_COMMENT):
name='category' shortname=TK_ID longname=TK_ID
longname2=TK_ID /*[CategoryDef]*/
    (cp=TypeParameterList)?
    KW_COLON 'Category' KW_2EQ
    (
    implName=TypeArguments? ((w=WithPart? a=AddPart?)| wh5=WherePart)
    | KW_OCURLY KW_NEWLINE*
      implName=TypeArguments ((w=WithPart? a=AddPart?)| wh5=WherePart)
      KW_CCURLY KW_NEWLINE* a2=AddPart?
    )
;

/*
 * longname and longname2 should both be ID and have the same value. Since the
 * runtime values can't be checked by the parser this must be checked later.
 */
PackageDef hidden(WS,KW_NEWLINE,TK_COMMENT):
name='package' shortname=TK_ID longname=TK_ID
longname2=TK_ID /*[PackageDef]*/
    (cp=TypeParameterList)? KW_COLON
    (
     exportName=TK_ID KW_2EQ implName=TK_ID
        (w=WithPart | wh5=WherePart)
     |
     w=WithPart
     (KW_2EQ add2=AddPart)?
    )
;

/*
 * longname and longname2 should both be ID and have the same value. Since the
 * runtime values can't be checked by the parser this must be checked later.
 */
DomainDef hidden(WS,KW_NEWLINE,TK_COMMENT):
name='domain' shortname5=TK_ID longname5=TK_ID
longname6=TK_ID /*[DomainDef]*/
    (cp5=TypeParameterList)?
    KW_COLON exportName=TK_ID (cp6=TypeParameterList)?
    KW_2EQ implName5=TK_ID?
    (w=WithPart | wh5=WherePart | a=AddPart)
;

/*
 * both category and domain can have 'where' part which holds overall information
 * such as category/domain parameter information and general macros. This is
 * followed by export('with') and import ('add') information.
 * Forms allowed include:
 * Exports == PlottablePlaneCurveCategory with {
 * Exports ==> PlottablePlaneCurveCategory with {
 * Exports ==> with {
 */
WherePart hidden(WS,TK_COMMENT):
name='where' KW_NEWLINE* KW_OCURLY KW_NEWLINE*
    (whereAssig +=WhereAssignments (KW_NEWLINE|KW_SEMICOLON)+)*
    // with part
    (longname8=TK_ID (KW_2EQ | KW_MARROW) (imp=TypeExpression2)? w8=WithPart)?
    // add part
    (
     (longname9=TK_ID (KW_2EQ | KW_MARROW))?
        ((fs=TK_ID KW_OPAREN par2=TK_ID? (KW_COMMA par3 += TK_ID)* KW_CPAREN)
         | (fs=TK_ID f2=TK_ID)
        )?
        add=AddPart
    )?
    KW_CCURLY KW_NEWLINE+
;

/* each one must be on a separate line or separated by ';'
 * need to add name=
 */
WhereAssignments hidden(WS):
VariableDeclaration
| MacroDef |Import
;

/*
 * the 'where' part contains a 'with' part which holds export information
 * such as function signatures (function declarations) but not function definitions.
 */
WithPart hidden(WS,TK_COMMENT):
name='with' KW_NEWLINE* KW_OCURLY KW_NEWLINE*
    (fundec += VariableDeclaration (KW_NEWLINE|KW_SEMICOLON)+)*
    KW_CCURLY KW_NEWLINE*
;

/*
 * similar to 'WithPart' but no trailing NL
 */
WithInline hidden(WS,TK_COMMENT):
name='with' KW_NEWLINE* KW_OCURLY KW_NEWLINE*
    (fundec += VariableDeclaration (KW_NEWLINE|KW_SEMICOLON)+)*
    KW_CCURLY
;

/*
 * the 'where' part contains a 'add' part which holds function and other
 * declarations.
 */
AddPart hidden(WS,TK_COMMENT):
name='add' KW_NEWLINE* KW_OCURLY KW_NEWLINE*
    (t+=AddStatements (KW_NEWLINE|KW_SEMICOLON)+)* KW_CCURLY KW_NEWLINE*
;

/*
 * The add section of domain or package may contain multiple lines
 *
 * Examples:
 * if (r := recip leadingCoefficient M) case "failed" then {
 * error "Modulus cannot be made monic"
 * }
 */
AddStatements hidden(WS,TK_COMMENT):
   VariableDeclarationAssign
   | FunctionDefinition
   | ('if' t1=Expression // expression has form 'x has y'
      'then' t13=FunctionDefinitionBlock)
   | 'else' t14=FunctionDefinitionBlock
   | 'else' t15=AddStatements
   | MacroDef
   | Import
;

/* function definition in add part (called by AddStatements)
 * has a form like:
 * name(params) == statement
 * or, option for single parameter without brackets:
 * name param == statement
 * or, option for zero parameters without brackets:
 * This does not always work at the moment, for instance, this does not work:
 * size == size$R ^ d
 * but this does
 * size() == size$R ^ d
 *
 * or, for infix operators,
 * a = b == statement
 * or, for multiple statements,
 * name(params) == {
 * statement
 * statement
 * }
 * some function definitions may be conditional like this:
 * if % has finiteAggregate then {
 * ... }
 */
FunctionDefinition hidden(WS,TK_COMMENT):
  ((
par3=FunctionSignature
    (KW_COLON par4=TypeExpression1)?
    KW_2EQ par5=Statement
   )|(
    // this is case where FunctionSignature is just an identifier
    fnNam=TK_ID KW_2EQ par5=Statement
   ))
;

/*
 * called by 'AddStatements' rule.
 * allows more add statements inside:
 * if a has y then 'more add statements'
 */
FunctionDefinitionBlock hidden(WS,TK_COMMENT):
    fnDecBr=KW_OCURLY KW_NEWLINE*
      (
       fnDecBk += FunctionDefinition (KW_NEWLINE|KW_SEMICOLON)+
       |
       vars+=VariableDeclarationAssign (KW_NEWLINE|KW_SEMICOLON)+
     | ('if' t1+=Expression // expression has form 'x has y'
        'then' t13+=FunctionDefinitionBlock (KW_NEWLINE|KW_SEMICOLON)+)
     | ('else' t14+=FunctionDefinitionBlock (KW_NEWLINE|KW_SEMICOLON)+)
     | i1+=Import (KW_NEWLINE|KW_SEMICOLON)+
      )*
      KW_CCURLY
      | 'error' e=Expression
      | KW_OCURLY KW_NEWLINE* 'error' e=Expression (KW_NEWLINE|KW_SEMICOLON)+ KW_CCURLY
;

/* This is the first part of the function definition without the return type or
 * the function implementation. Usually the function signature has a form like:
 * name(params)
 * We allow a single parameter to be given without brackets:
 * name param
 *
 * We also allow some alternative forms to represent infix operators like:
 * a = b to represent _=(a,b)
 * or the following (this works but only for % we need it to work for every type)
 * s:% = t:%
 * or
 * a > b to represent _>(a,b)
 * 0 or 1 can be used as a function signature as a short form of
 * _0() or _1()
 */
FunctionSignature hidden(WS,TK_COMMENT):
  (
fnNam=TK_ID
    KW_OPAREN
    par2=VariableTyped?
    (KW_COMMA par3 += VariableTyped)*
    KW_CPAREN
  ) | (
   // fnNam=ID par2=VariableDeclaration causes recursive definition so use:
   fnNam=TK_ID par=TK_ID
// ) | (
// t4=ID // no parameters without brackets
// commented out as it causes recursive rule invocation
// with ruleAddStatements and ruleFunctionDefinitionBlock
  ) | (
   t4=TK_ID (KW_COLON (PERCENT | TK_ID))? //(COLON te1=TypeExpression)?
   ( b1=KW_EQ | b1=KW_LT | b1=KW_GT | b1=KW_LE | b1=KW_GE |
            b1=KW_PLUS | b1=KW_MINUS | b1=KW_STAR | b1=KW_SLASH | b1=KW_AMPERSAND |
            b1=KW_BAR | b1=KW_HAT) t5=TK_ID
  ) | (
   b3=TK_INT // allows special form of function signature using '0' or '1'
   // can't specify '0' or '1' explicitly as this would affect lex
   // order
  ) | (
   b2=KW_MINUS t6=TK_ID
  ) | (
   b4=KW_TILDE t7=TK_ID
  ) | (
   b5='not' t8=TK_ID
  ) | (
   b6=KW_SHARP t8=TK_ID
  )
;

/* macros provide a general textual substitution
 * there are two forms:
 * name ==> body
 * and
 * name macro == body
 */
MacroDef: macroname=TK_ID MACROVALUE ; //MACRO val=ID NL;

/*
 * import domain
 */
Import hidden(WS):
'import' (impname += TK_ID)+ (KW_OPAREN par22+=TypeExpression1
(KW_COMMA par22+=TypeExpression1)* KW_CPAREN)?
;

/* Variable declaration in where and with sections:
 * A 'variable' can be simple like:
 * x:Float
 * or something more complicated like:
 * x:Record(newPt: Pt,type: String)
 * or it can be a function like:
 * x:(Float,Integer) -> Float
 * or it can be conditional like:
 * if
 */
VariableDeclarationBlock hidden(WS,TK_COMMENT):
    vardecbr=KW_OCURLY KW_NEWLINE*
      //=>(i1=Import NL*)?
      (vardecBlk += VariableDeclaration (KW_NEWLINE|KW_SEMICOLON)+)*
      KW_CCURLY
;

/* Variable declaration in where and with sections:
 * A 'variable' can be simple like:
 * x:Float
 * or something more complicated like:
 * x:Record(newPt: Pt,type: String)
 * or it can be a function like:
 * x:(Float,Integer) -> Float
 * or it can be conditional like:
 * if
 */
VariableDeclaration hidden(WS,TK_COMMENT):
//Import?
    ('if' t1=Expression 'then')? // expression has form 'x has y'
( v1=TypeWithName
      | v2=VariableDeclarationBlock
)
;

/*
 * This rule is used where a type is expected like:
 * Float
 * but it may also have an optional name like:
 * x:Float
 */
TypeWithName hidden(WS,TK_COMMENT):
(
(varName=TK_ID | varNameSt=TK_STRING) (KW_COMMA varName2=TK_ID)?
KW_COLON
)? typ=TypeExpression1
;


/* Variable name with optional type. This is used in function signature
 * and also by VariableDeclaration:
 * A 'variable' can be simple like:
 * x:Float
 * or something more complicated like:
 * x:Record(newPt: Pt,type: String)
 * or it can be a function like:
 * x:(Float,Integer) -> Float
 * we can define multiple variables together:
 * i,j : Integer
 */
VariableTyped hidden(WS,TK_COMMENT):
(varName=TK_ID | varNameSt=TK_STRING)
// =>(COMMA t2+=ID)* // multiple declarations in same line
    (KW_COLON typ=TypeExpression1)?
;

/* in add part we can declare and assign in same part
 * such as:
 * a := 3
 * a:Integer := 3
 * a := sin(x)
 *
 * There are two forms of multiple assignment:
 * a,b,c := 0@Integer
 * or:
 * a := b := c := 0@Integer
 */
VariableDeclarationAssign hidden(WS):
  varName=TK_ID // name of variable
  // if I just use name=ID then, when the ui program is running, I get:
  // Duplicate xxx 'coerce' in yyy
  (
    (KW_COMMA t12+=TK_ID)* // multiple declarations in same line
    (KW_COLON typ=TypeExpression1)? // option to explicitly define type
    (KW_ASSIGN (t4=Expression /* |(LBRACE NL* Expression NL* RBRACE) */))?
    // we need block since we can't always detect continuation after ':='
    // but this causes infinite loop
  )// | (BECOMES t2+=ID)+ BECOMES t4=Expression
;

/*
 * free variable allows us to declare a variable that is global
 */
FreeVariable hidden(WS):
'free' var=TK_ID
;

/*
 * allows us to declare a variable that is not global
 */
LocalVariable hidden(WS):
'local' var=TK_ID
;

/*
 * This is similar to Expression but known to be of type.
 * (Expression can also be of type) but if we know that
 * this is a type we can exclude some possibilities.
 *
 * A 'typeExpression' can be simple like:
 * Float
 * or something more complicated like:
 * Record(newPt: Pt,type: String)
 * or it can be a function like:
 * (Float,Integer) -> Float
 *
 * first we check for a function like: Integer -> Integer
 */
TypeExpression1 returns TypeExpression hidden(WS):
   =>(t2=TypeArguments KW_RARROW t3=TypeResult)
   | TypePrimaryExpression1
;

/*
 * This is the same as TypeExpression except it does not allow
 * the type to be extended by using a 'with' keyword. It is used
 * in the 'where' rule because the 'with' in that case has a
 * slightly different syntax.
 */
TypeExpression2 returns TypeExpression hidden(WS):
   =>(t92=TypeArguments KW_RARROW t93=TypeResult)
   | TypePrimaryExpression2
;

/*
 * we use a type parameter list for parameters of category, package or domains
 * Parameter list may be empty '()'.
 * in this case parameters may be just ID or they may be nameID:typeID
 *
 * examples are:
 * ()
 * (String)
 * (s:String)
 * (String,Integer)
 * (s:String,i:Integer)
 */
TypeParameterList hidden(WS):
tyname=KW_OPAREN par=TK_ID?
(KW_COLON par21=TypeExpression1)?
(KW_COMMA par2 += TK_ID (KW_COLON par22+=TypeExpression1)?)* KW_CPAREN;

/*
 * we use type arguments for first part of function type, that is
 * x in x-> y
 * usually this is enclosed in parenthesis
 * (x) in (x)-> y
 * but if x is a single argument (Including Record, Union, etc.) then it does
 * not need to be in parenthesis.
 */
TypeArguments hidden(WS):
  t=TypeLiteral |
  t2=PERCENT |
  t3='Type' |
  // usually, but not always type arguments are in parenthesis, and empty
  // parenthesis are allowed
  b1 ?= KW_OPAREN ((TK_ID KW_COLON)? t4=TypeExpression1)?
               ( KW_COMMA (TK_ID KW_COLON)? t16 +=TypeExpression1)* KW_CPAREN |
  t5='Record' KW_OPAREN t6=TypeExpression1
               (KW_COLON t22+=TypeExpression1)?
               (KW_COMMA t21+=TypeExpression1 (KW_COLON t23+=TypeExpression1)?)*
                KW_CPAREN |
  t9='Union' KW_OPAREN t10=TypeExpression1
              (KW_COLON t25+=TypeExpression1)?
              (KW_COMMA t24+=TypeExpression1 (KW_COLON t26+=TypeExpression1)?)*
              KW_CPAREN |
  t11='Join' KW_OPAREN t12=TypeExpression1 (KW_COMMA t13+=TypeExpression1)* KW_CPAREN |
  t15=TypeNameOrFunctionCall
;

/*
 * we use type arguments for final part of function type, that is
 * y in x-> y
 */
TypeResult hidden(WS):
  t=TypeLiteral |
  t2=PERCENT |
  tyname='Type' |
  tyname='Record' KW_OPAREN t7=TypeExpression1
               (KW_COLON t8+=TypeExpression1)?
               (KW_COMMA t21+=TypeExpression1 (KW_COLON t23+=TypeExpression1)?)*
                KW_CPAREN |
  tyname='Union' KW_OPAREN t10=TypeExpression1
              (KW_COLON t11+=TypeExpression1)?
              (KW_COMMA t24+=TypeExpression1 (KW_COLON t26+=TypeExpression1)?)*
              KW_CPAREN |
  tyname='Join' KW_OPAREN t12=TypeExpression1 (KW_COMMA t13+=TypeExpression1)* KW_CPAREN |
  t15=TypeNameOrFunctionCall
;

/*
 * this matches various specific types
 */
TypePrimaryExpression1 returns TypePrimaryExpression hidden(WS):
 TypeLiteral
 | ({TypePrimaryExpression}t32=PERCENT)
 | ({TypePrimaryExpression}tyname='Type') // 'Type' is top of the category hierarchy
 | ({TypePrimaryExpression}tyname='Lisp') // 'Lisp' is used for native lisp function calls such as Say$Lisp
 | ({TypePrimaryExpression}KW_OPAREN t5=TypeExpression1 KW_CPAREN)
 | ({TypePrimaryExpression}tyname='Record' KW_OPAREN t7=TypeExpression1
               (KW_COLON t8+=TypeExpression1)?
               (KW_COMMA t21+=TypeExpression1 (KW_COLON t23+=TypeExpression1)?)*
                KW_CPAREN)
 | ({TypePrimaryExpression}tyname='Union' KW_OPAREN t10=TypeExpression1
              (KW_COLON t11+=TypeExpression1)?
              (KW_COMMA t24+=TypeExpression1 (KW_COLON t26+=TypeExpression1)?)*
              KW_CPAREN)
 | ({TypePrimaryExpression}tyname='Join'
    KW_OPAREN t13=TypeExpression1 (KW_COMMA t14+=TypeExpression1)* KW_CPAREN)
 | TypeNameOrFunctionCall
 | => TupleDefinition
;

/*
 * This is the same as TypePrimaryExpression except it does not allow
 * the type to be extended by using a 'with' keyword. It is used
 * in the 'where' rule because the 'with' in that case has a
 * slightly different syntax.
 */
TypePrimaryExpression2 returns TypePrimaryExpression hidden(WS):
 TypeLiteral
 | ({TypePrimaryExpression}t32=PERCENT)
 | ({TypePrimaryExpression}tyname='Type') // 'Type' is top of the category hierarchy
 | ({TypePrimaryExpression}tyname='Lisp') // 'Lisp' is used for native lisp function calls such as Say$Lisp
 | ({TypePrimaryExpression}KW_OPAREN t5=TypeExpression1 KW_CPAREN)
 | ({TypePrimaryExpression}tyname='Record' KW_OPAREN t7=TypeExpression1
               (KW_COLON t8+=TypeExpression1)?
               (KW_COMMA t21+=TypeExpression1 (KW_COLON t23+=TypeExpression1)?)*
                KW_CPAREN)
 | ({TypePrimaryExpression}tyname='Union' KW_OPAREN t10=TypeExpression1
              (KW_COLON t11+=TypeExpression1)?
              (KW_COMMA t24+=TypeExpression1 (KW_COLON t26+=TypeExpression1)?)*
              KW_CPAREN)
 | ({TypePrimaryExpression}tyname='Join'
    KW_OPAREN t13=TypeExpression1 (KW_COMMA t14+=TypeExpression1)* KW_CPAREN)
 | TypeNameOrFunctionCall2
 | => TupleDefinition
;

/* This rule will match:
 * Float - an ID representation of a type
 * List(Float) - a type function call
 * List Float - a non-parenthesis form if only one parameter
 *
 * A type function is also known as a parameterised type or
 * functor (not necessarily a true
 * functor since it may not obey the axioms of a functor).
 * If there is only one parameter then the parenthesis are optional
 */
TypeNameOrFunctionCall hidden(WS):
  tfnname=TK_ID
  (
    (KW_OPAREN (TK_ID KW_COLON)? t4=TypeExpression1? (KW_COMMA (TK_ID KW_COLON)? t25+=TypeExpression1)* KW_CPAREN)
    // optional curried function:
    (KW_OPAREN t44+=StatementExpression? (KW_COMMA t45+=Expression)* KW_CPAREN)*
    // option of no parenthesis for single parameter
    | => t6=TypePrimaryExpression1
    | => w=WithInline
  )?
;

TypeNameOrFunctionCall2 hidden(WS):
  tfnname=TK_ID
  (
    (KW_OPAREN (TK_ID KW_COLON)? t4=TypeExpression1? (KW_COMMA (TK_ID KW_COLON)? t25+=TypeExpression1)* KW_CPAREN)
    // optional curried function:
    (KW_OPAREN t44+=StatementExpression? (KW_COMMA t45+=Expression)* KW_CPAREN)*
    // option of no parenthesis for single parameter
    | => t6=TypePrimaryExpression1
  )?
;

/* This has a form like: (Integer,Float,String)
 * like an array where each entry can be of a different type
 */
TupleDefinition hidden(WS):
  (KW_OPAREN t4=TypeExpression1 (KW_COMMA t25+=TypeExpression1)* KW_CPAREN)
;

/* Since SPAD supports dependent types then numbers and strings can occur here.
 * Outstanding issues:
 * 1) Float literals are parsed as elt(Int,Int) so we need to recognise this
 * and convert to float literal
 * 2) We need to be able to recognise exponent notation for floats
 * 3) Integers without '-' prefix can be converted to PI or NNI
 * 4) need to add hex or octal notation for integers (0xhhhh)
 * 5) String and Character literals need to have backslash "\" doubled to
 * "\\" otherwise xtext will interpret backslash as an escape character.
 * 6) values following immediately after string literal such as "abc"d should
 * represent an implied concat: concat("abc",d)
 */
TypeLiteral hidden(WS):
  t1=TK_INT |
  t22=TK_STRING |
// t3=FloatLiteral |
  t34=CharacterLiteral |
  t35=BooleanLiteral
;

/* In FunctionDefinition the algorithm is defined by a sequence of the
 * following statements:
 */
Statement hidden(WS,TK_COMMENT):
    s1=Block |
    s3= StatementExpression |
    // 'if' can occur in an expression or in
    // a statement so we use '=>' to choose
    // expression if there is any ambiguity
    s4=IfStatement |
    s4b=IfElseStatement |
// s4c=IfThenStatement |
    s5=WhileStatement |
    s6=DoStatement |
    s7=ForStatement |
    s8=BreakStatement |
    s12=RepeatStatement |
    s9= IterateStatement |
// s11= ContinueStatement|
    s10= ReturnStatement |
// s11= Import |
    'error' e=Expression
;

/* allows multiple statements which are grouped by wrapping in
 * braces (curly brackets) */
Block hidden(WS,TK_COMMENT):
stname=KW_OCURLY KW_NEWLINE*
    (statemBl += Statement (KW_NEWLINE|KW_SEMICOLON)+)*
    KW_CCURLY
;

/*
 * Gives a value or assigns a value to a variable or does conditional exit
 *
 * examples:
 * x
 * x:Int
 * x,y:INT -- multiple assignment
 * x:Int := 3
 *
 * x=y => 3
 */
StatementExpression hidden(WS,TK_COMMENT):
  //(ID COMMA)* // allow multiple assignment
  t=ConditionExpression // was Expression but changed so that 'if' statement
                        // does not clash with if-then-else expression
// (COLON t2=TypeExpression)?
// (BECOMES t3=Expression (BECOMES t33+=Expression)*)?
    (KW_ASSIGN t5=Block)?
    // breaks out of a block if predicate before '=>' is true then program
    // control leaves the block.
    // Put it here so that it can only occur at the top level of an expression.
    // if inside some complicated expression then it must be terminated with ';'.
    (KW_IMPLIES t4=Statement)?
;

/*
 * for i in n..m repeat ... is 1
 * for i in n..m by s repeat ...
 * for i in list repeat ...
 * for i in list for i in 1..length() repeat ...
 * for i in list for i in 1.. repeat ...
 * for j in n..m repeat loopBody
 * for j in n..m | odd? j repeat
 *
 * To Do
 * -----
 * As a temporary measure we check for '..' as a suffix operator
 * here, but we should really put this into expression?
 *
 * We need to allow conditions using BAR '|'
 */
ForStatement hidden(WS,TK_COMMENT):
'for' (
       stname=TK_ID 'in' t1=Expression KW_2DOT? //(=> '..' t2=Expression)?
       ('by' by1=Expression)?
// (=> BAR t2=PredicateOr)? // condition
       ('for' stname2+=TK_ID
        'in' t2+=Expression KW_2DOT?
        ('by' by2+=Expression)?
        )*
       ('while' t2+=Expression)*
) 'repeat' KW_NEWLINE? s1=Statement //('is' s2=Statement)?
;

/*
 * while BoolExpr repeat loopBody
 */
WhileStatement hidden(WS,TK_COMMENT):
stname='while' (
       t2=Expression /*PredicateOr*/
) 'repeat' KW_NEWLINE? s1=Statement
;

/*
 * do loopBody while BoolExpr
 */
DoStatement hidden(WS,TK_COMMENT):
stname='do' (
       s1=Statement
) 'while' KW_NEWLINE? t2=Expression /*PredicateOr*/
;

/*
 * will repeat until we jump out. For instance by calling return.
 */
RepeatStatement hidden(WS,TK_COMMENT):
stname='repeat' (
       s1=Statement
)
;

/*
 * iterate ...
 * skips over the remainder of a loop
 */
IterateStatement hidden(WS,TK_COMMENT):
stname='iterate'
;

/*
 * break leave current loop
 */
BreakStatement hidden(WS,TK_COMMENT):
stname='break'
;

/*
 * return leave current function
 */
ReturnStatement hidden(WS):
stname='return' t2=Expression
;

/*
 * import - use 'Import' instead
 */
//ImportStatement hidden(WS):
// stname='import' t2=Expression
//;

/* 'if' statement allows program flow to be switched
 * forms:
 * if boolean then
 * if equation then
 * if ... not ... and ...or ... then
 * if ... then ... else ...
 * note1:
 * if ... then ... else ... always returns a value so we can use this
 * on the right hand side of an assignment
 * note2:
 * since there is an explicit 'then' keyword there is no need to put
 * the condition in brackets
 *
 * examples:
 * a:= if x >0 then x else -x
 * if R has Field then ...
 * if myUnion case mtType then ...
 *
 * we also need to allow a form like this:
 * if x >0 {
 * then x
 * else -x
 * }
 *
 * also this form (this requires IfElseStatement rule):
 * if x >0 then {
 * x
 * }
 * else {
 * -x
 * }
 */
IfStatement hidden(WS,TK_COMMENT):
  'if' t2=Expression
// 'if' t2=ConditionExpression
  (
    'then' s1=Statement
    (=> 'else' s2=Statement)?
   |
    b?=KW_OCURLY
    KW_NEWLINE+ 'then' s11=Statement KW_NEWLINE*
    (=>'else' s12=Statement KW_NEWLINE*)?
    KW_CCURLY
  )
;

IfElseStatement hidden(WS,TK_COMMENT):
'else' s2=Statement
;

///////////// Expression syntax follows //////////////

/* This is the top level for expressions
 *
 * This level handles special cases such as:
 * if x then y else z
 * (x,y) +-> z
 *
 * We can consider expressions as elements of statements
 * expressions contain no newlines unless preceded by underscore
 * (which is handled by WS)
 */
Expression returns Expr hidden(WS,TK_COMMENT):
  (ifname='if' ifpred=Expression 'then' thenexp=Expression 'else' elseexp=Expression)
// | LPAREN t24=ConditionExpression (COMMA t25+=ConditionExpression)+ RPAREN (COLON rightType2 =TypeExpression)? GIVES ConditionExpression
  | ExitExpression
;

/*
 * condition '=>' expr1 ';' expr2
 */
ExitExpression returns Expr hidden(WS,TK_COMMENT):
  ConditionExpression
  ({ExitExpression.left=current} op=KW_IMPLIES right = ConditionExpression KW_SEMICOLON r2=ConditionExpression)*
;

/*
 * BAR "|" precedence: 108, 111
 */
ConditionExpression returns Expr hidden(WS,TK_COMMENT):
  OrExpression
  ({ConditionExpression.left=current} op=KW_BAR right = OrExpression )*
;

/*
 * COMMA"," precedence: 110, 111
 */
//CommaExpression returns Expr hidden(WS,TK_COMMENT):
// ConditionalAndExpression
// ({ConditionExpression.left=current} op=BAR right = ConditionalAndExpression )*
//;

/*
 * There is also another rule that looks for 'or' which is PredicateOr,
 * this version is used in a general expression and the other version is
 * used when we know we have a predicate.
 * "or", precedence: 200, 201
 */
OrExpression returns Expr hidden(WS,TK_COMMENT):
  AndExpression
  ( {OrExpression.left=current} op='or' right = AndExpression)*
;

/*
 * There is also another rule that looks for 'and' which is PredicateAnd,
 * this version is used in a general expression and the other version is
 * used when we know we have a predicate.
 * "and", precedence: 250, 251
 */
AndExpression returns Expr hidden(WS,TK_COMMENT):
  InnerProdExpression
  ( {AndExpression.left=current} op='and' right = InnerProdExpression)*
;

/*
 * This has multiple uses such as inner product and logical or.
 *
 * "\/", BACKSLASHSLASH precedence: 200, 201
 *
 * the backslash is duplicated here because it is the escape character for
 * strings, it will not be duplicated when used.
 */
InnerProdExpression returns Expr hidden(WS,TK_COMMENT):
  OuterProdExpression
  ( {InnerProdExpression.left=current} op=KW_VEE right = OuterProdExpression)*
;

/*
 * This has multiple uses such as outer product and logical and.
 *
 * "/\", SLASHBACKSLASH precedence: 250, 251
 *
 * the backslash is duplicated here because it is the escape character for
 * strings, it will not be duplicated when used.
 */
OuterProdExpression returns Expr hidden(WS,TK_COMMENT):
  HasExpression
  ( {OuterProdExpression.left=current} op=KW_WEDGE right = HasExpression)*
;

/* Predicate which returns true if preceding value is of a given type
 * example:
 * if R has Field then ..
 *
 * "has", precedence: 400, 400
 */
HasExpression returns Expr hidden(WS,TK_COMMENT):
  CaseExpression
  ({HasExpression.left=current} op='has' rightType = TypeExpression1)*
;

/* Select from Union values
 * example:
 * if myUnion case mtType then ...
 *
 * "case", precedence: 400, 400
 */
CaseExpression returns Expr hidden(WS,TK_COMMENT):
  EqualityExpression
  ( {CaseExpression.left=current} op='case' right = EqualityExpression)?
;

/* used in list comprehension
 *
 * "in", precedence: 400, 400
 */
/*InExpression returns Expr hidden(WS,TK_COMMENT):
  RelationalExpression
  ( {CaseExpression.left=current} op='in' right = RelationalExpression)?
;*/

/*
 * "~=", precedence: 400, 400
 * "^=", precedence: 400, 400
 * "=", precedence: 400, 400
 */
EqualityExpression returns Expr hidden(WS,TK_COMMENT):
  RelationalExpression
// ambiguous because EQ can be in top level expression
  ( {EqualityExpression.left=current}
   ( op=KW_EQ | op=KW_TILDEE | op=KW_HATE | (op=EQUALSDOLAR te=TK_ID))
   //(DOLAR te=ID)?
   right = RelationalExpression
  )*
;

/*
 * ">=", precedence: 400, 400
 * "<=", precedence: 400, 400
 * ">>", precedence: 400, 400
 * "<<", precedence: 400, 400
 * ">", precedence: 400, 400
 * "<", precedence: 400, 400
 */
RelationalExpression returns Expr hidden(WS,TK_COMMENT):
  IsExpression
  ( {RelationalExpression.left=current}
   ( op=KW_LT | op=KW_GT | op=KW_LE | op=KW_GE )
      right = IsExpression
  )?
;

/*
 *
 * "isnt", precedence: 400, 400
 * "is", precedence: 400, 400
 */
IsExpression returns Expr hidden(WS,TK_COMMENT):
  SegmentExpression
  ({IsExpression.left=current} (op='is' | op='isnt') rightType = TypeExpression1)*
;

/*
 * this is used to indicate a range:
 * 1..4 means the range from 1 to 4
 * 1.. means the range from 1 to infinity. This is used in cases where
 * no top bounds is necessary, when the end point is determined by other
 * means.
 * "..", "SEGMENT", precedence: 401, 699, ["parse_Seg"]
 */
SegmentExpression returns Expr hidden(WS,TK_COMMENT):
  AdditiveExpression
  ( {SegmentExpression.left=current} op=KW_2DOT right = AdditiveExpression)*
;

/*
 * add expression
 * we include both '+' and '-' in the same case as this allows a
 * multiple sequence like:
 * a + b + c - d + e -f
 *
 * "-", precedence: 700, 701
 * "+", precedence: 700, 701
 */
AdditiveExpression returns Expr hidden(WS,TK_COMMENT):
  ExquoExpression
  ( {AdditiveExpression.left=current}
    ( op=KW_PLUS | op=KW_MINUS | (op=PLUSDOLAR te=TK_ID) | (op=MINUSDOLAR te=TK_ID))
    right = ExquoExpression
  )*
;

/*
 * "exquo", precedence: 800, 801
 */
ExquoExpression returns Expr hidden(WS,TK_COMMENT):
  DivisionExpression
  ({ExquoExpression.left=current} op='exquo' right = DivisionExpression)*
;

/*
 * division expression
 * "/", precedence: 800, 801
 */
DivisionExpression returns Expr hidden(WS,TK_COMMENT):
  QuoExpression
  ( {DivisionExpression.left=current}
   (op=KW_SLASH | (op=DIVDOLAR te=TK_ID))
   right = QuoExpression
  )*
;

/*
 *"quo", precedence: 800, 801
 */
QuoExpression returns Expr hidden(WS,TK_COMMENT):
  ModExpression
  ({QuoExpression.left=current} op='quo' right = ModExpression)*
;

/*
 *"mod", precedence: 800, 801
 */
ModExpression returns Expr hidden(WS,TK_COMMENT):
  RemExpression
  ({ModExpression.left=current} op='mod' right = RemExpression)*
;

/*
 *"rem", precedence: 800, 801
 */
RemExpression returns Expr hidden(WS,TK_COMMENT):
  MultiplicativeExpression
  ({RemExpression.left=current} op='rem' right = MultiplicativeExpression)*
;

/*
 * multiplication expression
 * a * b * c
 *
 * "*", precedence: 800, 801
 */
MultiplicativeExpression returns Expr hidden(WS,TK_COMMENT):
  ExponentExpression
  ( {MultiplicativeExpression.left=current}
    (op=KW_STAR | (op=TIMESDOLAR te=TK_ID))
    right = ExponentExpression
  )*
;

/*
 *
 * "^", precedence: 901, 900
 * "**", precedence: 901, 900
 */
ExponentExpression returns Expr hidden(WS,TK_COMMENT):
  MapDefinition
  ({ExponentExpression.left=current} (op=KW_HAT | op=KW_2STAR) right = MapDefinition)*
;

/* Map or Lambda expression
 * var +-> function
 *
 * +-> is an infix operator meaning 'maps-to'
 * It can be used to create a function literal (an anonymous function), so
 * instead of:
 * myFunct(x:Type):Type == if x >0 then x else -x
 * we can have forms such as:
 * x +-> if x >0 then x else -x
 * or:
 * (x,y) +-> if x >0 then y else -x
 *
 * fricas compatibility:
 * "+->", precedence: 995, 112
 */
MapDefinition returns Expr hidden(WS,TK_COMMENT):
// (PretendExpression | LPAREN PretendExpression (COMMA t25+=PretendExpression)+ RPAREN) (COLON rightType2 =TypeExpression)?
  AssignExpression
  ({MapDefinition.left=current}
   op=KW_MAPSTO right = AssignExpression
   (par = TK_ID)? // optional parameter which function
                             // is applied to
  )*
;

/*
 * an assign expression like this:
 * x := y
 * can also be an inner assign like this:
 * x := (y := z)
 * or just:
 * x := y := z
 *
 * right is expression to allow forms like
 * x := if y<0 then -y else y
 */
AssignExpression returns Expr hidden(WS,TK_COMMENT):
  PretendExpression
  ({AssignExpression.left=current} op=KW_ASSIGN (
   right = PretendExpression
   | ifname='if' ifpred=ConditionExpression 'then' thenexp=ConditionExpression 'else' elseexp=PretendExpression
   )
  )*
;

/*
 * pretend Type: treat one type as another,
 * only works if they have the same internal structure.
 *
 * Not very safe and should be avoided, if possible, unfortunately
 * its not always possible to avoid.
 *
 * "pretend", precedence: 995, 996
 */
 PretendExpression returns Expr hidden(WS,TK_COMMENT):
  CoerceExpression
  ({PretendExpression.left=current} op='pretend' rightType = TypeExpression1)*
;

/*
 * "::", precedence: 996, 997
 *
 * although '::' and '@' apparently have the same precidence we want
 * '@' to bind more tightly than '::'. As we can see in the following example:
 * "dictionary"@String :: OutputForm.
 */
CoerceExpression returns Expr hidden(WS,TK_COMMENT):
  HintTypeExpression
  ({CoerceExpression.left=current} op=KW_2COLON rightType = TypeExpression1)*
;

/*
 * "@", precedence: 996, 997
 */
HintTypeExpression returns Expr hidden(WS,TK_COMMENT):
  EltExpression
  ( {HintTypeExpression.left=current} op=KW_AT rightType = TypeExpression1)?
;

/* We treat these as part of the language
 * : indicates type
 * ! is part of name to indicate mutable
 *
 * ":", precedence: 996, 997
 * "!", precedence: 1002, 1001
 *
 */
/*BangExpression returns Expr hidden(WS,TK_COMMENT):
  EqualityExpression
  ({AndExpression.left=current} op=AMPERSAND right = EqualityExpression)*
;*/

/*
 * "with", precedence: 2000, 400, ["parse_InfixWith"]
 *
 */
/*WithExpression returns Expr hidden(WS,TK_COMMENT):
  EqualityExpression
  ({AndExpression.left=current} op='with' right = EqualityExpression)*
;*/


/* Elt is Lisp terminology for the use of '.' to select parameters
 * the left expression is something that has selectable elements such as
 * a list, array, string, Record or union, the right element should be a
 * non-negative integer.
 */
EltExpression returns Expr hidden(WS,TK_COMMENT):
  ExplicitTypeExpression
  ( {EltExpression.left=current}
   op=KW_DOT right = ExplicitTypeExpression
  )*
;

////////////// unary expressions ////////////////////


/*
 * '$'
 */
ExplicitTypeExpression returns Expr hidden(WS,TK_COMMENT):
  UnaryExpression
  ({ExplicitTypeExpression.left=current} op=KW_DOLAR rightType = TypeExpression1)?
;

/* UnaryExpression
 * unary prefixes:
 * "~" TILDE : precedence 260, 259, nil
 * ":" COLON : precedence 194, 195
 * "-" MINUS : precedence 701, 700
 * "#" HASH : precedence 999, 998
 * "'" : precedence 999, 999, ["parse_Data"]
 * unary suffixes
 * ".." : range can be unary suffix
 */
UnaryExpression returns Expr hidden(WS,TK_COMMENT):
  PrimaryExpression |
  ({UnaryExpression} uop=KW_TILDE expr=UnaryExpression) |
// ({UnaryExpression} uop=COLON expr=UnaryExpression) |
  ({UnaryExpression} uop=KW_MINUS expr=UnaryExpression) |
  ({UnaryExpression} uop=MINUSDOLAR te=TK_ID expr=UnaryExpression) |
  ({UnaryExpression} uop=KW_SHARP expr=UnaryExpression) |
  ({UnaryExpression} uop='not' expr=PrimaryExpression) |
  ({UnaryExpression} uop=SUMLIST expr=PrimaryExpression) |
  ({UnaryExpression} uop=PRIMEPERCENT expr=PrimaryExpression) |
   e2=PERCENT |
  e3='Type' |
  e5='Record' KW_OPAREN e6=TypeExpression1
               (KW_COLON e22+=TypeExpression1)?
               (KW_COMMA e21+=TypeExpression1 (KW_COLON e23+=TypeExpression1)?)*
                KW_CPAREN |
  e9='Union' KW_OPAREN e10=TypeExpression1
              (KW_COLON e25+=TypeExpression1)?
              (KW_COMMA e24+=TypeExpression1 (KW_COLON e26+=TypeExpression1)?)*
              KW_CPAREN |
  e11='Join' KW_OPAREN e12=TypeExpression1 (KW_COMMA e13+=TypeExpression1)* KW_CPAREN
;

/*
 *
 */
/*UnaryExpressionHash returns Expr hidden(WS,TK_COMMENT):
// HASH? PrimaryExpression
  PrimaryExpression | ({UnaryExpressionHash} uop=HASH expr=UnaryExpressionHash)
;*/

/*
 *
 */
PrimaryExpression returns Expr hidden(WS,TK_COMMENT):
  PrimaryPrefix /* ( t2+=PrimarySuffix )* */
;

/*
 * Can contain an expression in parenthesis, this expression is
 * 'StatementExpression' which means that it can contain an
 * inner assignment.
 *
 * The comma option allows us to define a tuple
 */
PrimaryPrefix hidden(WS,TK_COMMENT):
 Literal
 | KW_OPAREN t4=Expression (KW_COMMA t25+=Expression)* KW_CPAREN =>(KW_COLON rightType3 =TypeExpression1)?
 | t7=NameOrFunctionCall
;

/* function call such as List(Integer)
 * known as a parameterised type or functor (not necessarily a true functor since
 * it may not obey the axioms of a functor)
 * if there is only one parameter then the parenthesis are optional
 *
 * function binds most tightly
 */
NameOrFunctionCall hidden(WS,TK_COMMENT):
  ("'")?
  fnname=TK_ID (=> lsp=KW_DOLAR 'Lisp'/*t2=TypeExpression*/)?
  // option for parameters in parenthesis
  (
// LPAREN t4=StatementExpression? (COMMA t5+=Expression)* RPAREN //(COLON rightType2 =TypeExpression)?
    KW_OPAREN t4=Expression? (KW_COMMA t5+=Expression)* KW_CPAREN //(COLON rightType2 =TypeExpression)?
    // optional curried function:
    (KW_OPAREN t14+=Statement? (KW_COMMA t15+=Expression)* KW_CPAREN)*
    // option of no parenthesis for single parameter
    | => t6=PrimaryExpression
  )?
  => ((KW_COMMA TK_ID)* KW_COLON rightType2 =TypeExpression1)?
  // allow multiple assignment
  //=>(op=GIVES lambda = Expression 'xxx')?
;

/* Literals are actual values of a given type
 * Outstanding issues:
 * 1) Float literals are parsed as elt(Int,Int) so we need to recognise this
 * and convert to float literal
 * 2) We need to be able to recognise exponent notation for floats
 * 3) Integers without '-' prefix can be converted to PI or NNI
 * 4) need to add hex or octal notation for integers (0xhhhh)
 * 5) String and Character literals need to have backslash "\" doubled to
 * "\\" otherwise xtext will interpret backslash as an escape character.
 * 6) values following immediately after string literal such as "abc"d should
 * represent an implied concat: concat("abc",d)
 */
Literal hidden(WS,TK_COMMENT):
  value=TK_INT
  | t2=TK_STRING (=> e1=NameOrFunctionCall =>(t31+=TK_STRING (=> e4+=NameOrFunctionCall)?)*)?
// | t3=FloatLiteral // conflicts with use of '.' for elt
  | ListLiteral
  | CharacterLiteral
  | BooleanLiteral
;

/* Contains a single character whereas a string contains multiple
 * characters.
 */
CharacterLiteral hidden(WS,TK_COMMENT):
 "'" c1=ANY_OTHER "'"
;

/* This may not need to be specified here at the syntax level. Perhaps we
* should treat boolean as any other library defined type.
*/
BooleanLiteral hidden(WS,TK_COMMENT):
 litname = 'true' | litname = 'false'
 | litname = 'true' KW_OPAREN KW_CPAREN
 | litname = 'false' KW_OPAREN KW_CPAREN
;

/*
 * a list literal may consist of:
 * [] an empty list
 * [a] a single element
 * [a,b] multiple elements
 * [a for b in c] a list comprehension
 */
ListLiteral hidden(WS,TK_COMMENT):
 litname = KW_OBRACK l2=Expression?
     (KW_COMMA t3+=Expression)*
     ('for' t14+=Expression 'in' l5+=Expression)?
     KW_CBRACK
;