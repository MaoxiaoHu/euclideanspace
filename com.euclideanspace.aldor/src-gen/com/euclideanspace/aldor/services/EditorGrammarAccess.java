/*
* generated by Xtext
*/
package com.euclideanspace.aldor.services;

import com.google.inject.Singleton;
import com.google.inject.Inject;

import java.util.List;

import org.eclipse.xtext.*;
import org.eclipse.xtext.service.GrammarProvider;
import org.eclipse.xtext.service.AbstractElementFinder.*;


@Singleton
public class EditorGrammarAccess extends AbstractGrammarElementFinder {
	
	
	public class ModelElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Model");
		private final RuleCall cCurlyContents_LabeledParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		/// * Copyright 2014 Martin John Baker
		// *
		// * This file is part of EuclideanSpace.
		// *
		// * EuclideanSpace is free software: you can redistribute it and/or modify
		// * it under the terms of the GNU Affero General Public License as published by
		// * the Free Software Foundation, either version 3 of the License, or
		// * (at your option) any later version.
		// *
		// * EuclideanSpace is distributed in the hope that it will be useful,
		// * but WITHOUT ANY WARRANTY; without even the implied warranty of
		// * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
		// * GNU Affero General Public License for more details.
		// *
		// * You should have received a copy of the GNU Affero General Public License
		// * along with EuclideanSpace. If not, see <http://www.gnu.org/licenses/>.
		// * / / *
		// *
		// * Here we are using a LL(*) recursive-descent parser generator and this
		// * may not be able to exactly replicate axl.z which is a
		// * LALR(1) conflict-free grammar for Aldor.
		// * / / * from tokInfoTable[] in token.c: Lexical elements.
		// * The TokenTag enumeration must use this order.
		// *
		// * This table MUST be laid out so that all "symbol" tokens starting with
		// * the same character are contiguous.
		// *
		// * Be extra careful with fields F, G, H and K: if you get them wrong then
		// * the lineariser will delete end-of-statement tokens when it ought not
		// * to. This can lead to odd compiler behaviour that is hard to track down
		// * unless you know about this table.
		// *
		// * struct tok_info tokInfoTable[] = {
		// *
		// * [A] TokenTag tag
		// * [B] Symbol sym
		// * [C] String str
		// * [D] Byte hasString i.e. use val.str (vs val.sym)
		// * [E] Byte isComment i.e. ++ --
		// * [F] Byte isOpener i.e. ( [ { etc
		// * [G] Byte isCloser i.e. ) ] } etc
		// * [H] Byte isFollower i.e. then else always in etc
		// * [I] Byte isLangword i.e. if then etc
		// * [J] Byte isLeftAssoc i.e., associates left to right
		// * [K] Byte isMaybeInfix i.e., add, with, +
		// * [L] Byte precedence i.e., 0 is lowest, or don't know
		// * [M] Byte isDisabled i.e., non-zero means disabled
		// *
		// * [A] [B][C] [D][E] [F] [G] [H] [I] [J] [K] [L] [M]
		// *
		//        {TK_Blank, 0,"TK_Blank", 0, 0, 0, 0, 0, 0, 1, 0, 170, 0},
		//        {TK_FLOAT, 0,"TK_FLOAT", 1, 0, 0, 0, 0, 0, 1, 0, 170, 0},
		//        {TK_SysCmd, 0,"TK_SysCmd", 1, 1, 0, 0, 0, 0, 1, 0, 170, 0},
		//        {TK_Error, 0,"TK_Error", 1, 0, 0, 0, 0, 0, 1, 0, 0, 0},
		//
		//        {KW_Add, 0,"add", 0, 0, 0, 0, 0, 1, 1, 0, 0, 0},
		//        {KW_And, 0,"and", 0, 0, 0, 0, 1, 1, 1, 1, 40, 0},
		//        {KW_Always, 0,"always", 0, 0, 0, 0, 1, 1, 1, 1, 0, 0},
		//        {KW_Assert, 0,"assert", 0, 0, 0, 0, 0, 1, 1, 0, 0, 0},
		//        {KW_Break, 0,"break", 0, 0, 0, 0, 0, 1, 1, 0, 0, 0},
		//        {KW_But, 0,"but", 0, 0, 0, 0, 1, 1, 1, 1, 0, 0},
		//        {KW_By, 0,"by", 0, 0, 0, 0, 0, 0, 1, 1, 110, 0},
		//        {KW_CASE, 0,"case", 0, 0, 0, 0, 0, 0, 1, 1, 0, 0},
		//        {KW_Catch, 0,"catch", 0, 0, 0, 0, 1, 1, 1, 1, 0, 0},
		//        {KW_Default, 0,"default", 0, 0, 0, 0, 0, 1, 1, 0, 0, 0},
		//        {KW_Define, 0,"define", 0, 0, 0, 0, 0, 1, 1, 0, 0, 0},
		//        {KW_Delay, 0,"delay", 0, 0, 0, 0, 0, 1, 1, 0, 0, 0},
		//        {KW_Do, 0,"do", 0, 0, 0, 0, 0, 1, 1, 0, 0, 0},
		//        {KW_Else, 0,"else", 0, 0, 0, 0, 1, 1, 1, 0, 0, 0},
		//        {KW_Except, 0,"except", 0, 0, 0, 0, 0, 1, 1, 1, 0, 0},
		//        {KW_Export, 0,"export", 0, 0, 0, 0, 0, 1, 1, 0, 0, 0},
		//        {KW_Exquo, 0,"exquo", 0, 0, 0, 0, 0, 0, 1, 1, 125, 0},
		//        {KW_Extend, 0,"extend", 0, 0, 0, 0, 0, 1, 1, 0, 0, 0},
		//        {KW_Finally, 0,"finally", 0, 0, 0, 0, 1, 1, 1, 1, 0, 0},
		//        {KW_Fix, 0,"fix", 0, 0, 0, 0, 0, 1, 1, 0, 0, 0},
		//        {KW_For, 0,"for", 0, 0, 0, 0, 0, 1, 1, 0, 0, 0},
		//        {KW_Fluid, 0,"fluid", 0, 0, 0, 0, 0, 1, 1, 0, 0, 0},
		//        {KW_Free, 0,"free", 0, 0, 0, 0, 0, 1, 1, 0, 0, 0},
		//        {KW_From, 0,"from", 0, 0, 0, 0, 1, 1, 1, 0, 0, 0},
		//        {KW_Generate, 0,"generate", 0, 0, 0, 0, 0, 1, 1, 0, 0, 0},
		//        {KW_Goto, 0,"goto", 0, 0, 0, 0, 0, 1, 1, 0, 0, 0},
		//        {KW_Has, 0,"has", 0, 0, 0, 0, 0, 0, 1, 1, 40, 0},
		//        {KW_If, 0,"if", 0, 0, 0, 0, 0, 1, 1, 0, 0, 0},
		//        {KW_Import, 0,"import", 0, 0, 0, 0, 0, 1, 1, 0, 0, 0},
		//        {KW_In, 0,"in", 0, 0, 0, 0, 1, 1, 1, 1, 0, 0},
		//        {KW_Inline, 0,"inline", 0, 0, 0, 0, 0, 1, 1, 0, 0, 0},
		//        {KW_IS, 0,"is", 0, 0, 0, 0, 0, 1, 1, 0, 0, 0},
		//        {KW_ISNT, 0,"isnt", 0, 0, 0, 0, 0, 1, 1, 0, 0, 0},
		//        {KW_Iterate, 0,"iterate", 0, 0, 0, 0, 0, 1, 1, 0, 0, 0},
		//        {KW_Let, 0,"let", 0, 0, 0, 0, 0, 1, 1, 0, 0, 0},
		//        {KW_Local, 0,"local", 0, 0, 0, 0, 0, 1, 1, 0, 0, 0},
		//        {KW_Macro, 0,"macro", 0, 0, 0, 0, 0, 1, 1, 0, 0, 0},
		//        {KW_Mod, 0,"mod", 0, 0, 0, 0, 0, 0, 1, 1, 125, 0},
		//        {KW_Never, 0,"never", 0, 0, 0, 0, 0, 1, 1, 0, 0, 0},
		//        {KW_Not, 0,"not", 0, 0, 0, 0, 0, 1, 1, 1, 150, 0},
		//        {KW_Of, 0,"of", 0, 0, 0, 0, 1, 1, 1, 1, 40, 0},
		//        {KW_Or, 0,"or", 0, 0, 0, 0, 1, 1, 1, 1, 40, 0},
		//        {KW_Pretend, 0,"pretend", 0, 0, 0, 0, 1, 1, 1, 1, 150, 0},
		//        {KW_Quo, 0,"quo", 0, 0, 0, 0, 0, 0, 1, 1, 125, 0},
		//        {KW_Reference, 0,"ref", 0, 0, 0, 0, 0, 1, 1, 0, 0, 0},
		//        {KW_Rem, 0,"rem", 0, 0, 0, 0, 0, 0, 1, 1, 125, 0},
		//        {KW_Repeat, 0,"repeat", 0, 0, 0, 0, 0, 1, 1, 0, 0, 0},
		//        {KW_Return, 0,"return", 0, 0, 0, 0, 0, 1, 1, 0, 0, 0},
		//        {KW_Rule, 0,"rule", 0, 0, 0, 0, 0, 1, 1, 0, 0, 0},
		//        {KW_Select, 0,"select", 0, 0, 0, 0, 0, 1, 1, 0, 0, 0},
		//        {KW_Then, 0,"then", 0, 0, 0, 0, 1, 1, 1, 0, 0, 0},
		//        {KW_Throw, 0,"throw", 0, 0, 0, 0, 0, 1, 1, 1, 0, 0},
		//        {KW_To, 0,"to", 0, 0, 0, 0, 1, 1, 1, 0, 0, 0},
		//        {KW_Try, 0,"try", 0, 0, 0, 0, 0, 1, 1, 0, 0, 0},
		//        {KW_Where, 0,"where", 0, 0, 0, 0, 1, 1, 1, 0, 0, 0},
		//        {KW_While, 0,"while", 0, 0, 0, 0, 0, 1, 1, 0, 0, 0},
		//        {KW_With, 0,"with", 0, 0, 0, 0, 0, 1, 1, 0, 0, 0},
		//        {KW_Yield, 0,"yield", 0, 0, 0, 0, 0, 1, 1, 0, 0, 0},
		//
		//        {KW_Grave, 0,"`", 0, 0, 0, 0, 0, 0, 1, 0, 0, 0},
		//        
		//
		//        {KW_LARROW, 0,"<-", 0, 0, 0, 0, 0, 0, 1, 1, 0, 0},
		//
		//
		//
		//        {KW_STARtPile, 0,"#pile", 0, 0, 0, 0, 0, 0, 1, 0, 0, 0},
		//        {KW_EndPile, 0,"#endpile", 0, 0, 0, 0, 0, 0, 1, 0, 0, 0},
		//        {KW_SetTab, 0,"KW_SetTab", 0, 0, 0, 0, 0, 0, 1, 0, 0, 0},
		//        {KW_BackSet, 0,"KW_BackSet", 0, 0, 0, 0, 0, 0, 1, 0, 0, 0},
		//        {KW_BackTab, 0,"KW_BackTab", 0, 0, 0, 0, 0, 0, 1, 0, 0, 0},
		//        {KW_Juxtapose, 0,"KW_Juxtapose",0, 0, 0, 0, 0, 0, 0, 0, 170, 0},
		//
		//        {TK_LIMIT, 0,"TK_LIMIT", 0, 0, 0, 0, 0, 0, 1, 0, 0, 0}
		//};
		// * / / *
		// * replaces Goal rule in Aldor grammar
		// * Parser starts here
		// * CategoryDef,PackageDef and DomainDef must end with newline to ensure that
		// * only an '@' at the start of a line will be taken as the end.
		// *
		// * On this line whitespace (WS) is not hidden so is explicitly included.
		// * / Model:
		//	CurlyContents_Labeled;
		public ParserRule getRule() { return rule; }

		//CurlyContents_Labeled
		public RuleCall getCurlyContents_LabeledParserRuleCall() { return cCurlyContents_LabeledParserRuleCall; }
	}

	public class ErrorElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "error");
		private final Keyword cErrorKeyword = (Keyword)rule.eContents().get(1);
		
		//////////// end of lexer rules ///////////////
		/// * error seems to be defined externally in Aldor grammar
		// * so I have added this rule so it will compile
		// * / error:
		//	"error";
		public ParserRule getRule() { return rule; }

		//"error"
		public Keyword getErrorKeyword() { return cErrorKeyword; }
	}

	public class ExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Expression");
		private final RuleCall cEnlist1a_Labeled_Semicolon_ABParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//Expression:
		//	enlist1a_Labeled_Semicolon_AB;
		public ParserRule getRule() { return rule; }

		//enlist1a_Labeled_Semicolon_AB
		public RuleCall getEnlist1a_Labeled_Semicolon_ABParserRuleCall() { return cEnlist1a_Labeled_Semicolon_ABParserRuleCall; }
	}

	public class LabeledElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Labeled");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cCommaParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cDeclarationParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final Group cGroup_2 = (Group)cAlternatives.eContents().get(2);
		private final RuleCall cKW_ATTerminalRuleCall_2_0 = (RuleCall)cGroup_2.eContents().get(0);
		private final RuleCall cAtomParserRuleCall_2_1 = (RuleCall)cGroup_2.eContents().get(1);
		private final Assignment cLabAssignment_2_2 = (Assignment)cGroup_2.eContents().get(2);
		private final RuleCall cLabLabeledParserRuleCall_2_2_0 = (RuleCall)cLabAssignment_2_2.eContents().get(0);
		
		/// * An '.as' file is effectivly a list of 'Labeled' 
		// * by semicolons* / Labeled hidden(WS, KW_NEWLINE):
		//	Comma | Declaration | KW_AT Atom lab=Labeled?;
		public ParserRule getRule() { return rule; }

		//Comma | Declaration | KW_AT Atom lab=Labeled?
		public Alternatives getAlternatives() { return cAlternatives; }

		//Comma
		public RuleCall getCommaParserRuleCall_0() { return cCommaParserRuleCall_0; }

		//Declaration
		public RuleCall getDeclarationParserRuleCall_1() { return cDeclarationParserRuleCall_1; }

		//KW_AT Atom lab=Labeled?
		public Group getGroup_2() { return cGroup_2; }

		//KW_AT
		public RuleCall getKW_ATTerminalRuleCall_2_0() { return cKW_ATTerminalRuleCall_2_0; }

		//Atom
		public RuleCall getAtomParserRuleCall_2_1() { return cAtomParserRuleCall_2_1; }

		//lab=Labeled?
		public Assignment getLabAssignment_2_2() { return cLabAssignment_2_2; }

		//Labeled
		public RuleCall getLabLabeledParserRuleCall_2_2_0() { return cLabLabeledParserRuleCall_2_2_0; }
	}

	public class DeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Declaration");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Keyword cMacroKeyword_0_0 = (Keyword)cGroup_0.eContents().get(0);
		private final RuleCall cMacroBodyParserRuleCall_0_1 = (RuleCall)cGroup_0.eContents().get(1);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Keyword cExtendKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final RuleCall cSigParserRuleCall_1_1 = (RuleCall)cGroup_1.eContents().get(1);
		private final Group cGroup_2 = (Group)cAlternatives.eContents().get(2);
		private final Keyword cLocalKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final RuleCall cSigParserRuleCall_2_1 = (RuleCall)cGroup_2.eContents().get(1);
		private final Group cGroup_3 = (Group)cAlternatives.eContents().get(3);
		private final Keyword cFreeKeyword_3_0 = (Keyword)cGroup_3.eContents().get(0);
		private final RuleCall cSigParserRuleCall_3_1 = (RuleCall)cGroup_3.eContents().get(1);
		private final Group cGroup_4 = (Group)cAlternatives.eContents().get(4);
		private final Keyword cFluidKeyword_4_0 = (Keyword)cGroup_4.eContents().get(0);
		private final RuleCall cSigParserRuleCall_4_1 = (RuleCall)cGroup_4.eContents().get(1);
		private final Group cGroup_5 = (Group)cAlternatives.eContents().get(5);
		private final Keyword cDefaultKeyword_5_0 = (Keyword)cGroup_5.eContents().get(0);
		private final RuleCall cSigParserRuleCall_5_1 = (RuleCall)cGroup_5.eContents().get(1);
		private final Group cGroup_6 = (Group)cAlternatives.eContents().get(6);
		private final Keyword cDefineKeyword_6_0 = (Keyword)cGroup_6.eContents().get(0);
		private final RuleCall cSigParserRuleCall_6_1 = (RuleCall)cGroup_6.eContents().get(1);
		private final Group cGroup_7 = (Group)cAlternatives.eContents().get(7);
		private final Keyword cFixKeyword_7_0 = (Keyword)cGroup_7.eContents().get(0);
		private final RuleCall cSigParserRuleCall_7_1 = (RuleCall)cGroup_7.eContents().get(1);
		private final Group cGroup_8 = (Group)cAlternatives.eContents().get(8);
		private final Keyword cInlineKeyword_8_0 = (Keyword)cGroup_8.eContents().get(0);
		private final RuleCall cSigParserRuleCall_8_1 = (RuleCall)cGroup_8.eContents().get(1);
		private final Assignment cFpAssignment_8_2 = (Assignment)cGroup_8.eContents().get(2);
		private final RuleCall cFpFromPartParserRuleCall_8_2_0 = (RuleCall)cFpAssignment_8_2.eContents().get(0);
		private final Group cGroup_9 = (Group)cAlternatives.eContents().get(9);
		private final Keyword cImportKeyword_9_0 = (Keyword)cGroup_9.eContents().get(0);
		private final RuleCall cSigParserRuleCall_9_1 = (RuleCall)cGroup_9.eContents().get(1);
		private final Assignment cFpAssignment_9_2 = (Assignment)cGroup_9.eContents().get(2);
		private final RuleCall cFpFromPartParserRuleCall_9_2_0 = (RuleCall)cFpAssignment_9_2.eContents().get(0);
		private final RuleCall cExportDeclParserRuleCall_10 = (RuleCall)cAlternatives.eContents().get(10);
		
		//Declaration hidden(WS, KW_NEWLINE):
		//	"macro" MacroBody | "extend" Sig | "local" Sig | "free" Sig | "fluid" Sig | "default" Sig | "define" Sig | "fix" Sig |
		//	"inline" Sig? fp=FromPart? | "import" Sig? fp=FromPart? | ExportDecl;
		public ParserRule getRule() { return rule; }

		//"macro" MacroBody | "extend" Sig | "local" Sig | "free" Sig | "fluid" Sig | "default" Sig | "define" Sig | "fix" Sig |
		//"inline" Sig? fp=FromPart? | "import" Sig? fp=FromPart? | ExportDecl
		public Alternatives getAlternatives() { return cAlternatives; }

		//"macro" MacroBody
		public Group getGroup_0() { return cGroup_0; }

		//"macro"
		public Keyword getMacroKeyword_0_0() { return cMacroKeyword_0_0; }

		//MacroBody
		public RuleCall getMacroBodyParserRuleCall_0_1() { return cMacroBodyParserRuleCall_0_1; }

		//"extend" Sig
		public Group getGroup_1() { return cGroup_1; }

		//"extend"
		public Keyword getExtendKeyword_1_0() { return cExtendKeyword_1_0; }

		//Sig
		public RuleCall getSigParserRuleCall_1_1() { return cSigParserRuleCall_1_1; }

		//"local" Sig
		public Group getGroup_2() { return cGroup_2; }

		//"local"
		public Keyword getLocalKeyword_2_0() { return cLocalKeyword_2_0; }

		//Sig
		public RuleCall getSigParserRuleCall_2_1() { return cSigParserRuleCall_2_1; }

		//"free" Sig
		public Group getGroup_3() { return cGroup_3; }

		//"free"
		public Keyword getFreeKeyword_3_0() { return cFreeKeyword_3_0; }

		//Sig
		public RuleCall getSigParserRuleCall_3_1() { return cSigParserRuleCall_3_1; }

		//"fluid" Sig
		public Group getGroup_4() { return cGroup_4; }

		//"fluid"
		public Keyword getFluidKeyword_4_0() { return cFluidKeyword_4_0; }

		//Sig
		public RuleCall getSigParserRuleCall_4_1() { return cSigParserRuleCall_4_1; }

		//"default" Sig
		public Group getGroup_5() { return cGroup_5; }

		//"default"
		public Keyword getDefaultKeyword_5_0() { return cDefaultKeyword_5_0; }

		//Sig
		public RuleCall getSigParserRuleCall_5_1() { return cSigParserRuleCall_5_1; }

		//"define" Sig
		public Group getGroup_6() { return cGroup_6; }

		//"define"
		public Keyword getDefineKeyword_6_0() { return cDefineKeyword_6_0; }

		//Sig
		public RuleCall getSigParserRuleCall_6_1() { return cSigParserRuleCall_6_1; }

		//"fix" Sig
		public Group getGroup_7() { return cGroup_7; }

		//"fix"
		public Keyword getFixKeyword_7_0() { return cFixKeyword_7_0; }

		//Sig
		public RuleCall getSigParserRuleCall_7_1() { return cSigParserRuleCall_7_1; }

		//"inline" Sig? fp=FromPart?
		public Group getGroup_8() { return cGroup_8; }

		//"inline"
		public Keyword getInlineKeyword_8_0() { return cInlineKeyword_8_0; }

		//Sig?
		public RuleCall getSigParserRuleCall_8_1() { return cSigParserRuleCall_8_1; }

		//fp=FromPart?
		public Assignment getFpAssignment_8_2() { return cFpAssignment_8_2; }

		//FromPart
		public RuleCall getFpFromPartParserRuleCall_8_2_0() { return cFpFromPartParserRuleCall_8_2_0; }

		//"import" Sig? fp=FromPart?
		public Group getGroup_9() { return cGroup_9; }

		//"import"
		public Keyword getImportKeyword_9_0() { return cImportKeyword_9_0; }

		//Sig?
		public RuleCall getSigParserRuleCall_9_1() { return cSigParserRuleCall_9_1; }

		//fp=FromPart?
		public Assignment getFpAssignment_9_2() { return cFpAssignment_9_2; }

		//FromPart
		public RuleCall getFpFromPartParserRuleCall_9_2_0() { return cFpFromPartParserRuleCall_9_2_0; }

		//ExportDecl
		public RuleCall getExportDeclParserRuleCall_10() { return cExportDeclParserRuleCall_10; }
	}

	public class ExportDeclElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ExportDecl");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Keyword cExportKeyword_0_0 = (Keyword)cGroup_0.eContents().get(0);
		private final RuleCall cSigParserRuleCall_0_1 = (RuleCall)cGroup_0.eContents().get(1);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Group cGroup_1_0 = (Group)cGroup_1.eContents().get(0);
		private final Keyword cExportKeyword_1_0_0 = (Keyword)cGroup_1_0.eContents().get(0);
		private final RuleCall cSigParserRuleCall_1_0_1 = (RuleCall)cGroup_1_0.eContents().get(1);
		private final Assignment cTpAssignment_1_0_2 = (Assignment)cGroup_1_0.eContents().get(2);
		private final RuleCall cTpToPartParserRuleCall_1_0_2_0 = (RuleCall)cTpAssignment_1_0_2.eContents().get(0);
		private final Group cGroup_2 = (Group)cAlternatives.eContents().get(2);
		private final Group cGroup_2_0 = (Group)cGroup_2.eContents().get(0);
		private final Keyword cExportKeyword_2_0_0 = (Keyword)cGroup_2_0.eContents().get(0);
		private final RuleCall cSigParserRuleCall_2_0_1 = (RuleCall)cGroup_2_0.eContents().get(1);
		private final Assignment cFpAssignment_2_0_2 = (Assignment)cGroup_2_0.eContents().get(2);
		private final RuleCall cFpFromPartParserRuleCall_2_0_2_0 = (RuleCall)cFpAssignment_2_0_2.eContents().get(0);
		
		//ExportDecl hidden(WS, KW_NEWLINE):
		//	"export" Sig? | => ("export" Sig? tp=ToPart) | => ("export" Sig? fp=FromPart);
		public ParserRule getRule() { return rule; }

		//"export" Sig? | => ("export" Sig? tp=ToPart) | => ("export" Sig? fp=FromPart)
		public Alternatives getAlternatives() { return cAlternatives; }

		//"export" Sig?
		public Group getGroup_0() { return cGroup_0; }

		//"export"
		public Keyword getExportKeyword_0_0() { return cExportKeyword_0_0; }

		//Sig?
		public RuleCall getSigParserRuleCall_0_1() { return cSigParserRuleCall_0_1; }

		//=> ("export" Sig? tp=ToPart)
		public Group getGroup_1() { return cGroup_1; }

		//"export" Sig? tp=ToPart
		public Group getGroup_1_0() { return cGroup_1_0; }

		//"export"
		public Keyword getExportKeyword_1_0_0() { return cExportKeyword_1_0_0; }

		//Sig?
		public RuleCall getSigParserRuleCall_1_0_1() { return cSigParserRuleCall_1_0_1; }

		//tp=ToPart
		public Assignment getTpAssignment_1_0_2() { return cTpAssignment_1_0_2; }

		//ToPart
		public RuleCall getTpToPartParserRuleCall_1_0_2_0() { return cTpToPartParserRuleCall_1_0_2_0; }

		//=> ("export" Sig? fp=FromPart)
		public Group getGroup_2() { return cGroup_2; }

		//"export" Sig? fp=FromPart
		public Group getGroup_2_0() { return cGroup_2_0; }

		//"export"
		public Keyword getExportKeyword_2_0_0() { return cExportKeyword_2_0_0; }

		//Sig?
		public RuleCall getSigParserRuleCall_2_0_1() { return cSigParserRuleCall_2_0_1; }

		//fp=FromPart
		public Assignment getFpAssignment_2_0_2() { return cFpAssignment_2_0_2; }

		//FromPart
		public RuleCall getFpFromPartParserRuleCall_2_0_2_0() { return cFpFromPartParserRuleCall_2_0_2_0; }
	}

	public class ToPartElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ToPart");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cToKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final RuleCall cInfixedParserRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		
		//ToPart hidden(WS, KW_NEWLINE):
		//	"to" Infixed;
		public ParserRule getRule() { return rule; }

		//"to" Infixed
		public Group getGroup() { return cGroup; }

		//"to"
		public Keyword getToKeyword_0() { return cToKeyword_0; }

		//Infixed
		public RuleCall getInfixedParserRuleCall_1() { return cInfixedParserRuleCall_1; }
	}

	public class FromPartElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "FromPart");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cFromKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final RuleCall cEnlist1_Infixed_Comma_ABParserRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		
		//FromPart hidden(WS, KW_NEWLINE):
		//	"from" enlist1_Infixed_Comma_AB;
		public ParserRule getRule() { return rule; }

		//"from" enlist1_Infixed_Comma_AB
		public Group getGroup() { return cGroup; }

		//"from"
		public Keyword getFromKeyword_0() { return cFromKeyword_0; }

		//enlist1_Infixed_Comma_AB
		public RuleCall getEnlist1_Infixed_Comma_ABParserRuleCall_1() { return cEnlist1_Infixed_Comma_ABParserRuleCall_1; }
	}

	public class MacroBodyElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "MacroBody");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cSigParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cExportDeclParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final Group cGroup_2 = (Group)cAlternatives.eContents().get(2);
		private final Keyword cImportKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final RuleCall cSigParserRuleCall_2_1 = (RuleCall)cGroup_2.eContents().get(1);
		private final Assignment cFpAssignment_2_2 = (Assignment)cGroup_2.eContents().get(2);
		private final RuleCall cFpFromPartParserRuleCall_2_2_0 = (RuleCall)cFpAssignment_2_2.eContents().get(0);
		
		//MacroBody hidden(WS, KW_NEWLINE):
		//	Sig | ExportDecl | "import" Sig fp=FromPart?;
		public ParserRule getRule() { return rule; }

		//Sig | ExportDecl | "import" Sig fp=FromPart?
		public Alternatives getAlternatives() { return cAlternatives; }

		//Sig
		public RuleCall getSigParserRuleCall_0() { return cSigParserRuleCall_0; }

		//ExportDecl
		public RuleCall getExportDeclParserRuleCall_1() { return cExportDeclParserRuleCall_1; }

		//"import" Sig fp=FromPart?
		public Group getGroup_2() { return cGroup_2; }

		//"import"
		public Keyword getImportKeyword_2_0() { return cImportKeyword_2_0; }

		//Sig
		public RuleCall getSigParserRuleCall_2_1() { return cSigParserRuleCall_2_1; }

		//fp=FromPart?
		public Assignment getFpAssignment_2_2() { return cFpAssignment_2_2; }

		//FromPart
		public RuleCall getFpFromPartParserRuleCall_2_2_0() { return cFpFromPartParserRuleCall_2_2_0; }
	}

	public class SigElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Sig");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cDeclBindingParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cBlockParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//Sig hidden(WS, KW_NEWLINE):
		//	DeclBinding | Block;
		public ParserRule getRule() { return rule; }

		//DeclBinding | Block
		public Alternatives getAlternatives() { return cAlternatives; }

		//DeclBinding
		public RuleCall getDeclBindingParserRuleCall_0() { return cDeclBindingParserRuleCall_0; }

		//Block
		public RuleCall getBlockParserRuleCall_1() { return cBlockParserRuleCall_1; }
	}

	public class DeclPartElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "DeclPart");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final RuleCall cKW_COLONTerminalRuleCall_0_0 = (RuleCall)cGroup_0.eContents().get(0);
		private final RuleCall cTypeParserRuleCall_0_1 = (RuleCall)cGroup_0.eContents().get(1);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final RuleCall cKW_COLONSTARTerminalRuleCall_1_0 = (RuleCall)cGroup_1.eContents().get(0);
		private final RuleCall cTypeParserRuleCall_1_1 = (RuleCall)cGroup_1.eContents().get(1);
		
		//DeclPart hidden(WS, KW_NEWLINE):
		//	KW_COLON Type | KW_COLONSTAR Type;
		public ParserRule getRule() { return rule; }

		//KW_COLON Type | KW_COLONSTAR Type
		public Alternatives getAlternatives() { return cAlternatives; }

		//KW_COLON Type
		public Group getGroup_0() { return cGroup_0; }

		//KW_COLON
		public RuleCall getKW_COLONTerminalRuleCall_0_0() { return cKW_COLONTerminalRuleCall_0_0; }

		//Type
		public RuleCall getTypeParserRuleCall_0_1() { return cTypeParserRuleCall_0_1; }

		//KW_COLONSTAR Type
		public Group getGroup_1() { return cGroup_1; }

		//KW_COLONSTAR
		public RuleCall getKW_COLONSTARTerminalRuleCall_1_0() { return cKW_COLONSTARTerminalRuleCall_1_0; }

		//Type
		public RuleCall getTypeParserRuleCall_1_1() { return cTypeParserRuleCall_1_1; }
	}

	public class CommaElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Comma");
		private final RuleCall cEnlist1_CommaItem_Comma_ABParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		/// *
		// * Commas
		// * / Comma hidden(WS, KW_NEWLINE):
		//	enlist1_CommaItem_Comma_AB;
		public ParserRule getRule() { return rule; }

		//enlist1_CommaItem_Comma_AB
		public RuleCall getEnlist1_CommaItem_Comma_ABParserRuleCall() { return cEnlist1_CommaItem_Comma_ABParserRuleCall; }
	}

	public class CommaItemElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "CommaItem");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cBinding_AnyStatementParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Group cGroup_1_0 = (Group)cGroup_1.eContents().get(0);
		private final Keyword cWhereKeyword_1_0_0 = (Keyword)cGroup_1_0.eContents().get(0);
		private final Assignment cCiAssignment_1_0_1 = (Assignment)cGroup_1_0.eContents().get(1);
		private final RuleCall cCiCommaItemParserRuleCall_1_0_1_0 = (RuleCall)cCiAssignment_1_0_1.eContents().get(0);
		
		//CommaItem hidden(WS, KW_NEWLINE):
		//	Binding_AnyStatement => ("where" ci=CommaItem)*;
		public ParserRule getRule() { return rule; }

		//Binding_AnyStatement => ("where" ci=CommaItem)*
		public Group getGroup() { return cGroup; }

		//Binding_AnyStatement
		public RuleCall getBinding_AnyStatementParserRuleCall_0() { return cBinding_AnyStatementParserRuleCall_0; }

		//=> ("where" ci=CommaItem)*
		public Group getGroup_1() { return cGroup_1; }

		//"where" ci=CommaItem
		public Group getGroup_1_0() { return cGroup_1_0; }

		//"where"
		public Keyword getWhereKeyword_1_0_0() { return cWhereKeyword_1_0_0; }

		//ci=CommaItem
		public Assignment getCiAssignment_1_0_1() { return cCiAssignment_1_0_1; }

		//CommaItem
		public RuleCall getCiCommaItemParserRuleCall_1_0_1_0() { return cCiCommaItemParserRuleCall_1_0_1_0; }
	}

	public class DeclBindingElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "DeclBinding");
		private final RuleCall cBindingR_InfixedExprsDecl_AnyStatementParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		/// *
		// * DeclBinding
		// * / DeclBinding hidden(WS, KW_NEWLINE):
		//	BindingR_InfixedExprsDecl_AnyStatement;
		public ParserRule getRule() { return rule; }

		//BindingR_InfixedExprsDecl_AnyStatement
		public RuleCall getBindingR_InfixedExprsDecl_AnyStatementParserRuleCall() { return cBindingR_InfixedExprsDecl_AnyStatementParserRuleCall; }
	}

	public class InfixedExprsDeclElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "InfixedExprsDecl");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cInfixedExprsParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final RuleCall cDeclPartParserRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		
		//InfixedExprsDecl hidden(WS, KW_NEWLINE):
		//	InfixedExprs DeclPart*;
		public ParserRule getRule() { return rule; }

		//InfixedExprs DeclPart*
		public Group getGroup() { return cGroup; }

		//InfixedExprs
		public RuleCall getInfixedExprsParserRuleCall_0() { return cInfixedExprsParserRuleCall_0; }

		//DeclPart*
		public RuleCall getDeclPartParserRuleCall_1() { return cDeclPartParserRuleCall_1; }
	}

	public class InfixedExprsElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "InfixedExprs");
		private final RuleCall cEnlist1_InfixedExpr_Comma_ABParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//InfixedExprs hidden(WS, KW_NEWLINE):
		//	enlist1_InfixedExpr_Comma_AB;
		public ParserRule getRule() { return rule; }

		//enlist1_InfixedExpr_Comma_AB
		public RuleCall getEnlist1_InfixedExpr_Comma_ABParserRuleCall() { return cEnlist1_InfixedExpr_Comma_ABParserRuleCall; }
	}

	public class Binding_AnyStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Binding_AnyStatement");
		private final RuleCall cBindingL_Infixed_AnyStatementParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		/// *
		// * Bindings
		// * 
		// * Substituted Rules in Xtext:
		// * Binding_BalStatement
		// * Binding_AnyStatement
		// * Binding_BalStatement
		// * Binding_InfixedExprsDecl
		// * Binding_Collection
		// * Binding(E)
		// * : BindingL(Infixed,E)
		// * ;
		// * / Binding_AnyStatement hidden(WS, KW_NEWLINE):
		//	BindingL_Infixed_AnyStatement;
		public ParserRule getRule() { return rule; }

		//BindingL_Infixed_AnyStatement
		public RuleCall getBindingL_Infixed_AnyStatementParserRuleCall() { return cBindingL_Infixed_AnyStatementParserRuleCall; }
	}

	public class Binding_BalStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Binding_BalStatement");
		private final RuleCall cBindingL_Infixed_BalStatementParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//Binding_BalStatement hidden(WS, KW_NEWLINE):
		//	BindingL_Infixed_BalStatement;
		public ParserRule getRule() { return rule; }

		//BindingL_Infixed_BalStatement
		public RuleCall getBindingL_Infixed_BalStatementParserRuleCall() { return cBindingL_Infixed_BalStatementParserRuleCall; }
	}

	public class Binding_CollectionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Binding_Collection");
		private final RuleCall cBindingL_Infixed_CollectionParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//Binding_Collection hidden(WS, KW_NEWLINE):
		//	BindingL_Infixed_Collection;
		public ParserRule getRule() { return rule; }

		//BindingL_Infixed_Collection
		public RuleCall getBindingL_Infixed_CollectionParserRuleCall() { return cBindingL_Infixed_CollectionParserRuleCall; }
	}

	public class BindingL_Infixed_AnyStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "BindingL_Infixed_AnyStatement");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cAnyStatementParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final RuleCall cInfixedParserRuleCall_1_0 = (RuleCall)cGroup_1.eContents().get(0);
		private final Keyword cAssignKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cBiaAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cBiaBindingL_Infixed_AnyStatementParserRuleCall_1_2_0 = (RuleCall)cBiaAssignment_1_2.eContents().get(0);
		private final Group cGroup_2 = (Group)cAlternatives.eContents().get(2);
		private final RuleCall cInfixedParserRuleCall_2_0 = (RuleCall)cGroup_2.eContents().get(0);
		private final RuleCall cKW_2EQTerminalRuleCall_2_1 = (RuleCall)cGroup_2.eContents().get(1);
		private final Assignment cBiaAssignment_2_2 = (Assignment)cGroup_2.eContents().get(2);
		private final RuleCall cBiaBindingL_Infixed_AnyStatementParserRuleCall_2_2_0 = (RuleCall)cBiaAssignment_2_2.eContents().get(0);
		private final Group cGroup_3 = (Group)cAlternatives.eContents().get(3);
		private final RuleCall cInfixedParserRuleCall_3_0 = (RuleCall)cGroup_3.eContents().get(0);
		private final RuleCall cKW_MARROWTerminalRuleCall_3_1 = (RuleCall)cGroup_3.eContents().get(1);
		private final Assignment cBiaAssignment_3_2 = (Assignment)cGroup_3.eContents().get(2);
		private final RuleCall cBiaBindingL_Infixed_AnyStatementParserRuleCall_3_2_0 = (RuleCall)cBiaAssignment_3_2.eContents().get(0);
		private final Group cGroup_4 = (Group)cAlternatives.eContents().get(4);
		private final RuleCall cInfixedParserRuleCall_4_0 = (RuleCall)cGroup_4.eContents().get(0);
		private final RuleCall cKW_MAPSTOTerminalRuleCall_4_1 = (RuleCall)cGroup_4.eContents().get(1);
		private final Assignment cBiaAssignment_4_2 = (Assignment)cGroup_4.eContents().get(2);
		private final RuleCall cBiaBindingL_Infixed_AnyStatementParserRuleCall_4_2_0 = (RuleCall)cBiaAssignment_4_2.eContents().get(0);
		private final Group cGroup_5 = (Group)cAlternatives.eContents().get(5);
		private final RuleCall cInfixedParserRuleCall_5_0 = (RuleCall)cGroup_5.eContents().get(0);
		private final RuleCall cKW_MAPSTOSTARTerminalRuleCall_5_1 = (RuleCall)cGroup_5.eContents().get(1);
		private final Assignment cBiaAssignment_5_2 = (Assignment)cGroup_5.eContents().get(2);
		private final RuleCall cBiaBindingL_Infixed_AnyStatementParserRuleCall_5_2_0 = (RuleCall)cBiaAssignment_5_2.eContents().get(0);
		
		/// * Substituted Rules in Xtext:
		// * BindingL(Infixed,E) where E is in Binding
		// * BindingL(R,L)
		// * : L
		// * | R KW_Assign BindingL(R,L)
		// * { $$ = abNewAssign(APOS($1),$1,$3); }
		// * | R KW_2EQ BindingL(R,L)
		// * { $$ = abNewDefine(APOS($1),$1,$3); }
		// * | R KW_MARROW BindingL(R,L)
		// * { $$ = abNewMDefine(APOS($1),$1,$3); }
		// * | R KW_MAPSTO BindingL(R,L)
		// * { $$ = abNewLambda(APOS($1),$1,abZip,$3); }
		// * | R KW_MAPSTOStar BindingL(R,L)
		// * { $$ = abNewPLambda(APOS($1),$1,abZip,$3); }
		// * ;
		// * / BindingL_Infixed_AnyStatement hidden(WS, KW_NEWLINE):
		//	AnyStatement | Infixed "assign" bia=BindingL_Infixed_AnyStatement | Infixed KW_2EQ bia=BindingL_Infixed_AnyStatement |
		//	Infixed KW_MARROW bia=BindingL_Infixed_AnyStatement | Infixed KW_MAPSTO bia=BindingL_Infixed_AnyStatement | Infixed
		//	KW_MAPSTOSTAR bia=BindingL_Infixed_AnyStatement;
		public ParserRule getRule() { return rule; }

		//AnyStatement | Infixed "assign" bia=BindingL_Infixed_AnyStatement | Infixed KW_2EQ bia=BindingL_Infixed_AnyStatement |
		//Infixed KW_MARROW bia=BindingL_Infixed_AnyStatement | Infixed KW_MAPSTO bia=BindingL_Infixed_AnyStatement | Infixed
		//KW_MAPSTOSTAR bia=BindingL_Infixed_AnyStatement
		public Alternatives getAlternatives() { return cAlternatives; }

		//AnyStatement
		public RuleCall getAnyStatementParserRuleCall_0() { return cAnyStatementParserRuleCall_0; }

		//Infixed "assign" bia=BindingL_Infixed_AnyStatement
		public Group getGroup_1() { return cGroup_1; }

		//Infixed
		public RuleCall getInfixedParserRuleCall_1_0() { return cInfixedParserRuleCall_1_0; }

		//"assign"
		public Keyword getAssignKeyword_1_1() { return cAssignKeyword_1_1; }

		//bia=BindingL_Infixed_AnyStatement
		public Assignment getBiaAssignment_1_2() { return cBiaAssignment_1_2; }

		//BindingL_Infixed_AnyStatement
		public RuleCall getBiaBindingL_Infixed_AnyStatementParserRuleCall_1_2_0() { return cBiaBindingL_Infixed_AnyStatementParserRuleCall_1_2_0; }

		//Infixed KW_2EQ bia=BindingL_Infixed_AnyStatement
		public Group getGroup_2() { return cGroup_2; }

		//Infixed
		public RuleCall getInfixedParserRuleCall_2_0() { return cInfixedParserRuleCall_2_0; }

		//KW_2EQ
		public RuleCall getKW_2EQTerminalRuleCall_2_1() { return cKW_2EQTerminalRuleCall_2_1; }

		//bia=BindingL_Infixed_AnyStatement
		public Assignment getBiaAssignment_2_2() { return cBiaAssignment_2_2; }

		//BindingL_Infixed_AnyStatement
		public RuleCall getBiaBindingL_Infixed_AnyStatementParserRuleCall_2_2_0() { return cBiaBindingL_Infixed_AnyStatementParserRuleCall_2_2_0; }

		//Infixed KW_MARROW bia=BindingL_Infixed_AnyStatement
		public Group getGroup_3() { return cGroup_3; }

		//Infixed
		public RuleCall getInfixedParserRuleCall_3_0() { return cInfixedParserRuleCall_3_0; }

		//KW_MARROW
		public RuleCall getKW_MARROWTerminalRuleCall_3_1() { return cKW_MARROWTerminalRuleCall_3_1; }

		//bia=BindingL_Infixed_AnyStatement
		public Assignment getBiaAssignment_3_2() { return cBiaAssignment_3_2; }

		//BindingL_Infixed_AnyStatement
		public RuleCall getBiaBindingL_Infixed_AnyStatementParserRuleCall_3_2_0() { return cBiaBindingL_Infixed_AnyStatementParserRuleCall_3_2_0; }

		//Infixed KW_MAPSTO bia=BindingL_Infixed_AnyStatement
		public Group getGroup_4() { return cGroup_4; }

		//Infixed
		public RuleCall getInfixedParserRuleCall_4_0() { return cInfixedParserRuleCall_4_0; }

		//KW_MAPSTO
		public RuleCall getKW_MAPSTOTerminalRuleCall_4_1() { return cKW_MAPSTOTerminalRuleCall_4_1; }

		//bia=BindingL_Infixed_AnyStatement
		public Assignment getBiaAssignment_4_2() { return cBiaAssignment_4_2; }

		//BindingL_Infixed_AnyStatement
		public RuleCall getBiaBindingL_Infixed_AnyStatementParserRuleCall_4_2_0() { return cBiaBindingL_Infixed_AnyStatementParserRuleCall_4_2_0; }

		//Infixed KW_MAPSTOSTAR bia=BindingL_Infixed_AnyStatement
		public Group getGroup_5() { return cGroup_5; }

		//Infixed
		public RuleCall getInfixedParserRuleCall_5_0() { return cInfixedParserRuleCall_5_0; }

		//KW_MAPSTOSTAR
		public RuleCall getKW_MAPSTOSTARTerminalRuleCall_5_1() { return cKW_MAPSTOSTARTerminalRuleCall_5_1; }

		//bia=BindingL_Infixed_AnyStatement
		public Assignment getBiaAssignment_5_2() { return cBiaAssignment_5_2; }

		//BindingL_Infixed_AnyStatement
		public RuleCall getBiaBindingL_Infixed_AnyStatementParserRuleCall_5_2_0() { return cBiaBindingL_Infixed_AnyStatementParserRuleCall_5_2_0; }
	}

	public class BindingL_Infixed_BalStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "BindingL_Infixed_BalStatement");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cBalStatementParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final RuleCall cInfixedParserRuleCall_1_0 = (RuleCall)cGroup_1.eContents().get(0);
		private final Keyword cAssignKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cBibAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cBibBindingL_Infixed_BalStatementParserRuleCall_1_2_0 = (RuleCall)cBibAssignment_1_2.eContents().get(0);
		private final Group cGroup_2 = (Group)cAlternatives.eContents().get(2);
		private final RuleCall cInfixedParserRuleCall_2_0 = (RuleCall)cGroup_2.eContents().get(0);
		private final RuleCall cKW_2EQTerminalRuleCall_2_1 = (RuleCall)cGroup_2.eContents().get(1);
		private final Assignment cBibAssignment_2_2 = (Assignment)cGroup_2.eContents().get(2);
		private final RuleCall cBibBindingL_Infixed_BalStatementParserRuleCall_2_2_0 = (RuleCall)cBibAssignment_2_2.eContents().get(0);
		private final Group cGroup_3 = (Group)cAlternatives.eContents().get(3);
		private final RuleCall cInfixedParserRuleCall_3_0 = (RuleCall)cGroup_3.eContents().get(0);
		private final RuleCall cKW_MARROWTerminalRuleCall_3_1 = (RuleCall)cGroup_3.eContents().get(1);
		private final Assignment cBibAssignment_3_2 = (Assignment)cGroup_3.eContents().get(2);
		private final RuleCall cBibBindingL_Infixed_BalStatementParserRuleCall_3_2_0 = (RuleCall)cBibAssignment_3_2.eContents().get(0);
		private final Group cGroup_4 = (Group)cAlternatives.eContents().get(4);
		private final RuleCall cInfixedParserRuleCall_4_0 = (RuleCall)cGroup_4.eContents().get(0);
		private final RuleCall cKW_MAPSTOTerminalRuleCall_4_1 = (RuleCall)cGroup_4.eContents().get(1);
		private final Assignment cBibAssignment_4_2 = (Assignment)cGroup_4.eContents().get(2);
		private final RuleCall cBibBindingL_Infixed_BalStatementParserRuleCall_4_2_0 = (RuleCall)cBibAssignment_4_2.eContents().get(0);
		private final Group cGroup_5 = (Group)cAlternatives.eContents().get(5);
		private final RuleCall cInfixedParserRuleCall_5_0 = (RuleCall)cGroup_5.eContents().get(0);
		private final RuleCall cKW_MAPSTOSTARTerminalRuleCall_5_1 = (RuleCall)cGroup_5.eContents().get(1);
		private final Assignment cBibAssignment_5_2 = (Assignment)cGroup_5.eContents().get(2);
		private final RuleCall cBibBindingL_Infixed_BalStatementParserRuleCall_5_2_0 = (RuleCall)cBibAssignment_5_2.eContents().get(0);
		
		//BindingL_Infixed_BalStatement hidden(WS, KW_NEWLINE):
		//	BalStatement | Infixed "assign" bib=BindingL_Infixed_BalStatement | Infixed KW_2EQ bib=BindingL_Infixed_BalStatement |
		//	Infixed KW_MARROW bib=BindingL_Infixed_BalStatement | Infixed KW_MAPSTO bib=BindingL_Infixed_BalStatement | Infixed
		//	KW_MAPSTOSTAR bib=BindingL_Infixed_BalStatement;
		public ParserRule getRule() { return rule; }

		//BalStatement | Infixed "assign" bib=BindingL_Infixed_BalStatement | Infixed KW_2EQ bib=BindingL_Infixed_BalStatement |
		//Infixed KW_MARROW bib=BindingL_Infixed_BalStatement | Infixed KW_MAPSTO bib=BindingL_Infixed_BalStatement | Infixed
		//KW_MAPSTOSTAR bib=BindingL_Infixed_BalStatement
		public Alternatives getAlternatives() { return cAlternatives; }

		//BalStatement
		public RuleCall getBalStatementParserRuleCall_0() { return cBalStatementParserRuleCall_0; }

		//Infixed "assign" bib=BindingL_Infixed_BalStatement
		public Group getGroup_1() { return cGroup_1; }

		//Infixed
		public RuleCall getInfixedParserRuleCall_1_0() { return cInfixedParserRuleCall_1_0; }

		//"assign"
		public Keyword getAssignKeyword_1_1() { return cAssignKeyword_1_1; }

		//bib=BindingL_Infixed_BalStatement
		public Assignment getBibAssignment_1_2() { return cBibAssignment_1_2; }

		//BindingL_Infixed_BalStatement
		public RuleCall getBibBindingL_Infixed_BalStatementParserRuleCall_1_2_0() { return cBibBindingL_Infixed_BalStatementParserRuleCall_1_2_0; }

		//Infixed KW_2EQ bib=BindingL_Infixed_BalStatement
		public Group getGroup_2() { return cGroup_2; }

		//Infixed
		public RuleCall getInfixedParserRuleCall_2_0() { return cInfixedParserRuleCall_2_0; }

		//KW_2EQ
		public RuleCall getKW_2EQTerminalRuleCall_2_1() { return cKW_2EQTerminalRuleCall_2_1; }

		//bib=BindingL_Infixed_BalStatement
		public Assignment getBibAssignment_2_2() { return cBibAssignment_2_2; }

		//BindingL_Infixed_BalStatement
		public RuleCall getBibBindingL_Infixed_BalStatementParserRuleCall_2_2_0() { return cBibBindingL_Infixed_BalStatementParserRuleCall_2_2_0; }

		//Infixed KW_MARROW bib=BindingL_Infixed_BalStatement
		public Group getGroup_3() { return cGroup_3; }

		//Infixed
		public RuleCall getInfixedParserRuleCall_3_0() { return cInfixedParserRuleCall_3_0; }

		//KW_MARROW
		public RuleCall getKW_MARROWTerminalRuleCall_3_1() { return cKW_MARROWTerminalRuleCall_3_1; }

		//bib=BindingL_Infixed_BalStatement
		public Assignment getBibAssignment_3_2() { return cBibAssignment_3_2; }

		//BindingL_Infixed_BalStatement
		public RuleCall getBibBindingL_Infixed_BalStatementParserRuleCall_3_2_0() { return cBibBindingL_Infixed_BalStatementParserRuleCall_3_2_0; }

		//Infixed KW_MAPSTO bib=BindingL_Infixed_BalStatement
		public Group getGroup_4() { return cGroup_4; }

		//Infixed
		public RuleCall getInfixedParserRuleCall_4_0() { return cInfixedParserRuleCall_4_0; }

		//KW_MAPSTO
		public RuleCall getKW_MAPSTOTerminalRuleCall_4_1() { return cKW_MAPSTOTerminalRuleCall_4_1; }

		//bib=BindingL_Infixed_BalStatement
		public Assignment getBibAssignment_4_2() { return cBibAssignment_4_2; }

		//BindingL_Infixed_BalStatement
		public RuleCall getBibBindingL_Infixed_BalStatementParserRuleCall_4_2_0() { return cBibBindingL_Infixed_BalStatementParserRuleCall_4_2_0; }

		//Infixed KW_MAPSTOSTAR bib=BindingL_Infixed_BalStatement
		public Group getGroup_5() { return cGroup_5; }

		//Infixed
		public RuleCall getInfixedParserRuleCall_5_0() { return cInfixedParserRuleCall_5_0; }

		//KW_MAPSTOSTAR
		public RuleCall getKW_MAPSTOSTARTerminalRuleCall_5_1() { return cKW_MAPSTOSTARTerminalRuleCall_5_1; }

		//bib=BindingL_Infixed_BalStatement
		public Assignment getBibAssignment_5_2() { return cBibAssignment_5_2; }

		//BindingL_Infixed_BalStatement
		public RuleCall getBibBindingL_Infixed_BalStatementParserRuleCall_5_2_0() { return cBibBindingL_Infixed_BalStatementParserRuleCall_5_2_0; }
	}

	public class BindingL_Infixed_CollectionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "BindingL_Infixed_Collection");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cCollectionParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final RuleCall cInfixedParserRuleCall_1_0 = (RuleCall)cGroup_1.eContents().get(0);
		private final Keyword cAssignKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cBicAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cBicBindingL_Infixed_CollectionParserRuleCall_1_2_0 = (RuleCall)cBicAssignment_1_2.eContents().get(0);
		private final Group cGroup_2 = (Group)cAlternatives.eContents().get(2);
		private final RuleCall cInfixedParserRuleCall_2_0 = (RuleCall)cGroup_2.eContents().get(0);
		private final RuleCall cKW_2EQTerminalRuleCall_2_1 = (RuleCall)cGroup_2.eContents().get(1);
		private final Assignment cBicAssignment_2_2 = (Assignment)cGroup_2.eContents().get(2);
		private final RuleCall cBicBindingL_Infixed_CollectionParserRuleCall_2_2_0 = (RuleCall)cBicAssignment_2_2.eContents().get(0);
		private final Group cGroup_3 = (Group)cAlternatives.eContents().get(3);
		private final RuleCall cInfixedParserRuleCall_3_0 = (RuleCall)cGroup_3.eContents().get(0);
		private final RuleCall cKW_MARROWTerminalRuleCall_3_1 = (RuleCall)cGroup_3.eContents().get(1);
		private final Assignment cBicAssignment_3_2 = (Assignment)cGroup_3.eContents().get(2);
		private final RuleCall cBicBindingL_Infixed_CollectionParserRuleCall_3_2_0 = (RuleCall)cBicAssignment_3_2.eContents().get(0);
		private final Group cGroup_4 = (Group)cAlternatives.eContents().get(4);
		private final RuleCall cInfixedParserRuleCall_4_0 = (RuleCall)cGroup_4.eContents().get(0);
		private final RuleCall cKW_MAPSTOTerminalRuleCall_4_1 = (RuleCall)cGroup_4.eContents().get(1);
		private final Assignment cBicAssignment_4_2 = (Assignment)cGroup_4.eContents().get(2);
		private final RuleCall cBicBindingL_Infixed_CollectionParserRuleCall_4_2_0 = (RuleCall)cBicAssignment_4_2.eContents().get(0);
		private final Group cGroup_5 = (Group)cAlternatives.eContents().get(5);
		private final RuleCall cInfixedParserRuleCall_5_0 = (RuleCall)cGroup_5.eContents().get(0);
		private final RuleCall cKW_MAPSTOSTARTerminalRuleCall_5_1 = (RuleCall)cGroup_5.eContents().get(1);
		private final Assignment cBicAssignment_5_2 = (Assignment)cGroup_5.eContents().get(2);
		private final RuleCall cBicBindingL_Infixed_CollectionParserRuleCall_5_2_0 = (RuleCall)cBicAssignment_5_2.eContents().get(0);
		
		//BindingL_Infixed_Collection hidden(WS, KW_NEWLINE):
		//	Collection | Infixed "assign" bic=BindingL_Infixed_Collection | Infixed KW_2EQ bic=BindingL_Infixed_Collection |
		//	Infixed KW_MARROW bic=BindingL_Infixed_Collection | Infixed KW_MAPSTO bic=BindingL_Infixed_Collection | Infixed
		//	KW_MAPSTOSTAR bic=BindingL_Infixed_Collection;
		public ParserRule getRule() { return rule; }

		//Collection | Infixed "assign" bic=BindingL_Infixed_Collection | Infixed KW_2EQ bic=BindingL_Infixed_Collection | Infixed
		//KW_MARROW bic=BindingL_Infixed_Collection | Infixed KW_MAPSTO bic=BindingL_Infixed_Collection | Infixed KW_MAPSTOSTAR
		//bic=BindingL_Infixed_Collection
		public Alternatives getAlternatives() { return cAlternatives; }

		//Collection
		public RuleCall getCollectionParserRuleCall_0() { return cCollectionParserRuleCall_0; }

		//Infixed "assign" bic=BindingL_Infixed_Collection
		public Group getGroup_1() { return cGroup_1; }

		//Infixed
		public RuleCall getInfixedParserRuleCall_1_0() { return cInfixedParserRuleCall_1_0; }

		//"assign"
		public Keyword getAssignKeyword_1_1() { return cAssignKeyword_1_1; }

		//bic=BindingL_Infixed_Collection
		public Assignment getBicAssignment_1_2() { return cBicAssignment_1_2; }

		//BindingL_Infixed_Collection
		public RuleCall getBicBindingL_Infixed_CollectionParserRuleCall_1_2_0() { return cBicBindingL_Infixed_CollectionParserRuleCall_1_2_0; }

		//Infixed KW_2EQ bic=BindingL_Infixed_Collection
		public Group getGroup_2() { return cGroup_2; }

		//Infixed
		public RuleCall getInfixedParserRuleCall_2_0() { return cInfixedParserRuleCall_2_0; }

		//KW_2EQ
		public RuleCall getKW_2EQTerminalRuleCall_2_1() { return cKW_2EQTerminalRuleCall_2_1; }

		//bic=BindingL_Infixed_Collection
		public Assignment getBicAssignment_2_2() { return cBicAssignment_2_2; }

		//BindingL_Infixed_Collection
		public RuleCall getBicBindingL_Infixed_CollectionParserRuleCall_2_2_0() { return cBicBindingL_Infixed_CollectionParserRuleCall_2_2_0; }

		//Infixed KW_MARROW bic=BindingL_Infixed_Collection
		public Group getGroup_3() { return cGroup_3; }

		//Infixed
		public RuleCall getInfixedParserRuleCall_3_0() { return cInfixedParserRuleCall_3_0; }

		//KW_MARROW
		public RuleCall getKW_MARROWTerminalRuleCall_3_1() { return cKW_MARROWTerminalRuleCall_3_1; }

		//bic=BindingL_Infixed_Collection
		public Assignment getBicAssignment_3_2() { return cBicAssignment_3_2; }

		//BindingL_Infixed_Collection
		public RuleCall getBicBindingL_Infixed_CollectionParserRuleCall_3_2_0() { return cBicBindingL_Infixed_CollectionParserRuleCall_3_2_0; }

		//Infixed KW_MAPSTO bic=BindingL_Infixed_Collection
		public Group getGroup_4() { return cGroup_4; }

		//Infixed
		public RuleCall getInfixedParserRuleCall_4_0() { return cInfixedParserRuleCall_4_0; }

		//KW_MAPSTO
		public RuleCall getKW_MAPSTOTerminalRuleCall_4_1() { return cKW_MAPSTOTerminalRuleCall_4_1; }

		//bic=BindingL_Infixed_Collection
		public Assignment getBicAssignment_4_2() { return cBicAssignment_4_2; }

		//BindingL_Infixed_Collection
		public RuleCall getBicBindingL_Infixed_CollectionParserRuleCall_4_2_0() { return cBicBindingL_Infixed_CollectionParserRuleCall_4_2_0; }

		//Infixed KW_MAPSTOSTAR bic=BindingL_Infixed_Collection
		public Group getGroup_5() { return cGroup_5; }

		//Infixed
		public RuleCall getInfixedParserRuleCall_5_0() { return cInfixedParserRuleCall_5_0; }

		//KW_MAPSTOSTAR
		public RuleCall getKW_MAPSTOSTARTerminalRuleCall_5_1() { return cKW_MAPSTOSTARTerminalRuleCall_5_1; }

		//bic=BindingL_Infixed_Collection
		public Assignment getBicAssignment_5_2() { return cBicAssignment_5_2; }

		//BindingL_Infixed_Collection
		public RuleCall getBicBindingL_Infixed_CollectionParserRuleCall_5_2_0() { return cBicBindingL_Infixed_CollectionParserRuleCall_5_2_0; }
	}

	public class BindingR_InfixedExprsDecl_AnyStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "BindingR_InfixedExprsDecl_AnyStatement");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cInfixedExprsDeclParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final RuleCall cInfixedExprsDeclParserRuleCall_1_0 = (RuleCall)cGroup_1.eContents().get(0);
		private final Keyword cAssignKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final RuleCall cBinding_AnyStatementParserRuleCall_1_2 = (RuleCall)cGroup_1.eContents().get(2);
		private final Group cGroup_2 = (Group)cAlternatives.eContents().get(2);
		private final RuleCall cInfixedExprsDeclParserRuleCall_2_0 = (RuleCall)cGroup_2.eContents().get(0);
		private final RuleCall cKW_2EQTerminalRuleCall_2_1 = (RuleCall)cGroup_2.eContents().get(1);
		private final RuleCall cBinding_AnyStatementParserRuleCall_2_2 = (RuleCall)cGroup_2.eContents().get(2);
		private final Group cGroup_3 = (Group)cAlternatives.eContents().get(3);
		private final RuleCall cInfixedExprsDeclParserRuleCall_3_0 = (RuleCall)cGroup_3.eContents().get(0);
		private final RuleCall cKW_MARROWTerminalRuleCall_3_1 = (RuleCall)cGroup_3.eContents().get(1);
		private final RuleCall cBinding_AnyStatementParserRuleCall_3_2 = (RuleCall)cGroup_3.eContents().get(2);
		private final Group cGroup_4 = (Group)cAlternatives.eContents().get(4);
		private final RuleCall cInfixedExprsDeclParserRuleCall_4_0 = (RuleCall)cGroup_4.eContents().get(0);
		private final RuleCall cKW_MAPSTOTerminalRuleCall_4_1 = (RuleCall)cGroup_4.eContents().get(1);
		private final RuleCall cBinding_AnyStatementParserRuleCall_4_2 = (RuleCall)cGroup_4.eContents().get(2);
		private final Group cGroup_5 = (Group)cAlternatives.eContents().get(5);
		private final RuleCall cInfixedExprsDeclParserRuleCall_5_0 = (RuleCall)cGroup_5.eContents().get(0);
		private final RuleCall cKW_MAPSTOSTARTerminalRuleCall_5_1 = (RuleCall)cGroup_5.eContents().get(1);
		private final RuleCall cBinding_AnyStatementParserRuleCall_5_2 = (RuleCall)cGroup_5.eContents().get(2);
		
		/// * Substituted Rules in Xtext:
		// * BindingR(InfixedExprsDecl,AnyStatement)
		// * BindingR(R,L)
		// * : R
		// * | R KW_Assign Binding(L)
		// * { $$ = abNewAssign(APOS($1),$1,$3); }
		// * | R KW_2EQ Binding(L)
		// * { $$ = abNewDefine(APOS($1),$1,$3); }
		// * | R KW_MARROW Binding(L)
		// * { $$ = abNewMDefine(APOS($1),$1,$3); }
		// * | R KW_MAPSTO Binding(L)
		// * { $$ = abNewLambda(APOS($1),$1,abZip,$3); }
		// * | R KW_MAPSTOStar Binding(L)
		// * { $$ = abNewPLambda(APOS($1),$1,abZip,$3); }
		// * ;
		// * / BindingR_InfixedExprsDecl_AnyStatement hidden(WS, KW_NEWLINE):
		//	InfixedExprsDecl | InfixedExprsDecl "assign" Binding_AnyStatement | InfixedExprsDecl KW_2EQ Binding_AnyStatement |
		//	InfixedExprsDecl KW_MARROW Binding_AnyStatement | InfixedExprsDecl KW_MAPSTO Binding_AnyStatement | InfixedExprsDecl
		//	KW_MAPSTOSTAR Binding_AnyStatement;
		public ParserRule getRule() { return rule; }

		//InfixedExprsDecl | InfixedExprsDecl "assign" Binding_AnyStatement | InfixedExprsDecl KW_2EQ Binding_AnyStatement |
		//InfixedExprsDecl KW_MARROW Binding_AnyStatement | InfixedExprsDecl KW_MAPSTO Binding_AnyStatement | InfixedExprsDecl
		//KW_MAPSTOSTAR Binding_AnyStatement
		public Alternatives getAlternatives() { return cAlternatives; }

		//InfixedExprsDecl
		public RuleCall getInfixedExprsDeclParserRuleCall_0() { return cInfixedExprsDeclParserRuleCall_0; }

		//InfixedExprsDecl "assign" Binding_AnyStatement
		public Group getGroup_1() { return cGroup_1; }

		//InfixedExprsDecl
		public RuleCall getInfixedExprsDeclParserRuleCall_1_0() { return cInfixedExprsDeclParserRuleCall_1_0; }

		//"assign"
		public Keyword getAssignKeyword_1_1() { return cAssignKeyword_1_1; }

		//Binding_AnyStatement
		public RuleCall getBinding_AnyStatementParserRuleCall_1_2() { return cBinding_AnyStatementParserRuleCall_1_2; }

		//InfixedExprsDecl KW_2EQ Binding_AnyStatement
		public Group getGroup_2() { return cGroup_2; }

		//InfixedExprsDecl
		public RuleCall getInfixedExprsDeclParserRuleCall_2_0() { return cInfixedExprsDeclParserRuleCall_2_0; }

		//KW_2EQ
		public RuleCall getKW_2EQTerminalRuleCall_2_1() { return cKW_2EQTerminalRuleCall_2_1; }

		//Binding_AnyStatement
		public RuleCall getBinding_AnyStatementParserRuleCall_2_2() { return cBinding_AnyStatementParserRuleCall_2_2; }

		//InfixedExprsDecl KW_MARROW Binding_AnyStatement
		public Group getGroup_3() { return cGroup_3; }

		//InfixedExprsDecl
		public RuleCall getInfixedExprsDeclParserRuleCall_3_0() { return cInfixedExprsDeclParserRuleCall_3_0; }

		//KW_MARROW
		public RuleCall getKW_MARROWTerminalRuleCall_3_1() { return cKW_MARROWTerminalRuleCall_3_1; }

		//Binding_AnyStatement
		public RuleCall getBinding_AnyStatementParserRuleCall_3_2() { return cBinding_AnyStatementParserRuleCall_3_2; }

		//InfixedExprsDecl KW_MAPSTO Binding_AnyStatement
		public Group getGroup_4() { return cGroup_4; }

		//InfixedExprsDecl
		public RuleCall getInfixedExprsDeclParserRuleCall_4_0() { return cInfixedExprsDeclParserRuleCall_4_0; }

		//KW_MAPSTO
		public RuleCall getKW_MAPSTOTerminalRuleCall_4_1() { return cKW_MAPSTOTerminalRuleCall_4_1; }

		//Binding_AnyStatement
		public RuleCall getBinding_AnyStatementParserRuleCall_4_2() { return cBinding_AnyStatementParserRuleCall_4_2; }

		//InfixedExprsDecl KW_MAPSTOSTAR Binding_AnyStatement
		public Group getGroup_5() { return cGroup_5; }

		//InfixedExprsDecl
		public RuleCall getInfixedExprsDeclParserRuleCall_5_0() { return cInfixedExprsDeclParserRuleCall_5_0; }

		//KW_MAPSTOSTAR
		public RuleCall getKW_MAPSTOSTARTerminalRuleCall_5_1() { return cKW_MAPSTOSTARTerminalRuleCall_5_1; }

		//Binding_AnyStatement
		public RuleCall getBinding_AnyStatementParserRuleCall_5_2() { return cBinding_AnyStatementParserRuleCall_5_2; }
	}

	public class AnyStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "AnyStatement");
		private final Keyword cTemp19Keyword = (Keyword)rule.eContents().get(1);
		
		/// *
		// * Statements
		// *
		// * It is easier to spot conflicts when explicitly handling dangling else.
		// * / // if we enable the following we get:
		//// 'A class may not be a super type of itself' error
		//// 'if' CommaItem 'then' bas=Binding_AnyStatement
		////| Flow_AnyStatement
		//AnyStatement hidden(WS, KW_NEWLINE):
		//	"temp19";
		public ParserRule getRule() { return rule; }

		//"temp19"
		public Keyword getTemp19Keyword() { return cTemp19Keyword; }
	}

	public class BalStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "BalStatement");
		private final Keyword cTemp20Keyword = (Keyword)rule.eContents().get(1);
		
		//// Flow_BalStatement
		//BalStatement hidden(WS, KW_NEWLINE):
		//	"temp20";
		public ParserRule getRule() { return rule; }

		//"temp20"
		public Keyword getTemp20Keyword() { return cTemp20Keyword; }
	}

	public class Flow_AnyStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Flow_AnyStatement");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cCollectionParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Keyword cIfKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final RuleCall cCommaItemParserRuleCall_1_1 = (RuleCall)cGroup_1.eContents().get(1);
		private final Keyword cThenKeyword_1_2 = (Keyword)cGroup_1.eContents().get(2);
		private final Assignment cBbsAssignment_1_3 = (Assignment)cGroup_1.eContents().get(3);
		private final RuleCall cBbsBinding_BalStatementParserRuleCall_1_3_0 = (RuleCall)cBbsAssignment_1_3.eContents().get(0);
		private final Keyword cElseKeyword_1_4 = (Keyword)cGroup_1.eContents().get(4);
		private final Assignment cBasAssignment_1_5 = (Assignment)cGroup_1.eContents().get(5);
		private final RuleCall cBasBinding_AnyStatementParserRuleCall_1_5_0 = (RuleCall)cBasAssignment_1_5.eContents().get(0);
		private final Group cGroup_2 = (Group)cAlternatives.eContents().get(2);
		private final RuleCall cCollectionParserRuleCall_2_0 = (RuleCall)cGroup_2.eContents().get(0);
		private final Keyword cImpliesKeyword_2_1 = (Keyword)cGroup_2.eContents().get(1);
		private final Assignment cBas2Assignment_2_2 = (Assignment)cGroup_2.eContents().get(2);
		private final RuleCall cBas2Binding_AnyStatementParserRuleCall_2_2_0 = (RuleCall)cBas2Assignment_2_2.eContents().get(0);
		private final Group cGroup_3 = (Group)cAlternatives.eContents().get(3);
		private final RuleCall cIteratorsParserRuleCall_3_0 = (RuleCall)cGroup_3.eContents().get(0);
		private final Keyword cRepeatKeyword_3_1 = (Keyword)cGroup_3.eContents().get(1);
		private final Assignment cBas3Assignment_3_2 = (Assignment)cGroup_3.eContents().get(2);
		private final RuleCall cBas3Binding_AnyStatementParserRuleCall_3_2_0 = (RuleCall)cBas3Assignment_3_2.eContents().get(0);
		private final Group cGroup_4 = (Group)cAlternatives.eContents().get(4);
		private final Keyword cRepeatKeyword_4_0 = (Keyword)cGroup_4.eContents().get(0);
		private final RuleCall cBinding_AnyStatementParserRuleCall_4_1 = (RuleCall)cGroup_4.eContents().get(1);
		private final Group cGroup_5 = (Group)cAlternatives.eContents().get(5);
		private final Keyword cTryKeyword_5_0 = (Keyword)cGroup_5.eContents().get(0);
		private final RuleCall cBinding_AnyStatementParserRuleCall_5_1 = (RuleCall)cGroup_5.eContents().get(1);
		private final Keyword cButKeyword_5_2 = (Keyword)cGroup_5.eContents().get(2);
		private final Assignment cBeAssignment_5_3 = (Assignment)cGroup_5.eContents().get(3);
		private final RuleCall cBeButExprParserRuleCall_5_3_0 = (RuleCall)cBeAssignment_5_3.eContents().get(0);
		private final Assignment cApaAssignment_5_4 = (Assignment)cGroup_5.eContents().get(4);
		private final RuleCall cApaAlwaysPart_AnyStatementParserRuleCall_5_4_0 = (RuleCall)cApaAssignment_5_4.eContents().get(0);
		private final Group cGroup_6 = (Group)cAlternatives.eContents().get(6);
		private final Keyword cTryKeyword_6_0 = (Keyword)cGroup_6.eContents().get(0);
		private final RuleCall cBinding_AnyStatementParserRuleCall_6_1 = (RuleCall)cGroup_6.eContents().get(1);
		private final Keyword cCatchKeyword_6_2 = (Keyword)cGroup_6.eContents().get(2);
		private final Assignment cBeAssignment_6_3 = (Assignment)cGroup_6.eContents().get(3);
		private final RuleCall cBeButExprParserRuleCall_6_3_0 = (RuleCall)cBeAssignment_6_3.eContents().get(0);
		private final Assignment cApaAssignment_6_4 = (Assignment)cGroup_6.eContents().get(4);
		private final RuleCall cApaAlwaysPart_AnyStatementParserRuleCall_6_4_0 = (RuleCall)cApaAssignment_6_4.eContents().get(0);
		private final Group cGroup_7 = (Group)cAlternatives.eContents().get(7);
		private final Keyword cSelectKeyword_7_0 = (Keyword)cGroup_7.eContents().get(0);
		private final RuleCall cBinding_AnyStatementParserRuleCall_7_1 = (RuleCall)cGroup_7.eContents().get(1);
		private final Keyword cInKeyword_7_2 = (Keyword)cGroup_7.eContents().get(2);
		private final Assignment cCAssignment_7_3 = (Assignment)cGroup_7.eContents().get(3);
		private final RuleCall cCCasesParserRuleCall_7_3_0 = (RuleCall)cCAssignment_7_3.eContents().get(0);
		private final Group cGroup_8 = (Group)cAlternatives.eContents().get(8);
		private final Keyword cDoKeyword_8_0 = (Keyword)cGroup_8.eContents().get(0);
		private final RuleCall cBinding_AnyStatementParserRuleCall_8_1 = (RuleCall)cGroup_8.eContents().get(1);
		private final Group cGroup_9 = (Group)cAlternatives.eContents().get(9);
		private final Keyword cDelayKeyword_9_0 = (Keyword)cGroup_9.eContents().get(0);
		private final RuleCall cBinding_AnyStatementParserRuleCall_9_1 = (RuleCall)cGroup_9.eContents().get(1);
		private final Group cGroup_10 = (Group)cAlternatives.eContents().get(10);
		private final Keyword cReferenceKeyword_10_0 = (Keyword)cGroup_10.eContents().get(0);
		private final RuleCall cBinding_AnyStatementParserRuleCall_10_1 = (RuleCall)cGroup_10.eContents().get(1);
		private final Group cGroup_11 = (Group)cAlternatives.eContents().get(11);
		private final Keyword cGenerateKeyword_11_0 = (Keyword)cGroup_11.eContents().get(0);
		private final RuleCall cGenBoundParserRuleCall_11_1 = (RuleCall)cGroup_11.eContents().get(1);
		private final Assignment cBas4Assignment_11_2 = (Assignment)cGroup_11.eContents().get(2);
		private final RuleCall cBas4Binding_AnyStatementParserRuleCall_11_2_0 = (RuleCall)cBas4Assignment_11_2.eContents().get(0);
		private final Group cGroup_12 = (Group)cAlternatives.eContents().get(12);
		private final Keyword cAssertKeyword_12_0 = (Keyword)cGroup_12.eContents().get(0);
		private final RuleCall cBinding_AnyStatementParserRuleCall_12_1 = (RuleCall)cGroup_12.eContents().get(1);
		private final Group cGroup_13 = (Group)cAlternatives.eContents().get(13);
		private final Keyword cIterateKeyword_13_0 = (Keyword)cGroup_13.eContents().get(0);
		private final RuleCall cNameParserRuleCall_13_1 = (RuleCall)cGroup_13.eContents().get(1);
		private final Group cGroup_14 = (Group)cAlternatives.eContents().get(14);
		private final Keyword cBreakKeyword_14_0 = (Keyword)cGroup_14.eContents().get(0);
		private final RuleCall cNameParserRuleCall_14_1 = (RuleCall)cGroup_14.eContents().get(1);
		private final Group cGroup_15 = (Group)cAlternatives.eContents().get(15);
		private final Keyword cReturnKeyword_15_0 = (Keyword)cGroup_15.eContents().get(0);
		private final RuleCall cCollectionParserRuleCall_15_1 = (RuleCall)cGroup_15.eContents().get(1);
		private final Group cGroup_16 = (Group)cAlternatives.eContents().get(16);
		private final Keyword cYieldKeyword_16_0 = (Keyword)cGroup_16.eContents().get(0);
		private final RuleCall cBinding_AnyStatementParserRuleCall_16_1 = (RuleCall)cGroup_16.eContents().get(1);
		private final Group cGroup_17 = (Group)cAlternatives.eContents().get(17);
		private final Keyword cExceptKeyword_17_0 = (Keyword)cGroup_17.eContents().get(0);
		private final RuleCall cBinding_AnyStatementParserRuleCall_17_1 = (RuleCall)cGroup_17.eContents().get(1);
		private final Group cGroup_18 = (Group)cAlternatives.eContents().get(18);
		private final Keyword cThrowKeyword_18_0 = (Keyword)cGroup_18.eContents().get(0);
		private final RuleCall cBinding_AnyStatementParserRuleCall_18_1 = (RuleCall)cGroup_18.eContents().get(1);
		private final Group cGroup_19 = (Group)cAlternatives.eContents().get(19);
		private final Keyword cGotoKeyword_19_0 = (Keyword)cGroup_19.eContents().get(0);
		private final RuleCall cIdParserRuleCall_19_1 = (RuleCall)cGroup_19.eContents().get(1);
		private final Keyword cNeverKeyword_20 = (Keyword)cAlternatives.eContents().get(20);
		
		/// * Substituted Rules in Xtext:
		//Flow(XX) -> Flow_AnyStatement or Flow_BalStatement
		////Flow(XX)
		////: Collection
		////| KW_If CommaItem KW_Then Binding_BalStatement KW_Else Binding(XX)
		////{ $$ = abNewIf(TPOS($1), TEST($2),$4,$6); }
		////| Collection KW_Implies Binding(XX)
		////{ $$ = abNewExit(TPOS($2), TEST($1),$3); }
		////| Iterators KW_Repeat Binding(XX)
		////{ $$ = abNewRepeatOL(TPOS($2),$3,$1); listFree(AbSyn)($1); }
		////| KW_Repeat Binding(XX)
		////{ $$ = abNewRepeat0(TPOS($1),$2); }
		////| KW_Try Binding_AnyStatement) KW_But ButExpr AlwaysPart(XX)
		////{ (void)parseDeprecated(KW_But, abNewNothing(TPOS($3))); $$ = abNewTry(TPOS($1),$2,$4->abSequence.argv[0], $4->abSequence.argv[1],$5); }
		////| KW_Try Binding_AnyStatement) KW_Catch ButExpr AlwaysPart(XX)
		////{ $$ = abNewTry(TPOS($1),$2,$4->abSequence.argv[0], $4->abSequence.argv[1],$5); }
		////| KW_Select Binding_AnyStatement) KW_In Cases
		////{ $$ = abNewSelect(TPOS($1),$2,$4); }
		////| KW_Do Binding(XX)
		////{ $$ = abNewDo(TPOS($1),$2); }
		////| KW_Delay Binding(XX)
		////{ $$ = abNewDelay(TPOS($1),$2); }
		////| KW_Reference Binding(XX)
		////{ $$ = abNewReference(TPOS($1),$2); }
		////| KW_Generate GenBound Binding(XX)
		////{ $$ = abNewGenerate(TPOS($1),$2,$3); }
		////| KW_Assert Binding(XX)
		////{ $$ = abNewAssert(TPOS($1),TEST($2)); }
		////| KW_Iterate opt(Name)
		////{ $$ = abNewIterate(TPOS($1),$2); }
		////| KW_Break opt(Name)
		////{ $$ = abNewBreak(TPOS($1),$2); }
		////| KW_Return opt(Collection)
		////{ $$ = abNewReturn(TPOS($1),$2); }
		////| KW_Yield Binding(XX)
		////{ $$ = abNewYield(TPOS($1),$2); }
		////| KW_Except Binding(XX)
		////{ $$ = parseDeprecated(KW_Except, abNewRaise(TPOS($1),$2)); }
		////| KW_Throw Binding(XX)
		////{ $$ = abNewRaise(TPOS($1),$2); }
		////| KW_Goto Id
		////{ $$ = abNewGoto(TPOS($1),$2); }
		////| KW_Never
		////{ $$ = abNewNever(TPOS($1)); }
		////;
		// * / Flow_AnyStatement hidden(WS, KW_NEWLINE):
		//	Collection | "if" CommaItem "then" bbs=Binding_BalStatement "else" bas=Binding_AnyStatement | Collection "implies"
		//	bas2=Binding_AnyStatement | Iterators "repeat" bas3=Binding_AnyStatement | "repeat" Binding_AnyStatement | "try"
		//	Binding_AnyStatement "but" be=ButExpr apa=AlwaysPart_AnyStatement | "try" Binding_AnyStatement "catch" be=ButExpr
		//	apa=AlwaysPart_AnyStatement | "select" Binding_AnyStatement "in" c=Cases | "do" Binding_AnyStatement | "delay"
		//	Binding_AnyStatement | "reference" Binding_AnyStatement | "generate" GenBound bas4=Binding_AnyStatement | "assert"
		//	Binding_AnyStatement | "iterate" Name? | "break" Name? | "return" Collection? | "yield" Binding_AnyStatement |
		//	"except" Binding_AnyStatement | "throw" Binding_AnyStatement | "goto" Id | "never";
		public ParserRule getRule() { return rule; }

		//Collection | "if" CommaItem "then" bbs=Binding_BalStatement "else" bas=Binding_AnyStatement | Collection "implies"
		//bas2=Binding_AnyStatement | Iterators "repeat" bas3=Binding_AnyStatement | "repeat" Binding_AnyStatement | "try"
		//Binding_AnyStatement "but" be=ButExpr apa=AlwaysPart_AnyStatement | "try" Binding_AnyStatement "catch" be=ButExpr
		//apa=AlwaysPart_AnyStatement | "select" Binding_AnyStatement "in" c=Cases | "do" Binding_AnyStatement | "delay"
		//Binding_AnyStatement | "reference" Binding_AnyStatement | "generate" GenBound bas4=Binding_AnyStatement | "assert"
		//Binding_AnyStatement | "iterate" Name? | "break" Name? | "return" Collection? | "yield" Binding_AnyStatement | "except"
		//Binding_AnyStatement | "throw" Binding_AnyStatement | "goto" Id | "never"
		public Alternatives getAlternatives() { return cAlternatives; }

		//Collection
		public RuleCall getCollectionParserRuleCall_0() { return cCollectionParserRuleCall_0; }

		//"if" CommaItem "then" bbs=Binding_BalStatement "else" bas=Binding_AnyStatement
		public Group getGroup_1() { return cGroup_1; }

		//"if"
		public Keyword getIfKeyword_1_0() { return cIfKeyword_1_0; }

		//CommaItem
		public RuleCall getCommaItemParserRuleCall_1_1() { return cCommaItemParserRuleCall_1_1; }

		//"then"
		public Keyword getThenKeyword_1_2() { return cThenKeyword_1_2; }

		//bbs=Binding_BalStatement
		public Assignment getBbsAssignment_1_3() { return cBbsAssignment_1_3; }

		//Binding_BalStatement
		public RuleCall getBbsBinding_BalStatementParserRuleCall_1_3_0() { return cBbsBinding_BalStatementParserRuleCall_1_3_0; }

		//"else"
		public Keyword getElseKeyword_1_4() { return cElseKeyword_1_4; }

		//bas=Binding_AnyStatement
		public Assignment getBasAssignment_1_5() { return cBasAssignment_1_5; }

		//Binding_AnyStatement
		public RuleCall getBasBinding_AnyStatementParserRuleCall_1_5_0() { return cBasBinding_AnyStatementParserRuleCall_1_5_0; }

		//Collection "implies" bas2=Binding_AnyStatement
		public Group getGroup_2() { return cGroup_2; }

		//Collection
		public RuleCall getCollectionParserRuleCall_2_0() { return cCollectionParserRuleCall_2_0; }

		//"implies"
		public Keyword getImpliesKeyword_2_1() { return cImpliesKeyword_2_1; }

		//bas2=Binding_AnyStatement
		public Assignment getBas2Assignment_2_2() { return cBas2Assignment_2_2; }

		//Binding_AnyStatement
		public RuleCall getBas2Binding_AnyStatementParserRuleCall_2_2_0() { return cBas2Binding_AnyStatementParserRuleCall_2_2_0; }

		//Iterators "repeat" bas3=Binding_AnyStatement
		public Group getGroup_3() { return cGroup_3; }

		//Iterators
		public RuleCall getIteratorsParserRuleCall_3_0() { return cIteratorsParserRuleCall_3_0; }

		//"repeat"
		public Keyword getRepeatKeyword_3_1() { return cRepeatKeyword_3_1; }

		//bas3=Binding_AnyStatement
		public Assignment getBas3Assignment_3_2() { return cBas3Assignment_3_2; }

		//Binding_AnyStatement
		public RuleCall getBas3Binding_AnyStatementParserRuleCall_3_2_0() { return cBas3Binding_AnyStatementParserRuleCall_3_2_0; }

		//"repeat" Binding_AnyStatement
		public Group getGroup_4() { return cGroup_4; }

		//"repeat"
		public Keyword getRepeatKeyword_4_0() { return cRepeatKeyword_4_0; }

		//Binding_AnyStatement
		public RuleCall getBinding_AnyStatementParserRuleCall_4_1() { return cBinding_AnyStatementParserRuleCall_4_1; }

		//"try" Binding_AnyStatement "but" be=ButExpr apa=AlwaysPart_AnyStatement
		public Group getGroup_5() { return cGroup_5; }

		//"try"
		public Keyword getTryKeyword_5_0() { return cTryKeyword_5_0; }

		//Binding_AnyStatement
		public RuleCall getBinding_AnyStatementParserRuleCall_5_1() { return cBinding_AnyStatementParserRuleCall_5_1; }

		//"but"
		public Keyword getButKeyword_5_2() { return cButKeyword_5_2; }

		//be=ButExpr
		public Assignment getBeAssignment_5_3() { return cBeAssignment_5_3; }

		//ButExpr
		public RuleCall getBeButExprParserRuleCall_5_3_0() { return cBeButExprParserRuleCall_5_3_0; }

		//apa=AlwaysPart_AnyStatement
		public Assignment getApaAssignment_5_4() { return cApaAssignment_5_4; }

		//AlwaysPart_AnyStatement
		public RuleCall getApaAlwaysPart_AnyStatementParserRuleCall_5_4_0() { return cApaAlwaysPart_AnyStatementParserRuleCall_5_4_0; }

		//"try" Binding_AnyStatement "catch" be=ButExpr apa=AlwaysPart_AnyStatement
		public Group getGroup_6() { return cGroup_6; }

		//"try"
		public Keyword getTryKeyword_6_0() { return cTryKeyword_6_0; }

		//Binding_AnyStatement
		public RuleCall getBinding_AnyStatementParserRuleCall_6_1() { return cBinding_AnyStatementParserRuleCall_6_1; }

		//"catch"
		public Keyword getCatchKeyword_6_2() { return cCatchKeyword_6_2; }

		//be=ButExpr
		public Assignment getBeAssignment_6_3() { return cBeAssignment_6_3; }

		//ButExpr
		public RuleCall getBeButExprParserRuleCall_6_3_0() { return cBeButExprParserRuleCall_6_3_0; }

		//apa=AlwaysPart_AnyStatement
		public Assignment getApaAssignment_6_4() { return cApaAssignment_6_4; }

		//AlwaysPart_AnyStatement
		public RuleCall getApaAlwaysPart_AnyStatementParserRuleCall_6_4_0() { return cApaAlwaysPart_AnyStatementParserRuleCall_6_4_0; }

		//"select" Binding_AnyStatement "in" c=Cases
		public Group getGroup_7() { return cGroup_7; }

		//"select"
		public Keyword getSelectKeyword_7_0() { return cSelectKeyword_7_0; }

		//Binding_AnyStatement
		public RuleCall getBinding_AnyStatementParserRuleCall_7_1() { return cBinding_AnyStatementParserRuleCall_7_1; }

		//"in"
		public Keyword getInKeyword_7_2() { return cInKeyword_7_2; }

		//c=Cases
		public Assignment getCAssignment_7_3() { return cCAssignment_7_3; }

		//Cases
		public RuleCall getCCasesParserRuleCall_7_3_0() { return cCCasesParserRuleCall_7_3_0; }

		//"do" Binding_AnyStatement
		public Group getGroup_8() { return cGroup_8; }

		//"do"
		public Keyword getDoKeyword_8_0() { return cDoKeyword_8_0; }

		//Binding_AnyStatement
		public RuleCall getBinding_AnyStatementParserRuleCall_8_1() { return cBinding_AnyStatementParserRuleCall_8_1; }

		//"delay" Binding_AnyStatement
		public Group getGroup_9() { return cGroup_9; }

		//"delay"
		public Keyword getDelayKeyword_9_0() { return cDelayKeyword_9_0; }

		//Binding_AnyStatement
		public RuleCall getBinding_AnyStatementParserRuleCall_9_1() { return cBinding_AnyStatementParserRuleCall_9_1; }

		//"reference" Binding_AnyStatement
		public Group getGroup_10() { return cGroup_10; }

		//"reference"
		public Keyword getReferenceKeyword_10_0() { return cReferenceKeyword_10_0; }

		//Binding_AnyStatement
		public RuleCall getBinding_AnyStatementParserRuleCall_10_1() { return cBinding_AnyStatementParserRuleCall_10_1; }

		//"generate" GenBound bas4=Binding_AnyStatement
		public Group getGroup_11() { return cGroup_11; }

		//"generate"
		public Keyword getGenerateKeyword_11_0() { return cGenerateKeyword_11_0; }

		//GenBound
		public RuleCall getGenBoundParserRuleCall_11_1() { return cGenBoundParserRuleCall_11_1; }

		//bas4=Binding_AnyStatement
		public Assignment getBas4Assignment_11_2() { return cBas4Assignment_11_2; }

		//Binding_AnyStatement
		public RuleCall getBas4Binding_AnyStatementParserRuleCall_11_2_0() { return cBas4Binding_AnyStatementParserRuleCall_11_2_0; }

		//"assert" Binding_AnyStatement
		public Group getGroup_12() { return cGroup_12; }

		//"assert"
		public Keyword getAssertKeyword_12_0() { return cAssertKeyword_12_0; }

		//Binding_AnyStatement
		public RuleCall getBinding_AnyStatementParserRuleCall_12_1() { return cBinding_AnyStatementParserRuleCall_12_1; }

		//"iterate" Name?
		public Group getGroup_13() { return cGroup_13; }

		//"iterate"
		public Keyword getIterateKeyword_13_0() { return cIterateKeyword_13_0; }

		//Name?
		public RuleCall getNameParserRuleCall_13_1() { return cNameParserRuleCall_13_1; }

		//"break" Name?
		public Group getGroup_14() { return cGroup_14; }

		//"break"
		public Keyword getBreakKeyword_14_0() { return cBreakKeyword_14_0; }

		//Name?
		public RuleCall getNameParserRuleCall_14_1() { return cNameParserRuleCall_14_1; }

		//"return" Collection?
		public Group getGroup_15() { return cGroup_15; }

		//"return"
		public Keyword getReturnKeyword_15_0() { return cReturnKeyword_15_0; }

		//Collection?
		public RuleCall getCollectionParserRuleCall_15_1() { return cCollectionParserRuleCall_15_1; }

		//"yield" Binding_AnyStatement
		public Group getGroup_16() { return cGroup_16; }

		//"yield"
		public Keyword getYieldKeyword_16_0() { return cYieldKeyword_16_0; }

		//Binding_AnyStatement
		public RuleCall getBinding_AnyStatementParserRuleCall_16_1() { return cBinding_AnyStatementParserRuleCall_16_1; }

		//"except" Binding_AnyStatement
		public Group getGroup_17() { return cGroup_17; }

		//"except"
		public Keyword getExceptKeyword_17_0() { return cExceptKeyword_17_0; }

		//Binding_AnyStatement
		public RuleCall getBinding_AnyStatementParserRuleCall_17_1() { return cBinding_AnyStatementParserRuleCall_17_1; }

		//"throw" Binding_AnyStatement
		public Group getGroup_18() { return cGroup_18; }

		//"throw"
		public Keyword getThrowKeyword_18_0() { return cThrowKeyword_18_0; }

		//Binding_AnyStatement
		public RuleCall getBinding_AnyStatementParserRuleCall_18_1() { return cBinding_AnyStatementParserRuleCall_18_1; }

		//"goto" Id
		public Group getGroup_19() { return cGroup_19; }

		//"goto"
		public Keyword getGotoKeyword_19_0() { return cGotoKeyword_19_0; }

		//Id
		public RuleCall getIdParserRuleCall_19_1() { return cIdParserRuleCall_19_1; }

		//"never"
		public Keyword getNeverKeyword_20() { return cNeverKeyword_20; }
	}

	public class Flow_BalStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Flow_BalStatement");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cCollectionParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Keyword cIfKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final RuleCall cCommaItemParserRuleCall_1_1 = (RuleCall)cGroup_1.eContents().get(1);
		private final Keyword cThenKeyword_1_2 = (Keyword)cGroup_1.eContents().get(2);
		private final Assignment cBbsAssignment_1_3 = (Assignment)cGroup_1.eContents().get(3);
		private final RuleCall cBbsBinding_BalStatementParserRuleCall_1_3_0 = (RuleCall)cBbsAssignment_1_3.eContents().get(0);
		private final Keyword cElseKeyword_1_4 = (Keyword)cGroup_1.eContents().get(4);
		private final Assignment cBbs2Assignment_1_5 = (Assignment)cGroup_1.eContents().get(5);
		private final RuleCall cBbs2Binding_BalStatementParserRuleCall_1_5_0 = (RuleCall)cBbs2Assignment_1_5.eContents().get(0);
		private final Group cGroup_2 = (Group)cAlternatives.eContents().get(2);
		private final RuleCall cCollectionParserRuleCall_2_0 = (RuleCall)cGroup_2.eContents().get(0);
		private final Keyword cImpliesKeyword_2_1 = (Keyword)cGroup_2.eContents().get(1);
		private final Assignment cBbs3Assignment_2_2 = (Assignment)cGroup_2.eContents().get(2);
		private final RuleCall cBbs3Binding_BalStatementParserRuleCall_2_2_0 = (RuleCall)cBbs3Assignment_2_2.eContents().get(0);
		private final Group cGroup_3 = (Group)cAlternatives.eContents().get(3);
		private final RuleCall cIteratorsParserRuleCall_3_0 = (RuleCall)cGroup_3.eContents().get(0);
		private final Keyword cRepeatKeyword_3_1 = (Keyword)cGroup_3.eContents().get(1);
		private final Assignment cBbs4Assignment_3_2 = (Assignment)cGroup_3.eContents().get(2);
		private final RuleCall cBbs4Binding_BalStatementParserRuleCall_3_2_0 = (RuleCall)cBbs4Assignment_3_2.eContents().get(0);
		private final Group cGroup_4 = (Group)cAlternatives.eContents().get(4);
		private final Keyword cRepeatKeyword_4_0 = (Keyword)cGroup_4.eContents().get(0);
		private final RuleCall cBinding_BalStatementParserRuleCall_4_1 = (RuleCall)cGroup_4.eContents().get(1);
		private final Group cGroup_5 = (Group)cAlternatives.eContents().get(5);
		private final Keyword cTryKeyword_5_0 = (Keyword)cGroup_5.eContents().get(0);
		private final RuleCall cBinding_AnyStatementParserRuleCall_5_1 = (RuleCall)cGroup_5.eContents().get(1);
		private final Keyword cButKeyword_5_2 = (Keyword)cGroup_5.eContents().get(2);
		private final Assignment cBeAssignment_5_3 = (Assignment)cGroup_5.eContents().get(3);
		private final RuleCall cBeButExprParserRuleCall_5_3_0 = (RuleCall)cBeAssignment_5_3.eContents().get(0);
		private final Assignment cApbAssignment_5_4 = (Assignment)cGroup_5.eContents().get(4);
		private final RuleCall cApbAlwaysPart_BalStatementParserRuleCall_5_4_0 = (RuleCall)cApbAssignment_5_4.eContents().get(0);
		private final Group cGroup_6 = (Group)cAlternatives.eContents().get(6);
		private final Keyword cTryKeyword_6_0 = (Keyword)cGroup_6.eContents().get(0);
		private final RuleCall cBinding_AnyStatementParserRuleCall_6_1 = (RuleCall)cGroup_6.eContents().get(1);
		private final Keyword cCatchKeyword_6_2 = (Keyword)cGroup_6.eContents().get(2);
		private final Assignment cBeAssignment_6_3 = (Assignment)cGroup_6.eContents().get(3);
		private final RuleCall cBeButExprParserRuleCall_6_3_0 = (RuleCall)cBeAssignment_6_3.eContents().get(0);
		private final Assignment cApbAssignment_6_4 = (Assignment)cGroup_6.eContents().get(4);
		private final RuleCall cApbAlwaysPart_BalStatementParserRuleCall_6_4_0 = (RuleCall)cApbAssignment_6_4.eContents().get(0);
		private final Group cGroup_7 = (Group)cAlternatives.eContents().get(7);
		private final Keyword cSelectKeyword_7_0 = (Keyword)cGroup_7.eContents().get(0);
		private final RuleCall cBinding_AnyStatementParserRuleCall_7_1 = (RuleCall)cGroup_7.eContents().get(1);
		private final Keyword cInKeyword_7_2 = (Keyword)cGroup_7.eContents().get(2);
		private final Assignment cCAssignment_7_3 = (Assignment)cGroup_7.eContents().get(3);
		private final RuleCall cCCasesParserRuleCall_7_3_0 = (RuleCall)cCAssignment_7_3.eContents().get(0);
		private final Group cGroup_8 = (Group)cAlternatives.eContents().get(8);
		private final Keyword cDoKeyword_8_0 = (Keyword)cGroup_8.eContents().get(0);
		private final RuleCall cBinding_BalStatementParserRuleCall_8_1 = (RuleCall)cGroup_8.eContents().get(1);
		private final Group cGroup_9 = (Group)cAlternatives.eContents().get(9);
		private final Keyword cDelayKeyword_9_0 = (Keyword)cGroup_9.eContents().get(0);
		private final RuleCall cBinding_BalStatementParserRuleCall_9_1 = (RuleCall)cGroup_9.eContents().get(1);
		private final Group cGroup_10 = (Group)cAlternatives.eContents().get(10);
		private final Keyword cReferenceKeyword_10_0 = (Keyword)cGroup_10.eContents().get(0);
		private final RuleCall cBinding_BalStatementParserRuleCall_10_1 = (RuleCall)cGroup_10.eContents().get(1);
		private final Group cGroup_11 = (Group)cAlternatives.eContents().get(11);
		private final Keyword cGenerateKeyword_11_0 = (Keyword)cGroup_11.eContents().get(0);
		private final RuleCall cGenBoundParserRuleCall_11_1 = (RuleCall)cGroup_11.eContents().get(1);
		private final Assignment cBbs5Assignment_11_2 = (Assignment)cGroup_11.eContents().get(2);
		private final RuleCall cBbs5Binding_BalStatementParserRuleCall_11_2_0 = (RuleCall)cBbs5Assignment_11_2.eContents().get(0);
		private final Group cGroup_12 = (Group)cAlternatives.eContents().get(12);
		private final Keyword cAssertKeyword_12_0 = (Keyword)cGroup_12.eContents().get(0);
		private final RuleCall cBinding_BalStatementParserRuleCall_12_1 = (RuleCall)cGroup_12.eContents().get(1);
		private final Group cGroup_13 = (Group)cAlternatives.eContents().get(13);
		private final Keyword cIterateKeyword_13_0 = (Keyword)cGroup_13.eContents().get(0);
		private final RuleCall cNameParserRuleCall_13_1 = (RuleCall)cGroup_13.eContents().get(1);
		private final Group cGroup_14 = (Group)cAlternatives.eContents().get(14);
		private final Keyword cBreakKeyword_14_0 = (Keyword)cGroup_14.eContents().get(0);
		private final RuleCall cNameParserRuleCall_14_1 = (RuleCall)cGroup_14.eContents().get(1);
		private final Group cGroup_15 = (Group)cAlternatives.eContents().get(15);
		private final Keyword cReturnKeyword_15_0 = (Keyword)cGroup_15.eContents().get(0);
		private final RuleCall cCollectionParserRuleCall_15_1 = (RuleCall)cGroup_15.eContents().get(1);
		private final Group cGroup_16 = (Group)cAlternatives.eContents().get(16);
		private final Keyword cYieldKeyword_16_0 = (Keyword)cGroup_16.eContents().get(0);
		private final RuleCall cBinding_BalStatementParserRuleCall_16_1 = (RuleCall)cGroup_16.eContents().get(1);
		private final Group cGroup_17 = (Group)cAlternatives.eContents().get(17);
		private final Keyword cExceptKeyword_17_0 = (Keyword)cGroup_17.eContents().get(0);
		private final RuleCall cBinding_BalStatementParserRuleCall_17_1 = (RuleCall)cGroup_17.eContents().get(1);
		private final Group cGroup_18 = (Group)cAlternatives.eContents().get(18);
		private final Keyword cThrowKeyword_18_0 = (Keyword)cGroup_18.eContents().get(0);
		private final RuleCall cBinding_BalStatementParserRuleCall_18_1 = (RuleCall)cGroup_18.eContents().get(1);
		private final Group cGroup_19 = (Group)cAlternatives.eContents().get(19);
		private final Keyword cGotoKeyword_19_0 = (Keyword)cGroup_19.eContents().get(0);
		private final RuleCall cIdParserRuleCall_19_1 = (RuleCall)cGroup_19.eContents().get(1);
		private final Keyword cNeverKeyword_20 = (Keyword)cAlternatives.eContents().get(20);
		
		//Flow_BalStatement hidden(WS, KW_NEWLINE):
		//	Collection | "if" CommaItem "then" bbs=Binding_BalStatement "else" bbs2=Binding_BalStatement | Collection "implies"
		//	bbs3=Binding_BalStatement | Iterators "repeat" bbs4=Binding_BalStatement | "repeat" Binding_BalStatement | "try"
		//	Binding_AnyStatement "but" be=ButExpr apb=AlwaysPart_BalStatement | "try" Binding_AnyStatement "catch" be=ButExpr
		//	apb=AlwaysPart_BalStatement | "select" Binding_AnyStatement "in" c=Cases | "do" Binding_BalStatement | "delay"
		//	Binding_BalStatement | "reference" Binding_BalStatement | "generate" GenBound bbs5=Binding_BalStatement | "assert"
		//	Binding_BalStatement | "iterate" Name? | "break" Name? | "return" Collection? | "yield" Binding_BalStatement |
		//	"except" Binding_BalStatement | "throw" Binding_BalStatement | "goto" Id | "never";
		public ParserRule getRule() { return rule; }

		//Collection | "if" CommaItem "then" bbs=Binding_BalStatement "else" bbs2=Binding_BalStatement | Collection "implies"
		//bbs3=Binding_BalStatement | Iterators "repeat" bbs4=Binding_BalStatement | "repeat" Binding_BalStatement | "try"
		//Binding_AnyStatement "but" be=ButExpr apb=AlwaysPart_BalStatement | "try" Binding_AnyStatement "catch" be=ButExpr
		//apb=AlwaysPart_BalStatement | "select" Binding_AnyStatement "in" c=Cases | "do" Binding_BalStatement | "delay"
		//Binding_BalStatement | "reference" Binding_BalStatement | "generate" GenBound bbs5=Binding_BalStatement | "assert"
		//Binding_BalStatement | "iterate" Name? | "break" Name? | "return" Collection? | "yield" Binding_BalStatement | "except"
		//Binding_BalStatement | "throw" Binding_BalStatement | "goto" Id | "never"
		public Alternatives getAlternatives() { return cAlternatives; }

		//Collection
		public RuleCall getCollectionParserRuleCall_0() { return cCollectionParserRuleCall_0; }

		//"if" CommaItem "then" bbs=Binding_BalStatement "else" bbs2=Binding_BalStatement
		public Group getGroup_1() { return cGroup_1; }

		//"if"
		public Keyword getIfKeyword_1_0() { return cIfKeyword_1_0; }

		//CommaItem
		public RuleCall getCommaItemParserRuleCall_1_1() { return cCommaItemParserRuleCall_1_1; }

		//"then"
		public Keyword getThenKeyword_1_2() { return cThenKeyword_1_2; }

		//bbs=Binding_BalStatement
		public Assignment getBbsAssignment_1_3() { return cBbsAssignment_1_3; }

		//Binding_BalStatement
		public RuleCall getBbsBinding_BalStatementParserRuleCall_1_3_0() { return cBbsBinding_BalStatementParserRuleCall_1_3_0; }

		//"else"
		public Keyword getElseKeyword_1_4() { return cElseKeyword_1_4; }

		//bbs2=Binding_BalStatement
		public Assignment getBbs2Assignment_1_5() { return cBbs2Assignment_1_5; }

		//Binding_BalStatement
		public RuleCall getBbs2Binding_BalStatementParserRuleCall_1_5_0() { return cBbs2Binding_BalStatementParserRuleCall_1_5_0; }

		//Collection "implies" bbs3=Binding_BalStatement
		public Group getGroup_2() { return cGroup_2; }

		//Collection
		public RuleCall getCollectionParserRuleCall_2_0() { return cCollectionParserRuleCall_2_0; }

		//"implies"
		public Keyword getImpliesKeyword_2_1() { return cImpliesKeyword_2_1; }

		//bbs3=Binding_BalStatement
		public Assignment getBbs3Assignment_2_2() { return cBbs3Assignment_2_2; }

		//Binding_BalStatement
		public RuleCall getBbs3Binding_BalStatementParserRuleCall_2_2_0() { return cBbs3Binding_BalStatementParserRuleCall_2_2_0; }

		//Iterators "repeat" bbs4=Binding_BalStatement
		public Group getGroup_3() { return cGroup_3; }

		//Iterators
		public RuleCall getIteratorsParserRuleCall_3_0() { return cIteratorsParserRuleCall_3_0; }

		//"repeat"
		public Keyword getRepeatKeyword_3_1() { return cRepeatKeyword_3_1; }

		//bbs4=Binding_BalStatement
		public Assignment getBbs4Assignment_3_2() { return cBbs4Assignment_3_2; }

		//Binding_BalStatement
		public RuleCall getBbs4Binding_BalStatementParserRuleCall_3_2_0() { return cBbs4Binding_BalStatementParserRuleCall_3_2_0; }

		//"repeat" Binding_BalStatement
		public Group getGroup_4() { return cGroup_4; }

		//"repeat"
		public Keyword getRepeatKeyword_4_0() { return cRepeatKeyword_4_0; }

		//Binding_BalStatement
		public RuleCall getBinding_BalStatementParserRuleCall_4_1() { return cBinding_BalStatementParserRuleCall_4_1; }

		//"try" Binding_AnyStatement "but" be=ButExpr apb=AlwaysPart_BalStatement
		public Group getGroup_5() { return cGroup_5; }

		//"try"
		public Keyword getTryKeyword_5_0() { return cTryKeyword_5_0; }

		//Binding_AnyStatement
		public RuleCall getBinding_AnyStatementParserRuleCall_5_1() { return cBinding_AnyStatementParserRuleCall_5_1; }

		//"but"
		public Keyword getButKeyword_5_2() { return cButKeyword_5_2; }

		//be=ButExpr
		public Assignment getBeAssignment_5_3() { return cBeAssignment_5_3; }

		//ButExpr
		public RuleCall getBeButExprParserRuleCall_5_3_0() { return cBeButExprParserRuleCall_5_3_0; }

		//apb=AlwaysPart_BalStatement
		public Assignment getApbAssignment_5_4() { return cApbAssignment_5_4; }

		//AlwaysPart_BalStatement
		public RuleCall getApbAlwaysPart_BalStatementParserRuleCall_5_4_0() { return cApbAlwaysPart_BalStatementParserRuleCall_5_4_0; }

		//"try" Binding_AnyStatement "catch" be=ButExpr apb=AlwaysPart_BalStatement
		public Group getGroup_6() { return cGroup_6; }

		//"try"
		public Keyword getTryKeyword_6_0() { return cTryKeyword_6_0; }

		//Binding_AnyStatement
		public RuleCall getBinding_AnyStatementParserRuleCall_6_1() { return cBinding_AnyStatementParserRuleCall_6_1; }

		//"catch"
		public Keyword getCatchKeyword_6_2() { return cCatchKeyword_6_2; }

		//be=ButExpr
		public Assignment getBeAssignment_6_3() { return cBeAssignment_6_3; }

		//ButExpr
		public RuleCall getBeButExprParserRuleCall_6_3_0() { return cBeButExprParserRuleCall_6_3_0; }

		//apb=AlwaysPart_BalStatement
		public Assignment getApbAssignment_6_4() { return cApbAssignment_6_4; }

		//AlwaysPart_BalStatement
		public RuleCall getApbAlwaysPart_BalStatementParserRuleCall_6_4_0() { return cApbAlwaysPart_BalStatementParserRuleCall_6_4_0; }

		//"select" Binding_AnyStatement "in" c=Cases
		public Group getGroup_7() { return cGroup_7; }

		//"select"
		public Keyword getSelectKeyword_7_0() { return cSelectKeyword_7_0; }

		//Binding_AnyStatement
		public RuleCall getBinding_AnyStatementParserRuleCall_7_1() { return cBinding_AnyStatementParserRuleCall_7_1; }

		//"in"
		public Keyword getInKeyword_7_2() { return cInKeyword_7_2; }

		//c=Cases
		public Assignment getCAssignment_7_3() { return cCAssignment_7_3; }

		//Cases
		public RuleCall getCCasesParserRuleCall_7_3_0() { return cCCasesParserRuleCall_7_3_0; }

		//"do" Binding_BalStatement
		public Group getGroup_8() { return cGroup_8; }

		//"do"
		public Keyword getDoKeyword_8_0() { return cDoKeyword_8_0; }

		//Binding_BalStatement
		public RuleCall getBinding_BalStatementParserRuleCall_8_1() { return cBinding_BalStatementParserRuleCall_8_1; }

		//"delay" Binding_BalStatement
		public Group getGroup_9() { return cGroup_9; }

		//"delay"
		public Keyword getDelayKeyword_9_0() { return cDelayKeyword_9_0; }

		//Binding_BalStatement
		public RuleCall getBinding_BalStatementParserRuleCall_9_1() { return cBinding_BalStatementParserRuleCall_9_1; }

		//"reference" Binding_BalStatement
		public Group getGroup_10() { return cGroup_10; }

		//"reference"
		public Keyword getReferenceKeyword_10_0() { return cReferenceKeyword_10_0; }

		//Binding_BalStatement
		public RuleCall getBinding_BalStatementParserRuleCall_10_1() { return cBinding_BalStatementParserRuleCall_10_1; }

		//"generate" GenBound bbs5=Binding_BalStatement
		public Group getGroup_11() { return cGroup_11; }

		//"generate"
		public Keyword getGenerateKeyword_11_0() { return cGenerateKeyword_11_0; }

		//GenBound
		public RuleCall getGenBoundParserRuleCall_11_1() { return cGenBoundParserRuleCall_11_1; }

		//bbs5=Binding_BalStatement
		public Assignment getBbs5Assignment_11_2() { return cBbs5Assignment_11_2; }

		//Binding_BalStatement
		public RuleCall getBbs5Binding_BalStatementParserRuleCall_11_2_0() { return cBbs5Binding_BalStatementParserRuleCall_11_2_0; }

		//"assert" Binding_BalStatement
		public Group getGroup_12() { return cGroup_12; }

		//"assert"
		public Keyword getAssertKeyword_12_0() { return cAssertKeyword_12_0; }

		//Binding_BalStatement
		public RuleCall getBinding_BalStatementParserRuleCall_12_1() { return cBinding_BalStatementParserRuleCall_12_1; }

		//"iterate" Name?
		public Group getGroup_13() { return cGroup_13; }

		//"iterate"
		public Keyword getIterateKeyword_13_0() { return cIterateKeyword_13_0; }

		//Name?
		public RuleCall getNameParserRuleCall_13_1() { return cNameParserRuleCall_13_1; }

		//"break" Name?
		public Group getGroup_14() { return cGroup_14; }

		//"break"
		public Keyword getBreakKeyword_14_0() { return cBreakKeyword_14_0; }

		//Name?
		public RuleCall getNameParserRuleCall_14_1() { return cNameParserRuleCall_14_1; }

		//"return" Collection?
		public Group getGroup_15() { return cGroup_15; }

		//"return"
		public Keyword getReturnKeyword_15_0() { return cReturnKeyword_15_0; }

		//Collection?
		public RuleCall getCollectionParserRuleCall_15_1() { return cCollectionParserRuleCall_15_1; }

		//"yield" Binding_BalStatement
		public Group getGroup_16() { return cGroup_16; }

		//"yield"
		public Keyword getYieldKeyword_16_0() { return cYieldKeyword_16_0; }

		//Binding_BalStatement
		public RuleCall getBinding_BalStatementParserRuleCall_16_1() { return cBinding_BalStatementParserRuleCall_16_1; }

		//"except" Binding_BalStatement
		public Group getGroup_17() { return cGroup_17; }

		//"except"
		public Keyword getExceptKeyword_17_0() { return cExceptKeyword_17_0; }

		//Binding_BalStatement
		public RuleCall getBinding_BalStatementParserRuleCall_17_1() { return cBinding_BalStatementParserRuleCall_17_1; }

		//"throw" Binding_BalStatement
		public Group getGroup_18() { return cGroup_18; }

		//"throw"
		public Keyword getThrowKeyword_18_0() { return cThrowKeyword_18_0; }

		//Binding_BalStatement
		public RuleCall getBinding_BalStatementParserRuleCall_18_1() { return cBinding_BalStatementParserRuleCall_18_1; }

		//"goto" Id
		public Group getGroup_19() { return cGroup_19; }

		//"goto"
		public Keyword getGotoKeyword_19_0() { return cGotoKeyword_19_0; }

		//Id
		public RuleCall getIdParserRuleCall_19_1() { return cIdParserRuleCall_19_1; }

		//"never"
		public Keyword getNeverKeyword_20() { return cNeverKeyword_20; }
	}

	public class GenBoundElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "GenBound");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cToKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final RuleCall cCommaItemParserRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Keyword cOfKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		//GenBound hidden(WS, KW_NEWLINE):
		//	("to" CommaItem "of")?;
		public ParserRule getRule() { return rule; }

		//("to" CommaItem "of")?
		public Group getGroup() { return cGroup; }

		//"to"
		public Keyword getToKeyword_0() { return cToKeyword_0; }

		//CommaItem
		public RuleCall getCommaItemParserRuleCall_1() { return cCommaItemParserRuleCall_1; }

		//"of"
		public Keyword getOfKeyword_2() { return cOfKeyword_2; }
	}

	public class ButExprElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ButExpr");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cDbAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cDbDeclBindingParserRuleCall_0_0 = (RuleCall)cDbAssignment_0.eContents().get(0);
		private final Keyword cInKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cCaAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cCaCasesParserRuleCall_2_0 = (RuleCall)cCaAssignment_2.eContents().get(0);
		
		//ButExpr hidden(WS, KW_NEWLINE):
		//	(db=DeclBinding "in" ca=Cases)?;
		public ParserRule getRule() { return rule; }

		//(db=DeclBinding "in" ca=Cases)?
		public Group getGroup() { return cGroup; }

		//db=DeclBinding
		public Assignment getDbAssignment_0() { return cDbAssignment_0; }

		//DeclBinding
		public RuleCall getDbDeclBindingParserRuleCall_0_0() { return cDbDeclBindingParserRuleCall_0_0; }

		//"in"
		public Keyword getInKeyword_1() { return cInKeyword_1; }

		//ca=Cases
		public Assignment getCaAssignment_2() { return cCaAssignment_2; }

		//Cases
		public RuleCall getCaCasesParserRuleCall_2_0() { return cCaCasesParserRuleCall_2_0; }
	}

	public class CasesElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Cases");
		private final RuleCall cBinding_CollectionParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//Cases hidden(WS, KW_NEWLINE):
		//	Binding_Collection;
		public ParserRule getRule() { return rule; }

		//Binding_Collection
		public RuleCall getBinding_CollectionParserRuleCall() { return cBinding_CollectionParserRuleCall; }
	}

	public class AlwaysPart_AnyStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "AlwaysPart_AnyStatement");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Keyword cAlwaysKeyword_0_0 = (Keyword)cGroup_0.eContents().get(0);
		private final RuleCall cBinding_AnyStatementParserRuleCall_0_1 = (RuleCall)cGroup_0.eContents().get(1);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Keyword cFinallyKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final RuleCall cBinding_AnyStatementParserRuleCall_1_1 = (RuleCall)cGroup_1.eContents().get(1);
		
		/// * Substituted Rules in Xtext:
		// * AlwaysPart(XX) -> AlwaysPart_AnyStatement
		// *                or AlwaysPart_BalStatement
		// * AlwaysPart(XX)
		// * : KW_Always Binding(XX)
		// * { (void)parseDeprecated(KW_Always, abNewNothing(TPOS($1))); $$ = $2; }
		// * | KW_Finally Binding(XX)
		// * { $$ = $2; }
		// * | Nothing
		////;
		// * / AlwaysPart_AnyStatement hidden(WS, KW_NEWLINE):
		//	("always" Binding_AnyStatement | "finally" Binding_AnyStatement)?;
		public ParserRule getRule() { return rule; }

		//("always" Binding_AnyStatement | "finally" Binding_AnyStatement)?
		public Alternatives getAlternatives() { return cAlternatives; }

		//"always" Binding_AnyStatement
		public Group getGroup_0() { return cGroup_0; }

		//"always"
		public Keyword getAlwaysKeyword_0_0() { return cAlwaysKeyword_0_0; }

		//Binding_AnyStatement
		public RuleCall getBinding_AnyStatementParserRuleCall_0_1() { return cBinding_AnyStatementParserRuleCall_0_1; }

		//"finally" Binding_AnyStatement
		public Group getGroup_1() { return cGroup_1; }

		//"finally"
		public Keyword getFinallyKeyword_1_0() { return cFinallyKeyword_1_0; }

		//Binding_AnyStatement
		public RuleCall getBinding_AnyStatementParserRuleCall_1_1() { return cBinding_AnyStatementParserRuleCall_1_1; }
	}

	public class AlwaysPart_BalStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "AlwaysPart_BalStatement");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Keyword cAlwaysKeyword_0_0 = (Keyword)cGroup_0.eContents().get(0);
		private final RuleCall cBinding_BalStatementParserRuleCall_0_1 = (RuleCall)cGroup_0.eContents().get(1);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Keyword cFinallyKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final RuleCall cBinding_BalStatementParserRuleCall_1_1 = (RuleCall)cGroup_1.eContents().get(1);
		
		//AlwaysPart_BalStatement hidden(WS, KW_NEWLINE):
		//	("always" Binding_BalStatement | "finally" Binding_BalStatement)?;
		public ParserRule getRule() { return rule; }

		//("always" Binding_BalStatement | "finally" Binding_BalStatement)?
		public Alternatives getAlternatives() { return cAlternatives; }

		//"always" Binding_BalStatement
		public Group getGroup_0() { return cGroup_0; }

		//"always"
		public Keyword getAlwaysKeyword_0_0() { return cAlwaysKeyword_0_0; }

		//Binding_BalStatement
		public RuleCall getBinding_BalStatementParserRuleCall_0_1() { return cBinding_BalStatementParserRuleCall_0_1; }

		//"finally" Binding_BalStatement
		public Group getGroup_1() { return cGroup_1; }

		//"finally"
		public Keyword getFinallyKeyword_1_0() { return cFinallyKeyword_1_0; }

		//Binding_BalStatement
		public RuleCall getBinding_BalStatementParserRuleCall_1_1() { return cBinding_BalStatementParserRuleCall_1_1; }
	}

	public class CollectionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Collection");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cInfixedParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Assignment cIAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cIIteratorsParserRuleCall_1_0 = (RuleCall)cIAssignment_1.eContents().get(0);
		
		/// *
		// * Iterators
		// * / Collection hidden(WS, KW_NEWLINE):
		//	Infixed i=Iterators?;
		public ParserRule getRule() { return rule; }

		//Infixed i=Iterators?
		public Group getGroup() { return cGroup; }

		//Infixed
		public RuleCall getInfixedParserRuleCall_0() { return cInfixedParserRuleCall_0; }

		//i=Iterators?
		public Assignment getIAssignment_1() { return cIAssignment_1; }

		//Iterators
		public RuleCall getIIteratorsParserRuleCall_1_0() { return cIIteratorsParserRuleCall_1_0; }
	}

	public class IteratorsElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Iterators");
		private final RuleCall cIterators1ParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//Iterators hidden(WS, KW_NEWLINE):
		//	Iterators1;
		public ParserRule getRule() { return rule; }

		//Iterators1
		public RuleCall getIterators1ParserRuleCall() { return cIterators1ParserRuleCall; }
	}

	public class Iterators1Elements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Iterators1");
		private final Keyword cTemp27Keyword = (Keyword)rule.eContents().get(1);
		
		//// left recursive when following uncommented
		//// Iterator
		////| Iterators1 itr=Iterator
		//Iterators1 hidden(WS, KW_NEWLINE):
		//	"temp27";
		public ParserRule getRule() { return rule; }

		//"temp27"
		public Keyword getTemp27Keyword() { return cTemp27Keyword; }
	}

	public class IteratorElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Iterator");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Keyword cForKeyword_0_0 = (Keyword)cGroup_0.eContents().get(0);
		private final RuleCall cForLhsParserRuleCall_0_1 = (RuleCall)cGroup_0.eContents().get(1);
		private final Keyword cInKeyword_0_2 = (Keyword)cGroup_0.eContents().get(2);
		private final Assignment cIAssignment_0_3 = (Assignment)cGroup_0.eContents().get(3);
		private final RuleCall cIInfixedParserRuleCall_0_3_0 = (RuleCall)cIAssignment_0_3.eContents().get(0);
		private final Assignment cSpAssignment_0_4 = (Assignment)cGroup_0.eContents().get(4);
		private final RuleCall cSpSuchthatPartParserRuleCall_0_4_0 = (RuleCall)cSpAssignment_0_4.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Keyword cWhileKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final RuleCall cInfixedParserRuleCall_1_1 = (RuleCall)cGroup_1.eContents().get(1);
		
		//Iterator:
		//	"for" ForLhs "in" i=Infixed sp=SuchthatPart? | "while" Infixed;
		public ParserRule getRule() { return rule; }

		//"for" ForLhs "in" i=Infixed sp=SuchthatPart? | "while" Infixed
		public Alternatives getAlternatives() { return cAlternatives; }

		//"for" ForLhs "in" i=Infixed sp=SuchthatPart?
		public Group getGroup_0() { return cGroup_0; }

		//"for"
		public Keyword getForKeyword_0_0() { return cForKeyword_0_0; }

		//ForLhs
		public RuleCall getForLhsParserRuleCall_0_1() { return cForLhsParserRuleCall_0_1; }

		//"in"
		public Keyword getInKeyword_0_2() { return cInKeyword_0_2; }

		//i=Infixed
		public Assignment getIAssignment_0_3() { return cIAssignment_0_3; }

		//Infixed
		public RuleCall getIInfixedParserRuleCall_0_3_0() { return cIInfixedParserRuleCall_0_3_0; }

		//sp=SuchthatPart?
		public Assignment getSpAssignment_0_4() { return cSpAssignment_0_4; }

		//SuchthatPart
		public RuleCall getSpSuchthatPartParserRuleCall_0_4_0() { return cSpSuchthatPartParserRuleCall_0_4_0; }

		//"while" Infixed
		public Group getGroup_1() { return cGroup_1; }

		//"while"
		public Keyword getWhileKeyword_1_0() { return cWhileKeyword_1_0; }

		//Infixed
		public RuleCall getInfixedParserRuleCall_1_1() { return cInfixedParserRuleCall_1_1; }
	}

	public class ForLhsElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ForLhs");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cInfixedParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Keyword cFreeKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final RuleCall cInfixedParserRuleCall_1_1 = (RuleCall)cGroup_1.eContents().get(1);
		private final Group cGroup_2 = (Group)cAlternatives.eContents().get(2);
		private final Keyword cLocalKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final RuleCall cInfixedParserRuleCall_2_1 = (RuleCall)cGroup_2.eContents().get(1);
		private final Group cGroup_3 = (Group)cAlternatives.eContents().get(3);
		private final Keyword cFluidKeyword_3_0 = (Keyword)cGroup_3.eContents().get(0);
		private final RuleCall cInfixedParserRuleCall_3_1 = (RuleCall)cGroup_3.eContents().get(1);
		
		//ForLhs:
		//	Infixed | "free" Infixed | "local" Infixed | "fluid" Infixed;
		public ParserRule getRule() { return rule; }

		//Infixed | "free" Infixed | "local" Infixed | "fluid" Infixed
		public Alternatives getAlternatives() { return cAlternatives; }

		//Infixed
		public RuleCall getInfixedParserRuleCall_0() { return cInfixedParserRuleCall_0; }

		//"free" Infixed
		public Group getGroup_1() { return cGroup_1; }

		//"free"
		public Keyword getFreeKeyword_1_0() { return cFreeKeyword_1_0; }

		//Infixed
		public RuleCall getInfixedParserRuleCall_1_1() { return cInfixedParserRuleCall_1_1; }

		//"local" Infixed
		public Group getGroup_2() { return cGroup_2; }

		//"local"
		public Keyword getLocalKeyword_2_0() { return cLocalKeyword_2_0; }

		//Infixed
		public RuleCall getInfixedParserRuleCall_2_1() { return cInfixedParserRuleCall_2_1; }

		//"fluid" Infixed
		public Group getGroup_3() { return cGroup_3; }

		//"fluid"
		public Keyword getFluidKeyword_3_0() { return cFluidKeyword_3_0; }

		//Infixed
		public RuleCall getInfixedParserRuleCall_3_1() { return cInfixedParserRuleCall_3_1; }
	}

	public class SuchthatPartElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "SuchthatPart");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cTemp30Keyword_0 = (Keyword)cGroup.eContents().get(0);
		private final RuleCall cKW_BARTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final RuleCall cInfixedParserRuleCall_2 = (RuleCall)cGroup.eContents().get(2);
		
		//SuchthatPart hidden(WS, KW_NEWLINE):
		//	"temp30" KW_BAR Infixed;
		public ParserRule getRule() { return rule; }

		//"temp30" KW_BAR Infixed
		public Group getGroup() { return cGroup; }

		//"temp30"
		public Keyword getTemp30Keyword_0() { return cTemp30Keyword_0; }

		//KW_BAR
		public RuleCall getKW_BARTerminalRuleCall_1() { return cKW_BARTerminalRuleCall_1; }

		//Infixed
		public RuleCall getInfixedParserRuleCall_2() { return cInfixedParserRuleCall_2; }
	}

	public class InfixedElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Infixed");
		private final Keyword cTemp31Keyword = (Keyword)rule.eContents().get(1);
		
		/// *
		// * Infixed Expressions
		// * / // causes constraint error when following is uncommented
		//// InfixedExpr DeclPart*
		//// | Block
		//Infixed hidden(WS, KW_NEWLINE):
		//	"temp31";
		public ParserRule getRule() { return rule; }

		//"temp31"
		public Keyword getTemp31Keyword() { return cTemp31Keyword; }
	}

	public class InfixedExprElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "InfixedExpr");
		private final Keyword cTemp32Keyword = (Keyword)rule.eContents().get(1);
		
		//// E11(Op)
		////| E3
		//InfixedExpr hidden(WS, KW_NEWLINE):
		//	"temp32";
		public ParserRule getRule() { return rule; }

		//"temp32"
		public Keyword getTemp32Keyword() { return cTemp32Keyword; }
	}

	public class TypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Type");
		private final Keyword cTemp41Keyword = (Keyword)rule.eContents().get(1);
		
		////E3
		////: E4
		////| E3 KW_And E4
		////{ $$ = abNewAnd(TPOS($2), TEST($1),TEST($3)); }
		////| E3 KW_Or E4
		////{ $$ = abNewOr(TPOS($2), TEST($1),TEST($3)); }
		////| E3 LatticeOp E4
		////{ $$ = abNewInfix(APOS($2),$2,$1,$3); }
		////;
		////E4
		////: E5
		////| E4 KW_Has E5
		////{ $$ = abNewHas(TPOS($2),$1,$3); }
		////| E4 RelationOp E5
		////{ $$ = abNewInfix(APOS($2),$2,$1,$3); }
		////| RelationOp E5
		////{ $$ = abNewPrefix(APOS($1),$1,$2); }
		////;
		////E5
		////: E6
		////| E5 SegOp
		////{ $$ = abNewPostfix(APOS($2),$2,$1); }
		////| E5 SegOp E6
		////{ $$ = abNewInfix(APOS($2),$2,$1,$3); }
		////;
		////E6
		////: E7
		////| E6 PlusOp E7
		////{ $$ = abNewInfix(APOS($2),$2,$1,$3); }
		////| PlusOp E7
		////{ $$ = abNewPrefix(APOS($1),$1,$2); }
		////;
		////E7
		////: E8
		////| E7 QuotientOp E8
		////{ $$ = abNewInfix(APOS($2),$2,$1,$3); }
		////;
		////E8
		////: E9
		////| E8 TimesOp E9
		////{ $$ = abNewInfix(APOS($2),$2,$1,$3); }
		////;
		////E9
		////: E11(E12)
		////| E11(E12) PowerOp E9
		////{ $$ = abNewInfix(APOS($2),$2,$1,$3); }
		////;
		/// * Substituted Rules in Xtext:
		// * E11_E12
		// * E11_Op
		// * / //E11(X)
		////: X
		////| E11(X) KW_2Colon E12
		////{ $$ = abNewCoerceTo(TPOS($2),$1,$3); }
		////| E11(X) KW_At E12
		////{ $$ = abNewRestrictTo(TPOS($2),$1,$3); }
		////| E11(X) KW_Pretend E12
		////{ $$ = abNewPretendTo(TPOS($2),$1,$3); }
		////;
		//// E11(E12)
		//Type hidden(WS, KW_NEWLINE):
		//	"temp41";
		public ParserRule getRule() { return rule; }

		//"temp41"
		public Keyword getTemp41Keyword() { return cTemp41Keyword; }
	}

	public class OpQualTailElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "OpQualTail");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final RuleCall cNameMoleculeParserRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Group cGroup_1_0 = (Group)cGroup_1.eContents().get(0);
		private final Assignment cNameAssignment_1_0_0 = (Assignment)cGroup_1_0.eContents().get(0);
		private final RuleCall cNameMoleculeParserRuleCall_1_0_0_0 = (RuleCall)cNameAssignment_1_0_0.eContents().get(0);
		private final RuleCall cKW_DOLLARTerminalRuleCall_1_0_1 = (RuleCall)cGroup_1_0.eContents().get(1);
		private final RuleCall cOpQualTailParserRuleCall_1_0_2 = (RuleCall)cGroup_1_0.eContents().get(2);
		
		////E12
		////: E13
		////| E13 ArrowOp E12
		////{ $$ = abNewInfix(APOS($2),$2,$1,$3); }
		////;
		////E13
		////: E14
		////| E14 KW_DOLLAR QualTail
		////{ $$ = abNewQualify(TPOS($2),$1,$3); }
		////;
		////QualTail
		////: LeftJuxtaposed
		////| LeftJuxtaposed KW_DOLLAR QualTail
		////{ $$ = abNewQualify(TPOS($2),$1,$3); }
		////;
		//OpQualTail hidden(WS, KW_NEWLINE):
		//	name=Molecule | => (name=Molecule KW_DOLLAR OpQualTail);
		public ParserRule getRule() { return rule; }

		//name=Molecule | => (name=Molecule KW_DOLLAR OpQualTail)
		public Alternatives getAlternatives() { return cAlternatives; }

		//name=Molecule
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }

		//Molecule
		public RuleCall getNameMoleculeParserRuleCall_0_0() { return cNameMoleculeParserRuleCall_0_0; }

		//=> (name=Molecule KW_DOLLAR OpQualTail)
		public Group getGroup_1() { return cGroup_1; }

		//name=Molecule KW_DOLLAR OpQualTail
		public Group getGroup_1_0() { return cGroup_1_0; }

		//name=Molecule
		public Assignment getNameAssignment_1_0_0() { return cNameAssignment_1_0_0; }

		//Molecule
		public RuleCall getNameMoleculeParserRuleCall_1_0_0_0() { return cNameMoleculeParserRuleCall_1_0_0_0; }

		//KW_DOLLAR
		public RuleCall getKW_DOLLARTerminalRuleCall_1_0_1() { return cKW_DOLLARTerminalRuleCall_1_0_1; }

		//OpQualTail
		public RuleCall getOpQualTailParserRuleCall_1_0_2() { return cOpQualTailParserRuleCall_1_0_2; }
	}

	public class E14Elements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "E14");
		private final Keyword cTemp46Keyword = (Keyword)rule.eContents().get(1);
		
		////: E15
		////| opt(E14) KW_With DeclMolecule
		////{ $$ = abNewWith(TPOS($2),$1,$3); }
		////| opt(E14) KW_Add DeclMolecule
		////{ $$ = abNewAdd(TPOS($2),$1,$3); }
		////| E14 KW_Except E15
		////{ $$ = parseDeprecated(KW_Except, abNewExcept(TPOS($2),$1,$3)); }
		////| E14 KW_Throw E15
		////{ $$ = abNewExcept(TPOS($2),$1,$3); }
		//E14 hidden(WS, KW_NEWLINE):
		//	"temp46";
		public ParserRule getRule() { return rule; }

		//"temp46"
		public Keyword getTemp46Keyword() { return cTemp46Keyword; }
	}

	public class E15Elements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "E15");
		private final RuleCall cApplicationParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//E15 hidden(WS, KW_NEWLINE):
		//	Application;
		public ParserRule getRule() { return rule; }

		//Application
		public RuleCall getApplicationParserRuleCall() { return cApplicationParserRuleCall; }
	}

	public class OpElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Op");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cArrowOpParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cLatticeOpParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cRelationOpParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cSegOpParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cPlusOpParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		private final RuleCall cQuotientOpParserRuleCall_5 = (RuleCall)cAlternatives.eContents().get(5);
		private final RuleCall cTimesOpParserRuleCall_6 = (RuleCall)cAlternatives.eContents().get(6);
		private final RuleCall cPowerOpParserRuleCall_7 = (RuleCall)cAlternatives.eContents().get(7);
		
		/// *
		// * Infixed Operations
		// * / Op hidden(WS, KW_NEWLINE):
		//	ArrowOp | LatticeOp | RelationOp | SegOp | PlusOp | QuotientOp | TimesOp | PowerOp;
		public ParserRule getRule() { return rule; }

		//ArrowOp | LatticeOp | RelationOp | SegOp | PlusOp | QuotientOp | TimesOp | PowerOp
		public Alternatives getAlternatives() { return cAlternatives; }

		//ArrowOp
		public RuleCall getArrowOpParserRuleCall_0() { return cArrowOpParserRuleCall_0; }

		//LatticeOp
		public RuleCall getLatticeOpParserRuleCall_1() { return cLatticeOpParserRuleCall_1; }

		//RelationOp
		public RuleCall getRelationOpParserRuleCall_2() { return cRelationOpParserRuleCall_2; }

		//SegOp
		public RuleCall getSegOpParserRuleCall_3() { return cSegOpParserRuleCall_3; }

		//PlusOp
		public RuleCall getPlusOpParserRuleCall_4() { return cPlusOpParserRuleCall_4; }

		//QuotientOp
		public RuleCall getQuotientOpParserRuleCall_5() { return cQuotientOpParserRuleCall_5; }

		//TimesOp
		public RuleCall getTimesOpParserRuleCall_6() { return cTimesOpParserRuleCall_6; }

		//PowerOp
		public RuleCall getPowerOpParserRuleCall_7() { return cPowerOpParserRuleCall_7; }
	}

	public class NakedOpElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "NakedOp");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cUnqualOp_ArrowTokParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cUnqualOp_LatticeTokParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cUnqualOp_RelationTokParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cUnqualOp_SegTokParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cUnqualOp_PlusTokParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		private final RuleCall cUnqualOp_QuotientTokParserRuleCall_5 = (RuleCall)cAlternatives.eContents().get(5);
		private final RuleCall cUnqualOp_TimesTokParserRuleCall_6 = (RuleCall)cAlternatives.eContents().get(6);
		private final RuleCall cUnqualOp_PowerTokParserRuleCall_7 = (RuleCall)cAlternatives.eContents().get(7);
		
		//NakedOp hidden(WS, KW_NEWLINE):
		//	UnqualOp_ArrowTok | UnqualOp_LatticeTok | UnqualOp_RelationTok | UnqualOp_SegTok | UnqualOp_PlusTok |
		//	UnqualOp_QuotientTok | UnqualOp_TimesTok | UnqualOp_PowerTok;
		public ParserRule getRule() { return rule; }

		//UnqualOp_ArrowTok | UnqualOp_LatticeTok | UnqualOp_RelationTok | UnqualOp_SegTok | UnqualOp_PlusTok |
		//UnqualOp_QuotientTok | UnqualOp_TimesTok | UnqualOp_PowerTok
		public Alternatives getAlternatives() { return cAlternatives; }

		//UnqualOp_ArrowTok
		public RuleCall getUnqualOp_ArrowTokParserRuleCall_0() { return cUnqualOp_ArrowTokParserRuleCall_0; }

		//UnqualOp_LatticeTok
		public RuleCall getUnqualOp_LatticeTokParserRuleCall_1() { return cUnqualOp_LatticeTokParserRuleCall_1; }

		//UnqualOp_RelationTok
		public RuleCall getUnqualOp_RelationTokParserRuleCall_2() { return cUnqualOp_RelationTokParserRuleCall_2; }

		//UnqualOp_SegTok
		public RuleCall getUnqualOp_SegTokParserRuleCall_3() { return cUnqualOp_SegTokParserRuleCall_3; }

		//UnqualOp_PlusTok
		public RuleCall getUnqualOp_PlusTokParserRuleCall_4() { return cUnqualOp_PlusTokParserRuleCall_4; }

		//UnqualOp_QuotientTok
		public RuleCall getUnqualOp_QuotientTokParserRuleCall_5() { return cUnqualOp_QuotientTokParserRuleCall_5; }

		//UnqualOp_TimesTok
		public RuleCall getUnqualOp_TimesTokParserRuleCall_6() { return cUnqualOp_TimesTokParserRuleCall_6; }

		//UnqualOp_PowerTok
		public RuleCall getUnqualOp_PowerTokParserRuleCall_7() { return cUnqualOp_PowerTokParserRuleCall_7; }
	}

	public class ArrowOpElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ArrowOp");
		private final RuleCall cQualOp_ArrowTokParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//ArrowOp:
		//	QualOp_ArrowTok;
		public ParserRule getRule() { return rule; }

		//QualOp_ArrowTok
		public RuleCall getQualOp_ArrowTokParserRuleCall() { return cQualOp_ArrowTokParserRuleCall; }
	}

	public class LatticeOpElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "LatticeOp");
		private final RuleCall cQualOp_LatticeTokParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//LatticeOp:
		//	QualOp_LatticeTok;
		public ParserRule getRule() { return rule; }

		//QualOp_LatticeTok
		public RuleCall getQualOp_LatticeTokParserRuleCall() { return cQualOp_LatticeTokParserRuleCall; }
	}

	public class RelationOpElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "RelationOp");
		private final RuleCall cQualOp_RelationTokParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//RelationOp:
		//	QualOp_RelationTok;
		public ParserRule getRule() { return rule; }

		//QualOp_RelationTok
		public RuleCall getQualOp_RelationTokParserRuleCall() { return cQualOp_RelationTokParserRuleCall; }
	}

	public class SegOpElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "SegOp");
		private final RuleCall cQualOp_SegTokParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//SegOp:
		//	QualOp_SegTok;
		public ParserRule getRule() { return rule; }

		//QualOp_SegTok
		public RuleCall getQualOp_SegTokParserRuleCall() { return cQualOp_SegTokParserRuleCall; }
	}

	public class PlusOpElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PlusOp");
		private final RuleCall cQualOp_PlusTokParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//PlusOp:
		//	QualOp_PlusTok;
		public ParserRule getRule() { return rule; }

		//QualOp_PlusTok
		public RuleCall getQualOp_PlusTokParserRuleCall() { return cQualOp_PlusTokParserRuleCall; }
	}

	public class QuotientOpElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "QuotientOp");
		private final RuleCall cQualOp_QuotientTokParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//QuotientOp:
		//	QualOp_QuotientTok;
		public ParserRule getRule() { return rule; }

		//QualOp_QuotientTok
		public RuleCall getQualOp_QuotientTokParserRuleCall() { return cQualOp_QuotientTokParserRuleCall; }
	}

	public class TimesOpElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "TimesOp");
		private final RuleCall cQualOp_TimesTokParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//TimesOp:
		//	QualOp_TimesTok;
		public ParserRule getRule() { return rule; }

		//QualOp_TimesTok
		public RuleCall getQualOp_TimesTokParserRuleCall() { return cQualOp_TimesTokParserRuleCall; }
	}

	public class PowerOpElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PowerOp");
		private final RuleCall cQualOp_PowerTokParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//PowerOp:
		//	QualOp_PowerTok;
		public ParserRule getRule() { return rule; }

		//QualOp_PowerTok
		public RuleCall getQualOp_PowerTokParserRuleCall() { return cQualOp_PowerTokParserRuleCall; }
	}

	public class ArrowTokElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ArrowTok");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cKW_RARROWTerminalRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cKW_LARROWTerminalRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cKW_MAPSTARTerminalRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		/// * in Aldor grammar this is ArrowTok<tok> * / ArrowTok:
		//	KW_RARROW | KW_LARROW | KW_MAPSTAR;
		public ParserRule getRule() { return rule; }

		//KW_RARROW | KW_LARROW | KW_MAPSTAR
		public Alternatives getAlternatives() { return cAlternatives; }

		//KW_RARROW
		public RuleCall getKW_RARROWTerminalRuleCall_0() { return cKW_RARROWTerminalRuleCall_0; }

		//KW_LARROW
		public RuleCall getKW_LARROWTerminalRuleCall_1() { return cKW_LARROWTerminalRuleCall_1; }

		//KW_MAPSTAR
		public RuleCall getKW_MAPSTARTerminalRuleCall_2() { return cKW_MAPSTARTerminalRuleCall_2; }
	}

	public class LatticeTokElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "LatticeTok");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cKW_VEETerminalRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cKW_WEDGETerminalRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		/// * in Aldor grammar this is LatticeTok<tok> * / LatticeTok:
		//	KW_VEE | KW_WEDGE;
		public ParserRule getRule() { return rule; }

		//KW_VEE | KW_WEDGE
		public Alternatives getAlternatives() { return cAlternatives; }

		//KW_VEE
		public RuleCall getKW_VEETerminalRuleCall_0() { return cKW_VEETerminalRuleCall_0; }

		//KW_WEDGE
		public RuleCall getKW_WEDGETerminalRuleCall_1() { return cKW_WEDGETerminalRuleCall_1; }
	}

	public class RelationTokElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "RelationTok");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cKW_EQTerminalRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cKW_TILDEETerminalRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cKW_HATETerminalRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cKW_GETerminalRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cKW_GTTerminalRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		private final RuleCall cKW_2GTTerminalRuleCall_5 = (RuleCall)cAlternatives.eContents().get(5);
		private final RuleCall cKW_LETerminalRuleCall_6 = (RuleCall)cAlternatives.eContents().get(6);
		private final RuleCall cKW_LTTerminalRuleCall_7 = (RuleCall)cAlternatives.eContents().get(7);
		private final RuleCall cKW_2LTTerminalRuleCall_8 = (RuleCall)cAlternatives.eContents().get(8);
		private final Keyword cIsKeyword_9 = (Keyword)cAlternatives.eContents().get(9);
		private final Keyword cIsntKeyword_10 = (Keyword)cAlternatives.eContents().get(10);
		private final Keyword cCaseKeyword_11 = (Keyword)cAlternatives.eContents().get(11);
		
		/// * in Aldor grammar this is RelationTok<tok> * / RelationTok:
		//	KW_EQ | KW_TILDEE | KW_HATE | KW_GE | KW_GT | KW_2GT | KW_LE | KW_LT | KW_2LT | "is" | "isnt" | "case";
		public ParserRule getRule() { return rule; }

		//KW_EQ | KW_TILDEE | KW_HATE | KW_GE | KW_GT | KW_2GT | KW_LE | KW_LT | KW_2LT | "is" | "isnt" | "case"
		public Alternatives getAlternatives() { return cAlternatives; }

		//KW_EQ
		public RuleCall getKW_EQTerminalRuleCall_0() { return cKW_EQTerminalRuleCall_0; }

		//KW_TILDEE
		public RuleCall getKW_TILDEETerminalRuleCall_1() { return cKW_TILDEETerminalRuleCall_1; }

		//KW_HATE
		public RuleCall getKW_HATETerminalRuleCall_2() { return cKW_HATETerminalRuleCall_2; }

		//KW_GE
		public RuleCall getKW_GETerminalRuleCall_3() { return cKW_GETerminalRuleCall_3; }

		//KW_GT
		public RuleCall getKW_GTTerminalRuleCall_4() { return cKW_GTTerminalRuleCall_4; }

		//KW_2GT
		public RuleCall getKW_2GTTerminalRuleCall_5() { return cKW_2GTTerminalRuleCall_5; }

		//KW_LE
		public RuleCall getKW_LETerminalRuleCall_6() { return cKW_LETerminalRuleCall_6; }

		//KW_LT
		public RuleCall getKW_LTTerminalRuleCall_7() { return cKW_LTTerminalRuleCall_7; }

		//KW_2LT
		public RuleCall getKW_2LTTerminalRuleCall_8() { return cKW_2LTTerminalRuleCall_8; }

		//"is"
		public Keyword getIsKeyword_9() { return cIsKeyword_9; }

		//"isnt"
		public Keyword getIsntKeyword_10() { return cIsntKeyword_10; }

		//"case"
		public Keyword getCaseKeyword_11() { return cCaseKeyword_11; }
	}

	public class SegTokElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "SegTok");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cKW_2DOTTerminalRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final Keyword cByKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		
		/// * in Aldor grammar this is SegTok<tok> * / SegTok:
		//	KW_2DOT | "by";
		public ParserRule getRule() { return rule; }

		//KW_2DOT | "by"
		public Alternatives getAlternatives() { return cAlternatives; }

		//KW_2DOT
		public RuleCall getKW_2DOTTerminalRuleCall_0() { return cKW_2DOTTerminalRuleCall_0; }

		//"by"
		public Keyword getByKeyword_1() { return cByKeyword_1; }
	}

	public class PlusTokElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PlusTok");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cKW_PLUSTerminalRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cKW_MINUSTerminalRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cKW_PLUSMINUSTerminalRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		/// * in Aldor grammar this is PlusTok<tok> * / PlusTok:
		//	KW_PLUS | KW_MINUS | KW_PLUSMINUS;
		public ParserRule getRule() { return rule; }

		//KW_PLUS | KW_MINUS | KW_PLUSMINUS
		public Alternatives getAlternatives() { return cAlternatives; }

		//KW_PLUS
		public RuleCall getKW_PLUSTerminalRuleCall_0() { return cKW_PLUSTerminalRuleCall_0; }

		//KW_MINUS
		public RuleCall getKW_MINUSTerminalRuleCall_1() { return cKW_MINUSTerminalRuleCall_1; }

		//KW_PLUSMINUS
		public RuleCall getKW_PLUSMINUSTerminalRuleCall_2() { return cKW_PLUSMINUSTerminalRuleCall_2; }
	}

	public class QuotientTokElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "QuotientTok");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cModKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cQuoKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cRemKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		private final Keyword cExquoKeyword_3 = (Keyword)cAlternatives.eContents().get(3);
		
		/// * in Aldor grammar this is QuotientTok<tok> * / QuotientTok:
		//	"mod" | "quo" | "rem" | "exquo";
		public ParserRule getRule() { return rule; }

		//"mod" | "quo" | "rem" | "exquo"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"mod"
		public Keyword getModKeyword_0() { return cModKeyword_0; }

		//"quo"
		public Keyword getQuoKeyword_1() { return cQuoKeyword_1; }

		//"rem"
		public Keyword getRemKeyword_2() { return cRemKeyword_2; }

		//"exquo"
		public Keyword getExquoKeyword_3() { return cExquoKeyword_3; }
	}

	public class TimesTokElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "TimesTok");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cKW_STARTerminalRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cKW_SLASHTerminalRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cKW_BACKSLASHTerminalRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		/// * in Aldor grammar this is TimesTok<tok> * / TimesTok:
		//	KW_STAR | KW_SLASH | KW_BACKSLASH;
		public ParserRule getRule() { return rule; }

		//KW_STAR | KW_SLASH | KW_BACKSLASH
		public Alternatives getAlternatives() { return cAlternatives; }

		//KW_STAR
		public RuleCall getKW_STARTerminalRuleCall_0() { return cKW_STARTerminalRuleCall_0; }

		//KW_SLASH
		public RuleCall getKW_SLASHTerminalRuleCall_1() { return cKW_SLASHTerminalRuleCall_1; }

		//KW_BACKSLASH
		public RuleCall getKW_BACKSLASHTerminalRuleCall_2() { return cKW_BACKSLASHTerminalRuleCall_2; }
	}

	public class PowerTokElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PowerTok");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cKW_2STARTerminalRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cKW_HATTerminalRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		/// * in Aldor grammar this is PowerTok<tok> * / PowerTok:
		//	KW_2STAR | KW_HAT;
		public ParserRule getRule() { return rule; }

		//KW_2STAR | KW_HAT
		public Alternatives getAlternatives() { return cAlternatives; }

		//KW_2STAR
		public RuleCall getKW_2STARTerminalRuleCall_0() { return cKW_2STARTerminalRuleCall_0; }

		//KW_HAT
		public RuleCall getKW_HATTerminalRuleCall_1() { return cKW_HATTerminalRuleCall_1; }
	}

	public class ApplicationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Application");
		private final Keyword cTemp52Keyword = (Keyword)rule.eContents().get(1);
		
		/// *
		// * Juxtaposed Expressions
		// * 
		// * A prefix application typically has the following form:
		// * 
		// *  f(a1, ..., an)
		// * 
		// * There are two additional forms for specifying a prefix
		// * application to one argument: juxtaposition and an infix dot.
		// * 
		// * f a
		// * f.a
		// * 
		// * The second of these forms is completely equivalent to
		// * f(a); the first is equivalent in a free-standing occurrence
		// * but associates differently -- to the right, rather than
		// * the left:
		// * 
		// *  f a b c      -- is equivalent to (f (a (b c)))
		// *  f.a.b.c      -- is equivalent to (((f.a).b).c)
		// *  f(a)(b)(c)   -- is equivalent to (((f(a))(b))(c))
		// *
		// * / //RightJuxtaposed
		//Application hidden(WS, KW_NEWLINE):
		//	"temp52";
		public ParserRule getRule() { return rule; }

		//"temp52"
		public Keyword getTemp52Keyword() { return cTemp52Keyword; }
	}

	public class RightJuxtaposedElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "RightJuxtaposed");
		private final Keyword cTemp53Keyword = (Keyword)rule.eContents().get(1);
		
		//// Jright_Molecule
		//RightJuxtaposed hidden(WS, KW_NEWLINE):
		//	"temp53";
		public ParserRule getRule() { return rule; }

		//"temp53"
		public Keyword getTemp53Keyword() { return cTemp53Keyword; }
	}

	public class LeftJuxtaposedElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "LeftJuxtaposed");
		private final Keyword cTemp54Keyword = (Keyword)rule.eContents().get(1);
		
		//// Jleft_Molecule
		//LeftJuxtaposed hidden(WS, KW_NEWLINE):
		//	"temp54";
		public ParserRule getRule() { return rule; }

		//"temp54"
		public Keyword getTemp54Keyword() { return cTemp54Keyword; }
	}

	public class Jright_MoleculeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Jright_Molecule");
		private final Keyword cTemp56Keyword = (Keyword)rule.eContents().get(1);
		
		/// * Substituted Rules in Xtext:
		// * Jright(Molecule)
		// * Jright(Atom)
		// * Jright(H)
		// * : Jleft(H)
		// * | Jleft(H) Jright(Atom)
		// * { $$ = parseMakeJuxtapose($1,$2); }
		// * | 'not' Jright(Atom)
		// * { $$ = abNewNot(TPOS($1),TEST($2)); }
		// * ;
		// * / //	(Jleft_Molecule (right=Jright_Atom)?)
		////	| ('not' Jright_Atom)
		//Jright_Molecule hidden(WS, KW_NEWLINE):
		//	"temp56";
		public ParserRule getRule() { return rule; }

		//"temp56"
		public Keyword getTemp56Keyword() { return cTemp56Keyword; }
	}

	public class Jright_AtomElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Jright_Atom");
		private final Keyword cTemp57Keyword = (Keyword)rule.eContents().get(1);
		
		////	(Jleft_Atom (right2=Jright_Atom)?)
		////	| 'not' Jright_Atom
		//Jright_Atom hidden(WS, KW_NEWLINE):
		//	"temp57";
		public ParserRule getRule() { return rule; }

		//"temp57"
		public Keyword getTemp57Keyword() { return cTemp57Keyword; }
	}

	public class Jleft_MoleculeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Jleft_Molecule");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Keyword cNotKeyword_0_0 = (Keyword)cGroup_0.eContents().get(0);
		private final RuleCall cBlockEnclosureParserRuleCall_0_1 = (RuleCall)cGroup_0.eContents().get(1);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final RuleCall cMoleculeParserRuleCall_1_0 = (RuleCall)cGroup_1.eContents().get(0);
		private final Group cGroup_1_1 = (Group)cGroup_1.eContents().get(1);
		private final RuleCall cKW_DOTTerminalRuleCall_1_1_0 = (RuleCall)cGroup_1_1.eContents().get(0);
		private final Assignment cBmAssignment_1_1_1 = (Assignment)cGroup_1_1.eContents().get(1);
		private final RuleCall cBmBlockMoleculeParserRuleCall_1_1_1_0 = (RuleCall)cBmAssignment_1_1_1.eContents().get(0);
		
		/// * Substituted Rules in Xtext:
		// * Jleft(Molecule)
		// * Jleft(Atom)
		// * Jleft(H)
		// * : H
		// * | 'not' BlockEnclosure
		// * { $$ = abNewNot(TPOS($1),TEST($2)); }
		// * | Jleft(H) BlockEnclosure
		// * { $$ = parseMakeJuxtapose($1,$2); }
		// * | Jleft(H) KW_DOT BlockMolecule
		// * { $$ = abNewPrefix(TPOS($2),$1,$3); }
		// * ;
		// * / Jleft_Molecule hidden(WS, KW_NEWLINE):
		//	"not" BlockEnclosure | Molecule (KW_DOT bm+=BlockMolecule)*;
		public ParserRule getRule() { return rule; }

		//"not" BlockEnclosure | Molecule (KW_DOT bm+=BlockMolecule)*
		public Alternatives getAlternatives() { return cAlternatives; }

		//"not" BlockEnclosure
		public Group getGroup_0() { return cGroup_0; }

		//"not"
		public Keyword getNotKeyword_0_0() { return cNotKeyword_0_0; }

		//BlockEnclosure
		public RuleCall getBlockEnclosureParserRuleCall_0_1() { return cBlockEnclosureParserRuleCall_0_1; }

		//Molecule (KW_DOT bm+=BlockMolecule)*
		public Group getGroup_1() { return cGroup_1; }

		//Molecule
		public RuleCall getMoleculeParserRuleCall_1_0() { return cMoleculeParserRuleCall_1_0; }

		//(KW_DOT bm+=BlockMolecule)*
		public Group getGroup_1_1() { return cGroup_1_1; }

		//KW_DOT
		public RuleCall getKW_DOTTerminalRuleCall_1_1_0() { return cKW_DOTTerminalRuleCall_1_1_0; }

		//bm+=BlockMolecule
		public Assignment getBmAssignment_1_1_1() { return cBmAssignment_1_1_1; }

		//BlockMolecule
		public RuleCall getBmBlockMoleculeParserRuleCall_1_1_1_0() { return cBmBlockMoleculeParserRuleCall_1_1_1_0; }
	}

	public class Jleft_AtomElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Jleft_Atom");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Keyword cNotKeyword_0_0 = (Keyword)cGroup_0.eContents().get(0);
		private final RuleCall cBlockEnclosureParserRuleCall_0_1 = (RuleCall)cGroup_0.eContents().get(1);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final RuleCall cAtomParserRuleCall_1_0 = (RuleCall)cGroup_1.eContents().get(0);
		private final Group cGroup_1_1 = (Group)cGroup_1.eContents().get(1);
		private final RuleCall cKW_DOTTerminalRuleCall_1_1_0 = (RuleCall)cGroup_1_1.eContents().get(0);
		private final Assignment cBm4Assignment_1_1_1 = (Assignment)cGroup_1_1.eContents().get(1);
		private final RuleCall cBm4BlockMoleculeParserRuleCall_1_1_1_0 = (RuleCall)cBm4Assignment_1_1_1.eContents().get(0);
		
		//Jleft_Atom hidden(WS, KW_NEWLINE):
		//	"not" BlockEnclosure | Atom (KW_DOT bm4+=BlockMolecule)*;
		public ParserRule getRule() { return rule; }

		//"not" BlockEnclosure | Atom (KW_DOT bm4+=BlockMolecule)*
		public Alternatives getAlternatives() { return cAlternatives; }

		//"not" BlockEnclosure
		public Group getGroup_0() { return cGroup_0; }

		//"not"
		public Keyword getNotKeyword_0_0() { return cNotKeyword_0_0; }

		//BlockEnclosure
		public RuleCall getBlockEnclosureParserRuleCall_0_1() { return cBlockEnclosureParserRuleCall_0_1; }

		//Atom (KW_DOT bm4+=BlockMolecule)*
		public Group getGroup_1() { return cGroup_1; }

		//Atom
		public RuleCall getAtomParserRuleCall_1_0() { return cAtomParserRuleCall_1_0; }

		//(KW_DOT bm4+=BlockMolecule)*
		public Group getGroup_1_1() { return cGroup_1_1; }

		//KW_DOT
		public RuleCall getKW_DOTTerminalRuleCall_1_1_0() { return cKW_DOTTerminalRuleCall_1_1_0; }

		//bm4+=BlockMolecule
		public Assignment getBm4Assignment_1_1_1() { return cBm4Assignment_1_1_1; }

		//BlockMolecule
		public RuleCall getBm4BlockMoleculeParserRuleCall_1_1_1_0() { return cBm4BlockMoleculeParserRuleCall_1_1_1_0; }
	}

	public class MoleculeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Molecule");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cAtomParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cEnclosureParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		/// *
		// * Indivisible Expressions
		// * / Molecule hidden(WS, KW_NEWLINE):
		//	Atom | Enclosure;
		public ParserRule getRule() { return rule; }

		//Atom | Enclosure
		public Alternatives getAlternatives() { return cAlternatives; }

		//Atom
		public RuleCall getAtomParserRuleCall_0() { return cAtomParserRuleCall_0; }

		//Enclosure
		public RuleCall getEnclosureParserRuleCall_1() { return cEnclosureParserRuleCall_1; }
	}

	public class EnclosureElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Enclosure");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cParenedParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cBracketedParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cQuotedIdsParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		//Enclosure hidden(WS, KW_NEWLINE):
		//	Parened | Bracketed | QuotedIds;
		public ParserRule getRule() { return rule; }

		//Parened | Bracketed | QuotedIds
		public Alternatives getAlternatives() { return cAlternatives; }

		//Parened
		public RuleCall getParenedParserRuleCall_0() { return cParenedParserRuleCall_0; }

		//Bracketed
		public RuleCall getBracketedParserRuleCall_1() { return cBracketedParserRuleCall_1; }

		//QuotedIds
		public RuleCall getQuotedIdsParserRuleCall_2() { return cQuotedIdsParserRuleCall_2; }
	}

	public class DeclMoleculeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "DeclMolecule");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cApplicationParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cBlockParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//DeclMolecule hidden(WS, KW_NEWLINE):
		//	Application? | Block;
		public ParserRule getRule() { return rule; }

		//Application? | Block
		public Alternatives getAlternatives() { return cAlternatives; }

		//Application?
		public RuleCall getApplicationParserRuleCall_0() { return cApplicationParserRuleCall_0; }

		//Block
		public RuleCall getBlockParserRuleCall_1() { return cBlockParserRuleCall_1; }
	}

	public class BlockMoleculeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "BlockMolecule");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cAtomParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cEnclosureParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cBlockParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		//BlockMolecule hidden(WS, KW_NEWLINE):
		//	Atom | Enclosure | Block;
		public ParserRule getRule() { return rule; }

		//Atom | Enclosure | Block
		public Alternatives getAlternatives() { return cAlternatives; }

		//Atom
		public RuleCall getAtomParserRuleCall_0() { return cAtomParserRuleCall_0; }

		//Enclosure
		public RuleCall getEnclosureParserRuleCall_1() { return cEnclosureParserRuleCall_1; }

		//Block
		public RuleCall getBlockParserRuleCall_2() { return cBlockParserRuleCall_2; }
	}

	public class BlockEnclosureElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "BlockEnclosure");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cEnclosureParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cBlockParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//BlockEnclosure hidden(WS, KW_NEWLINE):
		//	Enclosure | Block;
		public ParserRule getRule() { return rule; }

		//Enclosure | Block
		public Alternatives getAlternatives() { return cAlternatives; }

		//Enclosure
		public RuleCall getEnclosureParserRuleCall_0() { return cEnclosureParserRuleCall_0; }

		//Block
		public RuleCall getBlockParserRuleCall_1() { return cBlockParserRuleCall_1; }
	}

	public class BlockElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Block");
		private final RuleCall cCurly_LabeledParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//Block hidden(WS, KW_NEWLINE): // Piled(Expression)|
		//	Curly_Labeled;
		public ParserRule getRule() { return rule; }

		//// Piled(Expression)|
		//Curly_Labeled
		public RuleCall getCurly_LabeledParserRuleCall() { return cCurly_LabeledParserRuleCall; }
	}

	public class ParenedElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Parened");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final RuleCall cKW_OPARENTerminalRuleCall_0_0 = (RuleCall)cGroup_0.eContents().get(0);
		private final RuleCall cKW_CPARENTerminalRuleCall_0_1 = (RuleCall)cGroup_0.eContents().get(1);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final RuleCall cKW_OPARENTerminalRuleCall_1_0 = (RuleCall)cGroup_1.eContents().get(0);
		private final RuleCall cExpressionParserRuleCall_1_1 = (RuleCall)cGroup_1.eContents().get(1);
		private final RuleCall cKW_CPARENTerminalRuleCall_1_2 = (RuleCall)cGroup_1.eContents().get(2);
		
		//Parened hidden(WS, KW_NEWLINE):
		//	KW_OPAREN KW_CPAREN | KW_OPAREN Expression KW_CPAREN;
		public ParserRule getRule() { return rule; }

		//KW_OPAREN KW_CPAREN | KW_OPAREN Expression KW_CPAREN
		public Alternatives getAlternatives() { return cAlternatives; }

		//KW_OPAREN KW_CPAREN
		public Group getGroup_0() { return cGroup_0; }

		//KW_OPAREN
		public RuleCall getKW_OPARENTerminalRuleCall_0_0() { return cKW_OPARENTerminalRuleCall_0_0; }

		//KW_CPAREN
		public RuleCall getKW_CPARENTerminalRuleCall_0_1() { return cKW_CPARENTerminalRuleCall_0_1; }

		//KW_OPAREN Expression KW_CPAREN
		public Group getGroup_1() { return cGroup_1; }

		//KW_OPAREN
		public RuleCall getKW_OPARENTerminalRuleCall_1_0() { return cKW_OPARENTerminalRuleCall_1_0; }

		//Expression
		public RuleCall getExpressionParserRuleCall_1_1() { return cExpressionParserRuleCall_1_1; }

		//KW_CPAREN
		public RuleCall getKW_CPARENTerminalRuleCall_1_2() { return cKW_CPARENTerminalRuleCall_1_2; }
	}

	public class BracketedElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Bracketed");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final RuleCall cKW_OBRACKTerminalRuleCall_0_0 = (RuleCall)cGroup_0.eContents().get(0);
		private final RuleCall cKW_CBRACKTerminalRuleCall_0_1 = (RuleCall)cGroup_0.eContents().get(1);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final RuleCall cKW_OBRACKTerminalRuleCall_1_0 = (RuleCall)cGroup_1.eContents().get(0);
		private final RuleCall cExpressionParserRuleCall_1_1 = (RuleCall)cGroup_1.eContents().get(1);
		private final RuleCall cKW_CBRACKTerminalRuleCall_1_2 = (RuleCall)cGroup_1.eContents().get(2);
		
		//Bracketed hidden(WS, KW_NEWLINE):
		//	KW_OBRACK KW_CBRACK | KW_OBRACK Expression KW_CBRACK;
		public ParserRule getRule() { return rule; }

		//KW_OBRACK KW_CBRACK | KW_OBRACK Expression KW_CBRACK
		public Alternatives getAlternatives() { return cAlternatives; }

		//KW_OBRACK KW_CBRACK
		public Group getGroup_0() { return cGroup_0; }

		//KW_OBRACK
		public RuleCall getKW_OBRACKTerminalRuleCall_0_0() { return cKW_OBRACKTerminalRuleCall_0_0; }

		//KW_CBRACK
		public RuleCall getKW_CBRACKTerminalRuleCall_0_1() { return cKW_CBRACKTerminalRuleCall_0_1; }

		//KW_OBRACK Expression KW_CBRACK
		public Group getGroup_1() { return cGroup_1; }

		//KW_OBRACK
		public RuleCall getKW_OBRACKTerminalRuleCall_1_0() { return cKW_OBRACKTerminalRuleCall_1_0; }

		//Expression
		public RuleCall getExpressionParserRuleCall_1_1() { return cExpressionParserRuleCall_1_1; }

		//KW_CBRACK
		public RuleCall getKW_CBRACKTerminalRuleCall_1_2() { return cKW_CBRACKTerminalRuleCall_1_2; }
	}

	public class QuotedIdsElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "QuotedIds");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final RuleCall cKW_QUOTETerminalRuleCall_0_0 = (RuleCall)cGroup_0.eContents().get(0);
		private final RuleCall cKW_QUOTETerminalRuleCall_0_1 = (RuleCall)cGroup_0.eContents().get(1);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final RuleCall cKW_QUOTETerminalRuleCall_1_0 = (RuleCall)cGroup_1.eContents().get(0);
		private final RuleCall cNamesParserRuleCall_1_1 = (RuleCall)cGroup_1.eContents().get(1);
		private final RuleCall cKW_QUOTETerminalRuleCall_1_2 = (RuleCall)cGroup_1.eContents().get(2);
		
		//QuotedIds hidden(WS, KW_NEWLINE):
		//	KW_QUOTE KW_QUOTE | KW_QUOTE Names KW_QUOTE;
		public ParserRule getRule() { return rule; }

		//KW_QUOTE KW_QUOTE | KW_QUOTE Names KW_QUOTE
		public Alternatives getAlternatives() { return cAlternatives; }

		//KW_QUOTE KW_QUOTE
		public Group getGroup_0() { return cGroup_0; }

		//KW_QUOTE
		public RuleCall getKW_QUOTETerminalRuleCall_0_0() { return cKW_QUOTETerminalRuleCall_0_0; }

		//KW_QUOTE
		public RuleCall getKW_QUOTETerminalRuleCall_0_1() { return cKW_QUOTETerminalRuleCall_0_1; }

		//KW_QUOTE Names KW_QUOTE
		public Group getGroup_1() { return cGroup_1; }

		//KW_QUOTE
		public RuleCall getKW_QUOTETerminalRuleCall_1_0() { return cKW_QUOTETerminalRuleCall_1_0; }

		//Names
		public RuleCall getNamesParserRuleCall_1_1() { return cNamesParserRuleCall_1_1; }

		//KW_QUOTE
		public RuleCall getKW_QUOTETerminalRuleCall_1_2() { return cKW_QUOTETerminalRuleCall_1_2; }
	}

	public class NamesElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Names");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cFirstNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cFirstNameTK_IDTerminalRuleCall_0_0 = (RuleCall)cFirstNameAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final RuleCall cKW_COMMATerminalRuleCall_1_0 = (RuleCall)cGroup_1.eContents().get(0);
		private final Assignment cSubsequentNamesAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cSubsequentNamesTK_IDTerminalRuleCall_1_1_0 = (RuleCall)cSubsequentNamesAssignment_1_1.eContents().get(0);
		
		//Names hidden(WS, KW_NEWLINE):
		//	firstName=TK_ID (KW_COMMA subsequentNames+=TK_ID)*;
		public ParserRule getRule() { return rule; }

		//firstName=TK_ID (KW_COMMA subsequentNames+=TK_ID)*
		public Group getGroup() { return cGroup; }

		//firstName=TK_ID
		public Assignment getFirstNameAssignment_0() { return cFirstNameAssignment_0; }

		//TK_ID
		public RuleCall getFirstNameTK_IDTerminalRuleCall_0_0() { return cFirstNameTK_IDTerminalRuleCall_0_0; }

		//(KW_COMMA subsequentNames+=TK_ID)*
		public Group getGroup_1() { return cGroup_1; }

		//KW_COMMA
		public RuleCall getKW_COMMATerminalRuleCall_1_0() { return cKW_COMMATerminalRuleCall_1_0; }

		//subsequentNames+=TK_ID
		public Assignment getSubsequentNamesAssignment_1_1() { return cSubsequentNamesAssignment_1_1; }

		//TK_ID
		public RuleCall getSubsequentNamesTK_IDTerminalRuleCall_1_1_0() { return cSubsequentNamesTK_IDTerminalRuleCall_1_1_0; }
	}

	public class AtomElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Atom");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cIdAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final RuleCall cIdIdParserRuleCall_0_0 = (RuleCall)cIdAssignment_0.eContents().get(0);
		private final Assignment cLitAssignment_1 = (Assignment)cAlternatives.eContents().get(1);
		private final RuleCall cLitLiteralParserRuleCall_1_0 = (RuleCall)cLitAssignment_1.eContents().get(0);
		
		/// *
		// * Terminals
		// * / Atom hidden(WS, KW_NEWLINE):
		//	id=Id | lit=Literal;
		public ParserRule getRule() { return rule; }

		//id=Id | lit=Literal
		public Alternatives getAlternatives() { return cAlternatives; }

		//id=Id
		public Assignment getIdAssignment_0() { return cIdAssignment_0; }

		//Id
		public RuleCall getIdIdParserRuleCall_0_0() { return cIdIdParserRuleCall_0_0; }

		//lit=Literal
		public Assignment getLitAssignment_1() { return cLitAssignment_1; }

		//Literal
		public RuleCall getLitLiteralParserRuleCall_1_0() { return cLitLiteralParserRuleCall_1_0; }
	}

	public class NameElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Name");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cIdParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cNakedOpParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//Name hidden(WS, KW_NEWLINE):
		//	Id | NakedOp;
		public ParserRule getRule() { return rule; }

		//Id | NakedOp
		public Alternatives getAlternatives() { return cAlternatives; }

		//Id
		public RuleCall getIdParserRuleCall_0() { return cIdParserRuleCall_0; }

		//NakedOp
		public RuleCall getNakedOpParserRuleCall_1() { return cNakedOpParserRuleCall_1; }
	}

	public class IdElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Id");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cAB_IdAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final RuleCall cAB_IdTK_IDTerminalRuleCall_0_0 = (RuleCall)cAB_IdAssignment_0.eContents().get(0);
		private final Assignment cOpAssignment_1 = (Assignment)cAlternatives.eContents().get(1);
		private final RuleCall cOpKW_SHARPTerminalRuleCall_1_0 = (RuleCall)cOpAssignment_1.eContents().get(0);
		private final Assignment cOpAssignment_2 = (Assignment)cAlternatives.eContents().get(2);
		private final RuleCall cOpKW_TILDETerminalRuleCall_2_0 = (RuleCall)cOpAssignment_2.eContents().get(0);
		
		/// * original Aldor grammar uses abNewOfToken which is defined
		// * in Aldor file absyn.c: Abstract syntax construction and
		// * manipulation.
		// * / Id hidden(WS, KW_NEWLINE):
		//	AB_Id=TK_ID | op=KW_SHARP | op=KW_TILDE;
		public ParserRule getRule() { return rule; }

		//AB_Id=TK_ID | op=KW_SHARP | op=KW_TILDE
		public Alternatives getAlternatives() { return cAlternatives; }

		//AB_Id=TK_ID
		public Assignment getAB_IdAssignment_0() { return cAB_IdAssignment_0; }

		//TK_ID
		public RuleCall getAB_IdTK_IDTerminalRuleCall_0_0() { return cAB_IdTK_IDTerminalRuleCall_0_0; }

		//op=KW_SHARP
		public Assignment getOpAssignment_1() { return cOpAssignment_1; }

		//KW_SHARP
		public RuleCall getOpKW_SHARPTerminalRuleCall_1_0() { return cOpKW_SHARPTerminalRuleCall_1_0; }

		//op=KW_TILDE
		public Assignment getOpAssignment_2() { return cOpAssignment_2; }

		//KW_TILDE
		public RuleCall getOpKW_TILDETerminalRuleCall_2_0() { return cOpKW_TILDETerminalRuleCall_2_0; }
	}

	public class LiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Literal");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cTK_INTTerminalRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cTK_STRINGTerminalRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//Literal hidden(WS, KW_NEWLINE):
		//	TK_INT //| TK_FLOAT
		//	| TK_STRING;
		public ParserRule getRule() { return rule; }

		//TK_INT //| TK_FLOAT
		//| TK_STRING
		public Alternatives getAlternatives() { return cAlternatives; }

		//TK_INT
		public RuleCall getTK_INTTerminalRuleCall_0() { return cTK_INTTerminalRuleCall_0; }

		//TK_STRING
		public RuleCall getTK_STRINGTerminalRuleCall_1() { return cTK_STRINGTerminalRuleCall_1; }
	}

	public class UnqualOp_ArrowTokElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "UnqualOp_ArrowTok");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cArrowTokParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Action cArrowTokAction_1 = (Action)cGroup.eContents().get(1);
		
		/// *
		// * Meta-rules
		// * / / * Substituted Rules in Xtext:
		// * UnqualOp(ArrowTok)
		// * UnqualOp(LatticeTok)
		// * UnqualOp(RelationTok)
		// * UnqualOp(SegTok)
		// * UnqualOp(PlusTok)
		// * UnqualOp(QuotientTok)
		// * UnqualOp(TimesTok)
		// * UnqualOp(PowerTok)
		// * UnqualOp(op)
		// * : op
		// * { $$ = abNewOfToken(AB_Id, $1); }
		// * ;
		// * / UnqualOp_ArrowTok hidden(WS, KW_NEWLINE):
		//	ArrowTok {ArrowTok};
		public ParserRule getRule() { return rule; }

		//ArrowTok {ArrowTok}
		public Group getGroup() { return cGroup; }

		//ArrowTok
		public RuleCall getArrowTokParserRuleCall_0() { return cArrowTokParserRuleCall_0; }

		//{ArrowTok}
		public Action getArrowTokAction_1() { return cArrowTokAction_1; }
	}

	public class UnqualOp_LatticeTokElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "UnqualOp_LatticeTok");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cLatticeTokParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Action cLatticeTokAction_1 = (Action)cGroup.eContents().get(1);
		
		//UnqualOp_LatticeTok hidden(WS, KW_NEWLINE):
		//	LatticeTok {LatticeTok};
		public ParserRule getRule() { return rule; }

		//LatticeTok {LatticeTok}
		public Group getGroup() { return cGroup; }

		//LatticeTok
		public RuleCall getLatticeTokParserRuleCall_0() { return cLatticeTokParserRuleCall_0; }

		//{LatticeTok}
		public Action getLatticeTokAction_1() { return cLatticeTokAction_1; }
	}

	public class UnqualOp_RelationTokElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "UnqualOp_RelationTok");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cRelationTokParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Action cRelationTokAction_1 = (Action)cGroup.eContents().get(1);
		
		//UnqualOp_RelationTok hidden(WS, KW_NEWLINE):
		//	RelationTok {RelationTok};
		public ParserRule getRule() { return rule; }

		//RelationTok {RelationTok}
		public Group getGroup() { return cGroup; }

		//RelationTok
		public RuleCall getRelationTokParserRuleCall_0() { return cRelationTokParserRuleCall_0; }

		//{RelationTok}
		public Action getRelationTokAction_1() { return cRelationTokAction_1; }
	}

	public class UnqualOp_SegTokElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "UnqualOp_SegTok");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cSegTokParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Action cSegTokAction_1 = (Action)cGroup.eContents().get(1);
		
		//UnqualOp_SegTok hidden(WS, KW_NEWLINE):
		//	SegTok {SegTok};
		public ParserRule getRule() { return rule; }

		//SegTok {SegTok}
		public Group getGroup() { return cGroup; }

		//SegTok
		public RuleCall getSegTokParserRuleCall_0() { return cSegTokParserRuleCall_0; }

		//{SegTok}
		public Action getSegTokAction_1() { return cSegTokAction_1; }
	}

	public class UnqualOp_PlusTokElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "UnqualOp_PlusTok");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cPlusTokParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Action cPlusTokAction_1 = (Action)cGroup.eContents().get(1);
		
		//UnqualOp_PlusTok hidden(WS, KW_NEWLINE):
		//	PlusTok {PlusTok};
		public ParserRule getRule() { return rule; }

		//PlusTok {PlusTok}
		public Group getGroup() { return cGroup; }

		//PlusTok
		public RuleCall getPlusTokParserRuleCall_0() { return cPlusTokParserRuleCall_0; }

		//{PlusTok}
		public Action getPlusTokAction_1() { return cPlusTokAction_1; }
	}

	public class UnqualOp_QuotientTokElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "UnqualOp_QuotientTok");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cQuotientTokParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Action cQuotientTokAction_1 = (Action)cGroup.eContents().get(1);
		
		//UnqualOp_QuotientTok hidden(WS, KW_NEWLINE):
		//	QuotientTok {QuotientTok};
		public ParserRule getRule() { return rule; }

		//QuotientTok {QuotientTok}
		public Group getGroup() { return cGroup; }

		//QuotientTok
		public RuleCall getQuotientTokParserRuleCall_0() { return cQuotientTokParserRuleCall_0; }

		//{QuotientTok}
		public Action getQuotientTokAction_1() { return cQuotientTokAction_1; }
	}

	public class UnqualOp_TimesTokElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "UnqualOp_TimesTok");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cTimesTokParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Action cTimesTokAction_1 = (Action)cGroup.eContents().get(1);
		
		//UnqualOp_TimesTok hidden(WS, KW_NEWLINE):
		//	TimesTok {TimesTok};
		public ParserRule getRule() { return rule; }

		//TimesTok {TimesTok}
		public Group getGroup() { return cGroup; }

		//TimesTok
		public RuleCall getTimesTokParserRuleCall_0() { return cTimesTokParserRuleCall_0; }

		//{TimesTok}
		public Action getTimesTokAction_1() { return cTimesTokAction_1; }
	}

	public class UnqualOp_PowerTokElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "UnqualOp_PowerTok");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cPowerTokParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Action cPowerTokAction_1 = (Action)cGroup.eContents().get(1);
		
		//UnqualOp_PowerTok hidden(WS, KW_NEWLINE):
		//	PowerTok {PowerTok};
		public ParserRule getRule() { return rule; }

		//PowerTok {PowerTok}
		public Group getGroup() { return cGroup; }

		//PowerTok
		public RuleCall getPowerTokParserRuleCall_0() { return cPowerTokParserRuleCall_0; }

		//{PowerTok}
		public Action getPowerTokAction_1() { return cPowerTokAction_1; }
	}

	public class QualOp_ArrowTokElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "QualOp_ArrowTok");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cArrowTokParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final RuleCall cArrowTokParserRuleCall_1_0 = (RuleCall)cGroup_1.eContents().get(0);
		private final RuleCall cKW_DOLLARTerminalRuleCall_1_1 = (RuleCall)cGroup_1.eContents().get(1);
		private final RuleCall cOpQualTailParserRuleCall_1_2 = (RuleCall)cGroup_1.eContents().get(2);
		
		/// * Substituted Rules in Xtext:
		// * QualOp(ArrowTok)
		// * QualOp(LatticeTok)
		// * QualOp(RelationTok)
		// * QualOp(SegTok)
		// * QualOp(PlusTok)
		// * QualOp(QuotientTok)
		// * QualOp(TimesTok)
		// * QualOp(PowerTok)
		// * QualOp(op)
		// * : op
		// * { $$ = abNewOfToken(AB_Id, $1); }
		// * | op KW_DOLLAR OpQualTail
		// * { $$ = abNewQualify(TPOS($1), abNewOfToken(AB_Id, $1), $3); }
		// * ;
		// * / QualOp_ArrowTok hidden(WS, KW_NEWLINE):
		//	ArrowTok | ArrowTok KW_DOLLAR OpQualTail;
		public ParserRule getRule() { return rule; }

		//ArrowTok | ArrowTok KW_DOLLAR OpQualTail
		public Alternatives getAlternatives() { return cAlternatives; }

		//ArrowTok
		public RuleCall getArrowTokParserRuleCall_0() { return cArrowTokParserRuleCall_0; }

		//ArrowTok KW_DOLLAR OpQualTail
		public Group getGroup_1() { return cGroup_1; }

		//ArrowTok
		public RuleCall getArrowTokParserRuleCall_1_0() { return cArrowTokParserRuleCall_1_0; }

		//KW_DOLLAR
		public RuleCall getKW_DOLLARTerminalRuleCall_1_1() { return cKW_DOLLARTerminalRuleCall_1_1; }

		//OpQualTail
		public RuleCall getOpQualTailParserRuleCall_1_2() { return cOpQualTailParserRuleCall_1_2; }
	}

	public class QualOp_LatticeTokElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "QualOp_LatticeTok");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cLatticeTokParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final RuleCall cLatticeTokParserRuleCall_1_0 = (RuleCall)cGroup_1.eContents().get(0);
		private final RuleCall cKW_DOLLARTerminalRuleCall_1_1 = (RuleCall)cGroup_1.eContents().get(1);
		private final RuleCall cOpQualTailParserRuleCall_1_2 = (RuleCall)cGroup_1.eContents().get(2);
		
		//QualOp_LatticeTok hidden(WS, KW_NEWLINE):
		//	LatticeTok | LatticeTok KW_DOLLAR OpQualTail;
		public ParserRule getRule() { return rule; }

		//LatticeTok | LatticeTok KW_DOLLAR OpQualTail
		public Alternatives getAlternatives() { return cAlternatives; }

		//LatticeTok
		public RuleCall getLatticeTokParserRuleCall_0() { return cLatticeTokParserRuleCall_0; }

		//LatticeTok KW_DOLLAR OpQualTail
		public Group getGroup_1() { return cGroup_1; }

		//LatticeTok
		public RuleCall getLatticeTokParserRuleCall_1_0() { return cLatticeTokParserRuleCall_1_0; }

		//KW_DOLLAR
		public RuleCall getKW_DOLLARTerminalRuleCall_1_1() { return cKW_DOLLARTerminalRuleCall_1_1; }

		//OpQualTail
		public RuleCall getOpQualTailParserRuleCall_1_2() { return cOpQualTailParserRuleCall_1_2; }
	}

	public class QualOp_RelationTokElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "QualOp_RelationTok");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cRelationTokParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final RuleCall cRelationTokParserRuleCall_1_0 = (RuleCall)cGroup_1.eContents().get(0);
		private final RuleCall cKW_DOLLARTerminalRuleCall_1_1 = (RuleCall)cGroup_1.eContents().get(1);
		private final RuleCall cOpQualTailParserRuleCall_1_2 = (RuleCall)cGroup_1.eContents().get(2);
		
		//QualOp_RelationTok hidden(WS, KW_NEWLINE):
		//	RelationTok | RelationTok KW_DOLLAR OpQualTail;
		public ParserRule getRule() { return rule; }

		//RelationTok | RelationTok KW_DOLLAR OpQualTail
		public Alternatives getAlternatives() { return cAlternatives; }

		//RelationTok
		public RuleCall getRelationTokParserRuleCall_0() { return cRelationTokParserRuleCall_0; }

		//RelationTok KW_DOLLAR OpQualTail
		public Group getGroup_1() { return cGroup_1; }

		//RelationTok
		public RuleCall getRelationTokParserRuleCall_1_0() { return cRelationTokParserRuleCall_1_0; }

		//KW_DOLLAR
		public RuleCall getKW_DOLLARTerminalRuleCall_1_1() { return cKW_DOLLARTerminalRuleCall_1_1; }

		//OpQualTail
		public RuleCall getOpQualTailParserRuleCall_1_2() { return cOpQualTailParserRuleCall_1_2; }
	}

	public class QualOp_SegTokElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "QualOp_SegTok");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cSegTokParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final RuleCall cSegTokParserRuleCall_1_0 = (RuleCall)cGroup_1.eContents().get(0);
		private final RuleCall cKW_DOLLARTerminalRuleCall_1_1 = (RuleCall)cGroup_1.eContents().get(1);
		private final RuleCall cOpQualTailParserRuleCall_1_2 = (RuleCall)cGroup_1.eContents().get(2);
		
		//QualOp_SegTok hidden(WS, KW_NEWLINE):
		//	SegTok | SegTok KW_DOLLAR OpQualTail;
		public ParserRule getRule() { return rule; }

		//SegTok | SegTok KW_DOLLAR OpQualTail
		public Alternatives getAlternatives() { return cAlternatives; }

		//SegTok
		public RuleCall getSegTokParserRuleCall_0() { return cSegTokParserRuleCall_0; }

		//SegTok KW_DOLLAR OpQualTail
		public Group getGroup_1() { return cGroup_1; }

		//SegTok
		public RuleCall getSegTokParserRuleCall_1_0() { return cSegTokParserRuleCall_1_0; }

		//KW_DOLLAR
		public RuleCall getKW_DOLLARTerminalRuleCall_1_1() { return cKW_DOLLARTerminalRuleCall_1_1; }

		//OpQualTail
		public RuleCall getOpQualTailParserRuleCall_1_2() { return cOpQualTailParserRuleCall_1_2; }
	}

	public class QualOp_PlusTokElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "QualOp_PlusTok");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cPlusTokParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final RuleCall cPlusTokParserRuleCall_1_0 = (RuleCall)cGroup_1.eContents().get(0);
		private final RuleCall cKW_DOLLARTerminalRuleCall_1_1 = (RuleCall)cGroup_1.eContents().get(1);
		private final RuleCall cOpQualTailParserRuleCall_1_2 = (RuleCall)cGroup_1.eContents().get(2);
		
		//QualOp_PlusTok hidden(WS, KW_NEWLINE):
		//	PlusTok | PlusTok KW_DOLLAR OpQualTail;
		public ParserRule getRule() { return rule; }

		//PlusTok | PlusTok KW_DOLLAR OpQualTail
		public Alternatives getAlternatives() { return cAlternatives; }

		//PlusTok
		public RuleCall getPlusTokParserRuleCall_0() { return cPlusTokParserRuleCall_0; }

		//PlusTok KW_DOLLAR OpQualTail
		public Group getGroup_1() { return cGroup_1; }

		//PlusTok
		public RuleCall getPlusTokParserRuleCall_1_0() { return cPlusTokParserRuleCall_1_0; }

		//KW_DOLLAR
		public RuleCall getKW_DOLLARTerminalRuleCall_1_1() { return cKW_DOLLARTerminalRuleCall_1_1; }

		//OpQualTail
		public RuleCall getOpQualTailParserRuleCall_1_2() { return cOpQualTailParserRuleCall_1_2; }
	}

	public class QualOp_QuotientTokElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "QualOp_QuotientTok");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cQuotientTokParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final RuleCall cQuotientTokParserRuleCall_1_0 = (RuleCall)cGroup_1.eContents().get(0);
		private final RuleCall cKW_DOLLARTerminalRuleCall_1_1 = (RuleCall)cGroup_1.eContents().get(1);
		private final RuleCall cOpQualTailParserRuleCall_1_2 = (RuleCall)cGroup_1.eContents().get(2);
		
		//QualOp_QuotientTok hidden(WS, KW_NEWLINE):
		//	QuotientTok | QuotientTok KW_DOLLAR OpQualTail;
		public ParserRule getRule() { return rule; }

		//QuotientTok | QuotientTok KW_DOLLAR OpQualTail
		public Alternatives getAlternatives() { return cAlternatives; }

		//QuotientTok
		public RuleCall getQuotientTokParserRuleCall_0() { return cQuotientTokParserRuleCall_0; }

		//QuotientTok KW_DOLLAR OpQualTail
		public Group getGroup_1() { return cGroup_1; }

		//QuotientTok
		public RuleCall getQuotientTokParserRuleCall_1_0() { return cQuotientTokParserRuleCall_1_0; }

		//KW_DOLLAR
		public RuleCall getKW_DOLLARTerminalRuleCall_1_1() { return cKW_DOLLARTerminalRuleCall_1_1; }

		//OpQualTail
		public RuleCall getOpQualTailParserRuleCall_1_2() { return cOpQualTailParserRuleCall_1_2; }
	}

	public class QualOp_TimesTokElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "QualOp_TimesTok");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cTimesTokParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final RuleCall cTimesTokParserRuleCall_1_0 = (RuleCall)cGroup_1.eContents().get(0);
		private final RuleCall cKW_DOLLARTerminalRuleCall_1_1 = (RuleCall)cGroup_1.eContents().get(1);
		private final RuleCall cOpQualTailParserRuleCall_1_2 = (RuleCall)cGroup_1.eContents().get(2);
		
		//QualOp_TimesTok hidden(WS, KW_NEWLINE):
		//	TimesTok | TimesTok KW_DOLLAR OpQualTail;
		public ParserRule getRule() { return rule; }

		//TimesTok | TimesTok KW_DOLLAR OpQualTail
		public Alternatives getAlternatives() { return cAlternatives; }

		//TimesTok
		public RuleCall getTimesTokParserRuleCall_0() { return cTimesTokParserRuleCall_0; }

		//TimesTok KW_DOLLAR OpQualTail
		public Group getGroup_1() { return cGroup_1; }

		//TimesTok
		public RuleCall getTimesTokParserRuleCall_1_0() { return cTimesTokParserRuleCall_1_0; }

		//KW_DOLLAR
		public RuleCall getKW_DOLLARTerminalRuleCall_1_1() { return cKW_DOLLARTerminalRuleCall_1_1; }

		//OpQualTail
		public RuleCall getOpQualTailParserRuleCall_1_2() { return cOpQualTailParserRuleCall_1_2; }
	}

	public class QualOp_PowerTokElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "QualOp_PowerTok");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cPowerTokParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final RuleCall cPowerTokParserRuleCall_1_0 = (RuleCall)cGroup_1.eContents().get(0);
		private final RuleCall cKW_DOLLARTerminalRuleCall_1_1 = (RuleCall)cGroup_1.eContents().get(1);
		private final RuleCall cOpQualTailParserRuleCall_1_2 = (RuleCall)cGroup_1.eContents().get(2);
		
		//QualOp_PowerTok hidden(WS, KW_NEWLINE):
		//	PowerTok | PowerTok KW_DOLLAR OpQualTail;
		public ParserRule getRule() { return rule; }

		//PowerTok | PowerTok KW_DOLLAR OpQualTail
		public Alternatives getAlternatives() { return cAlternatives; }

		//PowerTok
		public RuleCall getPowerTokParserRuleCall_0() { return cPowerTokParserRuleCall_0; }

		//PowerTok KW_DOLLAR OpQualTail
		public Group getGroup_1() { return cGroup_1; }

		//PowerTok
		public RuleCall getPowerTokParserRuleCall_1_0() { return cPowerTokParserRuleCall_1_0; }

		//KW_DOLLAR
		public RuleCall getKW_DOLLARTerminalRuleCall_1_1() { return cKW_DOLLARTerminalRuleCall_1_1; }

		//OpQualTail
		public RuleCall getOpQualTailParserRuleCall_1_2() { return cOpQualTailParserRuleCall_1_2; }
	}

	public class PreDocumentElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PreDocument");
		private final RuleCall cPreDocumentListParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		/// * ++ Doc. * / / * Substituted Rules in Xtext:
		// * E is E from PileContents(E)
		// * / //Doc(E)
		////: PreDocument E PostDocument
		////{
		////$$ = $2;
		////if($3) $$ = abNewDocumented(APOS($3),$$,$3);
		////if($1) $$ = abNewDocumented(APOS($$),$$,$1);
		////}
		////;
		//PreDocument hidden(WS, KW_NEWLINE):
		//	PreDocumentList;
		public ParserRule getRule() { return rule; }

		//PreDocumentList
		public RuleCall getPreDocumentListParserRuleCall() { return cPreDocumentListParserRuleCall; }
	}

	public class PostDocumentElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PostDocument");
		private final RuleCall cPostDocumentListParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//PostDocument hidden(WS, KW_NEWLINE):
		//	PostDocumentList;
		public ParserRule getRule() { return rule; }

		//PostDocumentList
		public RuleCall getPostDocumentListParserRuleCall() { return cPostDocumentListParserRuleCall; }
	}

	public class PreDocumentListElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PreDocumentList");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cTK_PREDOCTerminalRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final RuleCall cPreDocumentListParserRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		
		//PreDocumentList hidden(WS, KW_NEWLINE):
		//	(TK_PREDOC PreDocumentList)?;
		public ParserRule getRule() { return rule; }

		//(TK_PREDOC PreDocumentList)?
		public Group getGroup() { return cGroup; }

		//TK_PREDOC
		public RuleCall getTK_PREDOCTerminalRuleCall_0() { return cTK_PREDOCTerminalRuleCall_0; }

		//PreDocumentList
		public RuleCall getPreDocumentListParserRuleCall_1() { return cPreDocumentListParserRuleCall_1; }
	}

	public class PostDocumentListElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PostDocumentList");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cTK_POSTDOCTerminalRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final RuleCall cPostDocumentListParserRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		
		//PostDocumentList hidden(WS, KW_NEWLINE):
		//	(TK_POSTDOC PostDocumentList)?;
		public ParserRule getRule() { return rule; }

		//(TK_POSTDOC PostDocumentList)?
		public Group getGroup() { return cGroup; }

		//TK_POSTDOC
		public RuleCall getTK_POSTDOCTerminalRuleCall_0() { return cTK_POSTDOCTerminalRuleCall_0; }

		//PostDocumentList
		public RuleCall getPostDocumentListParserRuleCall_1() { return cPostDocumentListParserRuleCall_1; }
	}

	public class Enlist1_CommaItem_Comma_ABElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "enlist1_CommaItem_Comma_AB");
		private final RuleCall cEnlister1_CommaItem_CommaParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		/// * Substituted Rules in Xtext:
		// * enlist1(Infixed, KW_Comma, `AB_Comma)
		// * enlist1(CommaItem, KW_Comma, `AB_Comma) enlist1_CommaItem_Comma_AB
		// * enlist1(InfixedExpr, KW_Comma, `AB_Comma)
		// * enlist1(Name, KW_Comma, `AB_Comma)
		// * 
		// *  E {sep E sep E}
		// * 
		// * enlist1(E,Sep,Tag)
		// * : enlister1(E, Sep)
		// * 
		// * { $$ = abOneOrNewOfList(Tag, $1); listFree(AbSyn)($1); }
		// * ;
		// * / enlist1_CommaItem_Comma_AB hidden(WS, KW_NEWLINE):
		//	enlister1_CommaItem_Comma;
		public ParserRule getRule() { return rule; }

		//enlister1_CommaItem_Comma
		public RuleCall getEnlister1_CommaItem_CommaParserRuleCall() { return cEnlister1_CommaItem_CommaParserRuleCall; }
	}

	public class Enlist1_Infixed_Comma_ABElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "enlist1_Infixed_Comma_AB");
		private final RuleCall cEnlister1_Infixed_CommaParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//enlist1_Infixed_Comma_AB hidden(WS, KW_NEWLINE):
		//	enlister1_Infixed_Comma;
		public ParserRule getRule() { return rule; }

		//enlister1_Infixed_Comma
		public RuleCall getEnlister1_Infixed_CommaParserRuleCall() { return cEnlister1_Infixed_CommaParserRuleCall; }
	}

	public class Enlist1_InfixedExpr_Comma_ABElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "enlist1_InfixedExpr_Comma_AB");
		private final RuleCall cEnlister1_InfixedExpr_CommaParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//enlist1_InfixedExpr_Comma_AB hidden(WS, KW_NEWLINE):
		//	enlister1_InfixedExpr_Comma;
		public ParserRule getRule() { return rule; }

		//enlister1_InfixedExpr_Comma
		public RuleCall getEnlister1_InfixedExpr_CommaParserRuleCall() { return cEnlister1_InfixedExpr_CommaParserRuleCall; }
	}

	public class Enlister1_CommaItem_CommaElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "enlister1_CommaItem_Comma");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cCommaItemParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final RuleCall cKW_COMMATerminalRuleCall_1_0 = (RuleCall)cGroup_1.eContents().get(0);
		private final Assignment cCiAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cCiCommaItemParserRuleCall_1_1_0 = (RuleCall)cCiAssignment_1_1.eContents().get(0);
		
		/// * not used
		// * E sep E {sep E}
		// * / //enlist2(E,Sep,Tag)
		////: enlister1(E, Sep) Sep E
		////{
		////$1 = listCons(AbSyn)($3, $1);
		////$$ = abOneOrNewOfList(Tag, $1);
		////listFree(AbSyn)($1);
		////}
		////;
		/// * Substituted Rules in Xtext:
		// * enlister1(E, Sep)
		// * where E is E from enlist1 or enlist1a 
		// * enlister1(E, Sep)<ablist>
		// * : E
		// * { $$ = listCons(AbSyn)($1, listNil(AbSyn) ); }
		// * | enlister1(E, Sep) Sep E
		// * { $$ = listCons(AbSyn)($3, $1); }
		// * ;
		// * / enlister1_CommaItem_Comma hidden(WS, KW_NEWLINE):
		//	CommaItem (KW_COMMA ci=CommaItem)*;
		public ParserRule getRule() { return rule; }

		//CommaItem (KW_COMMA ci=CommaItem)*
		public Group getGroup() { return cGroup; }

		//CommaItem
		public RuleCall getCommaItemParserRuleCall_0() { return cCommaItemParserRuleCall_0; }

		//(KW_COMMA ci=CommaItem)*
		public Group getGroup_1() { return cGroup_1; }

		//KW_COMMA
		public RuleCall getKW_COMMATerminalRuleCall_1_0() { return cKW_COMMATerminalRuleCall_1_0; }

		//ci=CommaItem
		public Assignment getCiAssignment_1_1() { return cCiAssignment_1_1; }

		//CommaItem
		public RuleCall getCiCommaItemParserRuleCall_1_1_0() { return cCiCommaItemParserRuleCall_1_1_0; }
	}

	public class Enlister1_Infixed_CommaElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "enlister1_Infixed_Comma");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cInfixedParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final RuleCall cKW_COMMATerminalRuleCall_1_0 = (RuleCall)cGroup_1.eContents().get(0);
		private final Assignment cIAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cIInfixedParserRuleCall_1_1_0 = (RuleCall)cIAssignment_1_1.eContents().get(0);
		
		//enlister1_Infixed_Comma hidden(WS, KW_NEWLINE):
		//	Infixed (KW_COMMA i=Infixed)*;
		public ParserRule getRule() { return rule; }

		//Infixed (KW_COMMA i=Infixed)*
		public Group getGroup() { return cGroup; }

		//Infixed
		public RuleCall getInfixedParserRuleCall_0() { return cInfixedParserRuleCall_0; }

		//(KW_COMMA i=Infixed)*
		public Group getGroup_1() { return cGroup_1; }

		//KW_COMMA
		public RuleCall getKW_COMMATerminalRuleCall_1_0() { return cKW_COMMATerminalRuleCall_1_0; }

		//i=Infixed
		public Assignment getIAssignment_1_1() { return cIAssignment_1_1; }

		//Infixed
		public RuleCall getIInfixedParserRuleCall_1_1_0() { return cIInfixedParserRuleCall_1_1_0; }
	}

	public class Enlister1_InfixedExpr_CommaElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "enlister1_InfixedExpr_Comma");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cInfixedExprParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final RuleCall cKW_COMMATerminalRuleCall_1_0 = (RuleCall)cGroup_1.eContents().get(0);
		private final RuleCall cInfixedExprParserRuleCall_1_1 = (RuleCall)cGroup_1.eContents().get(1);
		
		//enlister1_InfixedExpr_Comma hidden(WS, KW_NEWLINE):
		//	InfixedExpr (KW_COMMA InfixedExpr)*;
		public ParserRule getRule() { return rule; }

		//InfixedExpr (KW_COMMA InfixedExpr)*
		public Group getGroup() { return cGroup; }

		//InfixedExpr
		public RuleCall getInfixedExprParserRuleCall_0() { return cInfixedExprParserRuleCall_0; }

		//(KW_COMMA InfixedExpr)*
		public Group getGroup_1() { return cGroup_1; }

		//KW_COMMA
		public RuleCall getKW_COMMATerminalRuleCall_1_0() { return cKW_COMMATerminalRuleCall_1_0; }

		//InfixedExpr
		public RuleCall getInfixedExprParserRuleCall_1_1() { return cInfixedExprParserRuleCall_1_1; }
	}

	public class Enlist1a_Labeled_Semicolon_ABElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "enlist1a_Labeled_Semicolon_AB");
		private final RuleCall cEnlister1a_Labeled_SemicolonParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		/// * Substituted Rules in Xtext:
		// * enlist1a(Labeled, KW_SEMICOLON, `AB_Sequence)
		// * 
		// * E {sep+ E sep+ E sep*} * / enlist1a_Labeled_Semicolon_AB hidden(WS, KW_NEWLINE):
		//	enlister1a_Labeled_Semicolon;
		public ParserRule getRule() { return rule; }

		//enlister1a_Labeled_Semicolon
		public RuleCall getEnlister1a_Labeled_SemicolonParserRuleCall() { return cEnlister1a_Labeled_SemicolonParserRuleCall; }
	}

	public class Enlister1a_Labeled_SemicolonElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "enlister1a_Labeled_Semicolon");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cStatemntsAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cStatemntsLabeledParserRuleCall_0_0 = (RuleCall)cStatemntsAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final RuleCall cKW_SEMICOLONTerminalRuleCall_1_0 = (RuleCall)cGroup_1.eContents().get(0);
		private final Assignment cStatemntsAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cStatemntsLabeledParserRuleCall_1_1_0 = (RuleCall)cStatemntsAssignment_1_1.eContents().get(0);
		private final RuleCall cKW_SEMICOLONTerminalRuleCall_2 = (RuleCall)cGroup.eContents().get(2);
		
		/// * Substituted Rules in Xtext:
		// * enlister1a(E, Sep) where E is from enlist1a
		// * 
		// * / //Labeled
		////| enlister1a_Labeled_Semicolon KW_SEMICOLON Labeled
		////| enlister1a_Labeled_Semicolon KW_SEMICOLON
		//enlister1a_Labeled_Semicolon hidden(WS, KW_NEWLINE):
		//	statemnts+=Labeled (KW_SEMICOLON statemnts+=Labeled) KW_SEMICOLON?;
		public ParserRule getRule() { return rule; }

		//statemnts+=Labeled (KW_SEMICOLON statemnts+=Labeled) KW_SEMICOLON?
		public Group getGroup() { return cGroup; }

		//statemnts+=Labeled
		public Assignment getStatemntsAssignment_0() { return cStatemntsAssignment_0; }

		//Labeled
		public RuleCall getStatemntsLabeledParserRuleCall_0_0() { return cStatemntsLabeledParserRuleCall_0_0; }

		//KW_SEMICOLON statemnts+=Labeled
		public Group getGroup_1() { return cGroup_1; }

		//KW_SEMICOLON
		public RuleCall getKW_SEMICOLONTerminalRuleCall_1_0() { return cKW_SEMICOLONTerminalRuleCall_1_0; }

		//statemnts+=Labeled
		public Assignment getStatemntsAssignment_1_1() { return cStatemntsAssignment_1_1; }

		//Labeled
		public RuleCall getStatemntsLabeledParserRuleCall_1_1_0() { return cStatemntsLabeledParserRuleCall_1_1_0; }

		//KW_SEMICOLON?
		public RuleCall getKW_SEMICOLONTerminalRuleCall_2() { return cKW_SEMICOLONTerminalRuleCall_2; }
	}

	public class Curly_LabeledElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Curly_Labeled");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cKW_OCURLYTerminalRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final RuleCall cCurlyContents_LabeledParserRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final RuleCall cKW_CCURLYTerminalRuleCall_2 = (RuleCall)cGroup.eContents().get(2);
		
		/// * Substituted Rules in Xtext:
		// * Piled(Expression)
		// * 
		// * / / * Piled * / //Piled(E)
		////: KW_SetTab PileContents(E) KW_BackTab
		////{ $$ = abOneOrNewOfList(AB_Sequence,$2); listFree(AbSyn)($2); }
		////;
		/// * Substituted Rules in Xtext:
		// * Curly(Labeled)
		// * 
		// * / Curly_Labeled:
		//	KW_OCURLY CurlyContents_Labeled KW_CCURLY;
		public ParserRule getRule() { return rule; }

		//KW_OCURLY CurlyContents_Labeled KW_CCURLY
		public Group getGroup() { return cGroup; }

		//KW_OCURLY
		public RuleCall getKW_OCURLYTerminalRuleCall_0() { return cKW_OCURLYTerminalRuleCall_0; }

		//CurlyContents_Labeled
		public RuleCall getCurlyContents_LabeledParserRuleCall_1() { return cCurlyContents_LabeledParserRuleCall_1; }

		//KW_CCURLY
		public RuleCall getKW_CCURLYTerminalRuleCall_2() { return cKW_CCURLYTerminalRuleCall_2; }
	}

	public class CurlyContents_LabeledElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "CurlyContents_Labeled");
		private final RuleCall cCurlyContentsList_LabeledParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		/// * Substituted Rules in Xtext:
		// * PileContents(E) E is from piled
		// * 
		// * / //PileContents(E)<ablist>
		////: Doc(E)
		////{ $$ = listCons(AbSyn)($1, listNil(AbSyn)); }
		////| PileContents(E) KW_BackSet Doc(E)
		////{ $$ = listCons(AbSyn)($3, $1); }
		////| error KW_BackSet Doc(E)
		////{ yyerrok; $$ = listCons(AbSyn)($3, listNil(AbSyn)); }
		////;
		/// * Substituted Rules in Xtext:
		// * CurlyContents(Labeled)
		// * CurlyContents(E) E is from Curly
		// * 
		// * CurlyContents(E) : CurlyContentsList(E);
		// * / CurlyContents_Labeled hidden(WS):
		//	CurlyContentsList_Labeled;
		public ParserRule getRule() { return rule; }

		//CurlyContentsList_Labeled
		public RuleCall getCurlyContentsList_LabeledParserRuleCall() { return cCurlyContentsList_LabeledParserRuleCall; }
	}

	public class CurlyContentsList_LabeledElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "CurlyContentsList_Labeled");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cStatemtsAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cStatemtsLabeledParserRuleCall_0_0 = (RuleCall)cStatemtsAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final RuleCall cKW_SEMICOLONTerminalRuleCall_1_0 = (RuleCall)cGroup_1.eContents().get(0);
		private final Assignment cStatemtsAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cStatemtsLabeledParserRuleCall_1_1_0 = (RuleCall)cStatemtsAssignment_1_1.eContents().get(0);
		private final RuleCall cKW_SEMICOLONTerminalRuleCall_2 = (RuleCall)cGroup.eContents().get(2);
		
		/// * Substituted Rules in Xtext:
		// * is CurlyContentsList(E)<ablist> in Aldor grammar
		// * CurlyContentsList(E) E is from CurlyContents(E)
		// * 
		// * CurlyContentsList(E)<ablist>:
		// * CurlyContent1(E)
		// * | CurlyContent1(E) CurlyContentB(E)
		// * ;
		// * / //CurlyContent1_Labeled
		////| CurlyContent1_Labeled ccb=CurlyContentB_Labeled
		//CurlyContentsList_Labeled hidden(WS):
		//	statemts+=Labeled (KW_SEMICOLON statemts+=Labeled)* KW_SEMICOLON?;
		public ParserRule getRule() { return rule; }

		//statemts+=Labeled (KW_SEMICOLON statemts+=Labeled)* KW_SEMICOLON?
		public Group getGroup() { return cGroup; }

		//statemts+=Labeled
		public Assignment getStatemtsAssignment_0() { return cStatemtsAssignment_0; }

		//Labeled
		public RuleCall getStatemtsLabeledParserRuleCall_0_0() { return cStatemtsLabeledParserRuleCall_0_0; }

		//(KW_SEMICOLON statemts+=Labeled)*
		public Group getGroup_1() { return cGroup_1; }

		//KW_SEMICOLON
		public RuleCall getKW_SEMICOLONTerminalRuleCall_1_0() { return cKW_SEMICOLONTerminalRuleCall_1_0; }

		//statemts+=Labeled
		public Assignment getStatemtsAssignment_1_1() { return cStatemtsAssignment_1_1; }

		//Labeled
		public RuleCall getStatemtsLabeledParserRuleCall_1_1_0() { return cStatemtsLabeledParserRuleCall_1_1_0; }

		//KW_SEMICOLON?
		public RuleCall getKW_SEMICOLONTerminalRuleCall_2() { return cKW_SEMICOLONTerminalRuleCall_2; }
	}

	public class CurlyContentB_LabeledElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "CurlyContentB_Labeled");
		private final Keyword cTemp100Keyword = (Keyword)rule.eContents().get(1);
		
		/// * CurlyContent1_Labeled
		// * this rule is used by CurlyContentsList_Labeled
		// *
		// * Substituted Rules in Xtext:
		// * CurlyContent1(E) E is form CurlyContentsList(E)
		// * 
		// * This rule is left recursive in the Aldor grammar so I have
		// * to change it here.
		// * / //CurlyContent1_Labeled
		////: Nothing
		////| CurlyContent1_Labeled cca=CurlyContentA_Labeled
		////;
		/// * Substituted Rules in Xtext:
		// * CurlyContentA(E) E is from CurlyContent1(E)
		// * 
		// * / //CurlyContentA_Labeled
		////: CurlyContentB_Labeled KW_SEMICOLON pd=PostDocument
		////| error KW_SEMICOLON PostDocument
		////;
		/// * Substituted Rules in Xtext:
		// * CurlyContentB(E) E is from CurlyContentA(E)
		// * or CurlyContentsList(E)
		// * 
		// * / //PreDocument Labeled pd=PostDocument
		/////////// end of Aldor stuff
		/// *
		// * longname and longname2 should both be ID and have the same value. Since the
		// * runtime values can't be checked by the parser this must be checked later.
		// * / //CategoryDef hidden(WS,KW_NEWLINE,TK_COMMENT):
		////name='category' shortname=TK_ID longname=TK_ID
		////longname2=TK_ID / *[CategoryDef]* /
		////    (cp=TypeParameterList)?
		////    KW_COLON 'Category' KW_2EQ
		////    (
		////    implName=TypeArguments? ((w=WithPart? a=AddPart?)| wh5=WherePart)
		////    | KW_OCURLY KW_NEWLINE*
		////      implName=TypeArguments ((w=WithPart? a=AddPart?)| wh5=WherePart)
		////      KW_CCURLY KW_NEWLINE* a2=AddPart?
		////    )
		////;
		/// *
		// * longname and longname2 should both be ID and have the same value. Since the
		// * runtime values can't be checked by the parser this must be checked later.
		// * / //PackageDef hidden(WS,KW_NEWLINE,TK_COMMENT):
		////name='package' shortname=TK_ID longname=TK_ID
		////longname2=TK_ID / *[PackageDef]* /
		////    (cp=TypeParameterList)? KW_COLON
		////    (
		////     exportName=TK_ID KW_2EQ implName=TK_ID
		////        (w=WithPart | wh5=WherePart)
		////     |
		////     w=WithPart
		////     (KW_2EQ add2=AddPart)?
		////    )
		////;
		/// *
		// * longname and longname2 should both be ID and have the same value. Since the
		// * runtime values can't be checked by the parser this must be checked later.
		// * / //DomainDef hidden(WS,KW_NEWLINE,TK_COMMENT):
		////name='domain' shortname5=TK_ID longname5=TK_ID
		////longname6=TK_ID / *[DomainDef]* /
		////    (cp5=TypeParameterList)?
		////    KW_COLON exportName=TK_ID (cp6=TypeParameterList)?
		////    KW_2EQ implName5=TK_ID?
		////    (w=WithPart | wh5=WherePart | a=AddPart)
		////;
		/// *
		// * both category and domain can have 'where' part which holds overall information
		// * such as category/domain parameter information and general macros. This is
		// * followed by export('with') and import ('add') information.
		// * Forms allowed include:
		// * Exports == PlottablePlaneCurveCategory with {
		// * Exports ==> PlottablePlaneCurveCategory with {
		// * Exports ==> with {
		// * / //WherePart hidden(WS,TK_COMMENT):
		////name='where' KW_NEWLINE* KW_OCURLY KW_NEWLINE*
		////    (whereAssig +=WhereAssignments (KW_NEWLINE|KW_SEMICOLON)+)*
		////    // with part
		////    (longname8=TK_ID (KW_2EQ | KW_MARROW) (imp=TypeExpression2)? w8=WithPart)?
		////    // add part
		////    (
		////     (longname9=TK_ID (KW_2EQ | KW_MARROW))?
		////        ((fs=TK_ID KW_OPAREN par2=TK_ID? (KW_COMMA par3 += TK_ID)* KW_CPAREN)
		////         | (fs=TK_ID f2=TK_ID)
		////        )?
		////        add=AddPart
		////    )?
		////    KW_CCURLY KW_NEWLINE+
		////;
		/// * each one must be on a separate line or separated by ';'
		// * need to add name=
		// * / //WhereAssignments hidden(WS):
		////VariableDeclaration
		////| MacroDef |Import
		////;
		/// *
		// * the 'where' part contains a 'with' part which holds export information
		// * such as function signatures (function declarations) but not function definitions.
		// * / //WithPart hidden(WS,TK_COMMENT):
		////name='with' KW_NEWLINE* KW_OCURLY KW_NEWLINE*
		////    (fundec += VariableDeclaration (KW_NEWLINE|KW_SEMICOLON)+)*
		////    KW_CCURLY KW_NEWLINE*
		////;
		/// *
		// * similar to 'WithPart' but no trailing NL
		// * / //WithInline hidden(WS,TK_COMMENT):
		////name='with' KW_NEWLINE* KW_OCURLY KW_NEWLINE*
		////    (fundec += VariableDeclaration (KW_NEWLINE|KW_SEMICOLON)+)*
		////    KW_CCURLY
		////;
		/// *
		// * the 'where' part contains a 'add' part which holds function and other
		// * declarations.
		// * / //AddPart hidden(WS,TK_COMMENT):
		////name='add' KW_NEWLINE* KW_OCURLY KW_NEWLINE*
		////    (t+=AddStatements (KW_NEWLINE|KW_SEMICOLON)+)* KW_CCURLY KW_NEWLINE*
		////;
		/// *
		// * The add section of domain or package may contain multiple lines
		// *
		// * Examples:
		// * if (r := recip leadingCoefficient M) case "failed" then {
		// * error "Modulus cannot be made monic"
		// * }
		// * / //AddStatements hidden(WS,TK_COMMENT):
		////   VariableDeclarationAssign
		////   | FunctionDefinition
		////   | ('if' t1=Expression // expression has form 'x has y'
		////      'then' t13=FunctionDefinitionBlock)
		////   | 'else' t14=FunctionDefinitionBlock
		////   | 'else' t15=AddStatements
		////   | MacroDef
		////   | Import
		////;
		/// * function definition in add part (called by AddStatements)
		// * has a form like:
		// * name(params) == statement
		// * or, option for single parameter without brackets:
		// * name param == statement
		// * or, option for zero parameters without brackets:
		// * This does not always work at the moment, for instance, this does not work:
		// * size == size$R ^ d
		// * but this does
		// * size() == size$R ^ d
		// *
		// * or, for infix operators,
		// * a = b == statement
		// * or, for multiple statements,
		// * name(params) == {
		// * statement
		// * statement
		// * }
		// * some function definitions may be conditional like this:
		// * if % has finiteAggregate then {
		// * ... }
		// * / //FunctionDefinition hidden(WS,TK_COMMENT):
		////  ((
		////par3=FunctionSignature
		////    (KW_COLON par4=TypeExpression1)?
		////    KW_2EQ par5=Statement
		////   )|(
		////    // this is case where FunctionSignature is just an identifier
		////    fnNam=TK_ID KW_2EQ par5=Statement
		////   ))
		////;
		/// *
		// * called by 'AddStatements' rule.
		// * allows more add statements inside:
		// * if a has y then 'more add statements'
		// * / //FunctionDefinitionBlock hidden(WS,TK_COMMENT):
		////    fnDecBr=KW_OCURLY KW_NEWLINE*
		////      (
		////       fnDecBk += FunctionDefinition (KW_NEWLINE|KW_SEMICOLON)+
		////       |
		////       vars+=VariableDeclarationAssign (KW_NEWLINE|KW_SEMICOLON)+
		////     | ('if' t1+=Expression // expression has form 'x has y'
		////        'then' t13+=FunctionDefinitionBlock (KW_NEWLINE|KW_SEMICOLON)+)
		////     | ('else' t14+=FunctionDefinitionBlock (KW_NEWLINE|KW_SEMICOLON)+)
		////     | i1+=Import (KW_NEWLINE|KW_SEMICOLON)+
		////      )*
		////      KW_CCURLY
		////      | 'error' e=Expression
		////      | KW_OCURLY KW_NEWLINE* 'error' e=Expression (KW_NEWLINE|KW_SEMICOLON)+ KW_CCURLY
		////;
		/// * This is the first part of the function definition without the return type or
		// * the function implementation. Usually the function signature has a form like:
		// * name(params)
		// * We allow a single parameter to be given without brackets:
		// * name param
		// *
		// * We also allow some alternative forms to represent infix operators like:
		// * a = b to represent _=(a,b)
		// * or the following (this works but only for % we need it to work for every type)
		// * s:% = t:%
		// * or
		// * a > b to represent _>(a,b)
		// * 0 or 1 can be used as a function signature as a short form of
		// * _0() or _1()
		// * / //FunctionSignature hidden(WS,TK_COMMENT):
		////  (
		////fnNam=TK_ID
		////    KW_OPAREN
		////    par2=VariableTyped?
		////    (KW_COMMA par3 += VariableTyped)*
		////    KW_CPAREN
		////  ) | (
		////   // fnNam=ID par2=VariableDeclaration causes recursive definition so use:
		////   fnNam=TK_ID par=TK_ID
		////// ) | (
		////// t4=ID // no parameters without brackets
		////// commented out as it causes recursive rule invocation
		////// with ruleAddStatements and ruleFunctionDefinitionBlock
		////  ) | (
		////   t4=TK_ID (KW_COLON (PERCENT | TK_ID))? //(COLON te1=TypeExpression)?
		////   ( b1=KW_EQ | b1=KW_LT | b1=KW_GT | b1=KW_LE | b1=KW_GE |
		////            b1=KW_PLUS | b1=KW_MINUS | b1=KW_STAR | b1=KW_SLASH | b1=KW_AMPERSAND |
		////            b1=KW_BAR | b1=KW_HAT) t5=TK_ID
		////  ) | (
		////   b3=TK_INT // allows special form of function signature using '0' or '1'
		////   // can't specify '0' or '1' explicitly as this would affect lex
		////   // order
		////  ) | (
		////   b2=KW_MINUS t6=TK_ID
		////  ) | (
		////   b4=KW_TILDE t7=TK_ID
		////  ) | (
		////   b5='not' t8=TK_ID
		////  ) | (
		////   b6=KW_SHARP t8=TK_ID
		////  )
		////;
		/// * macros provide a general textual substitution
		// * there are two forms:
		// * name ==> body
		// * and
		// * name macro == body
		// * / //MacroDef: macroname=TK_ID MACROVALUE ; //MACRO val=ID NL;
		/// *
		// * import domain
		// * / //Import hidden(WS):
		////'import' (impname += TK_ID)+ (KW_OPAREN par22+=TypeExpression1
		////(KW_COMMA par22+=TypeExpression1)* KW_CPAREN)?
		////;
		/// * Variable declaration in where and with sections:
		// * A 'variable' can be simple like:
		// * x:Float
		// * or something more complicated like:
		// * x:Record(newPt: Pt,type: String)
		// * or it can be a function like:
		// * x:(Float,Integer) -> Float
		// * or it can be conditional like:
		// * if
		// * / //VariableDeclarationBlock hidden(WS,TK_COMMENT):
		////    vardecbr=KW_OCURLY KW_NEWLINE*
		////      //=>(i1=Import NL*)?
		////      (vardecBlk += VariableDeclaration (KW_NEWLINE|KW_SEMICOLON)+)*
		////      KW_CCURLY
		////;
		/// * Variable declaration in where and with sections:
		// * A 'variable' can be simple like:
		// * x:Float
		// * or something more complicated like:
		// * x:Record(newPt: Pt,type: String)
		// * or it can be a function like:
		// * x:(Float,Integer) -> Float
		// * or it can be conditional like:
		// * if
		// * / //VariableDeclaration hidden(WS,TK_COMMENT):
		//////Import?
		////    ('if' t1=Expression 'then')? // expression has form 'x has y'
		////( v1=TypeWithName
		////      | v2=VariableDeclarationBlock
		////)
		////;
		/// *
		// * This rule is used where a type is expected like:
		// * Float
		// * but it may also have an optional name like:
		// * x:Float
		// * / //TypeWithName hidden(WS,TK_COMMENT):
		////(
		////(varName=TK_ID | varNameSt=TK_STRING) (KW_COMMA varName2=TK_ID)?
		////KW_COLON
		////)? typ=TypeExpression1
		////;
		/// * Variable name with optional type. This is used in function signature
		// * and also by VariableDeclaration:
		// * A 'variable' can be simple like:
		// * x:Float
		// * or something more complicated like:
		// * x:Record(newPt: Pt,type: String)
		// * or it can be a function like:
		// * x:(Float,Integer) -> Float
		// * we can define multiple variables together:
		// * i,j : Integer
		// * / //VariableTyped hidden(WS,TK_COMMENT):
		////(varName=TK_ID | varNameSt=TK_STRING)
		////// =>(COMMA t2+=ID)* // multiple declarations in same line
		////    (KW_COLON typ=TypeExpression1)?
		////;
		/// * in add part we can declare and assign in same part
		// * such as:
		// * a := 3
		// * a:Integer := 3
		// * a := sin(x)
		// *
		// * There are two forms of multiple assignment:
		// * a,b,c := 0@Integer
		// * or:
		// * a := b := c := 0@Integer
		// * / //VariableDeclarationAssign hidden(WS):
		////  varName=TK_ID // name of variable
		////  // if I just use name=ID then, when the ui program is running, I get:
		////  // Duplicate xxx 'coerce' in yyy
		////  (
		////    (KW_COMMA t12+=TK_ID)* // multiple declarations in same line
		////    (KW_COLON typ=TypeExpression1)? // option to explicitly define type
		////    (KW_ASSIGN (t4=Expression / * |(LBRACE NL* Expression NL* RBRACE) * /))?
		////    // we need block since we can't always detect continuation after ':='
		////    // but this causes infinite loop
		////  )// | (BECOMES t2+=ID)+ BECOMES t4=Expression
		////;
		/// *
		// * free variable allows us to declare a variable that is global
		// * / //FreeVariable hidden(WS):
		////'free' var=TK_ID
		////;
		/// *
		// * allows us to declare a variable that is not global
		// * / //LocalVariable hidden(WS):
		////'local' var=TK_ID
		////;
		/// *
		// * This is similar to Expression but known to be of type.
		// * (Expression can also be of type) but if we know that
		// * this is a type we can exclude some possibilities.
		// *
		// * A 'typeExpression' can be simple like:
		// * Float
		// * or something more complicated like:
		// * Record(newPt: Pt,type: String)
		// * or it can be a function like:
		// * (Float,Integer) -> Float
		// *
		// * first we check for a function like: Integer -> Integer
		// * / //TypeExpression1 returns TypeExpression hidden(WS):
		////   =>(t2=TypeArguments KW_RARROW t3=TypeResult)
		////   | TypePrimaryExpression1
		////;
		/// *
		// * This is the same as TypeExpression except it does not allow
		// * the type to be extended by using a 'with' keyword. It is used
		// * in the 'where' rule because the 'with' in that case has a
		// * slightly different syntax.
		// * / //TypeExpression2 returns TypeExpression hidden(WS):
		////   =>(t92=TypeArguments KW_RARROW t93=TypeResult)
		////   | TypePrimaryExpression2
		////;
		/// *
		// * we use a type parameter list for parameters of category, package or domains
		// * Parameter list may be empty '()'.
		// * in this case parameters may be just ID or they may be nameID:typeID
		// *
		// * examples are:
		// * ()
		// * (String)
		// * (s:String)
		// * (String,Integer)
		// * (s:String,i:Integer)
		// * / //TypeParameterList hidden(WS):
		////tyname=KW_OPAREN par=TK_ID?
		////(KW_COLON par21=TypeExpression1)?
		////(KW_COMMA par2 += TK_ID (KW_COLON par22+=TypeExpression1)?)* KW_CPAREN;
		/// *
		// * we use type arguments for first part of function type, that is
		// * x in x-> y
		// * usually this is enclosed in parenthesis
		// * (x) in (x)-> y
		// * but if x is a single argument (Including Record, Union, etc.) then it does
		// * not need to be in parenthesis.
		// * / //TypeArguments hidden(WS):
		////  t=TypeLiteral |
		////  t2=PERCENT |
		////  t3='Type' |
		////  // usually, but not always type arguments are in parenthesis, and empty
		////  // parenthesis are allowed
		////  b1 ?= KW_OPAREN ((TK_ID KW_COLON)? t4=TypeExpression1)?
		////               ( KW_COMMA (TK_ID KW_COLON)? t16 +=TypeExpression1)* KW_CPAREN |
		////  t5='Record' KW_OPAREN t6=TypeExpression1
		////               (KW_COLON t22+=TypeExpression1)?
		////               (KW_COMMA t21+=TypeExpression1 (KW_COLON t23+=TypeExpression1)?)*
		////                KW_CPAREN |
		////  t9='Union' KW_OPAREN t10=TypeExpression1
		////              (KW_COLON t25+=TypeExpression1)?
		////              (KW_COMMA t24+=TypeExpression1 (KW_COLON t26+=TypeExpression1)?)*
		////              KW_CPAREN |
		////  t11='Join' KW_OPAREN t12=TypeExpression1 (KW_COMMA t13+=TypeExpression1)* KW_CPAREN |
		////  t15=TypeNameOrFunctionCall
		////;
		/// *
		// * we use type arguments for final part of function type, that is
		// * y in x-> y
		// * / //TypeResult hidden(WS):
		////  t=TypeLiteral |
		////  t2=PERCENT |
		////  tyname='Type' |
		////  tyname='Record' KW_OPAREN t7=TypeExpression1
		////               (KW_COLON t8+=TypeExpression1)?
		////               (KW_COMMA t21+=TypeExpression1 (KW_COLON t23+=TypeExpression1)?)*
		////                KW_CPAREN |
		////  tyname='Union' KW_OPAREN t10=TypeExpression1
		////              (KW_COLON t11+=TypeExpression1)?
		////              (KW_COMMA t24+=TypeExpression1 (KW_COLON t26+=TypeExpression1)?)*
		////              KW_CPAREN |
		////  tyname='Join' KW_OPAREN t12=TypeExpression1 (KW_COMMA t13+=TypeExpression1)* KW_CPAREN |
		////  t15=TypeNameOrFunctionCall
		////;
		/// *
		// * this matches various specific types
		// * / //TypePrimaryExpression1 returns TypePrimaryExpression hidden(WS):
		//// TypeLiteral
		//// | ({TypePrimaryExpression}t32=PERCENT)
		//// | ({TypePrimaryExpression}tyname='Type') // 'Type' is top of the category hierarchy
		//// | ({TypePrimaryExpression}tyname='Lisp') // 'Lisp' is used for native lisp function calls such as Say$Lisp
		//// | ({TypePrimaryExpression}KW_OPAREN t5=TypeExpression1 KW_CPAREN)
		//// | ({TypePrimaryExpression}tyname='Record' KW_OPAREN t7=TypeExpression1
		////               (KW_COLON t8+=TypeExpression1)?
		////               (KW_COMMA t21+=TypeExpression1 (KW_COLON t23+=TypeExpression1)?)*
		////                KW_CPAREN)
		//// | ({TypePrimaryExpression}tyname='Union' KW_OPAREN t10=TypeExpression1
		////              (KW_COLON t11+=TypeExpression1)?
		////              (KW_COMMA t24+=TypeExpression1 (KW_COLON t26+=TypeExpression1)?)*
		////              KW_CPAREN)
		//// | ({TypePrimaryExpression}tyname='Join'
		////    KW_OPAREN t13=TypeExpression1 (KW_COMMA t14+=TypeExpression1)* KW_CPAREN)
		//// | TypeNameOrFunctionCall
		//// | => TupleDefinition
		////;
		/// *
		// * This is the same as TypePrimaryExpression except it does not allow
		// * the type to be extended by using a 'with' keyword. It is used
		// * in the 'where' rule because the 'with' in that case has a
		// * slightly different syntax.
		// * / //TypePrimaryExpression2 returns TypePrimaryExpression hidden(WS):
		//// TypeLiteral
		//// | ({TypePrimaryExpression}t32=PERCENT)
		//// | ({TypePrimaryExpression}tyname='Type') // 'Type' is top of the category hierarchy
		//// | ({TypePrimaryExpression}tyname='Lisp') // 'Lisp' is used for native lisp function calls such as Say$Lisp
		//// | ({TypePrimaryExpression}KW_OPAREN t5=TypeExpression1 KW_CPAREN)
		//// | ({TypePrimaryExpression}tyname='Record' KW_OPAREN t7=TypeExpression1
		////               (KW_COLON t8+=TypeExpression1)?
		////               (KW_COMMA t21+=TypeExpression1 (KW_COLON t23+=TypeExpression1)?)*
		////                KW_CPAREN)
		//// | ({TypePrimaryExpression}tyname='Union' KW_OPAREN t10=TypeExpression1
		////              (KW_COLON t11+=TypeExpression1)?
		////              (KW_COMMA t24+=TypeExpression1 (KW_COLON t26+=TypeExpression1)?)*
		////              KW_CPAREN)
		//// | ({TypePrimaryExpression}tyname='Join'
		////    KW_OPAREN t13=TypeExpression1 (KW_COMMA t14+=TypeExpression1)* KW_CPAREN)
		//// | TypeNameOrFunctionCall2
		//// | => TupleDefinition
		////;
		/// * This rule will match:
		// * Float - an ID representation of a type
		// * List(Float) - a type function call
		// * List Float - a non-parenthesis form if only one parameter
		// *
		// * A type function is also known as a parameterised type or
		// * functor (not necessarily a true
		// * functor since it may not obey the axioms of a functor).
		// * If there is only one parameter then the parenthesis are optional
		// * / //TypeNameOrFunctionCall hidden(WS):
		////  tfnname=TK_ID
		////  (
		////    (KW_OPAREN (TK_ID KW_COLON)? t4=TypeExpression1? (KW_COMMA (TK_ID KW_COLON)? t25+=TypeExpression1)* KW_CPAREN)
		////    // optional curried function:
		////    (KW_OPAREN t44+=StatementExpression? (KW_COMMA t45+=Expression)* KW_CPAREN)*
		////    // option of no parenthesis for single parameter
		////    | => t6=TypePrimaryExpression1
		////    | => w=WithInline
		////  )?
		////;
		////TypeNameOrFunctionCall2 hidden(WS):
		////  tfnname=TK_ID
		////  (
		////    (KW_OPAREN (TK_ID KW_COLON)? t4=TypeExpression1? (KW_COMMA (TK_ID KW_COLON)? t25+=TypeExpression1)* KW_CPAREN)
		////    // optional curried function:
		////    (KW_OPAREN t44+=StatementExpression? (KW_COMMA t45+=Expression)* KW_CPAREN)*
		////    // option of no parenthesis for single parameter
		////    | => t6=TypePrimaryExpression1
		////  )?
		////;
		/// * This has a form like: (Integer,Float,String)
		// * like an array where each entry can be of a different type
		// * / //TupleDefinition hidden(WS):
		////  (KW_OPAREN t4=TypeExpression1 (KW_COMMA t25+=TypeExpression1)* KW_CPAREN)
		////;
		/// * Since SPAD supports dependent types then numbers and strings can occur here.
		// * Outstanding issues:
		// * 1) Float literals are parsed as elt(Int,Int) so we need to recognise this
		// * and convert to float literal
		// * 2) We need to be able to recognise exponent notation for floats
		// * 3) Integers without '-' prefix can be converted to PI or NNI
		// * 4) need to add hex or octal notation for integers (0xhhhh)
		// * 5) String and Character literals need to have backslash "\" doubled to
		// * "\\" otherwise xtext will interpret backslash as an escape character.
		// * 6) values following immediately after string literal such as "abc"d should
		// * represent an implied concat: concat("abc",d)
		// * / //TypeLiteral hidden(WS):
		////  t1=TK_INT |
		////  t22=TK_STRING |
		////// t3=FloatLiteral |
		////  t34=CharacterLiteral |
		////  t35=BooleanLiteral
		////;
		/// * In FunctionDefinition the algorithm is defined by a sequence of the
		// * following statements:
		// * / //Statement hidden(WS,TK_COMMENT):
		////    s1=Block |
		////    s3= StatementExpression |
		////    // 'if' can occur in an expression or in
		////    // a statement so we use '=>' to choose
		////    // expression if there is any ambiguity
		////    s4=IfStatement |
		////    s4b=IfElseStatement |
		////// s4c=IfThenStatement |
		////    s5=WhileStatement |
		////    s6=DoStatement |
		////    s7=ForStatement |
		////    s8=BreakStatement |
		////    s12=RepeatStatement |
		////    s9= IterateStatement |
		////// s11= ContinueStatement|
		////    s10= ReturnStatement |
		////// s11= Import |
		////    'error' e=Expression
		////;
		/// * allows multiple statements which are grouped by wrapping in
		// * braces (curly brackets) * / //Block hidden(WS,TK_COMMENT):
		////stname=KW_OCURLY KW_NEWLINE*
		////    (statemBl += Statement (KW_NEWLINE|KW_SEMICOLON)+)*
		////    KW_CCURLY
		////;
		/// *
		// * Gives a value or assigns a value to a variable or does conditional exit
		// *
		// * examples:
		// * x
		// * x:Int
		// * x,y:INT -- multiple assignment
		// * x:Int := 3
		// *
		// * x=y => 3
		// * / //StatementExpression hidden(WS,TK_COMMENT):
		////  //(ID COMMA)* // allow multiple assignment
		////  t=ConditionExpression // was Expression but changed so that 'if' statement
		////                        // does not clash with if-then-else expression
		////// (COLON t2=TypeExpression)?
		////// (BECOMES t3=Expression (BECOMES t33+=Expression)*)?
		////    (KW_ASSIGN t5=Block)?
		////    // breaks out of a block if predicate before '=>' is true then program
		////    // control leaves the block.
		////    // Put it here so that it can only occur at the top level of an expression.
		////    // if inside some complicated expression then it must be terminated with ';'.
		////    (KW_IMPLIES t4=Statement)?
		////;
		/// *
		// * for i in n..m repeat ... is 1
		// * for i in n..m by s repeat ...
		// * for i in list repeat ...
		// * for i in list for i in 1..length() repeat ...
		// * for i in list for i in 1.. repeat ...
		// * for j in n..m repeat loopBody
		// * for j in n..m | odd? j repeat
		// *
		// * To Do
		// * -----
		// * As a temporary measure we check for '..' as a suffix operator
		// * here, but we should really put this into expression?
		// *
		// * We need to allow conditions using BAR '|'
		// * / //ForStatement hidden(WS,TK_COMMENT):
		////'for' (
		////       stname=TK_ID 'in' t1=Expression KW_2DOT? //(=> '..' t2=Expression)?
		////       ('by' by1=Expression)?
		////// (=> BAR t2=PredicateOr)? // condition
		////       ('for' stname2+=TK_ID
		////        'in' t2+=Expression KW_2DOT?
		////        ('by' by2+=Expression)?
		////        )*
		////       ('while' t2+=Expression)*
		////) 'repeat' KW_NEWLINE? s1=Statement //('is' s2=Statement)?
		////;
		/// *
		// * while BoolExpr repeat loopBody
		// * / //WhileStatement hidden(WS,TK_COMMENT):
		////stname='while' (
		////       t2=Expression / *PredicateOr* /
		////) 'repeat' KW_NEWLINE? s1=Statement
		////;
		/// *
		// * do loopBody while BoolExpr
		// * / //DoStatement hidden(WS,TK_COMMENT):
		////stname='do' (
		////       s1=Statement
		////) 'while' KW_NEWLINE? t2=Expression / *PredicateOr* /
		////;
		/// *
		// * will repeat until we jump out. For instance by calling return.
		// * / //RepeatStatement hidden(WS,TK_COMMENT):
		////stname='repeat' (
		////       s1=Statement
		////)
		////;
		/// *
		// * iterate ...
		// * skips over the remainder of a loop
		// * / //IterateStatement hidden(WS,TK_COMMENT):
		////stname='iterate'
		////;
		/// *
		// * break leave current loop
		// * / //BreakStatement hidden(WS,TK_COMMENT):
		////stname='break'
		////;
		/// *
		// * return leave current function
		// * / //ReturnStatement hidden(WS):
		////stname='return' t2=Expression
		////;
		/// *
		// * import - use 'Import' instead
		// * / //ImportStatement hidden(WS):
		//// stname='import' t2=Expression
		////;
		/// * 'if' statement allows program flow to be switched
		// * forms:
		// * if boolean then
		// * if equation then
		// * if ... not ... and ...or ... then
		// * if ... then ... else ...
		// * note1:
		// * if ... then ... else ... always returns a value so we can use this
		// * on the right hand side of an assignment
		// * note2:
		// * since there is an explicit 'then' keyword there is no need to put
		// * the condition in brackets
		// *
		// * examples:
		// * a:= if x >0 then x else -x
		// * if R has Field then ...
		// * if myUnion case mtType then ...
		// *
		// * we also need to allow a form like this:
		// * if x >0 {
		// * then x
		// * else -x
		// * }
		// *
		// * also this form (this requires IfElseStatement rule):
		// * if x >0 then {
		// * x
		// * }
		// * else {
		// * -x
		// * }
		// * / //IfStatement hidden(WS,TK_COMMENT):
		////  'if' t2=Expression
		////// 'if' t2=ConditionExpression
		////  (
		////    'then' s1=Statement
		////    (=> 'else' s2=Statement)?
		////   |
		////    b?=KW_OCURLY
		////    KW_NEWLINE+ 'then' s11=Statement KW_NEWLINE*
		////    (=>'else' s12=Statement KW_NEWLINE*)?
		////    KW_CCURLY
		////  )
		////;
		////IfElseStatement hidden(WS,TK_COMMENT):
		////'else' s2=Statement
		////;
		/////////////// Expression syntax follows //////////////
		/// * This is the top level for expressions
		// *
		// * This level handles special cases such as:
		// * if x then y else z
		// * (x,y) +-> z
		// *
		// * We can consider expressions as elements of statements
		// * expressions contain no newlines unless preceded by underscore
		// * (which is handled by WS)
		// * / //Expression returns Expr hidden(WS,TK_COMMENT):
		////  (ifname='if' ifpred=Expression 'then' thenexp=Expression 'else' elseexp=Expression)
		////// | LPAREN t24=ConditionExpression (COMMA t25+=ConditionExpression)+ RPAREN (COLON rightType2 =TypeExpression)? GIVES ConditionExpression
		////  | ExitExpression
		////;
		/// *
		// * condition '=>' expr1 ';' expr2
		// * / //ExitExpression returns Expr hidden(WS,TK_COMMENT):
		////  ConditionExpression
		////  ({ExitExpression.left=current} op=KW_IMPLIES right = ConditionExpression KW_SEMICOLON r2=ConditionExpression)*
		////;
		/// *
		// * BAR "|" precedence: 108, 111
		// * / //ConditionExpression returns Expr hidden(WS,TK_COMMENT):
		////  OrExpression
		////  ({ConditionExpression.left=current} op=KW_BAR right = OrExpression )*
		////;
		/// *
		// * COMMA"," precedence: 110, 111
		// * / //CommaExpression returns Expr hidden(WS,TK_COMMENT):
		//// ConditionalAndExpression
		//// ({ConditionExpression.left=current} op=BAR right = ConditionalAndExpression )*
		////;
		/// *
		// * There is also another rule that looks for 'or' which is PredicateOr,
		// * this version is used in a general expression and the other version is
		// * used when we know we have a predicate.
		// * "or", precedence: 200, 201
		// * / //OrExpression returns Expr hidden(WS,TK_COMMENT):
		////  AndExpression
		////  ( {OrExpression.left=current} op='or' right = AndExpression)*
		////;
		/// *
		// * There is also another rule that looks for 'and' which is PredicateAnd,
		// * this version is used in a general expression and the other version is
		// * used when we know we have a predicate.
		// * "and", precedence: 250, 251
		// * / //AndExpression returns Expr hidden(WS,TK_COMMENT):
		////  InnerProdExpression
		////  ( {AndExpression.left=current} op='and' right = InnerProdExpression)*
		////;
		/// *
		// * This has multiple uses such as inner product and logical or.
		// *
		// * "\/", BACKSLASHSLASH precedence: 200, 201
		// *
		// * the backslash is duplicated here because it is the escape character for
		// * strings, it will not be duplicated when used.
		// * / //InnerProdExpression returns Expr hidden(WS,TK_COMMENT):
		////  OuterProdExpression
		////  ( {InnerProdExpression.left=current} op=KW_VEE right = OuterProdExpression)*
		////;
		/// *
		// * This has multiple uses such as outer product and logical and.
		// *
		// * "/\", SLASHBACKSLASH precedence: 250, 251
		// *
		// * the backslash is duplicated here because it is the escape character for
		// * strings, it will not be duplicated when used.
		// * / //OuterProdExpression returns Expr hidden(WS,TK_COMMENT):
		////  HasExpression
		////  ( {OuterProdExpression.left=current} op=KW_WEDGE right = HasExpression)*
		////;
		/// * Predicate which returns true if preceding value is of a given type
		// * example:
		// * if R has Field then ..
		// *
		// * "has", precedence: 400, 400
		// * / //HasExpression returns Expr hidden(WS,TK_COMMENT):
		////  CaseExpression
		////  ({HasExpression.left=current} op='has' rightType = TypeExpression1)*
		////;
		/// * Select from Union values
		// * example:
		// * if myUnion case mtType then ...
		// *
		// * "case", precedence: 400, 400
		// * / //CaseExpression returns Expr hidden(WS,TK_COMMENT):
		////  EqualityExpression
		////  ( {CaseExpression.left=current} op='case' right = EqualityExpression)?
		////;
		/// * used in list comprehension
		// *
		// * "in", precedence: 400, 400
		// * / / *InExpression returns Expr hidden(WS,TK_COMMENT):
		//  RelationalExpression
		//  ( {CaseExpression.left=current} op='in' right = RelationalExpression)?
		//;* / / *
		// * "~=", precedence: 400, 400
		// * "^=", precedence: 400, 400
		// * "=", precedence: 400, 400
		// * / //EqualityExpression returns Expr hidden(WS,TK_COMMENT):
		////  RelationalExpression
		////// ambiguous because EQ can be in top level expression
		////  ( {EqualityExpression.left=current}
		////   ( op=KW_EQ | op=KW_TILDEE | op=KW_HATE | (op=EQUALSDOLAR te=TK_ID))
		////   //(DOLAR te=ID)?
		////   right = RelationalExpression
		////  )*
		////;
		/// *
		// * ">=", precedence: 400, 400
		// * "<=", precedence: 400, 400
		// * ">>", precedence: 400, 400
		// * "<<", precedence: 400, 400
		// * ">", precedence: 400, 400
		// * "<", precedence: 400, 400
		// * / //RelationalExpression returns Expr hidden(WS,TK_COMMENT):
		////  IsExpression
		////  ( {RelationalExpression.left=current}
		////   ( op=KW_LT | op=KW_GT | op=KW_LE | op=KW_GE )
		////      right = IsExpression
		////  )?
		////;
		/// *
		// *
		// * "isnt", precedence: 400, 400
		// * "is", precedence: 400, 400
		// * / //IsExpression returns Expr hidden(WS,TK_COMMENT):
		////  SegmentExpression
		////  ({IsExpression.left=current} (op='is' | op='isnt') rightType = TypeExpression1)*
		////;
		/// *
		// * this is used to indicate a range:
		// * 1..4 means the range from 1 to 4
		// * 1.. means the range from 1 to infinity. This is used in cases where
		// * no top bounds is necessary, when the end point is determined by other
		// * means.
		// * "..", "SEGMENT", precedence: 401, 699, ["parse_Seg"]
		// * / //SegmentExpression returns Expr hidden(WS,TK_COMMENT):
		////  AdditiveExpression
		////  ( {SegmentExpression.left=current} op=KW_2DOT right = AdditiveExpression)*
		////;
		/// *
		// * add expression
		// * we include both '+' and '-' in the same case as this allows a
		// * multiple sequence like:
		// * a + b + c - d + e -f
		// *
		// * "-", precedence: 700, 701
		// * "+", precedence: 700, 701
		// * / //AdditiveExpression returns Expr hidden(WS,TK_COMMENT):
		////  ExquoExpression
		////  ( {AdditiveExpression.left=current}
		////    ( op=KW_PLUS | op=KW_MINUS | (op=PLUSDOLAR te=TK_ID) | (op=MINUSDOLAR te=TK_ID))
		////    right = ExquoExpression
		////  )*
		////;
		/// *
		// * "exquo", precedence: 800, 801
		// * / //ExquoExpression returns Expr hidden(WS,TK_COMMENT):
		////  DivisionExpression
		////  ({ExquoExpression.left=current} op='exquo' right = DivisionExpression)*
		////;
		/// *
		// * division expression
		// * "/", precedence: 800, 801
		// * / //DivisionExpression returns Expr hidden(WS,TK_COMMENT):
		////  QuoExpression
		////  ( {DivisionExpression.left=current}
		////   (op=KW_SLASH | (op=DIVDOLAR te=TK_ID))
		////   right = QuoExpression
		////  )*
		////;
		/// *
		// *"quo", precedence: 800, 801
		// * / //QuoExpression returns Expr hidden(WS,TK_COMMENT):
		////  ModExpression
		////  ({QuoExpression.left=current} op='quo' right = ModExpression)*
		////;
		/// *
		// *"mod", precedence: 800, 801
		// * / //ModExpression returns Expr hidden(WS,TK_COMMENT):
		////  RemExpression
		////  ({ModExpression.left=current} op='mod' right = RemExpression)*
		////;
		/// *
		// *"rem", precedence: 800, 801
		// * / //RemExpression returns Expr hidden(WS,TK_COMMENT):
		////  MultiplicativeExpression
		////  ({RemExpression.left=current} op='rem' right = MultiplicativeExpression)*
		////;
		/// *
		// * multiplication expression
		// * a * b * c
		// *
		// * "*", precedence: 800, 801
		// * / //MultiplicativeExpression returns Expr hidden(WS,TK_COMMENT):
		////  ExponentExpression
		////  ( {MultiplicativeExpression.left=current}
		////    (op=KW_STAR | (op=TIMESDOLAR te=TK_ID))
		////    right = ExponentExpression
		////  )*
		////;
		/// *
		// *
		// * "^", precedence: 901, 900
		// * "**", precedence: 901, 900
		// * / //ExponentExpression returns Expr hidden(WS,TK_COMMENT):
		////  MapDefinition
		////  ({ExponentExpression.left=current} (op=KW_HAT | op=KW_2STAR) right = MapDefinition)*
		////;
		/// * Map or Lambda expression
		// * var +-> function
		// *
		// * +-> is an infix operator meaning 'maps-to'
		// * It can be used to create a function literal (an anonymous function), so
		// * instead of:
		// * myFunct(x:Type):Type == if x >0 then x else -x
		// * we can have forms such as:
		// * x +-> if x >0 then x else -x
		// * or:
		// * (x,y) +-> if x >0 then y else -x
		// *
		// * fricas compatibility:
		// * "+->", precedence: 995, 112
		// * / //MapDefinition returns Expr hidden(WS,TK_COMMENT):
		////// (PretendExpression | LPAREN PretendExpression (COMMA t25+=PretendExpression)+ RPAREN) (COLON rightType2 =TypeExpression)?
		////  AssignExpression
		////  ({MapDefinition.left=current}
		////   op=KW_MAPSTO right = AssignExpression
		////   (par = TK_ID)? // optional parameter which function
		////                             // is applied to
		////  )*
		////;
		/// *
		// * an assign expression like this:
		// * x := y
		// * can also be an inner assign like this:
		// * x := (y := z)
		// * or just:
		// * x := y := z
		// *
		// * right is expression to allow forms like
		// * x := if y<0 then -y else y
		// * / //AssignExpression returns Expr hidden(WS,TK_COMMENT):
		////  PretendExpression
		////  ({AssignExpression.left=current} op=KW_ASSIGN (
		////   right = PretendExpression
		////   | ifname='if' ifpred=ConditionExpression 'then' thenexp=ConditionExpression 'else' elseexp=PretendExpression
		////   )
		////  )*
		////;
		/// *
		// * pretend Type: treat one type as another,
		// * only works if they have the same internal structure.
		// *
		// * Not very safe and should be avoided, if possible, unfortunately
		// * its not always possible to avoid.
		// *
		// * "pretend", precedence: 995, 996
		// * / // PretendExpression returns Expr hidden(WS,TK_COMMENT):
		////  CoerceExpression
		////  ({PretendExpression.left=current} op='pretend' rightType = TypeExpression1)*
		////;
		/// *
		// * "::", precedence: 996, 997
		// *
		// * although '::' and '@' apparently have the same precidence we want
		// * '@' to bind more tightly than '::'. As we can see in the following example:
		// * "dictionary"@String :: OutputForm.
		// * / //CoerceExpression returns Expr hidden(WS,TK_COMMENT):
		////  HintTypeExpression
		////  ({CoerceExpression.left=current} op=KW_2COLON rightType = TypeExpression1)*
		////;
		/// *
		// * "@", precedence: 996, 997
		// * / //HintTypeExpression returns Expr hidden(WS,TK_COMMENT):
		////  EltExpression
		////  ( {HintTypeExpression.left=current} op=KW_AT rightType = TypeExpression1)?
		////;
		/// * We treat these as part of the language
		// * : indicates type
		// * ! is part of name to indicate mutable
		// *
		// * ":", precedence: 996, 997
		// * "!", precedence: 1002, 1001
		// *
		// * / / *BangExpression returns Expr hidden(WS,TK_COMMENT):
		//  EqualityExpression
		//  ({AndExpression.left=current} op=AMPERSAND right = EqualityExpression)*
		//;* / / *
		// * "with", precedence: 2000, 400, ["parse_InfixWith"]
		// *
		// * / / *WithExpression returns Expr hidden(WS,TK_COMMENT):
		//  EqualityExpression
		//  ({AndExpression.left=current} op='with' right = EqualityExpression)*
		//;* / / * Elt is Lisp terminology for the use of '.' to select parameters
		// * the left expression is something that has selectable elements such as
		// * a list, array, string, Record or union, the right element should be a
		// * non-negative integer.
		// * / //EltExpression returns Expr hidden(WS,TK_COMMENT):
		////  ExplicitTypeExpression
		////  ( {EltExpression.left=current}
		////   op=KW_DOT right = ExplicitTypeExpression
		////  )*
		////;
		//////////////// unary expressions ////////////////////
		/// *
		// * '$'
		// * / //ExplicitTypeExpression returns Expr hidden(WS,TK_COMMENT):
		////  UnaryExpression
		////  ({ExplicitTypeExpression.left=current} op=KW_DOLLAR rightType = TypeExpression1)?
		////;
		/// * UnaryExpression
		// * unary prefixes:
		// * "~" TILDE : precedence 260, 259, nil
		// * ":" COLON : precedence 194, 195
		// * "-" MINUS : precedence 701, 700
		// * "#" HASH : precedence 999, 998
		// * "'" : precedence 999, 999, ["parse_Data"]
		// * unary suffixes
		// * ".." : range can be unary suffix
		// * / //UnaryExpression returns Expr hidden(WS,TK_COMMENT):
		////  PrimaryExpression |
		////  ({UnaryExpression} uop=KW_TILDE expr=UnaryExpression) |
		////// ({UnaryExpression} uop=COLON expr=UnaryExpression) |
		////  ({UnaryExpression} uop=KW_MINUS expr=UnaryExpression) |
		////  ({UnaryExpression} uop=MINUSDOLAR te=TK_ID expr=UnaryExpression) |
		////  ({UnaryExpression} uop=KW_SHARP expr=UnaryExpression) |
		////  ({UnaryExpression} uop='not' expr=PrimaryExpression) |
		////  ({UnaryExpression} uop=SUMLIST expr=PrimaryExpression) |
		////  ({UnaryExpression} uop=PRIMEPERCENT expr=PrimaryExpression) |
		////   e2=PERCENT |
		////  e3='Type' |
		////  e5='Record' KW_OPAREN e6=TypeExpression1
		////               (KW_COLON e22+=TypeExpression1)?
		////               (KW_COMMA e21+=TypeExpression1 (KW_COLON e23+=TypeExpression1)?)*
		////                KW_CPAREN |
		////  e9='Union' KW_OPAREN e10=TypeExpression1
		////              (KW_COLON e25+=TypeExpression1)?
		////              (KW_COMMA e24+=TypeExpression1 (KW_COLON e26+=TypeExpression1)?)*
		////              KW_CPAREN |
		////  e11='Join' KW_OPAREN e12=TypeExpression1 (KW_COMMA e13+=TypeExpression1)* KW_CPAREN
		////;
		/// *
		// *
		// * / / *UnaryExpressionHash returns Expr hidden(WS,TK_COMMENT):
		//// HASH? PrimaryExpression
		//  PrimaryExpression | ({UnaryExpressionHash} uop=HASH expr=UnaryExpressionHash)
		//;* / / *
		// *
		// * / //PrimaryExpression returns Expr hidden(WS,TK_COMMENT):
		////  PrimaryPrefix / * ( t2+=PrimarySuffix )* * /
		////;
		/// *
		// * Can contain an expression in parenthesis, this expression is
		// * 'StatementExpression' which means that it can contain an
		// * inner assignment.
		// *
		// * The comma option allows us to define a tuple
		// * / //PrimaryPrefix hidden(WS,TK_COMMENT):
		//// Literal
		//// | KW_OPAREN t4=Expression (KW_COMMA t25+=Expression)* KW_CPAREN =>(KW_COLON rightType3 =TypeExpression1)?
		//// | t7=NameOrFunctionCall
		////;
		/// * function call such as List(Integer)
		// * known as a parameterised type or functor (not necessarily a true functor since
		// * it may not obey the axioms of a functor)
		// * if there is only one parameter then the parenthesis are optional
		// *
		// * function binds most tightly
		// * / //NameOrFunctionCall hidden(WS,TK_COMMENT):
		////  (KW_QUOTE)?
		////  fnname=TK_ID (=> lsp=KW_DOLLAR 'Lisp'/ *t2=TypeExpression* /)?
		////  // option for parameters in parenthesis
		////  (
		////// LPAREN t4=StatementExpression? (COMMA t5+=Expression)* RPAREN //(COLON rightType2 =TypeExpression)?
		////    KW_OPAREN t4=Expression? (KW_COMMA t5+=Expression)* KW_CPAREN //(COLON rightType2 =TypeExpression)?
		////    // optional curried function:
		////    (KW_OPAREN t14+=Statement? (KW_COMMA t15+=Expression)* KW_CPAREN)*
		////    // option of no parenthesis for single parameter
		////    | => t6=PrimaryExpression
		////  )?
		////  => ((KW_COMMA TK_ID)* KW_COLON rightType2 =TypeExpression1)?
		////  // allow multiple assignment
		////  //=>(op=GIVES lambda = Expression 'xxx')?
		/////;
		/// * Literals are actual values of a given type
		// * Outstanding issues:
		// * 1) Float literals are parsed as elt(Int,Int) so we need to recognise this
		// * and convert to float literal
		// * 2) We need to be able to recognise exponent notation for floats
		// * 3) Integers without '-' prefix can be converted to PI or NNI
		// * 4) need to add hex or octal notation for integers (0xhhhh)
		// * 5) String and Character literals need to have backslash "\" doubled to
		// * "\\" otherwise xtext will interpret backslash as an escape character.
		// * 6) values following immediately after string literal such as "abc"d should
		// * represent an implied concat: concat("abc",d)
		// * / //Literal hidden(WS,TK_COMMENT):
		////  value=TK_INT
		////  | t2=TK_STRING (=> e1=NameOrFunctionCall =>(t31+=TK_STRING (=> e4+=NameOrFunctionCall)?)*)?
		//// | t3=FloatLiteral // conflicts with use of '.' for elt
		////  | ListLiteral
		////  | CharacterLiteral
		////  | BooleanLiteral
		////;
		/// * Contains a single character whereas a string contains multiple
		// * characters.
		// * / //CharacterLiteral hidden(WS,TK_COMMENT):
		//// KW_QUOTE c1=ANY_OTHER KW_QUOTE
		////;
		/// * This may not need to be specified here at the syntax level. Perhaps we
		// * should treat boolean as any other library defined type.
		// * / //BooleanLiteral hidden(WS,TK_COMMENT):
		//// litname = 'true' | litname = 'false'
		//// | litname = 'true' KW_OPAREN KW_CPAREN
		//// | litname = 'false' KW_OPAREN KW_CPAREN
		////;
		/// *
		// * a list literal may consist of:
		// * [] an empty list
		// * [a] a single element
		// * [a,b] multiple elements
		// * [a for b in c] a list comprehension
		// * / //ListLiteral hidden(WS,TK_COMMENT):
		//// litname = KW_OBRACK l2=Expression?
		////     (KW_COMMA t3+=Expression)*
		////     ('for' t14+=Expression 'in' l5+=Expression)?
		////     KW_CBRACK
		////; CurlyContentB_Labeled:
		//	"temp100";
		public ParserRule getRule() { return rule; }

		//"temp100"
		public Keyword getTemp100Keyword() { return cTemp100Keyword; }
	}
	
	
	private ModelElements pModel;
	private TerminalRule tTK_ID;
	private TerminalRule tWS;
	private TerminalRule tKW_NEWLINE;
	private TerminalRule tTK_PREDOC;
	private TerminalRule tTK_POSTDOC;
	private TerminalRule tMACROVALUE;
	private TerminalRule tTK_STRING;
	private TerminalRule tTK_INT;
	private TerminalRule tKW_QUOTE;
	private TerminalRule tKW_OPAREN;
	private TerminalRule tKW_CPAREN;
	private TerminalRule tKW_OCURLY;
	private TerminalRule tKW_CCURLY;
	private TerminalRule tKW_OBRACK;
	private TerminalRule tKW_CBRACK;
	private TerminalRule tKW_2LT;
	private TerminalRule tKW_2GT;
	private TerminalRule tKW_MARROW;
	private TerminalRule tKW_BAR;
	private TerminalRule tKW_DOT;
	private TerminalRule tKW_2COLON;
	private TerminalRule tKW_COLONSTAR;
	private TerminalRule tKW_COLON;
	private TerminalRule tKW_AT;
	private TerminalRule tKW_COMMA;
	private TerminalRule tKW_SEMICOLON;
	private TerminalRule tKW_2STAR;
	private TerminalRule tKW_STAR;
	private TerminalRule tKW_PLUS;
	private TerminalRule tKW_MINUS;
	private TerminalRule tKW_PLUSMINUS;
	private TerminalRule tKW_LT;
	private TerminalRule tKW_GT;
	private TerminalRule tKW_LE;
	private TerminalRule tKW_GE;
	private TerminalRule tKW_EQ;
	private TerminalRule tKW_TILDEE;
	private TerminalRule tKW_HATE;
	private TerminalRule tKW_TILDE;
	private TerminalRule tKW_HAT;
	private TerminalRule tKW_2DOT;
	private TerminalRule tKW_SHARP;
	private TerminalRule tKW_AMPERSAND;
	private TerminalRule tKW_DOLLAR;
	private TerminalRule tKW_SLASH;
	private TerminalRule tKW_BACKSLASH;
	private TerminalRule tSLASHSLASH;
	private TerminalRule tBACKSLASHBACKSLASH;
	private TerminalRule tKW_WEDGE;
	private TerminalRule tKW_VEE;
	private TerminalRule tTIMESDOLAR;
	private TerminalRule tDIVDOLAR;
	private TerminalRule tPLUSDOLAR;
	private TerminalRule tMINUSDOLAR;
	private TerminalRule tEQUALSDOLAR;
	private TerminalRule tKW_IMPLIES;
	private TerminalRule tKW_ASSIGN;
	private TerminalRule tKW_2EQ;
	private TerminalRule tKW_RARROW;
	private TerminalRule tKW_LARROW;
	private TerminalRule tKW_MAPSTO;
	private TerminalRule tKW_MAPSTOSTAR;
	private TerminalRule tKW_MAPSTAR;
	private TerminalRule tPERCENT;
	private TerminalRule tPRIMEPERCENT;
	private TerminalRule tELLIPSIS;
	private TerminalRule tSUMLIST;
	private TerminalRule tANY_OTHER;
	private ErrorElements pError;
	private ExpressionElements pExpression;
	private LabeledElements pLabeled;
	private DeclarationElements pDeclaration;
	private ExportDeclElements pExportDecl;
	private ToPartElements pToPart;
	private FromPartElements pFromPart;
	private MacroBodyElements pMacroBody;
	private SigElements pSig;
	private DeclPartElements pDeclPart;
	private CommaElements pComma;
	private CommaItemElements pCommaItem;
	private DeclBindingElements pDeclBinding;
	private InfixedExprsDeclElements pInfixedExprsDecl;
	private InfixedExprsElements pInfixedExprs;
	private Binding_AnyStatementElements pBinding_AnyStatement;
	private Binding_BalStatementElements pBinding_BalStatement;
	private Binding_CollectionElements pBinding_Collection;
	private BindingL_Infixed_AnyStatementElements pBindingL_Infixed_AnyStatement;
	private BindingL_Infixed_BalStatementElements pBindingL_Infixed_BalStatement;
	private BindingL_Infixed_CollectionElements pBindingL_Infixed_Collection;
	private BindingR_InfixedExprsDecl_AnyStatementElements pBindingR_InfixedExprsDecl_AnyStatement;
	private AnyStatementElements pAnyStatement;
	private BalStatementElements pBalStatement;
	private Flow_AnyStatementElements pFlow_AnyStatement;
	private Flow_BalStatementElements pFlow_BalStatement;
	private GenBoundElements pGenBound;
	private ButExprElements pButExpr;
	private CasesElements pCases;
	private AlwaysPart_AnyStatementElements pAlwaysPart_AnyStatement;
	private AlwaysPart_BalStatementElements pAlwaysPart_BalStatement;
	private CollectionElements pCollection;
	private IteratorsElements pIterators;
	private Iterators1Elements pIterators1;
	private IteratorElements pIterator;
	private ForLhsElements pForLhs;
	private SuchthatPartElements pSuchthatPart;
	private InfixedElements pInfixed;
	private InfixedExprElements pInfixedExpr;
	private TypeElements pType;
	private OpQualTailElements pOpQualTail;
	private E14Elements pE14;
	private E15Elements pE15;
	private OpElements pOp;
	private NakedOpElements pNakedOp;
	private ArrowOpElements pArrowOp;
	private LatticeOpElements pLatticeOp;
	private RelationOpElements pRelationOp;
	private SegOpElements pSegOp;
	private PlusOpElements pPlusOp;
	private QuotientOpElements pQuotientOp;
	private TimesOpElements pTimesOp;
	private PowerOpElements pPowerOp;
	private ArrowTokElements pArrowTok;
	private LatticeTokElements pLatticeTok;
	private RelationTokElements pRelationTok;
	private SegTokElements pSegTok;
	private PlusTokElements pPlusTok;
	private QuotientTokElements pQuotientTok;
	private TimesTokElements pTimesTok;
	private PowerTokElements pPowerTok;
	private ApplicationElements pApplication;
	private RightJuxtaposedElements pRightJuxtaposed;
	private LeftJuxtaposedElements pLeftJuxtaposed;
	private Jright_MoleculeElements pJright_Molecule;
	private Jright_AtomElements pJright_Atom;
	private Jleft_MoleculeElements pJleft_Molecule;
	private Jleft_AtomElements pJleft_Atom;
	private MoleculeElements pMolecule;
	private EnclosureElements pEnclosure;
	private DeclMoleculeElements pDeclMolecule;
	private BlockMoleculeElements pBlockMolecule;
	private BlockEnclosureElements pBlockEnclosure;
	private BlockElements pBlock;
	private ParenedElements pParened;
	private BracketedElements pBracketed;
	private QuotedIdsElements pQuotedIds;
	private NamesElements pNames;
	private AtomElements pAtom;
	private NameElements pName;
	private IdElements pId;
	private LiteralElements pLiteral;
	private UnqualOp_ArrowTokElements pUnqualOp_ArrowTok;
	private UnqualOp_LatticeTokElements pUnqualOp_LatticeTok;
	private UnqualOp_RelationTokElements pUnqualOp_RelationTok;
	private UnqualOp_SegTokElements pUnqualOp_SegTok;
	private UnqualOp_PlusTokElements pUnqualOp_PlusTok;
	private UnqualOp_QuotientTokElements pUnqualOp_QuotientTok;
	private UnqualOp_TimesTokElements pUnqualOp_TimesTok;
	private UnqualOp_PowerTokElements pUnqualOp_PowerTok;
	private QualOp_ArrowTokElements pQualOp_ArrowTok;
	private QualOp_LatticeTokElements pQualOp_LatticeTok;
	private QualOp_RelationTokElements pQualOp_RelationTok;
	private QualOp_SegTokElements pQualOp_SegTok;
	private QualOp_PlusTokElements pQualOp_PlusTok;
	private QualOp_QuotientTokElements pQualOp_QuotientTok;
	private QualOp_TimesTokElements pQualOp_TimesTok;
	private QualOp_PowerTokElements pQualOp_PowerTok;
	private PreDocumentElements pPreDocument;
	private PostDocumentElements pPostDocument;
	private PreDocumentListElements pPreDocumentList;
	private PostDocumentListElements pPostDocumentList;
	private Enlist1_CommaItem_Comma_ABElements pEnlist1_CommaItem_Comma_AB;
	private Enlist1_Infixed_Comma_ABElements pEnlist1_Infixed_Comma_AB;
	private Enlist1_InfixedExpr_Comma_ABElements pEnlist1_InfixedExpr_Comma_AB;
	private Enlister1_CommaItem_CommaElements pEnlister1_CommaItem_Comma;
	private Enlister1_Infixed_CommaElements pEnlister1_Infixed_Comma;
	private Enlister1_InfixedExpr_CommaElements pEnlister1_InfixedExpr_Comma;
	private Enlist1a_Labeled_Semicolon_ABElements pEnlist1a_Labeled_Semicolon_AB;
	private Enlister1a_Labeled_SemicolonElements pEnlister1a_Labeled_Semicolon;
	private Curly_LabeledElements pCurly_Labeled;
	private CurlyContents_LabeledElements pCurlyContents_Labeled;
	private CurlyContentsList_LabeledElements pCurlyContentsList_Labeled;
	private CurlyContentB_LabeledElements pCurlyContentB_Labeled;
	
	private final Grammar grammar;

	@Inject
	public EditorGrammarAccess(GrammarProvider grammarProvider) {
		this.grammar = internalFindGrammar(grammarProvider);
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("com.euclideanspace.aldor.Editor".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	
	public Grammar getGrammar() {
		return grammar;
	}
	

	
	/// * Copyright 2014 Martin John Baker
	// *
	// * This file is part of EuclideanSpace.
	// *
	// * EuclideanSpace is free software: you can redistribute it and/or modify
	// * it under the terms of the GNU Affero General Public License as published by
	// * the Free Software Foundation, either version 3 of the License, or
	// * (at your option) any later version.
	// *
	// * EuclideanSpace is distributed in the hope that it will be useful,
	// * but WITHOUT ANY WARRANTY; without even the implied warranty of
	// * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
	// * GNU Affero General Public License for more details.
	// *
	// * You should have received a copy of the GNU Affero General Public License
	// * along with EuclideanSpace. If not, see <http://www.gnu.org/licenses/>.
	// * / / *
	// *
	// * Here we are using a LL(*) recursive-descent parser generator and this
	// * may not be able to exactly replicate axl.z which is a
	// * LALR(1) conflict-free grammar for Aldor.
	// * / / * from tokInfoTable[] in token.c: Lexical elements.
	// * The TokenTag enumeration must use this order.
	// *
	// * This table MUST be laid out so that all "symbol" tokens starting with
	// * the same character are contiguous.
	// *
	// * Be extra careful with fields F, G, H and K: if you get them wrong then
	// * the lineariser will delete end-of-statement tokens when it ought not
	// * to. This can lead to odd compiler behaviour that is hard to track down
	// * unless you know about this table.
	// *
	// * struct tok_info tokInfoTable[] = {
	// *
	// * [A] TokenTag tag
	// * [B] Symbol sym
	// * [C] String str
	// * [D] Byte hasString i.e. use val.str (vs val.sym)
	// * [E] Byte isComment i.e. ++ --
	// * [F] Byte isOpener i.e. ( [ { etc
	// * [G] Byte isCloser i.e. ) ] } etc
	// * [H] Byte isFollower i.e. then else always in etc
	// * [I] Byte isLangword i.e. if then etc
	// * [J] Byte isLeftAssoc i.e., associates left to right
	// * [K] Byte isMaybeInfix i.e., add, with, +
	// * [L] Byte precedence i.e., 0 is lowest, or don't know
	// * [M] Byte isDisabled i.e., non-zero means disabled
	// *
	// * [A] [B][C] [D][E] [F] [G] [H] [I] [J] [K] [L] [M]
	// *
	//        {TK_Blank, 0,"TK_Blank", 0, 0, 0, 0, 0, 0, 1, 0, 170, 0},
	//        {TK_FLOAT, 0,"TK_FLOAT", 1, 0, 0, 0, 0, 0, 1, 0, 170, 0},
	//        {TK_SysCmd, 0,"TK_SysCmd", 1, 1, 0, 0, 0, 0, 1, 0, 170, 0},
	//        {TK_Error, 0,"TK_Error", 1, 0, 0, 0, 0, 0, 1, 0, 0, 0},
	//
	//        {KW_Add, 0,"add", 0, 0, 0, 0, 0, 1, 1, 0, 0, 0},
	//        {KW_And, 0,"and", 0, 0, 0, 0, 1, 1, 1, 1, 40, 0},
	//        {KW_Always, 0,"always", 0, 0, 0, 0, 1, 1, 1, 1, 0, 0},
	//        {KW_Assert, 0,"assert", 0, 0, 0, 0, 0, 1, 1, 0, 0, 0},
	//        {KW_Break, 0,"break", 0, 0, 0, 0, 0, 1, 1, 0, 0, 0},
	//        {KW_But, 0,"but", 0, 0, 0, 0, 1, 1, 1, 1, 0, 0},
	//        {KW_By, 0,"by", 0, 0, 0, 0, 0, 0, 1, 1, 110, 0},
	//        {KW_CASE, 0,"case", 0, 0, 0, 0, 0, 0, 1, 1, 0, 0},
	//        {KW_Catch, 0,"catch", 0, 0, 0, 0, 1, 1, 1, 1, 0, 0},
	//        {KW_Default, 0,"default", 0, 0, 0, 0, 0, 1, 1, 0, 0, 0},
	//        {KW_Define, 0,"define", 0, 0, 0, 0, 0, 1, 1, 0, 0, 0},
	//        {KW_Delay, 0,"delay", 0, 0, 0, 0, 0, 1, 1, 0, 0, 0},
	//        {KW_Do, 0,"do", 0, 0, 0, 0, 0, 1, 1, 0, 0, 0},
	//        {KW_Else, 0,"else", 0, 0, 0, 0, 1, 1, 1, 0, 0, 0},
	//        {KW_Except, 0,"except", 0, 0, 0, 0, 0, 1, 1, 1, 0, 0},
	//        {KW_Export, 0,"export", 0, 0, 0, 0, 0, 1, 1, 0, 0, 0},
	//        {KW_Exquo, 0,"exquo", 0, 0, 0, 0, 0, 0, 1, 1, 125, 0},
	//        {KW_Extend, 0,"extend", 0, 0, 0, 0, 0, 1, 1, 0, 0, 0},
	//        {KW_Finally, 0,"finally", 0, 0, 0, 0, 1, 1, 1, 1, 0, 0},
	//        {KW_Fix, 0,"fix", 0, 0, 0, 0, 0, 1, 1, 0, 0, 0},
	//        {KW_For, 0,"for", 0, 0, 0, 0, 0, 1, 1, 0, 0, 0},
	//        {KW_Fluid, 0,"fluid", 0, 0, 0, 0, 0, 1, 1, 0, 0, 0},
	//        {KW_Free, 0,"free", 0, 0, 0, 0, 0, 1, 1, 0, 0, 0},
	//        {KW_From, 0,"from", 0, 0, 0, 0, 1, 1, 1, 0, 0, 0},
	//        {KW_Generate, 0,"generate", 0, 0, 0, 0, 0, 1, 1, 0, 0, 0},
	//        {KW_Goto, 0,"goto", 0, 0, 0, 0, 0, 1, 1, 0, 0, 0},
	//        {KW_Has, 0,"has", 0, 0, 0, 0, 0, 0, 1, 1, 40, 0},
	//        {KW_If, 0,"if", 0, 0, 0, 0, 0, 1, 1, 0, 0, 0},
	//        {KW_Import, 0,"import", 0, 0, 0, 0, 0, 1, 1, 0, 0, 0},
	//        {KW_In, 0,"in", 0, 0, 0, 0, 1, 1, 1, 1, 0, 0},
	//        {KW_Inline, 0,"inline", 0, 0, 0, 0, 0, 1, 1, 0, 0, 0},
	//        {KW_IS, 0,"is", 0, 0, 0, 0, 0, 1, 1, 0, 0, 0},
	//        {KW_ISNT, 0,"isnt", 0, 0, 0, 0, 0, 1, 1, 0, 0, 0},
	//        {KW_Iterate, 0,"iterate", 0, 0, 0, 0, 0, 1, 1, 0, 0, 0},
	//        {KW_Let, 0,"let", 0, 0, 0, 0, 0, 1, 1, 0, 0, 0},
	//        {KW_Local, 0,"local", 0, 0, 0, 0, 0, 1, 1, 0, 0, 0},
	//        {KW_Macro, 0,"macro", 0, 0, 0, 0, 0, 1, 1, 0, 0, 0},
	//        {KW_Mod, 0,"mod", 0, 0, 0, 0, 0, 0, 1, 1, 125, 0},
	//        {KW_Never, 0,"never", 0, 0, 0, 0, 0, 1, 1, 0, 0, 0},
	//        {KW_Not, 0,"not", 0, 0, 0, 0, 0, 1, 1, 1, 150, 0},
	//        {KW_Of, 0,"of", 0, 0, 0, 0, 1, 1, 1, 1, 40, 0},
	//        {KW_Or, 0,"or", 0, 0, 0, 0, 1, 1, 1, 1, 40, 0},
	//        {KW_Pretend, 0,"pretend", 0, 0, 0, 0, 1, 1, 1, 1, 150, 0},
	//        {KW_Quo, 0,"quo", 0, 0, 0, 0, 0, 0, 1, 1, 125, 0},
	//        {KW_Reference, 0,"ref", 0, 0, 0, 0, 0, 1, 1, 0, 0, 0},
	//        {KW_Rem, 0,"rem", 0, 0, 0, 0, 0, 0, 1, 1, 125, 0},
	//        {KW_Repeat, 0,"repeat", 0, 0, 0, 0, 0, 1, 1, 0, 0, 0},
	//        {KW_Return, 0,"return", 0, 0, 0, 0, 0, 1, 1, 0, 0, 0},
	//        {KW_Rule, 0,"rule", 0, 0, 0, 0, 0, 1, 1, 0, 0, 0},
	//        {KW_Select, 0,"select", 0, 0, 0, 0, 0, 1, 1, 0, 0, 0},
	//        {KW_Then, 0,"then", 0, 0, 0, 0, 1, 1, 1, 0, 0, 0},
	//        {KW_Throw, 0,"throw", 0, 0, 0, 0, 0, 1, 1, 1, 0, 0},
	//        {KW_To, 0,"to", 0, 0, 0, 0, 1, 1, 1, 0, 0, 0},
	//        {KW_Try, 0,"try", 0, 0, 0, 0, 0, 1, 1, 0, 0, 0},
	//        {KW_Where, 0,"where", 0, 0, 0, 0, 1, 1, 1, 0, 0, 0},
	//        {KW_While, 0,"while", 0, 0, 0, 0, 0, 1, 1, 0, 0, 0},
	//        {KW_With, 0,"with", 0, 0, 0, 0, 0, 1, 1, 0, 0, 0},
	//        {KW_Yield, 0,"yield", 0, 0, 0, 0, 0, 1, 1, 0, 0, 0},
	//
	//        {KW_Grave, 0,"`", 0, 0, 0, 0, 0, 0, 1, 0, 0, 0},
	//        
	//
	//        {KW_LARROW, 0,"<-", 0, 0, 0, 0, 0, 0, 1, 1, 0, 0},
	//
	//
	//
	//        {KW_STARtPile, 0,"#pile", 0, 0, 0, 0, 0, 0, 1, 0, 0, 0},
	//        {KW_EndPile, 0,"#endpile", 0, 0, 0, 0, 0, 0, 1, 0, 0, 0},
	//        {KW_SetTab, 0,"KW_SetTab", 0, 0, 0, 0, 0, 0, 1, 0, 0, 0},
	//        {KW_BackSet, 0,"KW_BackSet", 0, 0, 0, 0, 0, 0, 1, 0, 0, 0},
	//        {KW_BackTab, 0,"KW_BackTab", 0, 0, 0, 0, 0, 0, 1, 0, 0, 0},
	//        {KW_Juxtapose, 0,"KW_Juxtapose",0, 0, 0, 0, 0, 0, 0, 0, 170, 0},
	//
	//        {TK_LIMIT, 0,"TK_LIMIT", 0, 0, 0, 0, 0, 0, 1, 0, 0, 0}
	//};
	// * / / *
	// * replaces Goal rule in Aldor grammar
	// * Parser starts here
	// * CategoryDef,PackageDef and DomainDef must end with newline to ensure that
	// * only an '@' at the start of a line will be taken as the end.
	// *
	// * On this line whitespace (WS) is not hidden so is explicitly included.
	// * / Model:
	//	CurlyContents_Labeled;
	public ModelElements getModelAccess() {
		return (pModel != null) ? pModel : (pModel = new ModelElements());
	}
	
	public ParserRule getModelRule() {
		return getModelAccess().getRule();
	}

	////Goal
	////: CurlyContents(Labeled)
	////{ yypval = $$ = $1; }
	////;
	//////////// start of lexer rules ///////////////
	/// * ID consists of alpha (upper or lower case) followed by alphanumeric
	// * any other character can stand in for alpha if prefixed by '_'
	// * for instance a multiply function is often named '_*'
	// * IDs can also end with ? or ! where:
	// * '?' indicates a function which returns a boolean value
	// * '!' indicates a function which changes an existing domain value
	// * (in a mutable domain)
	//        {TK_ID, 0,"TK_ID", 0, 0, 0, 0, 0, 0, 1, 0, 170, 0},
	// * / terminal TK_ID:
	//	("a".."z" | "A".."Z" | "_" .) ("a".."z" | "A".."Z" | "_" . | "0".."9")* "!"? "?"?;
	public TerminalRule getTK_IDRule() {
		return (tTK_ID != null) ? tTK_ID : (tTK_ID = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "TK_ID"));
	} 

	/// * whitespace on single line overrides default whitespace
	// * does not include newline unless it follows underscore.
	// * I would have liked to do this as follows:
	// * terminal WS : (' '|'\t'|'_'(('\r'|'\n')+))+;
	// * problem: unfortunately use of underscore in this way masks the use of underscore
	// * in ID. We therefore need to remove this type of underscore in a
	// * preprocessor
	// * / terminal WS:
	//	(" " | "\t")+;
	public TerminalRule getWSRule() {
		return (tWS != null) ? tWS : (tWS = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "WS"));
	} 

	/// * at least one newline or carriage return character.
	// * This is not included with WS because whitespace is significant in SPAD.
	// * We usually absorb newlines like this: NL+ which absorbs any number of
	// * blank lines and it also supports both the Linux and the Windows forms of
	// * newlines.
	// * {KW_NewLine, 0,"\n", 0, 0, 0, 0, 0, 0, 1, 0, 0, 0},
	// * / terminal KW_NEWLINE:
	//	"\r" | "\n";
	public TerminalRule getKW_NEWLINERule() {
		return (tKW_NEWLINE != null) ? tKW_NEWLINE : (tKW_NEWLINE = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "KW_NEWLINE"));
	} 

	/// * overwriting TK_COMMENTS we do not want Java syntax (//) but spad syntax (--)
	// * This absorbs everything from '--' or '++' to the end of the line (but not
	// * including the newline or carriage return characters)
	// * 
	// *  {TK_PREDOC, 0,"TK_PREDOC", 1, 1, 0, 0, 0, 0, 1, 0, 170, 0},
	//    {TK_POSTDOC, 0,"TK_POSTDOC", 1, 1, 0, 0, 0, 0, 1, 0, 170, 0},
	//    {TK_COMMENT, 0,"TK_COMMENT", 1, 1, 0, 0, 0, 0, 1, 0, 170, 0},
	// * / //terminal TK_COMMENT :
	////  ('--'|'++') !('\n'|'\r')* ;//('\r'|'\n')?;
	////('\r'|'\n')?;
	//terminal TK_PREDOC:
	//	"--" !("\n" | "\r")*;
	public TerminalRule getTK_PREDOCRule() {
		return (tTK_PREDOC != null) ? tTK_PREDOC : (tTK_PREDOC = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "TK_PREDOC"));
	} 

	////('\r'|'\n')?;
	//terminal TK_POSTDOC:
	//	"++" !("\n" | "\r")*;
	public TerminalRule getTK_POSTDOCRule() {
		return (tTK_POSTDOC != null) ? tTK_POSTDOC : (tTK_POSTDOC = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "TK_POSTDOC"));
	} 

	/// * Macro value can be anything until the end of line
	// * Macro is really '==>' but the pre-processor inserts an extra '=' so
	// * that we can distinguish from where ==> is used in 'with' or 'add' parts
	// * It is difficult for a LL(*) parser to handle macros so we want to
	// * substitute the macro in a pre-processor * / terminal MACROVALUE:
	//	"===>" !("\n" | "\r")*;
	public TerminalRule getMACROVALUERule() {
		return (tMACROVALUE != null) ? tMACROVALUE : (tMACROVALUE = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "MACROVALUE"));
	} 

	/// * '==>' is used in 'with' or 'add' parts so is not really a macro?
	// * / //terminal MACRO:
	//// '==>'
	////;
	/// * string literals are enclosed in double quotes
	// *         {TK_STRING, 0,"TK_STRING", 1, 0, 0, 0, 0, 0, 1, 0, 170, 0},
	// 
	// * / terminal TK_STRING:
	//	"\"" !"\""* "\"";
	public TerminalRule getTK_STRINGRule() {
		return (tTK_STRING != null) ? tTK_STRING : (tTK_STRING = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "TK_STRING"));
	} 

	/// *
	// * Integer
	// *
	// * {TK_INT, 0,"TK_INT", 1, 0, 0, 0, 0, 0, 1, 0, 170, 0},
	// * / terminal TK_INT returns ecore::EInt:
	//	"0".."9"+;
	public TerminalRule getTK_INTRule() {
		return (tTK_INT != null) ? tTK_INT : (tTK_INT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "TK_INT"));
	} 

	/// * grouping
	// * {KW_OBBrack, 0,"[|", 0, 0, 1, 0, 0, 0, 1, 0, 0, 0},
	// * {KW_OBCurly, 0,"{|", 0, 0, 1, 0, 0, 0, 1, 0, 0, 0},
	// * {KW_OBParen, 0,"(|", 0, 0, 1, 0, 0, 0, 1, 0, 0, 0},
	// * 
	// * {KW_CBBrack, 0,"|]", 0, 0, 0, 1, 0, 0, 1, 0, 0, 0},
	// * {KW_CBCurly, 0,"|}", 0, 0, 0, 1, 0, 0, 1, 0, 0, 0},
	// * {KW_CBParen, 0,"|)", 0, 0, 0, 1, 0, 0, 1, 0, 0, 0},
	// * {KW_2Bar, 0,"||", 0, 0, 0, 0, 0, 1, 1, 0, 0, 0},
	// * 
	// * / / * '
	// * {KW_QUOTE, 0,"'", 0, 0, 0, 0, 0, 0, 1, 0, 0, 0},
	// * / terminal KW_QUOTE:
	//	"\'";
	public TerminalRule getKW_QUOTERule() {
		return (tKW_QUOTE != null) ? tKW_QUOTE : (tKW_QUOTE = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "KW_QUOTE"));
	} 

	/// * (
	// * {KW_OPAREN, 0,"(", 0, 0, 1, 0, 0, 0, 1, 0, 0, 0},
	// * / terminal KW_OPAREN:
	//	"(";
	public TerminalRule getKW_OPARENRule() {
		return (tKW_OPAREN != null) ? tKW_OPAREN : (tKW_OPAREN = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "KW_OPAREN"));
	} 

	/// * )
	// * {KW_CPAREN, 0,")", 0, 0, 0, 1, 0, 0, 1, 0, 0, 0},
	// * / terminal KW_CPAREN:
	//	")";
	public TerminalRule getKW_CPARENRule() {
		return (tKW_CPAREN != null) ? tKW_CPAREN : (tKW_CPAREN = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "KW_CPAREN"));
	} 

	/// * {
	// * {KW_OCURLY, 0,"{", 0, 0, 1, 0, 0, 0, 1, 0, 0, 0},
	// * / terminal KW_OCURLY:
	//	"{";
	public TerminalRule getKW_OCURLYRule() {
		return (tKW_OCURLY != null) ? tKW_OCURLY : (tKW_OCURLY = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "KW_OCURLY"));
	} 

	/// * }
	// * {KW_CCURLY, 0,"}", 0, 0, 0, 1, 0, 0, 1, 0, 0, 0},
	// * / terminal KW_CCURLY:
	//	"}";
	public TerminalRule getKW_CCURLYRule() {
		return (tKW_CCURLY != null) ? tKW_CCURLY : (tKW_CCURLY = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "KW_CCURLY"));
	} 

	/// * [
	// * {KW_OBRACK, 0,"[", 0, 0, 1, 0, 0, 0, 1, 0, 0, 0},
	// * / terminal KW_OBRACK:
	//	"[";
	public TerminalRule getKW_OBRACKRule() {
		return (tKW_OBRACK != null) ? tKW_OBRACK : (tKW_OBRACK = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "KW_OBRACK"));
	} 

	/// * ]
	// * {KW_CBRACK, 0,"]", 0, 0, 0, 1, 0, 0, 1, 0, 0, 0},
	// * / terminal KW_CBRACK:
	//	"]";
	public TerminalRule getKW_CBRACKRule() {
		return (tKW_CBRACK != null) ? tKW_CBRACK : (tKW_CBRACK = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "KW_CBRACK"));
	} 

	/// *
	//terminal LBANANA '(|';
	//terminal RBANANA '|)';
	//terminal EBRACKET '[__]';
	//terminal EBRACKET2 '[]';
	//terminal EBRACE '{__}';
	//terminal EBRACE2 '{}';
	//terminal LBANANABRACKET '[|';
	//terminal RBANANABRACKET '|]';
	//terminal EBANANABRACKET '[|__|]';
	//terminal EBANANABRACKET2 '[||]';
	//terminal LBANANABRACE '{|';
	//terminal RBANANABRACE '|}';
	//terminal EBANANABRACE '{|__|}';
	//terminal EBANANABRACE2 '{||}'; * / / * <<
	// * {KW_2LT, 0,"<<", 0, 0, 0, 0, 0, 0, 1, 1, 100, 0},
	// * / terminal KW_2LT:
	//	"<<";
	public TerminalRule getKW_2LTRule() {
		return (tKW_2LT != null) ? tKW_2LT : (tKW_2LT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "KW_2LT"));
	} 

	/// * >>
	// * {KW_2GT, 0,">>", 0, 0, 0, 0, 0, 0, 1, 1, 100, 0},
	// * / terminal KW_2GT:
	//	">>";
	public TerminalRule getKW_2GTRule() {
		return (tKW_2GT != null) ? tKW_2GT : (tKW_2GT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "KW_2GT"));
	} 

	/// *terminal QUOTE "'";
	//terminal BACKQUOTE "`";* / // operators
	/// * ==> MDEF or MARROW
	// * {KW_MARROW, 0,"==>", 0, 0, 0, 0, 1, 0, 0, 1, 25, 0},
	// * / terminal KW_MARROW:
	//	"==>";
	public TerminalRule getKW_MARROWRule() {
		return (tKW_MARROW != null) ? tKW_MARROW : (tKW_MARROW = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "KW_MARROW"));
	} 

	/// * |
	// * {KW_Bar, 0,"|", 0, 0, 0, 0, 0, 0, 1, 0, 0, 0},
	// * / terminal KW_BAR:
	//	"|";
	public TerminalRule getKW_BARRule() {
		return (tKW_BAR != null) ? tKW_BAR : (tKW_BAR = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "KW_BAR"));
	} 

	/// * .
	// * {KW_DOT, 0,".", 0, 0, 0, 0, 1, 0, 1, 1, 170, 0},
	// * / terminal KW_DOT:
	//	".";
	public TerminalRule getKW_DOTRule() {
		return (tKW_DOT != null) ? tKW_DOT : (tKW_DOT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "KW_DOT"));
	} 

	/// * :: 2Colon or coerce
	// * {KW_2Colon, 0,"::", 0, 0, 0, 0, 1, 0, 1, 1, 150, 0},
	// * / terminal KW_2COLON:
	//	"::";
	public TerminalRule getKW_2COLONRule() {
		return (tKW_2COLON != null) ? tKW_2COLON : (tKW_2COLON = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "KW_2COLON"));
	} 

	/// * :*
	// * {KW_ColonStar, 0,":*", 0, 0, 0, 0, 1, 0, 1, 1, 36, 0},
	// * / terminal KW_COLONSTAR:
	//	":*";
	public TerminalRule getKW_COLONSTARRule() {
		return (tKW_COLONSTAR != null) ? tKW_COLONSTAR : (tKW_COLONSTAR = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "KW_COLONSTAR"));
	} 

	/// * :
	// * {KW_Colon, 0,":", 0, 0, 0, 0, 1, 0, 1, 1, 36, 0},
	// * / terminal KW_COLON:
	//	":";
	public TerminalRule getKW_COLONRule() {
		return (tKW_COLON != null) ? tKW_COLON : (tKW_COLON = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "KW_COLON"));
	} 

	/// * @
	// * {KW_At, 0,"@", 0, 0, 0, 0, 0, 0, 1, 1, 150, 0},
	// * / terminal KW_AT:
	//	"@";
	public TerminalRule getKW_ATRule() {
		return (tKW_AT != null) ? tKW_AT : (tKW_AT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "KW_AT"));
	} 

	/// * , 
	// * {KW_Comma, 0,",", 0, 0, 0, 0, 1, 0, 1, 1, 11, 0},
	// * / terminal KW_COMMA:
	//	",";
	public TerminalRule getKW_COMMARule() {
		return (tKW_COMMA != null) ? tKW_COMMA : (tKW_COMMA = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "KW_COMMA"));
	} 

	/// * ;
	// * {KW_SEMICOLON, 0,";", 0, 0, 0, 0, 0, 0, 1, 0, 10, 0},
	// * / terminal KW_SEMICOLON:
	//	";";
	public TerminalRule getKW_SEMICOLONRule() {
		return (tKW_SEMICOLON != null) ? tKW_SEMICOLON : (tKW_SEMICOLON = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "KW_SEMICOLON"));
	} 

	/// * ** 2star or power
	// * {KW_2STAR, 0,"**", 0, 0, 0, 0, 0, 0, 1, 1, 140, 0},
	// * / terminal KW_2STAR:
	//	"**";
	public TerminalRule getKW_2STARRule() {
		return (tKW_2STAR != null) ? tKW_2STAR : (tKW_2STAR = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "KW_2STAR"));
	} 

	/// * * times or star
	// * {KW_STAR, 0,"*", 0, 0, 0, 0, 0, 0, 1, 1, 130, 0},
	// * / terminal KW_STAR:
	//	"*";
	public TerminalRule getKW_STARRule() {
		return (tKW_STAR != null) ? tKW_STAR : (tKW_STAR = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "KW_STAR"));
	} 

	/// * + plus
	// * {KW_PLUS, 0,"+", 0, 0, 0, 0, 0, 0, 1, 1, 120, 0},
	// * / terminal KW_PLUS:
	//	"+";
	public TerminalRule getKW_PLUSRule() {
		return (tKW_PLUS != null) ? tKW_PLUS : (tKW_PLUS = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "KW_PLUS"));
	} 

	/// * -
	// * {KW_MINUS, 0,"-", 0, 0, 0, 0, 0, 0, 1, 1, 120, 0},
	// * / terminal KW_MINUS:
	//	"-";
	public TerminalRule getKW_MINUSRule() {
		return (tKW_MINUS != null) ? tKW_MINUS : (tKW_MINUS = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "KW_MINUS"));
	} 

	/// * +-
	// * {KW_PLUSMINUS, 0,"+-", 0, 0, 0, 0, 0, 0, 1, 1, 120, 0},
	// * / terminal KW_PLUSMINUS:
	//	"+-";
	public TerminalRule getKW_PLUSMINUSRule() {
		return (tKW_PLUSMINUS != null) ? tKW_PLUSMINUS : (tKW_PLUSMINUS = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "KW_PLUSMINUS"));
	} 

	/// * <
	// * {KW_GT, 0,">", 0, 0, 0, 0, 0, 0, 1, 1, 100, 0},
	// * {KW_GE, 0,">=", 0, 0, 0, 0, 0, 0, 1, 1, 100, 0},
	// * {KW_LT, 0,"<", 0, 0, 0, 0, 0, 0, 1, 1, 100, 0},
	// * {KW_LE, 0,"<=", 0, 0, 0, 0, 0, 0, 1, 1, 100, 0},
	// * / terminal KW_LT:
	//	"<";
	public TerminalRule getKW_LTRule() {
		return (tKW_LT != null) ? tKW_LT : (tKW_LT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "KW_LT"));
	} 

	/// * > * / terminal KW_GT:
	//	">";
	public TerminalRule getKW_GTRule() {
		return (tKW_GT != null) ? tKW_GT : (tKW_GT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "KW_GT"));
	} 

	/// * <= * / terminal KW_LE:
	//	"<=";
	public TerminalRule getKW_LERule() {
		return (tKW_LE != null) ? tKW_LE : (tKW_LE = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "KW_LE"));
	} 

	/// * >= * / terminal KW_GE:
	//	">=";
	public TerminalRule getKW_GERule() {
		return (tKW_GE != null) ? tKW_GE : (tKW_GE = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "KW_GE"));
	} 

	/// * = equal
	// * {KW_EQ, 0,"=", 0, 0, 0, 0, 0, 0, 1, 1, 100, 0},
	// * / terminal KW_EQ:
	//	"=";
	public TerminalRule getKW_EQRule() {
		return (tKW_EQ != null) ? tKW_EQ : (tKW_EQ = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "KW_EQ"));
	} 

	/// * ~= not-equal or tilde-equal
	// * {KW_TILDEE, 0,"~=", 0, 0, 0, 0, 0, 0, 1, 1, 90, 0},
	// * / terminal KW_TILDEE:
	//	"~=";
	public TerminalRule getKW_TILDEERule() {
		return (tKW_TILDEE != null) ? tKW_TILDEE : (tKW_TILDEE = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "KW_TILDEE"));
	} 

	/// * ^= hat-equal
	// * {KW_HATE, 0,"^=", 0, 0, 0, 0, 0, 0, 1, 1, 90, 0},
	// * / terminal KW_HATE:
	//	"^=";
	public TerminalRule getKW_HATERule() {
		return (tKW_HATE != null) ? tKW_HATE : (tKW_HATE = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "KW_HATE"));
	} 

	/// * ~
	// * {KW_TILDE, 0,"~", 0, 0, 0, 0, 0, 0, 0, 1, 150, 0},
	// * / terminal KW_TILDE:
	//	"~";
	public TerminalRule getKW_TILDERule() {
		return (tKW_TILDE != null) ? tKW_TILDE : (tKW_TILDE = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "KW_TILDE"));
	} 

	/// * ^ hat or carat
	// * {KW_HAT, 0,"^", 0, 0, 0, 0, 0, 0, 1, 1, 140, 0},
	// * / terminal KW_HAT:
	//	"^";
	public TerminalRule getKW_HATRule() {
		return (tKW_HAT != null) ? tKW_HAT : (tKW_HAT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "KW_HAT"));
	} 

	/// * .. 2Dot or seg
	// *{KW_2DOT, 0,"..", 0, 0, 0, 0, 0, 0, 1, 1, 110, 0},
	// * 
	// * / terminal KW_2DOT:
	//	"..";
	public TerminalRule getKW_2DOTRule() {
		return (tKW_2DOT != null) ? tKW_2DOT : (tKW_2DOT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "KW_2DOT"));
	} 

	/// * # Hash or Sharp
	// * {KW_SHARP, 0,"#", 0, 0, 0, 0, 0, 0, 1, 0, 0, 0},
	// * / terminal KW_SHARP:
	//	"#";
	public TerminalRule getKW_SHARPRule() {
		return (tKW_SHARP != null) ? tKW_SHARP : (tKW_SHARP = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "KW_SHARP"));
	} 

	/// * &
	// * {KW_Ampersand, 0,"&", 0, 0, 0, 0, 0, 0, 1, 0, 160, 0},
	// * / terminal KW_AMPERSAND:
	//	"&";
	public TerminalRule getKW_AMPERSANDRule() {
		return (tKW_AMPERSAND != null) ? tKW_AMPERSAND : (tKW_AMPERSAND = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "KW_AMPERSAND"));
	} 

	/// * $
	// * {KW_DOLLAR, 0,"$", 0, 0, 0, 0, 1, 0, 0, 1, 70, 0},
	// * / terminal KW_DOLLAR:
	//	"$";
	public TerminalRule getKW_DOLLARRule() {
		return (tKW_DOLLAR != null) ? tKW_DOLLAR : (tKW_DOLLAR = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "KW_DOLLAR"));
	} 

	/// * /
	// * {KW_SLASH, 0,"/", 0, 0, 0, 0, 0, 0, 1, 1, 130, 0},
	// * / terminal KW_SLASH:
	//	"/";
	public TerminalRule getKW_SLASHRule() {
		return (tKW_SLASH != null) ? tKW_SLASH : (tKW_SLASH = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "KW_SLASH"));
	} 

	/// *
	// * {KW_BACKSLASH, 0,"\\", 0, 0, 0, 0, 0, 0, 1, 1, 130, 0},
	// * / terminal KW_BACKSLASH:
	//	"\\";
	public TerminalRule getKW_BACKSLASHRule() {
		return (tKW_BACKSLASH != null) ? tKW_BACKSLASH : (tKW_BACKSLASH = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "KW_BACKSLASH"));
	} 

	//terminal SLASHSLASH:
	//	"//";
	public TerminalRule getSLASHSLASHRule() {
		return (tSLASHSLASH != null) ? tSLASHSLASH : (tSLASHSLASH = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "SLASHSLASH"));
	} 

	//terminal BACKSLASHBACKSLASH:
	//	"\\\\";
	public TerminalRule getBACKSLASHBACKSLASHRule() {
		return (tBACKSLASHBACKSLASH != null) ? tBACKSLASHBACKSLASH : (tBACKSLASHBACKSLASH = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "BACKSLASHBACKSLASH"));
	} 

	/// * '/\\' SLASH-BACKSLASH or wedge
	// * outer product or logical 'and'
	// * {KW_WEDGE, 0,"/\\", 0, 0, 0, 0, 0, 0, 1, 1, 40, 0},
	// * / terminal KW_WEDGE:
	//	"/\\";
	public TerminalRule getKW_WEDGERule() {
		return (tKW_WEDGE != null) ? tKW_WEDGE : (tKW_WEDGE = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "KW_WEDGE"));
	} 

	/// * \\/ BACKSLASH-SLASH or vee
	// * inner product or logical 'or'
	// * {KW_VEE, 0,"\\/", 0, 0, 0, 0, 0, 0, 1, 1, 40, 0},
	// * / terminal KW_VEE:
	//	"\\/";
	public TerminalRule getKW_VEERule() {
		return (tKW_VEE != null) ? tKW_VEE : (tKW_VEE = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "KW_VEE"));
	} 

	/// * *$ multiply with specific type* / terminal TIMESDOLAR:
	//	"*$";
	public TerminalRule getTIMESDOLARRule() {
		return (tTIMESDOLAR != null) ? tTIMESDOLAR : (tTIMESDOLAR = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "TIMESDOLAR"));
	} 

	/// * /$ divide with specific type* / terminal DIVDOLAR:
	//	"/$";
	public TerminalRule getDIVDOLARRule() {
		return (tDIVDOLAR != null) ? tDIVDOLAR : (tDIVDOLAR = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "DIVDOLAR"));
	} 

	/// * +$ add with specific type* / terminal PLUSDOLAR:
	//	"+$";
	public TerminalRule getPLUSDOLARRule() {
		return (tPLUSDOLAR != null) ? tPLUSDOLAR : (tPLUSDOLAR = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "PLUSDOLAR"));
	} 

	/// * -$ subtract or minus with specific type* / terminal MINUSDOLAR:
	//	"-$";
	public TerminalRule getMINUSDOLARRule() {
		return (tMINUSDOLAR != null) ? tMINUSDOLAR : (tMINUSDOLAR = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "MINUSDOLAR"));
	} 

	/// * =$ equals with specific type* / terminal EQUALSDOLAR:
	//	"=$";
	public TerminalRule getEQUALSDOLARRule() {
		return (tEQUALSDOLAR != null) ? tEQUALSDOLAR : (tEQUALSDOLAR = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "EQUALSDOLAR"));
	} 

	/// * '=>' implies or exit
	// * {KW_Implies, 0,"=>", 0, 0, 0, 0, 0, 0, 1, 1, 35, 0},
	// * / terminal KW_IMPLIES:
	//	"=>";
	public TerminalRule getKW_IMPLIESRule() {
		return (tKW_IMPLIES != null) ? tKW_IMPLIES : (tKW_IMPLIES = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "KW_IMPLIES"));
	} 

	/// * := Assign or Becomes
	// * {KW_Assign, 0,":=", 0, 0, 0, 0, 1, 0, 0, 1, 20, 0},
	// * / terminal KW_ASSIGN:
	//	":=";
	public TerminalRule getKW_ASSIGNRule() {
		return (tKW_ASSIGN != null) ? tKW_ASSIGN : (tKW_ASSIGN = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "KW_ASSIGN"));
	} 

	/// * == 2eq or def
	// * {KW_2EQ, 0,"==", 0, 0, 0, 0, 1, 0, 0, 1, 25, 0},
	// * / terminal KW_2EQ:
	//	"==";
	public TerminalRule getKW_2EQRule() {
		return (tKW_2EQ != null) ? tKW_2EQ : (tKW_2EQ = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "KW_2EQ"));
	} 

	/// * -> right-arrow
	// * {KW_RARROW, 0,"->", 0, 0, 0, 0, 0, 0, 0, 1, 80, 0},
	// * / terminal KW_RARROW:
	//	"->";
	public TerminalRule getKW_RARROWRule() {
		return (tKW_RARROW != null) ? tKW_RARROW : (tKW_RARROW = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "KW_RARROW"));
	} 

	//terminal KW_LARROW:
	//	"<-";
	public TerminalRule getKW_LARROWRule() {
		return (tKW_LARROW != null) ? tKW_LARROW : (tKW_LARROW = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "KW_LARROW"));
	} 

	/// * +-> gives or maps-to
	// * {KW_MAPSTO, 0,"+->", 0, 0, 0, 0, 1, 0, 1, 1, 30, 0},
	// * / terminal KW_MAPSTO:
	//	"+->";
	public TerminalRule getKW_MAPSTORule() {
		return (tKW_MAPSTO != null) ? tKW_MAPSTO : (tKW_MAPSTO = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "KW_MAPSTO"));
	} 

	/// * +->*
	// * {KW_MAPSTOStar, 0,"+->*", 0, 0, 0, 0, 1, 0, 1, 1, 30, 0},
	// * / terminal KW_MAPSTOSTAR:
	//	"+->*";
	public TerminalRule getKW_MAPSTOSTARRule() {
		return (tKW_MAPSTOSTAR != null) ? tKW_MAPSTOSTAR : (tKW_MAPSTOSTAR = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "KW_MAPSTOSTAR"));
	} 

	/// * ->* gives or maps-to
	// * {KW_MAPSTAR, 0,"->*", 0, 0, 0, 0, 0, 0, 0, 1, 80, 0},
	// * / terminal KW_MAPSTAR:
	//	"->*";
	public TerminalRule getKW_MAPSTARRule() {
		return (tKW_MAPSTAR != null) ? tKW_MAPSTAR : (tKW_MAPSTAR = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "KW_MAPSTAR"));
	} 

	/// * % represents an instance of this type * / terminal PERCENT:
	//	"%";
	public TerminalRule getPERCENTRule() {
		return (tPERCENT != null) ? tPERCENT : (tPERCENT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "PERCENT"));
	} 

	/// * '% * / terminal PRIMEPERCENT:
	//	"\'%";
	public TerminalRule getPRIMEPERCENTRule() {
		return (tPRIMEPERCENT != null) ? tPRIMEPERCENT : (tPRIMEPERCENT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "PRIMEPERCENT"));
	} 

	/// * ... * / terminal ELLIPSIS:
	//	"...";
	public TerminalRule getELLIPSISRule() {
		return (tELLIPSIS != null) ? tELLIPSIS : (tELLIPSIS = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "ELLIPSIS"));
	} 

	/// * +/ takes the sum of a list * / terminal SUMLIST:
	//	"+/";
	public TerminalRule getSUMLISTRule() {
		return (tSUMLIST != null) ? tSUMLIST : (tSUMLIST = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "SUMLIST"));
	} 

	//terminal ANY_OTHER:
	//	.;
	public TerminalRule getANY_OTHERRule() {
		return (tANY_OTHER != null) ? tANY_OTHER : (tANY_OTHER = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "ANY_OTHER"));
	} 

	//////////// end of lexer rules ///////////////
	/// * error seems to be defined externally in Aldor grammar
	// * so I have added this rule so it will compile
	// * / error:
	//	"error";
	public ErrorElements getErrorAccess() {
		return (pError != null) ? pError : (pError = new ErrorElements());
	}
	
	public ParserRule getErrorRule() {
		return getErrorAccess().getRule();
	}

	//Expression:
	//	enlist1a_Labeled_Semicolon_AB;
	public ExpressionElements getExpressionAccess() {
		return (pExpression != null) ? pExpression : (pExpression = new ExpressionElements());
	}
	
	public ParserRule getExpressionRule() {
		return getExpressionAccess().getRule();
	}

	/// * An '.as' file is effectivly a list of 'Labeled' 
	// * by semicolons* / Labeled hidden(WS, KW_NEWLINE):
	//	Comma | Declaration | KW_AT Atom lab=Labeled?;
	public LabeledElements getLabeledAccess() {
		return (pLabeled != null) ? pLabeled : (pLabeled = new LabeledElements());
	}
	
	public ParserRule getLabeledRule() {
		return getLabeledAccess().getRule();
	}

	//Declaration hidden(WS, KW_NEWLINE):
	//	"macro" MacroBody | "extend" Sig | "local" Sig | "free" Sig | "fluid" Sig | "default" Sig | "define" Sig | "fix" Sig |
	//	"inline" Sig? fp=FromPart? | "import" Sig? fp=FromPart? | ExportDecl;
	public DeclarationElements getDeclarationAccess() {
		return (pDeclaration != null) ? pDeclaration : (pDeclaration = new DeclarationElements());
	}
	
	public ParserRule getDeclarationRule() {
		return getDeclarationAccess().getRule();
	}

	//ExportDecl hidden(WS, KW_NEWLINE):
	//	"export" Sig? | => ("export" Sig? tp=ToPart) | => ("export" Sig? fp=FromPart);
	public ExportDeclElements getExportDeclAccess() {
		return (pExportDecl != null) ? pExportDecl : (pExportDecl = new ExportDeclElements());
	}
	
	public ParserRule getExportDeclRule() {
		return getExportDeclAccess().getRule();
	}

	//ToPart hidden(WS, KW_NEWLINE):
	//	"to" Infixed;
	public ToPartElements getToPartAccess() {
		return (pToPart != null) ? pToPart : (pToPart = new ToPartElements());
	}
	
	public ParserRule getToPartRule() {
		return getToPartAccess().getRule();
	}

	//FromPart hidden(WS, KW_NEWLINE):
	//	"from" enlist1_Infixed_Comma_AB;
	public FromPartElements getFromPartAccess() {
		return (pFromPart != null) ? pFromPart : (pFromPart = new FromPartElements());
	}
	
	public ParserRule getFromPartRule() {
		return getFromPartAccess().getRule();
	}

	//MacroBody hidden(WS, KW_NEWLINE):
	//	Sig | ExportDecl | "import" Sig fp=FromPart?;
	public MacroBodyElements getMacroBodyAccess() {
		return (pMacroBody != null) ? pMacroBody : (pMacroBody = new MacroBodyElements());
	}
	
	public ParserRule getMacroBodyRule() {
		return getMacroBodyAccess().getRule();
	}

	//Sig hidden(WS, KW_NEWLINE):
	//	DeclBinding | Block;
	public SigElements getSigAccess() {
		return (pSig != null) ? pSig : (pSig = new SigElements());
	}
	
	public ParserRule getSigRule() {
		return getSigAccess().getRule();
	}

	//DeclPart hidden(WS, KW_NEWLINE):
	//	KW_COLON Type | KW_COLONSTAR Type;
	public DeclPartElements getDeclPartAccess() {
		return (pDeclPart != null) ? pDeclPart : (pDeclPart = new DeclPartElements());
	}
	
	public ParserRule getDeclPartRule() {
		return getDeclPartAccess().getRule();
	}

	/// *
	// * Commas
	// * / Comma hidden(WS, KW_NEWLINE):
	//	enlist1_CommaItem_Comma_AB;
	public CommaElements getCommaAccess() {
		return (pComma != null) ? pComma : (pComma = new CommaElements());
	}
	
	public ParserRule getCommaRule() {
		return getCommaAccess().getRule();
	}

	//CommaItem hidden(WS, KW_NEWLINE):
	//	Binding_AnyStatement => ("where" ci=CommaItem)*;
	public CommaItemElements getCommaItemAccess() {
		return (pCommaItem != null) ? pCommaItem : (pCommaItem = new CommaItemElements());
	}
	
	public ParserRule getCommaItemRule() {
		return getCommaItemAccess().getRule();
	}

	/// *
	// * DeclBinding
	// * / DeclBinding hidden(WS, KW_NEWLINE):
	//	BindingR_InfixedExprsDecl_AnyStatement;
	public DeclBindingElements getDeclBindingAccess() {
		return (pDeclBinding != null) ? pDeclBinding : (pDeclBinding = new DeclBindingElements());
	}
	
	public ParserRule getDeclBindingRule() {
		return getDeclBindingAccess().getRule();
	}

	//InfixedExprsDecl hidden(WS, KW_NEWLINE):
	//	InfixedExprs DeclPart*;
	public InfixedExprsDeclElements getInfixedExprsDeclAccess() {
		return (pInfixedExprsDecl != null) ? pInfixedExprsDecl : (pInfixedExprsDecl = new InfixedExprsDeclElements());
	}
	
	public ParserRule getInfixedExprsDeclRule() {
		return getInfixedExprsDeclAccess().getRule();
	}

	//InfixedExprs hidden(WS, KW_NEWLINE):
	//	enlist1_InfixedExpr_Comma_AB;
	public InfixedExprsElements getInfixedExprsAccess() {
		return (pInfixedExprs != null) ? pInfixedExprs : (pInfixedExprs = new InfixedExprsElements());
	}
	
	public ParserRule getInfixedExprsRule() {
		return getInfixedExprsAccess().getRule();
	}

	/// *
	// * Bindings
	// * 
	// * Substituted Rules in Xtext:
	// * Binding_BalStatement
	// * Binding_AnyStatement
	// * Binding_BalStatement
	// * Binding_InfixedExprsDecl
	// * Binding_Collection
	// * Binding(E)
	// * : BindingL(Infixed,E)
	// * ;
	// * / Binding_AnyStatement hidden(WS, KW_NEWLINE):
	//	BindingL_Infixed_AnyStatement;
	public Binding_AnyStatementElements getBinding_AnyStatementAccess() {
		return (pBinding_AnyStatement != null) ? pBinding_AnyStatement : (pBinding_AnyStatement = new Binding_AnyStatementElements());
	}
	
	public ParserRule getBinding_AnyStatementRule() {
		return getBinding_AnyStatementAccess().getRule();
	}

	//Binding_BalStatement hidden(WS, KW_NEWLINE):
	//	BindingL_Infixed_BalStatement;
	public Binding_BalStatementElements getBinding_BalStatementAccess() {
		return (pBinding_BalStatement != null) ? pBinding_BalStatement : (pBinding_BalStatement = new Binding_BalStatementElements());
	}
	
	public ParserRule getBinding_BalStatementRule() {
		return getBinding_BalStatementAccess().getRule();
	}

	//Binding_Collection hidden(WS, KW_NEWLINE):
	//	BindingL_Infixed_Collection;
	public Binding_CollectionElements getBinding_CollectionAccess() {
		return (pBinding_Collection != null) ? pBinding_Collection : (pBinding_Collection = new Binding_CollectionElements());
	}
	
	public ParserRule getBinding_CollectionRule() {
		return getBinding_CollectionAccess().getRule();
	}

	/// * Substituted Rules in Xtext:
	// * BindingL(Infixed,E) where E is in Binding
	// * BindingL(R,L)
	// * : L
	// * | R KW_Assign BindingL(R,L)
	// * { $$ = abNewAssign(APOS($1),$1,$3); }
	// * | R KW_2EQ BindingL(R,L)
	// * { $$ = abNewDefine(APOS($1),$1,$3); }
	// * | R KW_MARROW BindingL(R,L)
	// * { $$ = abNewMDefine(APOS($1),$1,$3); }
	// * | R KW_MAPSTO BindingL(R,L)
	// * { $$ = abNewLambda(APOS($1),$1,abZip,$3); }
	// * | R KW_MAPSTOStar BindingL(R,L)
	// * { $$ = abNewPLambda(APOS($1),$1,abZip,$3); }
	// * ;
	// * / BindingL_Infixed_AnyStatement hidden(WS, KW_NEWLINE):
	//	AnyStatement | Infixed "assign" bia=BindingL_Infixed_AnyStatement | Infixed KW_2EQ bia=BindingL_Infixed_AnyStatement |
	//	Infixed KW_MARROW bia=BindingL_Infixed_AnyStatement | Infixed KW_MAPSTO bia=BindingL_Infixed_AnyStatement | Infixed
	//	KW_MAPSTOSTAR bia=BindingL_Infixed_AnyStatement;
	public BindingL_Infixed_AnyStatementElements getBindingL_Infixed_AnyStatementAccess() {
		return (pBindingL_Infixed_AnyStatement != null) ? pBindingL_Infixed_AnyStatement : (pBindingL_Infixed_AnyStatement = new BindingL_Infixed_AnyStatementElements());
	}
	
	public ParserRule getBindingL_Infixed_AnyStatementRule() {
		return getBindingL_Infixed_AnyStatementAccess().getRule();
	}

	//BindingL_Infixed_BalStatement hidden(WS, KW_NEWLINE):
	//	BalStatement | Infixed "assign" bib=BindingL_Infixed_BalStatement | Infixed KW_2EQ bib=BindingL_Infixed_BalStatement |
	//	Infixed KW_MARROW bib=BindingL_Infixed_BalStatement | Infixed KW_MAPSTO bib=BindingL_Infixed_BalStatement | Infixed
	//	KW_MAPSTOSTAR bib=BindingL_Infixed_BalStatement;
	public BindingL_Infixed_BalStatementElements getBindingL_Infixed_BalStatementAccess() {
		return (pBindingL_Infixed_BalStatement != null) ? pBindingL_Infixed_BalStatement : (pBindingL_Infixed_BalStatement = new BindingL_Infixed_BalStatementElements());
	}
	
	public ParserRule getBindingL_Infixed_BalStatementRule() {
		return getBindingL_Infixed_BalStatementAccess().getRule();
	}

	//BindingL_Infixed_Collection hidden(WS, KW_NEWLINE):
	//	Collection | Infixed "assign" bic=BindingL_Infixed_Collection | Infixed KW_2EQ bic=BindingL_Infixed_Collection |
	//	Infixed KW_MARROW bic=BindingL_Infixed_Collection | Infixed KW_MAPSTO bic=BindingL_Infixed_Collection | Infixed
	//	KW_MAPSTOSTAR bic=BindingL_Infixed_Collection;
	public BindingL_Infixed_CollectionElements getBindingL_Infixed_CollectionAccess() {
		return (pBindingL_Infixed_Collection != null) ? pBindingL_Infixed_Collection : (pBindingL_Infixed_Collection = new BindingL_Infixed_CollectionElements());
	}
	
	public ParserRule getBindingL_Infixed_CollectionRule() {
		return getBindingL_Infixed_CollectionAccess().getRule();
	}

	/// * Substituted Rules in Xtext:
	// * BindingR(InfixedExprsDecl,AnyStatement)
	// * BindingR(R,L)
	// * : R
	// * | R KW_Assign Binding(L)
	// * { $$ = abNewAssign(APOS($1),$1,$3); }
	// * | R KW_2EQ Binding(L)
	// * { $$ = abNewDefine(APOS($1),$1,$3); }
	// * | R KW_MARROW Binding(L)
	// * { $$ = abNewMDefine(APOS($1),$1,$3); }
	// * | R KW_MAPSTO Binding(L)
	// * { $$ = abNewLambda(APOS($1),$1,abZip,$3); }
	// * | R KW_MAPSTOStar Binding(L)
	// * { $$ = abNewPLambda(APOS($1),$1,abZip,$3); }
	// * ;
	// * / BindingR_InfixedExprsDecl_AnyStatement hidden(WS, KW_NEWLINE):
	//	InfixedExprsDecl | InfixedExprsDecl "assign" Binding_AnyStatement | InfixedExprsDecl KW_2EQ Binding_AnyStatement |
	//	InfixedExprsDecl KW_MARROW Binding_AnyStatement | InfixedExprsDecl KW_MAPSTO Binding_AnyStatement | InfixedExprsDecl
	//	KW_MAPSTOSTAR Binding_AnyStatement;
	public BindingR_InfixedExprsDecl_AnyStatementElements getBindingR_InfixedExprsDecl_AnyStatementAccess() {
		return (pBindingR_InfixedExprsDecl_AnyStatement != null) ? pBindingR_InfixedExprsDecl_AnyStatement : (pBindingR_InfixedExprsDecl_AnyStatement = new BindingR_InfixedExprsDecl_AnyStatementElements());
	}
	
	public ParserRule getBindingR_InfixedExprsDecl_AnyStatementRule() {
		return getBindingR_InfixedExprsDecl_AnyStatementAccess().getRule();
	}

	/// *
	// * Statements
	// *
	// * It is easier to spot conflicts when explicitly handling dangling else.
	// * / // if we enable the following we get:
	//// 'A class may not be a super type of itself' error
	//// 'if' CommaItem 'then' bas=Binding_AnyStatement
	////| Flow_AnyStatement
	//AnyStatement hidden(WS, KW_NEWLINE):
	//	"temp19";
	public AnyStatementElements getAnyStatementAccess() {
		return (pAnyStatement != null) ? pAnyStatement : (pAnyStatement = new AnyStatementElements());
	}
	
	public ParserRule getAnyStatementRule() {
		return getAnyStatementAccess().getRule();
	}

	//// Flow_BalStatement
	//BalStatement hidden(WS, KW_NEWLINE):
	//	"temp20";
	public BalStatementElements getBalStatementAccess() {
		return (pBalStatement != null) ? pBalStatement : (pBalStatement = new BalStatementElements());
	}
	
	public ParserRule getBalStatementRule() {
		return getBalStatementAccess().getRule();
	}

	/// * Substituted Rules in Xtext:
	//Flow(XX) -> Flow_AnyStatement or Flow_BalStatement
	////Flow(XX)
	////: Collection
	////| KW_If CommaItem KW_Then Binding_BalStatement KW_Else Binding(XX)
	////{ $$ = abNewIf(TPOS($1), TEST($2),$4,$6); }
	////| Collection KW_Implies Binding(XX)
	////{ $$ = abNewExit(TPOS($2), TEST($1),$3); }
	////| Iterators KW_Repeat Binding(XX)
	////{ $$ = abNewRepeatOL(TPOS($2),$3,$1); listFree(AbSyn)($1); }
	////| KW_Repeat Binding(XX)
	////{ $$ = abNewRepeat0(TPOS($1),$2); }
	////| KW_Try Binding_AnyStatement) KW_But ButExpr AlwaysPart(XX)
	////{ (void)parseDeprecated(KW_But, abNewNothing(TPOS($3))); $$ = abNewTry(TPOS($1),$2,$4->abSequence.argv[0], $4->abSequence.argv[1],$5); }
	////| KW_Try Binding_AnyStatement) KW_Catch ButExpr AlwaysPart(XX)
	////{ $$ = abNewTry(TPOS($1),$2,$4->abSequence.argv[0], $4->abSequence.argv[1],$5); }
	////| KW_Select Binding_AnyStatement) KW_In Cases
	////{ $$ = abNewSelect(TPOS($1),$2,$4); }
	////| KW_Do Binding(XX)
	////{ $$ = abNewDo(TPOS($1),$2); }
	////| KW_Delay Binding(XX)
	////{ $$ = abNewDelay(TPOS($1),$2); }
	////| KW_Reference Binding(XX)
	////{ $$ = abNewReference(TPOS($1),$2); }
	////| KW_Generate GenBound Binding(XX)
	////{ $$ = abNewGenerate(TPOS($1),$2,$3); }
	////| KW_Assert Binding(XX)
	////{ $$ = abNewAssert(TPOS($1),TEST($2)); }
	////| KW_Iterate opt(Name)
	////{ $$ = abNewIterate(TPOS($1),$2); }
	////| KW_Break opt(Name)
	////{ $$ = abNewBreak(TPOS($1),$2); }
	////| KW_Return opt(Collection)
	////{ $$ = abNewReturn(TPOS($1),$2); }
	////| KW_Yield Binding(XX)
	////{ $$ = abNewYield(TPOS($1),$2); }
	////| KW_Except Binding(XX)
	////{ $$ = parseDeprecated(KW_Except, abNewRaise(TPOS($1),$2)); }
	////| KW_Throw Binding(XX)
	////{ $$ = abNewRaise(TPOS($1),$2); }
	////| KW_Goto Id
	////{ $$ = abNewGoto(TPOS($1),$2); }
	////| KW_Never
	////{ $$ = abNewNever(TPOS($1)); }
	////;
	// * / Flow_AnyStatement hidden(WS, KW_NEWLINE):
	//	Collection | "if" CommaItem "then" bbs=Binding_BalStatement "else" bas=Binding_AnyStatement | Collection "implies"
	//	bas2=Binding_AnyStatement | Iterators "repeat" bas3=Binding_AnyStatement | "repeat" Binding_AnyStatement | "try"
	//	Binding_AnyStatement "but" be=ButExpr apa=AlwaysPart_AnyStatement | "try" Binding_AnyStatement "catch" be=ButExpr
	//	apa=AlwaysPart_AnyStatement | "select" Binding_AnyStatement "in" c=Cases | "do" Binding_AnyStatement | "delay"
	//	Binding_AnyStatement | "reference" Binding_AnyStatement | "generate" GenBound bas4=Binding_AnyStatement | "assert"
	//	Binding_AnyStatement | "iterate" Name? | "break" Name? | "return" Collection? | "yield" Binding_AnyStatement |
	//	"except" Binding_AnyStatement | "throw" Binding_AnyStatement | "goto" Id | "never";
	public Flow_AnyStatementElements getFlow_AnyStatementAccess() {
		return (pFlow_AnyStatement != null) ? pFlow_AnyStatement : (pFlow_AnyStatement = new Flow_AnyStatementElements());
	}
	
	public ParserRule getFlow_AnyStatementRule() {
		return getFlow_AnyStatementAccess().getRule();
	}

	//Flow_BalStatement hidden(WS, KW_NEWLINE):
	//	Collection | "if" CommaItem "then" bbs=Binding_BalStatement "else" bbs2=Binding_BalStatement | Collection "implies"
	//	bbs3=Binding_BalStatement | Iterators "repeat" bbs4=Binding_BalStatement | "repeat" Binding_BalStatement | "try"
	//	Binding_AnyStatement "but" be=ButExpr apb=AlwaysPart_BalStatement | "try" Binding_AnyStatement "catch" be=ButExpr
	//	apb=AlwaysPart_BalStatement | "select" Binding_AnyStatement "in" c=Cases | "do" Binding_BalStatement | "delay"
	//	Binding_BalStatement | "reference" Binding_BalStatement | "generate" GenBound bbs5=Binding_BalStatement | "assert"
	//	Binding_BalStatement | "iterate" Name? | "break" Name? | "return" Collection? | "yield" Binding_BalStatement |
	//	"except" Binding_BalStatement | "throw" Binding_BalStatement | "goto" Id | "never";
	public Flow_BalStatementElements getFlow_BalStatementAccess() {
		return (pFlow_BalStatement != null) ? pFlow_BalStatement : (pFlow_BalStatement = new Flow_BalStatementElements());
	}
	
	public ParserRule getFlow_BalStatementRule() {
		return getFlow_BalStatementAccess().getRule();
	}

	//GenBound hidden(WS, KW_NEWLINE):
	//	("to" CommaItem "of")?;
	public GenBoundElements getGenBoundAccess() {
		return (pGenBound != null) ? pGenBound : (pGenBound = new GenBoundElements());
	}
	
	public ParserRule getGenBoundRule() {
		return getGenBoundAccess().getRule();
	}

	//ButExpr hidden(WS, KW_NEWLINE):
	//	(db=DeclBinding "in" ca=Cases)?;
	public ButExprElements getButExprAccess() {
		return (pButExpr != null) ? pButExpr : (pButExpr = new ButExprElements());
	}
	
	public ParserRule getButExprRule() {
		return getButExprAccess().getRule();
	}

	//Cases hidden(WS, KW_NEWLINE):
	//	Binding_Collection;
	public CasesElements getCasesAccess() {
		return (pCases != null) ? pCases : (pCases = new CasesElements());
	}
	
	public ParserRule getCasesRule() {
		return getCasesAccess().getRule();
	}

	/// * Substituted Rules in Xtext:
	// * AlwaysPart(XX) -> AlwaysPart_AnyStatement
	// *                or AlwaysPart_BalStatement
	// * AlwaysPart(XX)
	// * : KW_Always Binding(XX)
	// * { (void)parseDeprecated(KW_Always, abNewNothing(TPOS($1))); $$ = $2; }
	// * | KW_Finally Binding(XX)
	// * { $$ = $2; }
	// * | Nothing
	////;
	// * / AlwaysPart_AnyStatement hidden(WS, KW_NEWLINE):
	//	("always" Binding_AnyStatement | "finally" Binding_AnyStatement)?;
	public AlwaysPart_AnyStatementElements getAlwaysPart_AnyStatementAccess() {
		return (pAlwaysPart_AnyStatement != null) ? pAlwaysPart_AnyStatement : (pAlwaysPart_AnyStatement = new AlwaysPart_AnyStatementElements());
	}
	
	public ParserRule getAlwaysPart_AnyStatementRule() {
		return getAlwaysPart_AnyStatementAccess().getRule();
	}

	//AlwaysPart_BalStatement hidden(WS, KW_NEWLINE):
	//	("always" Binding_BalStatement | "finally" Binding_BalStatement)?;
	public AlwaysPart_BalStatementElements getAlwaysPart_BalStatementAccess() {
		return (pAlwaysPart_BalStatement != null) ? pAlwaysPart_BalStatement : (pAlwaysPart_BalStatement = new AlwaysPart_BalStatementElements());
	}
	
	public ParserRule getAlwaysPart_BalStatementRule() {
		return getAlwaysPart_BalStatementAccess().getRule();
	}

	/// *
	// * Iterators
	// * / Collection hidden(WS, KW_NEWLINE):
	//	Infixed i=Iterators?;
	public CollectionElements getCollectionAccess() {
		return (pCollection != null) ? pCollection : (pCollection = new CollectionElements());
	}
	
	public ParserRule getCollectionRule() {
		return getCollectionAccess().getRule();
	}

	//Iterators hidden(WS, KW_NEWLINE):
	//	Iterators1;
	public IteratorsElements getIteratorsAccess() {
		return (pIterators != null) ? pIterators : (pIterators = new IteratorsElements());
	}
	
	public ParserRule getIteratorsRule() {
		return getIteratorsAccess().getRule();
	}

	//// left recursive when following uncommented
	//// Iterator
	////| Iterators1 itr=Iterator
	//Iterators1 hidden(WS, KW_NEWLINE):
	//	"temp27";
	public Iterators1Elements getIterators1Access() {
		return (pIterators1 != null) ? pIterators1 : (pIterators1 = new Iterators1Elements());
	}
	
	public ParserRule getIterators1Rule() {
		return getIterators1Access().getRule();
	}

	//Iterator:
	//	"for" ForLhs "in" i=Infixed sp=SuchthatPart? | "while" Infixed;
	public IteratorElements getIteratorAccess() {
		return (pIterator != null) ? pIterator : (pIterator = new IteratorElements());
	}
	
	public ParserRule getIteratorRule() {
		return getIteratorAccess().getRule();
	}

	//ForLhs:
	//	Infixed | "free" Infixed | "local" Infixed | "fluid" Infixed;
	public ForLhsElements getForLhsAccess() {
		return (pForLhs != null) ? pForLhs : (pForLhs = new ForLhsElements());
	}
	
	public ParserRule getForLhsRule() {
		return getForLhsAccess().getRule();
	}

	//SuchthatPart hidden(WS, KW_NEWLINE):
	//	"temp30" KW_BAR Infixed;
	public SuchthatPartElements getSuchthatPartAccess() {
		return (pSuchthatPart != null) ? pSuchthatPart : (pSuchthatPart = new SuchthatPartElements());
	}
	
	public ParserRule getSuchthatPartRule() {
		return getSuchthatPartAccess().getRule();
	}

	/// *
	// * Infixed Expressions
	// * / // causes constraint error when following is uncommented
	//// InfixedExpr DeclPart*
	//// | Block
	//Infixed hidden(WS, KW_NEWLINE):
	//	"temp31";
	public InfixedElements getInfixedAccess() {
		return (pInfixed != null) ? pInfixed : (pInfixed = new InfixedElements());
	}
	
	public ParserRule getInfixedRule() {
		return getInfixedAccess().getRule();
	}

	//// E11(Op)
	////| E3
	//InfixedExpr hidden(WS, KW_NEWLINE):
	//	"temp32";
	public InfixedExprElements getInfixedExprAccess() {
		return (pInfixedExpr != null) ? pInfixedExpr : (pInfixedExpr = new InfixedExprElements());
	}
	
	public ParserRule getInfixedExprRule() {
		return getInfixedExprAccess().getRule();
	}

	////E3
	////: E4
	////| E3 KW_And E4
	////{ $$ = abNewAnd(TPOS($2), TEST($1),TEST($3)); }
	////| E3 KW_Or E4
	////{ $$ = abNewOr(TPOS($2), TEST($1),TEST($3)); }
	////| E3 LatticeOp E4
	////{ $$ = abNewInfix(APOS($2),$2,$1,$3); }
	////;
	////E4
	////: E5
	////| E4 KW_Has E5
	////{ $$ = abNewHas(TPOS($2),$1,$3); }
	////| E4 RelationOp E5
	////{ $$ = abNewInfix(APOS($2),$2,$1,$3); }
	////| RelationOp E5
	////{ $$ = abNewPrefix(APOS($1),$1,$2); }
	////;
	////E5
	////: E6
	////| E5 SegOp
	////{ $$ = abNewPostfix(APOS($2),$2,$1); }
	////| E5 SegOp E6
	////{ $$ = abNewInfix(APOS($2),$2,$1,$3); }
	////;
	////E6
	////: E7
	////| E6 PlusOp E7
	////{ $$ = abNewInfix(APOS($2),$2,$1,$3); }
	////| PlusOp E7
	////{ $$ = abNewPrefix(APOS($1),$1,$2); }
	////;
	////E7
	////: E8
	////| E7 QuotientOp E8
	////{ $$ = abNewInfix(APOS($2),$2,$1,$3); }
	////;
	////E8
	////: E9
	////| E8 TimesOp E9
	////{ $$ = abNewInfix(APOS($2),$2,$1,$3); }
	////;
	////E9
	////: E11(E12)
	////| E11(E12) PowerOp E9
	////{ $$ = abNewInfix(APOS($2),$2,$1,$3); }
	////;
	/// * Substituted Rules in Xtext:
	// * E11_E12
	// * E11_Op
	// * / //E11(X)
	////: X
	////| E11(X) KW_2Colon E12
	////{ $$ = abNewCoerceTo(TPOS($2),$1,$3); }
	////| E11(X) KW_At E12
	////{ $$ = abNewRestrictTo(TPOS($2),$1,$3); }
	////| E11(X) KW_Pretend E12
	////{ $$ = abNewPretendTo(TPOS($2),$1,$3); }
	////;
	//// E11(E12)
	//Type hidden(WS, KW_NEWLINE):
	//	"temp41";
	public TypeElements getTypeAccess() {
		return (pType != null) ? pType : (pType = new TypeElements());
	}
	
	public ParserRule getTypeRule() {
		return getTypeAccess().getRule();
	}

	////E12
	////: E13
	////| E13 ArrowOp E12
	////{ $$ = abNewInfix(APOS($2),$2,$1,$3); }
	////;
	////E13
	////: E14
	////| E14 KW_DOLLAR QualTail
	////{ $$ = abNewQualify(TPOS($2),$1,$3); }
	////;
	////QualTail
	////: LeftJuxtaposed
	////| LeftJuxtaposed KW_DOLLAR QualTail
	////{ $$ = abNewQualify(TPOS($2),$1,$3); }
	////;
	//OpQualTail hidden(WS, KW_NEWLINE):
	//	name=Molecule | => (name=Molecule KW_DOLLAR OpQualTail);
	public OpQualTailElements getOpQualTailAccess() {
		return (pOpQualTail != null) ? pOpQualTail : (pOpQualTail = new OpQualTailElements());
	}
	
	public ParserRule getOpQualTailRule() {
		return getOpQualTailAccess().getRule();
	}

	////: E15
	////| opt(E14) KW_With DeclMolecule
	////{ $$ = abNewWith(TPOS($2),$1,$3); }
	////| opt(E14) KW_Add DeclMolecule
	////{ $$ = abNewAdd(TPOS($2),$1,$3); }
	////| E14 KW_Except E15
	////{ $$ = parseDeprecated(KW_Except, abNewExcept(TPOS($2),$1,$3)); }
	////| E14 KW_Throw E15
	////{ $$ = abNewExcept(TPOS($2),$1,$3); }
	//E14 hidden(WS, KW_NEWLINE):
	//	"temp46";
	public E14Elements getE14Access() {
		return (pE14 != null) ? pE14 : (pE14 = new E14Elements());
	}
	
	public ParserRule getE14Rule() {
		return getE14Access().getRule();
	}

	//E15 hidden(WS, KW_NEWLINE):
	//	Application;
	public E15Elements getE15Access() {
		return (pE15 != null) ? pE15 : (pE15 = new E15Elements());
	}
	
	public ParserRule getE15Rule() {
		return getE15Access().getRule();
	}

	/// *
	// * Infixed Operations
	// * / Op hidden(WS, KW_NEWLINE):
	//	ArrowOp | LatticeOp | RelationOp | SegOp | PlusOp | QuotientOp | TimesOp | PowerOp;
	public OpElements getOpAccess() {
		return (pOp != null) ? pOp : (pOp = new OpElements());
	}
	
	public ParserRule getOpRule() {
		return getOpAccess().getRule();
	}

	//NakedOp hidden(WS, KW_NEWLINE):
	//	UnqualOp_ArrowTok | UnqualOp_LatticeTok | UnqualOp_RelationTok | UnqualOp_SegTok | UnqualOp_PlusTok |
	//	UnqualOp_QuotientTok | UnqualOp_TimesTok | UnqualOp_PowerTok;
	public NakedOpElements getNakedOpAccess() {
		return (pNakedOp != null) ? pNakedOp : (pNakedOp = new NakedOpElements());
	}
	
	public ParserRule getNakedOpRule() {
		return getNakedOpAccess().getRule();
	}

	//ArrowOp:
	//	QualOp_ArrowTok;
	public ArrowOpElements getArrowOpAccess() {
		return (pArrowOp != null) ? pArrowOp : (pArrowOp = new ArrowOpElements());
	}
	
	public ParserRule getArrowOpRule() {
		return getArrowOpAccess().getRule();
	}

	//LatticeOp:
	//	QualOp_LatticeTok;
	public LatticeOpElements getLatticeOpAccess() {
		return (pLatticeOp != null) ? pLatticeOp : (pLatticeOp = new LatticeOpElements());
	}
	
	public ParserRule getLatticeOpRule() {
		return getLatticeOpAccess().getRule();
	}

	//RelationOp:
	//	QualOp_RelationTok;
	public RelationOpElements getRelationOpAccess() {
		return (pRelationOp != null) ? pRelationOp : (pRelationOp = new RelationOpElements());
	}
	
	public ParserRule getRelationOpRule() {
		return getRelationOpAccess().getRule();
	}

	//SegOp:
	//	QualOp_SegTok;
	public SegOpElements getSegOpAccess() {
		return (pSegOp != null) ? pSegOp : (pSegOp = new SegOpElements());
	}
	
	public ParserRule getSegOpRule() {
		return getSegOpAccess().getRule();
	}

	//PlusOp:
	//	QualOp_PlusTok;
	public PlusOpElements getPlusOpAccess() {
		return (pPlusOp != null) ? pPlusOp : (pPlusOp = new PlusOpElements());
	}
	
	public ParserRule getPlusOpRule() {
		return getPlusOpAccess().getRule();
	}

	//QuotientOp:
	//	QualOp_QuotientTok;
	public QuotientOpElements getQuotientOpAccess() {
		return (pQuotientOp != null) ? pQuotientOp : (pQuotientOp = new QuotientOpElements());
	}
	
	public ParserRule getQuotientOpRule() {
		return getQuotientOpAccess().getRule();
	}

	//TimesOp:
	//	QualOp_TimesTok;
	public TimesOpElements getTimesOpAccess() {
		return (pTimesOp != null) ? pTimesOp : (pTimesOp = new TimesOpElements());
	}
	
	public ParserRule getTimesOpRule() {
		return getTimesOpAccess().getRule();
	}

	//PowerOp:
	//	QualOp_PowerTok;
	public PowerOpElements getPowerOpAccess() {
		return (pPowerOp != null) ? pPowerOp : (pPowerOp = new PowerOpElements());
	}
	
	public ParserRule getPowerOpRule() {
		return getPowerOpAccess().getRule();
	}

	/// * in Aldor grammar this is ArrowTok<tok> * / ArrowTok:
	//	KW_RARROW | KW_LARROW | KW_MAPSTAR;
	public ArrowTokElements getArrowTokAccess() {
		return (pArrowTok != null) ? pArrowTok : (pArrowTok = new ArrowTokElements());
	}
	
	public ParserRule getArrowTokRule() {
		return getArrowTokAccess().getRule();
	}

	/// * in Aldor grammar this is LatticeTok<tok> * / LatticeTok:
	//	KW_VEE | KW_WEDGE;
	public LatticeTokElements getLatticeTokAccess() {
		return (pLatticeTok != null) ? pLatticeTok : (pLatticeTok = new LatticeTokElements());
	}
	
	public ParserRule getLatticeTokRule() {
		return getLatticeTokAccess().getRule();
	}

	/// * in Aldor grammar this is RelationTok<tok> * / RelationTok:
	//	KW_EQ | KW_TILDEE | KW_HATE | KW_GE | KW_GT | KW_2GT | KW_LE | KW_LT | KW_2LT | "is" | "isnt" | "case";
	public RelationTokElements getRelationTokAccess() {
		return (pRelationTok != null) ? pRelationTok : (pRelationTok = new RelationTokElements());
	}
	
	public ParserRule getRelationTokRule() {
		return getRelationTokAccess().getRule();
	}

	/// * in Aldor grammar this is SegTok<tok> * / SegTok:
	//	KW_2DOT | "by";
	public SegTokElements getSegTokAccess() {
		return (pSegTok != null) ? pSegTok : (pSegTok = new SegTokElements());
	}
	
	public ParserRule getSegTokRule() {
		return getSegTokAccess().getRule();
	}

	/// * in Aldor grammar this is PlusTok<tok> * / PlusTok:
	//	KW_PLUS | KW_MINUS | KW_PLUSMINUS;
	public PlusTokElements getPlusTokAccess() {
		return (pPlusTok != null) ? pPlusTok : (pPlusTok = new PlusTokElements());
	}
	
	public ParserRule getPlusTokRule() {
		return getPlusTokAccess().getRule();
	}

	/// * in Aldor grammar this is QuotientTok<tok> * / QuotientTok:
	//	"mod" | "quo" | "rem" | "exquo";
	public QuotientTokElements getQuotientTokAccess() {
		return (pQuotientTok != null) ? pQuotientTok : (pQuotientTok = new QuotientTokElements());
	}
	
	public ParserRule getQuotientTokRule() {
		return getQuotientTokAccess().getRule();
	}

	/// * in Aldor grammar this is TimesTok<tok> * / TimesTok:
	//	KW_STAR | KW_SLASH | KW_BACKSLASH;
	public TimesTokElements getTimesTokAccess() {
		return (pTimesTok != null) ? pTimesTok : (pTimesTok = new TimesTokElements());
	}
	
	public ParserRule getTimesTokRule() {
		return getTimesTokAccess().getRule();
	}

	/// * in Aldor grammar this is PowerTok<tok> * / PowerTok:
	//	KW_2STAR | KW_HAT;
	public PowerTokElements getPowerTokAccess() {
		return (pPowerTok != null) ? pPowerTok : (pPowerTok = new PowerTokElements());
	}
	
	public ParserRule getPowerTokRule() {
		return getPowerTokAccess().getRule();
	}

	/// *
	// * Juxtaposed Expressions
	// * 
	// * A prefix application typically has the following form:
	// * 
	// *  f(a1, ..., an)
	// * 
	// * There are two additional forms for specifying a prefix
	// * application to one argument: juxtaposition and an infix dot.
	// * 
	// * f a
	// * f.a
	// * 
	// * The second of these forms is completely equivalent to
	// * f(a); the first is equivalent in a free-standing occurrence
	// * but associates differently -- to the right, rather than
	// * the left:
	// * 
	// *  f a b c      -- is equivalent to (f (a (b c)))
	// *  f.a.b.c      -- is equivalent to (((f.a).b).c)
	// *  f(a)(b)(c)   -- is equivalent to (((f(a))(b))(c))
	// *
	// * / //RightJuxtaposed
	//Application hidden(WS, KW_NEWLINE):
	//	"temp52";
	public ApplicationElements getApplicationAccess() {
		return (pApplication != null) ? pApplication : (pApplication = new ApplicationElements());
	}
	
	public ParserRule getApplicationRule() {
		return getApplicationAccess().getRule();
	}

	//// Jright_Molecule
	//RightJuxtaposed hidden(WS, KW_NEWLINE):
	//	"temp53";
	public RightJuxtaposedElements getRightJuxtaposedAccess() {
		return (pRightJuxtaposed != null) ? pRightJuxtaposed : (pRightJuxtaposed = new RightJuxtaposedElements());
	}
	
	public ParserRule getRightJuxtaposedRule() {
		return getRightJuxtaposedAccess().getRule();
	}

	//// Jleft_Molecule
	//LeftJuxtaposed hidden(WS, KW_NEWLINE):
	//	"temp54";
	public LeftJuxtaposedElements getLeftJuxtaposedAccess() {
		return (pLeftJuxtaposed != null) ? pLeftJuxtaposed : (pLeftJuxtaposed = new LeftJuxtaposedElements());
	}
	
	public ParserRule getLeftJuxtaposedRule() {
		return getLeftJuxtaposedAccess().getRule();
	}

	/// * Substituted Rules in Xtext:
	// * Jright(Molecule)
	// * Jright(Atom)
	// * Jright(H)
	// * : Jleft(H)
	// * | Jleft(H) Jright(Atom)
	// * { $$ = parseMakeJuxtapose($1,$2); }
	// * | 'not' Jright(Atom)
	// * { $$ = abNewNot(TPOS($1),TEST($2)); }
	// * ;
	// * / //	(Jleft_Molecule (right=Jright_Atom)?)
	////	| ('not' Jright_Atom)
	//Jright_Molecule hidden(WS, KW_NEWLINE):
	//	"temp56";
	public Jright_MoleculeElements getJright_MoleculeAccess() {
		return (pJright_Molecule != null) ? pJright_Molecule : (pJright_Molecule = new Jright_MoleculeElements());
	}
	
	public ParserRule getJright_MoleculeRule() {
		return getJright_MoleculeAccess().getRule();
	}

	////	(Jleft_Atom (right2=Jright_Atom)?)
	////	| 'not' Jright_Atom
	//Jright_Atom hidden(WS, KW_NEWLINE):
	//	"temp57";
	public Jright_AtomElements getJright_AtomAccess() {
		return (pJright_Atom != null) ? pJright_Atom : (pJright_Atom = new Jright_AtomElements());
	}
	
	public ParserRule getJright_AtomRule() {
		return getJright_AtomAccess().getRule();
	}

	/// * Substituted Rules in Xtext:
	// * Jleft(Molecule)
	// * Jleft(Atom)
	// * Jleft(H)
	// * : H
	// * | 'not' BlockEnclosure
	// * { $$ = abNewNot(TPOS($1),TEST($2)); }
	// * | Jleft(H) BlockEnclosure
	// * { $$ = parseMakeJuxtapose($1,$2); }
	// * | Jleft(H) KW_DOT BlockMolecule
	// * { $$ = abNewPrefix(TPOS($2),$1,$3); }
	// * ;
	// * / Jleft_Molecule hidden(WS, KW_NEWLINE):
	//	"not" BlockEnclosure | Molecule (KW_DOT bm+=BlockMolecule)*;
	public Jleft_MoleculeElements getJleft_MoleculeAccess() {
		return (pJleft_Molecule != null) ? pJleft_Molecule : (pJleft_Molecule = new Jleft_MoleculeElements());
	}
	
	public ParserRule getJleft_MoleculeRule() {
		return getJleft_MoleculeAccess().getRule();
	}

	//Jleft_Atom hidden(WS, KW_NEWLINE):
	//	"not" BlockEnclosure | Atom (KW_DOT bm4+=BlockMolecule)*;
	public Jleft_AtomElements getJleft_AtomAccess() {
		return (pJleft_Atom != null) ? pJleft_Atom : (pJleft_Atom = new Jleft_AtomElements());
	}
	
	public ParserRule getJleft_AtomRule() {
		return getJleft_AtomAccess().getRule();
	}

	/// *
	// * Indivisible Expressions
	// * / Molecule hidden(WS, KW_NEWLINE):
	//	Atom | Enclosure;
	public MoleculeElements getMoleculeAccess() {
		return (pMolecule != null) ? pMolecule : (pMolecule = new MoleculeElements());
	}
	
	public ParserRule getMoleculeRule() {
		return getMoleculeAccess().getRule();
	}

	//Enclosure hidden(WS, KW_NEWLINE):
	//	Parened | Bracketed | QuotedIds;
	public EnclosureElements getEnclosureAccess() {
		return (pEnclosure != null) ? pEnclosure : (pEnclosure = new EnclosureElements());
	}
	
	public ParserRule getEnclosureRule() {
		return getEnclosureAccess().getRule();
	}

	//DeclMolecule hidden(WS, KW_NEWLINE):
	//	Application? | Block;
	public DeclMoleculeElements getDeclMoleculeAccess() {
		return (pDeclMolecule != null) ? pDeclMolecule : (pDeclMolecule = new DeclMoleculeElements());
	}
	
	public ParserRule getDeclMoleculeRule() {
		return getDeclMoleculeAccess().getRule();
	}

	//BlockMolecule hidden(WS, KW_NEWLINE):
	//	Atom | Enclosure | Block;
	public BlockMoleculeElements getBlockMoleculeAccess() {
		return (pBlockMolecule != null) ? pBlockMolecule : (pBlockMolecule = new BlockMoleculeElements());
	}
	
	public ParserRule getBlockMoleculeRule() {
		return getBlockMoleculeAccess().getRule();
	}

	//BlockEnclosure hidden(WS, KW_NEWLINE):
	//	Enclosure | Block;
	public BlockEnclosureElements getBlockEnclosureAccess() {
		return (pBlockEnclosure != null) ? pBlockEnclosure : (pBlockEnclosure = new BlockEnclosureElements());
	}
	
	public ParserRule getBlockEnclosureRule() {
		return getBlockEnclosureAccess().getRule();
	}

	//Block hidden(WS, KW_NEWLINE): // Piled(Expression)|
	//	Curly_Labeled;
	public BlockElements getBlockAccess() {
		return (pBlock != null) ? pBlock : (pBlock = new BlockElements());
	}
	
	public ParserRule getBlockRule() {
		return getBlockAccess().getRule();
	}

	//Parened hidden(WS, KW_NEWLINE):
	//	KW_OPAREN KW_CPAREN | KW_OPAREN Expression KW_CPAREN;
	public ParenedElements getParenedAccess() {
		return (pParened != null) ? pParened : (pParened = new ParenedElements());
	}
	
	public ParserRule getParenedRule() {
		return getParenedAccess().getRule();
	}

	//Bracketed hidden(WS, KW_NEWLINE):
	//	KW_OBRACK KW_CBRACK | KW_OBRACK Expression KW_CBRACK;
	public BracketedElements getBracketedAccess() {
		return (pBracketed != null) ? pBracketed : (pBracketed = new BracketedElements());
	}
	
	public ParserRule getBracketedRule() {
		return getBracketedAccess().getRule();
	}

	//QuotedIds hidden(WS, KW_NEWLINE):
	//	KW_QUOTE KW_QUOTE | KW_QUOTE Names KW_QUOTE;
	public QuotedIdsElements getQuotedIdsAccess() {
		return (pQuotedIds != null) ? pQuotedIds : (pQuotedIds = new QuotedIdsElements());
	}
	
	public ParserRule getQuotedIdsRule() {
		return getQuotedIdsAccess().getRule();
	}

	//Names hidden(WS, KW_NEWLINE):
	//	firstName=TK_ID (KW_COMMA subsequentNames+=TK_ID)*;
	public NamesElements getNamesAccess() {
		return (pNames != null) ? pNames : (pNames = new NamesElements());
	}
	
	public ParserRule getNamesRule() {
		return getNamesAccess().getRule();
	}

	/// *
	// * Terminals
	// * / Atom hidden(WS, KW_NEWLINE):
	//	id=Id | lit=Literal;
	public AtomElements getAtomAccess() {
		return (pAtom != null) ? pAtom : (pAtom = new AtomElements());
	}
	
	public ParserRule getAtomRule() {
		return getAtomAccess().getRule();
	}

	//Name hidden(WS, KW_NEWLINE):
	//	Id | NakedOp;
	public NameElements getNameAccess() {
		return (pName != null) ? pName : (pName = new NameElements());
	}
	
	public ParserRule getNameRule() {
		return getNameAccess().getRule();
	}

	/// * original Aldor grammar uses abNewOfToken which is defined
	// * in Aldor file absyn.c: Abstract syntax construction and
	// * manipulation.
	// * / Id hidden(WS, KW_NEWLINE):
	//	AB_Id=TK_ID | op=KW_SHARP | op=KW_TILDE;
	public IdElements getIdAccess() {
		return (pId != null) ? pId : (pId = new IdElements());
	}
	
	public ParserRule getIdRule() {
		return getIdAccess().getRule();
	}

	//Literal hidden(WS, KW_NEWLINE):
	//	TK_INT //| TK_FLOAT
	//	| TK_STRING;
	public LiteralElements getLiteralAccess() {
		return (pLiteral != null) ? pLiteral : (pLiteral = new LiteralElements());
	}
	
	public ParserRule getLiteralRule() {
		return getLiteralAccess().getRule();
	}

	/// *
	// * Meta-rules
	// * / / * Substituted Rules in Xtext:
	// * UnqualOp(ArrowTok)
	// * UnqualOp(LatticeTok)
	// * UnqualOp(RelationTok)
	// * UnqualOp(SegTok)
	// * UnqualOp(PlusTok)
	// * UnqualOp(QuotientTok)
	// * UnqualOp(TimesTok)
	// * UnqualOp(PowerTok)
	// * UnqualOp(op)
	// * : op
	// * { $$ = abNewOfToken(AB_Id, $1); }
	// * ;
	// * / UnqualOp_ArrowTok hidden(WS, KW_NEWLINE):
	//	ArrowTok {ArrowTok};
	public UnqualOp_ArrowTokElements getUnqualOp_ArrowTokAccess() {
		return (pUnqualOp_ArrowTok != null) ? pUnqualOp_ArrowTok : (pUnqualOp_ArrowTok = new UnqualOp_ArrowTokElements());
	}
	
	public ParserRule getUnqualOp_ArrowTokRule() {
		return getUnqualOp_ArrowTokAccess().getRule();
	}

	//UnqualOp_LatticeTok hidden(WS, KW_NEWLINE):
	//	LatticeTok {LatticeTok};
	public UnqualOp_LatticeTokElements getUnqualOp_LatticeTokAccess() {
		return (pUnqualOp_LatticeTok != null) ? pUnqualOp_LatticeTok : (pUnqualOp_LatticeTok = new UnqualOp_LatticeTokElements());
	}
	
	public ParserRule getUnqualOp_LatticeTokRule() {
		return getUnqualOp_LatticeTokAccess().getRule();
	}

	//UnqualOp_RelationTok hidden(WS, KW_NEWLINE):
	//	RelationTok {RelationTok};
	public UnqualOp_RelationTokElements getUnqualOp_RelationTokAccess() {
		return (pUnqualOp_RelationTok != null) ? pUnqualOp_RelationTok : (pUnqualOp_RelationTok = new UnqualOp_RelationTokElements());
	}
	
	public ParserRule getUnqualOp_RelationTokRule() {
		return getUnqualOp_RelationTokAccess().getRule();
	}

	//UnqualOp_SegTok hidden(WS, KW_NEWLINE):
	//	SegTok {SegTok};
	public UnqualOp_SegTokElements getUnqualOp_SegTokAccess() {
		return (pUnqualOp_SegTok != null) ? pUnqualOp_SegTok : (pUnqualOp_SegTok = new UnqualOp_SegTokElements());
	}
	
	public ParserRule getUnqualOp_SegTokRule() {
		return getUnqualOp_SegTokAccess().getRule();
	}

	//UnqualOp_PlusTok hidden(WS, KW_NEWLINE):
	//	PlusTok {PlusTok};
	public UnqualOp_PlusTokElements getUnqualOp_PlusTokAccess() {
		return (pUnqualOp_PlusTok != null) ? pUnqualOp_PlusTok : (pUnqualOp_PlusTok = new UnqualOp_PlusTokElements());
	}
	
	public ParserRule getUnqualOp_PlusTokRule() {
		return getUnqualOp_PlusTokAccess().getRule();
	}

	//UnqualOp_QuotientTok hidden(WS, KW_NEWLINE):
	//	QuotientTok {QuotientTok};
	public UnqualOp_QuotientTokElements getUnqualOp_QuotientTokAccess() {
		return (pUnqualOp_QuotientTok != null) ? pUnqualOp_QuotientTok : (pUnqualOp_QuotientTok = new UnqualOp_QuotientTokElements());
	}
	
	public ParserRule getUnqualOp_QuotientTokRule() {
		return getUnqualOp_QuotientTokAccess().getRule();
	}

	//UnqualOp_TimesTok hidden(WS, KW_NEWLINE):
	//	TimesTok {TimesTok};
	public UnqualOp_TimesTokElements getUnqualOp_TimesTokAccess() {
		return (pUnqualOp_TimesTok != null) ? pUnqualOp_TimesTok : (pUnqualOp_TimesTok = new UnqualOp_TimesTokElements());
	}
	
	public ParserRule getUnqualOp_TimesTokRule() {
		return getUnqualOp_TimesTokAccess().getRule();
	}

	//UnqualOp_PowerTok hidden(WS, KW_NEWLINE):
	//	PowerTok {PowerTok};
	public UnqualOp_PowerTokElements getUnqualOp_PowerTokAccess() {
		return (pUnqualOp_PowerTok != null) ? pUnqualOp_PowerTok : (pUnqualOp_PowerTok = new UnqualOp_PowerTokElements());
	}
	
	public ParserRule getUnqualOp_PowerTokRule() {
		return getUnqualOp_PowerTokAccess().getRule();
	}

	/// * Substituted Rules in Xtext:
	// * QualOp(ArrowTok)
	// * QualOp(LatticeTok)
	// * QualOp(RelationTok)
	// * QualOp(SegTok)
	// * QualOp(PlusTok)
	// * QualOp(QuotientTok)
	// * QualOp(TimesTok)
	// * QualOp(PowerTok)
	// * QualOp(op)
	// * : op
	// * { $$ = abNewOfToken(AB_Id, $1); }
	// * | op KW_DOLLAR OpQualTail
	// * { $$ = abNewQualify(TPOS($1), abNewOfToken(AB_Id, $1), $3); }
	// * ;
	// * / QualOp_ArrowTok hidden(WS, KW_NEWLINE):
	//	ArrowTok | ArrowTok KW_DOLLAR OpQualTail;
	public QualOp_ArrowTokElements getQualOp_ArrowTokAccess() {
		return (pQualOp_ArrowTok != null) ? pQualOp_ArrowTok : (pQualOp_ArrowTok = new QualOp_ArrowTokElements());
	}
	
	public ParserRule getQualOp_ArrowTokRule() {
		return getQualOp_ArrowTokAccess().getRule();
	}

	//QualOp_LatticeTok hidden(WS, KW_NEWLINE):
	//	LatticeTok | LatticeTok KW_DOLLAR OpQualTail;
	public QualOp_LatticeTokElements getQualOp_LatticeTokAccess() {
		return (pQualOp_LatticeTok != null) ? pQualOp_LatticeTok : (pQualOp_LatticeTok = new QualOp_LatticeTokElements());
	}
	
	public ParserRule getQualOp_LatticeTokRule() {
		return getQualOp_LatticeTokAccess().getRule();
	}

	//QualOp_RelationTok hidden(WS, KW_NEWLINE):
	//	RelationTok | RelationTok KW_DOLLAR OpQualTail;
	public QualOp_RelationTokElements getQualOp_RelationTokAccess() {
		return (pQualOp_RelationTok != null) ? pQualOp_RelationTok : (pQualOp_RelationTok = new QualOp_RelationTokElements());
	}
	
	public ParserRule getQualOp_RelationTokRule() {
		return getQualOp_RelationTokAccess().getRule();
	}

	//QualOp_SegTok hidden(WS, KW_NEWLINE):
	//	SegTok | SegTok KW_DOLLAR OpQualTail;
	public QualOp_SegTokElements getQualOp_SegTokAccess() {
		return (pQualOp_SegTok != null) ? pQualOp_SegTok : (pQualOp_SegTok = new QualOp_SegTokElements());
	}
	
	public ParserRule getQualOp_SegTokRule() {
		return getQualOp_SegTokAccess().getRule();
	}

	//QualOp_PlusTok hidden(WS, KW_NEWLINE):
	//	PlusTok | PlusTok KW_DOLLAR OpQualTail;
	public QualOp_PlusTokElements getQualOp_PlusTokAccess() {
		return (pQualOp_PlusTok != null) ? pQualOp_PlusTok : (pQualOp_PlusTok = new QualOp_PlusTokElements());
	}
	
	public ParserRule getQualOp_PlusTokRule() {
		return getQualOp_PlusTokAccess().getRule();
	}

	//QualOp_QuotientTok hidden(WS, KW_NEWLINE):
	//	QuotientTok | QuotientTok KW_DOLLAR OpQualTail;
	public QualOp_QuotientTokElements getQualOp_QuotientTokAccess() {
		return (pQualOp_QuotientTok != null) ? pQualOp_QuotientTok : (pQualOp_QuotientTok = new QualOp_QuotientTokElements());
	}
	
	public ParserRule getQualOp_QuotientTokRule() {
		return getQualOp_QuotientTokAccess().getRule();
	}

	//QualOp_TimesTok hidden(WS, KW_NEWLINE):
	//	TimesTok | TimesTok KW_DOLLAR OpQualTail;
	public QualOp_TimesTokElements getQualOp_TimesTokAccess() {
		return (pQualOp_TimesTok != null) ? pQualOp_TimesTok : (pQualOp_TimesTok = new QualOp_TimesTokElements());
	}
	
	public ParserRule getQualOp_TimesTokRule() {
		return getQualOp_TimesTokAccess().getRule();
	}

	//QualOp_PowerTok hidden(WS, KW_NEWLINE):
	//	PowerTok | PowerTok KW_DOLLAR OpQualTail;
	public QualOp_PowerTokElements getQualOp_PowerTokAccess() {
		return (pQualOp_PowerTok != null) ? pQualOp_PowerTok : (pQualOp_PowerTok = new QualOp_PowerTokElements());
	}
	
	public ParserRule getQualOp_PowerTokRule() {
		return getQualOp_PowerTokAccess().getRule();
	}

	/// * ++ Doc. * / / * Substituted Rules in Xtext:
	// * E is E from PileContents(E)
	// * / //Doc(E)
	////: PreDocument E PostDocument
	////{
	////$$ = $2;
	////if($3) $$ = abNewDocumented(APOS($3),$$,$3);
	////if($1) $$ = abNewDocumented(APOS($$),$$,$1);
	////}
	////;
	//PreDocument hidden(WS, KW_NEWLINE):
	//	PreDocumentList;
	public PreDocumentElements getPreDocumentAccess() {
		return (pPreDocument != null) ? pPreDocument : (pPreDocument = new PreDocumentElements());
	}
	
	public ParserRule getPreDocumentRule() {
		return getPreDocumentAccess().getRule();
	}

	//PostDocument hidden(WS, KW_NEWLINE):
	//	PostDocumentList;
	public PostDocumentElements getPostDocumentAccess() {
		return (pPostDocument != null) ? pPostDocument : (pPostDocument = new PostDocumentElements());
	}
	
	public ParserRule getPostDocumentRule() {
		return getPostDocumentAccess().getRule();
	}

	//PreDocumentList hidden(WS, KW_NEWLINE):
	//	(TK_PREDOC PreDocumentList)?;
	public PreDocumentListElements getPreDocumentListAccess() {
		return (pPreDocumentList != null) ? pPreDocumentList : (pPreDocumentList = new PreDocumentListElements());
	}
	
	public ParserRule getPreDocumentListRule() {
		return getPreDocumentListAccess().getRule();
	}

	//PostDocumentList hidden(WS, KW_NEWLINE):
	//	(TK_POSTDOC PostDocumentList)?;
	public PostDocumentListElements getPostDocumentListAccess() {
		return (pPostDocumentList != null) ? pPostDocumentList : (pPostDocumentList = new PostDocumentListElements());
	}
	
	public ParserRule getPostDocumentListRule() {
		return getPostDocumentListAccess().getRule();
	}

	/// * Substituted Rules in Xtext:
	// * enlist1(Infixed, KW_Comma, `AB_Comma)
	// * enlist1(CommaItem, KW_Comma, `AB_Comma) enlist1_CommaItem_Comma_AB
	// * enlist1(InfixedExpr, KW_Comma, `AB_Comma)
	// * enlist1(Name, KW_Comma, `AB_Comma)
	// * 
	// *  E {sep E sep E}
	// * 
	// * enlist1(E,Sep,Tag)
	// * : enlister1(E, Sep)
	// * 
	// * { $$ = abOneOrNewOfList(Tag, $1); listFree(AbSyn)($1); }
	// * ;
	// * / enlist1_CommaItem_Comma_AB hidden(WS, KW_NEWLINE):
	//	enlister1_CommaItem_Comma;
	public Enlist1_CommaItem_Comma_ABElements getEnlist1_CommaItem_Comma_ABAccess() {
		return (pEnlist1_CommaItem_Comma_AB != null) ? pEnlist1_CommaItem_Comma_AB : (pEnlist1_CommaItem_Comma_AB = new Enlist1_CommaItem_Comma_ABElements());
	}
	
	public ParserRule getEnlist1_CommaItem_Comma_ABRule() {
		return getEnlist1_CommaItem_Comma_ABAccess().getRule();
	}

	//enlist1_Infixed_Comma_AB hidden(WS, KW_NEWLINE):
	//	enlister1_Infixed_Comma;
	public Enlist1_Infixed_Comma_ABElements getEnlist1_Infixed_Comma_ABAccess() {
		return (pEnlist1_Infixed_Comma_AB != null) ? pEnlist1_Infixed_Comma_AB : (pEnlist1_Infixed_Comma_AB = new Enlist1_Infixed_Comma_ABElements());
	}
	
	public ParserRule getEnlist1_Infixed_Comma_ABRule() {
		return getEnlist1_Infixed_Comma_ABAccess().getRule();
	}

	//enlist1_InfixedExpr_Comma_AB hidden(WS, KW_NEWLINE):
	//	enlister1_InfixedExpr_Comma;
	public Enlist1_InfixedExpr_Comma_ABElements getEnlist1_InfixedExpr_Comma_ABAccess() {
		return (pEnlist1_InfixedExpr_Comma_AB != null) ? pEnlist1_InfixedExpr_Comma_AB : (pEnlist1_InfixedExpr_Comma_AB = new Enlist1_InfixedExpr_Comma_ABElements());
	}
	
	public ParserRule getEnlist1_InfixedExpr_Comma_ABRule() {
		return getEnlist1_InfixedExpr_Comma_ABAccess().getRule();
	}

	/// * not used
	// * E sep E {sep E}
	// * / //enlist2(E,Sep,Tag)
	////: enlister1(E, Sep) Sep E
	////{
	////$1 = listCons(AbSyn)($3, $1);
	////$$ = abOneOrNewOfList(Tag, $1);
	////listFree(AbSyn)($1);
	////}
	////;
	/// * Substituted Rules in Xtext:
	// * enlister1(E, Sep)
	// * where E is E from enlist1 or enlist1a 
	// * enlister1(E, Sep)<ablist>
	// * : E
	// * { $$ = listCons(AbSyn)($1, listNil(AbSyn) ); }
	// * | enlister1(E, Sep) Sep E
	// * { $$ = listCons(AbSyn)($3, $1); }
	// * ;
	// * / enlister1_CommaItem_Comma hidden(WS, KW_NEWLINE):
	//	CommaItem (KW_COMMA ci=CommaItem)*;
	public Enlister1_CommaItem_CommaElements getEnlister1_CommaItem_CommaAccess() {
		return (pEnlister1_CommaItem_Comma != null) ? pEnlister1_CommaItem_Comma : (pEnlister1_CommaItem_Comma = new Enlister1_CommaItem_CommaElements());
	}
	
	public ParserRule getEnlister1_CommaItem_CommaRule() {
		return getEnlister1_CommaItem_CommaAccess().getRule();
	}

	//enlister1_Infixed_Comma hidden(WS, KW_NEWLINE):
	//	Infixed (KW_COMMA i=Infixed)*;
	public Enlister1_Infixed_CommaElements getEnlister1_Infixed_CommaAccess() {
		return (pEnlister1_Infixed_Comma != null) ? pEnlister1_Infixed_Comma : (pEnlister1_Infixed_Comma = new Enlister1_Infixed_CommaElements());
	}
	
	public ParserRule getEnlister1_Infixed_CommaRule() {
		return getEnlister1_Infixed_CommaAccess().getRule();
	}

	//enlister1_InfixedExpr_Comma hidden(WS, KW_NEWLINE):
	//	InfixedExpr (KW_COMMA InfixedExpr)*;
	public Enlister1_InfixedExpr_CommaElements getEnlister1_InfixedExpr_CommaAccess() {
		return (pEnlister1_InfixedExpr_Comma != null) ? pEnlister1_InfixedExpr_Comma : (pEnlister1_InfixedExpr_Comma = new Enlister1_InfixedExpr_CommaElements());
	}
	
	public ParserRule getEnlister1_InfixedExpr_CommaRule() {
		return getEnlister1_InfixedExpr_CommaAccess().getRule();
	}

	/// * Substituted Rules in Xtext:
	// * enlist1a(Labeled, KW_SEMICOLON, `AB_Sequence)
	// * 
	// * E {sep+ E sep+ E sep*} * / enlist1a_Labeled_Semicolon_AB hidden(WS, KW_NEWLINE):
	//	enlister1a_Labeled_Semicolon;
	public Enlist1a_Labeled_Semicolon_ABElements getEnlist1a_Labeled_Semicolon_ABAccess() {
		return (pEnlist1a_Labeled_Semicolon_AB != null) ? pEnlist1a_Labeled_Semicolon_AB : (pEnlist1a_Labeled_Semicolon_AB = new Enlist1a_Labeled_Semicolon_ABElements());
	}
	
	public ParserRule getEnlist1a_Labeled_Semicolon_ABRule() {
		return getEnlist1a_Labeled_Semicolon_ABAccess().getRule();
	}

	/// * Substituted Rules in Xtext:
	// * enlister1a(E, Sep) where E is from enlist1a
	// * 
	// * / //Labeled
	////| enlister1a_Labeled_Semicolon KW_SEMICOLON Labeled
	////| enlister1a_Labeled_Semicolon KW_SEMICOLON
	//enlister1a_Labeled_Semicolon hidden(WS, KW_NEWLINE):
	//	statemnts+=Labeled (KW_SEMICOLON statemnts+=Labeled) KW_SEMICOLON?;
	public Enlister1a_Labeled_SemicolonElements getEnlister1a_Labeled_SemicolonAccess() {
		return (pEnlister1a_Labeled_Semicolon != null) ? pEnlister1a_Labeled_Semicolon : (pEnlister1a_Labeled_Semicolon = new Enlister1a_Labeled_SemicolonElements());
	}
	
	public ParserRule getEnlister1a_Labeled_SemicolonRule() {
		return getEnlister1a_Labeled_SemicolonAccess().getRule();
	}

	/// * Substituted Rules in Xtext:
	// * Piled(Expression)
	// * 
	// * / / * Piled * / //Piled(E)
	////: KW_SetTab PileContents(E) KW_BackTab
	////{ $$ = abOneOrNewOfList(AB_Sequence,$2); listFree(AbSyn)($2); }
	////;
	/// * Substituted Rules in Xtext:
	// * Curly(Labeled)
	// * 
	// * / Curly_Labeled:
	//	KW_OCURLY CurlyContents_Labeled KW_CCURLY;
	public Curly_LabeledElements getCurly_LabeledAccess() {
		return (pCurly_Labeled != null) ? pCurly_Labeled : (pCurly_Labeled = new Curly_LabeledElements());
	}
	
	public ParserRule getCurly_LabeledRule() {
		return getCurly_LabeledAccess().getRule();
	}

	/// * Substituted Rules in Xtext:
	// * PileContents(E) E is from piled
	// * 
	// * / //PileContents(E)<ablist>
	////: Doc(E)
	////{ $$ = listCons(AbSyn)($1, listNil(AbSyn)); }
	////| PileContents(E) KW_BackSet Doc(E)
	////{ $$ = listCons(AbSyn)($3, $1); }
	////| error KW_BackSet Doc(E)
	////{ yyerrok; $$ = listCons(AbSyn)($3, listNil(AbSyn)); }
	////;
	/// * Substituted Rules in Xtext:
	// * CurlyContents(Labeled)
	// * CurlyContents(E) E is from Curly
	// * 
	// * CurlyContents(E) : CurlyContentsList(E);
	// * / CurlyContents_Labeled hidden(WS):
	//	CurlyContentsList_Labeled;
	public CurlyContents_LabeledElements getCurlyContents_LabeledAccess() {
		return (pCurlyContents_Labeled != null) ? pCurlyContents_Labeled : (pCurlyContents_Labeled = new CurlyContents_LabeledElements());
	}
	
	public ParserRule getCurlyContents_LabeledRule() {
		return getCurlyContents_LabeledAccess().getRule();
	}

	/// * Substituted Rules in Xtext:
	// * is CurlyContentsList(E)<ablist> in Aldor grammar
	// * CurlyContentsList(E) E is from CurlyContents(E)
	// * 
	// * CurlyContentsList(E)<ablist>:
	// * CurlyContent1(E)
	// * | CurlyContent1(E) CurlyContentB(E)
	// * ;
	// * / //CurlyContent1_Labeled
	////| CurlyContent1_Labeled ccb=CurlyContentB_Labeled
	//CurlyContentsList_Labeled hidden(WS):
	//	statemts+=Labeled (KW_SEMICOLON statemts+=Labeled)* KW_SEMICOLON?;
	public CurlyContentsList_LabeledElements getCurlyContentsList_LabeledAccess() {
		return (pCurlyContentsList_Labeled != null) ? pCurlyContentsList_Labeled : (pCurlyContentsList_Labeled = new CurlyContentsList_LabeledElements());
	}
	
	public ParserRule getCurlyContentsList_LabeledRule() {
		return getCurlyContentsList_LabeledAccess().getRule();
	}

	/// * CurlyContent1_Labeled
	// * this rule is used by CurlyContentsList_Labeled
	// *
	// * Substituted Rules in Xtext:
	// * CurlyContent1(E) E is form CurlyContentsList(E)
	// * 
	// * This rule is left recursive in the Aldor grammar so I have
	// * to change it here.
	// * / //CurlyContent1_Labeled
	////: Nothing
	////| CurlyContent1_Labeled cca=CurlyContentA_Labeled
	////;
	/// * Substituted Rules in Xtext:
	// * CurlyContentA(E) E is from CurlyContent1(E)
	// * 
	// * / //CurlyContentA_Labeled
	////: CurlyContentB_Labeled KW_SEMICOLON pd=PostDocument
	////| error KW_SEMICOLON PostDocument
	////;
	/// * Substituted Rules in Xtext:
	// * CurlyContentB(E) E is from CurlyContentA(E)
	// * or CurlyContentsList(E)
	// * 
	// * / //PreDocument Labeled pd=PostDocument
	/////////// end of Aldor stuff
	/// *
	// * longname and longname2 should both be ID and have the same value. Since the
	// * runtime values can't be checked by the parser this must be checked later.
	// * / //CategoryDef hidden(WS,KW_NEWLINE,TK_COMMENT):
	////name='category' shortname=TK_ID longname=TK_ID
	////longname2=TK_ID / *[CategoryDef]* /
	////    (cp=TypeParameterList)?
	////    KW_COLON 'Category' KW_2EQ
	////    (
	////    implName=TypeArguments? ((w=WithPart? a=AddPart?)| wh5=WherePart)
	////    | KW_OCURLY KW_NEWLINE*
	////      implName=TypeArguments ((w=WithPart? a=AddPart?)| wh5=WherePart)
	////      KW_CCURLY KW_NEWLINE* a2=AddPart?
	////    )
	////;
	/// *
	// * longname and longname2 should both be ID and have the same value. Since the
	// * runtime values can't be checked by the parser this must be checked later.
	// * / //PackageDef hidden(WS,KW_NEWLINE,TK_COMMENT):
	////name='package' shortname=TK_ID longname=TK_ID
	////longname2=TK_ID / *[PackageDef]* /
	////    (cp=TypeParameterList)? KW_COLON
	////    (
	////     exportName=TK_ID KW_2EQ implName=TK_ID
	////        (w=WithPart | wh5=WherePart)
	////     |
	////     w=WithPart
	////     (KW_2EQ add2=AddPart)?
	////    )
	////;
	/// *
	// * longname and longname2 should both be ID and have the same value. Since the
	// * runtime values can't be checked by the parser this must be checked later.
	// * / //DomainDef hidden(WS,KW_NEWLINE,TK_COMMENT):
	////name='domain' shortname5=TK_ID longname5=TK_ID
	////longname6=TK_ID / *[DomainDef]* /
	////    (cp5=TypeParameterList)?
	////    KW_COLON exportName=TK_ID (cp6=TypeParameterList)?
	////    KW_2EQ implName5=TK_ID?
	////    (w=WithPart | wh5=WherePart | a=AddPart)
	////;
	/// *
	// * both category and domain can have 'where' part which holds overall information
	// * such as category/domain parameter information and general macros. This is
	// * followed by export('with') and import ('add') information.
	// * Forms allowed include:
	// * Exports == PlottablePlaneCurveCategory with {
	// * Exports ==> PlottablePlaneCurveCategory with {
	// * Exports ==> with {
	// * / //WherePart hidden(WS,TK_COMMENT):
	////name='where' KW_NEWLINE* KW_OCURLY KW_NEWLINE*
	////    (whereAssig +=WhereAssignments (KW_NEWLINE|KW_SEMICOLON)+)*
	////    // with part
	////    (longname8=TK_ID (KW_2EQ | KW_MARROW) (imp=TypeExpression2)? w8=WithPart)?
	////    // add part
	////    (
	////     (longname9=TK_ID (KW_2EQ | KW_MARROW))?
	////        ((fs=TK_ID KW_OPAREN par2=TK_ID? (KW_COMMA par3 += TK_ID)* KW_CPAREN)
	////         | (fs=TK_ID f2=TK_ID)
	////        )?
	////        add=AddPart
	////    )?
	////    KW_CCURLY KW_NEWLINE+
	////;
	/// * each one must be on a separate line or separated by ';'
	// * need to add name=
	// * / //WhereAssignments hidden(WS):
	////VariableDeclaration
	////| MacroDef |Import
	////;
	/// *
	// * the 'where' part contains a 'with' part which holds export information
	// * such as function signatures (function declarations) but not function definitions.
	// * / //WithPart hidden(WS,TK_COMMENT):
	////name='with' KW_NEWLINE* KW_OCURLY KW_NEWLINE*
	////    (fundec += VariableDeclaration (KW_NEWLINE|KW_SEMICOLON)+)*
	////    KW_CCURLY KW_NEWLINE*
	////;
	/// *
	// * similar to 'WithPart' but no trailing NL
	// * / //WithInline hidden(WS,TK_COMMENT):
	////name='with' KW_NEWLINE* KW_OCURLY KW_NEWLINE*
	////    (fundec += VariableDeclaration (KW_NEWLINE|KW_SEMICOLON)+)*
	////    KW_CCURLY
	////;
	/// *
	// * the 'where' part contains a 'add' part which holds function and other
	// * declarations.
	// * / //AddPart hidden(WS,TK_COMMENT):
	////name='add' KW_NEWLINE* KW_OCURLY KW_NEWLINE*
	////    (t+=AddStatements (KW_NEWLINE|KW_SEMICOLON)+)* KW_CCURLY KW_NEWLINE*
	////;
	/// *
	// * The add section of domain or package may contain multiple lines
	// *
	// * Examples:
	// * if (r := recip leadingCoefficient M) case "failed" then {
	// * error "Modulus cannot be made monic"
	// * }
	// * / //AddStatements hidden(WS,TK_COMMENT):
	////   VariableDeclarationAssign
	////   | FunctionDefinition
	////   | ('if' t1=Expression // expression has form 'x has y'
	////      'then' t13=FunctionDefinitionBlock)
	////   | 'else' t14=FunctionDefinitionBlock
	////   | 'else' t15=AddStatements
	////   | MacroDef
	////   | Import
	////;
	/// * function definition in add part (called by AddStatements)
	// * has a form like:
	// * name(params) == statement
	// * or, option for single parameter without brackets:
	// * name param == statement
	// * or, option for zero parameters without brackets:
	// * This does not always work at the moment, for instance, this does not work:
	// * size == size$R ^ d
	// * but this does
	// * size() == size$R ^ d
	// *
	// * or, for infix operators,
	// * a = b == statement
	// * or, for multiple statements,
	// * name(params) == {
	// * statement
	// * statement
	// * }
	// * some function definitions may be conditional like this:
	// * if % has finiteAggregate then {
	// * ... }
	// * / //FunctionDefinition hidden(WS,TK_COMMENT):
	////  ((
	////par3=FunctionSignature
	////    (KW_COLON par4=TypeExpression1)?
	////    KW_2EQ par5=Statement
	////   )|(
	////    // this is case where FunctionSignature is just an identifier
	////    fnNam=TK_ID KW_2EQ par5=Statement
	////   ))
	////;
	/// *
	// * called by 'AddStatements' rule.
	// * allows more add statements inside:
	// * if a has y then 'more add statements'
	// * / //FunctionDefinitionBlock hidden(WS,TK_COMMENT):
	////    fnDecBr=KW_OCURLY KW_NEWLINE*
	////      (
	////       fnDecBk += FunctionDefinition (KW_NEWLINE|KW_SEMICOLON)+
	////       |
	////       vars+=VariableDeclarationAssign (KW_NEWLINE|KW_SEMICOLON)+
	////     | ('if' t1+=Expression // expression has form 'x has y'
	////        'then' t13+=FunctionDefinitionBlock (KW_NEWLINE|KW_SEMICOLON)+)
	////     | ('else' t14+=FunctionDefinitionBlock (KW_NEWLINE|KW_SEMICOLON)+)
	////     | i1+=Import (KW_NEWLINE|KW_SEMICOLON)+
	////      )*
	////      KW_CCURLY
	////      | 'error' e=Expression
	////      | KW_OCURLY KW_NEWLINE* 'error' e=Expression (KW_NEWLINE|KW_SEMICOLON)+ KW_CCURLY
	////;
	/// * This is the first part of the function definition without the return type or
	// * the function implementation. Usually the function signature has a form like:
	// * name(params)
	// * We allow a single parameter to be given without brackets:
	// * name param
	// *
	// * We also allow some alternative forms to represent infix operators like:
	// * a = b to represent _=(a,b)
	// * or the following (this works but only for % we need it to work for every type)
	// * s:% = t:%
	// * or
	// * a > b to represent _>(a,b)
	// * 0 or 1 can be used as a function signature as a short form of
	// * _0() or _1()
	// * / //FunctionSignature hidden(WS,TK_COMMENT):
	////  (
	////fnNam=TK_ID
	////    KW_OPAREN
	////    par2=VariableTyped?
	////    (KW_COMMA par3 += VariableTyped)*
	////    KW_CPAREN
	////  ) | (
	////   // fnNam=ID par2=VariableDeclaration causes recursive definition so use:
	////   fnNam=TK_ID par=TK_ID
	////// ) | (
	////// t4=ID // no parameters without brackets
	////// commented out as it causes recursive rule invocation
	////// with ruleAddStatements and ruleFunctionDefinitionBlock
	////  ) | (
	////   t4=TK_ID (KW_COLON (PERCENT | TK_ID))? //(COLON te1=TypeExpression)?
	////   ( b1=KW_EQ | b1=KW_LT | b1=KW_GT | b1=KW_LE | b1=KW_GE |
	////            b1=KW_PLUS | b1=KW_MINUS | b1=KW_STAR | b1=KW_SLASH | b1=KW_AMPERSAND |
	////            b1=KW_BAR | b1=KW_HAT) t5=TK_ID
	////  ) | (
	////   b3=TK_INT // allows special form of function signature using '0' or '1'
	////   // can't specify '0' or '1' explicitly as this would affect lex
	////   // order
	////  ) | (
	////   b2=KW_MINUS t6=TK_ID
	////  ) | (
	////   b4=KW_TILDE t7=TK_ID
	////  ) | (
	////   b5='not' t8=TK_ID
	////  ) | (
	////   b6=KW_SHARP t8=TK_ID
	////  )
	////;
	/// * macros provide a general textual substitution
	// * there are two forms:
	// * name ==> body
	// * and
	// * name macro == body
	// * / //MacroDef: macroname=TK_ID MACROVALUE ; //MACRO val=ID NL;
	/// *
	// * import domain
	// * / //Import hidden(WS):
	////'import' (impname += TK_ID)+ (KW_OPAREN par22+=TypeExpression1
	////(KW_COMMA par22+=TypeExpression1)* KW_CPAREN)?
	////;
	/// * Variable declaration in where and with sections:
	// * A 'variable' can be simple like:
	// * x:Float
	// * or something more complicated like:
	// * x:Record(newPt: Pt,type: String)
	// * or it can be a function like:
	// * x:(Float,Integer) -> Float
	// * or it can be conditional like:
	// * if
	// * / //VariableDeclarationBlock hidden(WS,TK_COMMENT):
	////    vardecbr=KW_OCURLY KW_NEWLINE*
	////      //=>(i1=Import NL*)?
	////      (vardecBlk += VariableDeclaration (KW_NEWLINE|KW_SEMICOLON)+)*
	////      KW_CCURLY
	////;
	/// * Variable declaration in where and with sections:
	// * A 'variable' can be simple like:
	// * x:Float
	// * or something more complicated like:
	// * x:Record(newPt: Pt,type: String)
	// * or it can be a function like:
	// * x:(Float,Integer) -> Float
	// * or it can be conditional like:
	// * if
	// * / //VariableDeclaration hidden(WS,TK_COMMENT):
	//////Import?
	////    ('if' t1=Expression 'then')? // expression has form 'x has y'
	////( v1=TypeWithName
	////      | v2=VariableDeclarationBlock
	////)
	////;
	/// *
	// * This rule is used where a type is expected like:
	// * Float
	// * but it may also have an optional name like:
	// * x:Float
	// * / //TypeWithName hidden(WS,TK_COMMENT):
	////(
	////(varName=TK_ID | varNameSt=TK_STRING) (KW_COMMA varName2=TK_ID)?
	////KW_COLON
	////)? typ=TypeExpression1
	////;
	/// * Variable name with optional type. This is used in function signature
	// * and also by VariableDeclaration:
	// * A 'variable' can be simple like:
	// * x:Float
	// * or something more complicated like:
	// * x:Record(newPt: Pt,type: String)
	// * or it can be a function like:
	// * x:(Float,Integer) -> Float
	// * we can define multiple variables together:
	// * i,j : Integer
	// * / //VariableTyped hidden(WS,TK_COMMENT):
	////(varName=TK_ID | varNameSt=TK_STRING)
	////// =>(COMMA t2+=ID)* // multiple declarations in same line
	////    (KW_COLON typ=TypeExpression1)?
	////;
	/// * in add part we can declare and assign in same part
	// * such as:
	// * a := 3
	// * a:Integer := 3
	// * a := sin(x)
	// *
	// * There are two forms of multiple assignment:
	// * a,b,c := 0@Integer
	// * or:
	// * a := b := c := 0@Integer
	// * / //VariableDeclarationAssign hidden(WS):
	////  varName=TK_ID // name of variable
	////  // if I just use name=ID then, when the ui program is running, I get:
	////  // Duplicate xxx 'coerce' in yyy
	////  (
	////    (KW_COMMA t12+=TK_ID)* // multiple declarations in same line
	////    (KW_COLON typ=TypeExpression1)? // option to explicitly define type
	////    (KW_ASSIGN (t4=Expression / * |(LBRACE NL* Expression NL* RBRACE) * /))?
	////    // we need block since we can't always detect continuation after ':='
	////    // but this causes infinite loop
	////  )// | (BECOMES t2+=ID)+ BECOMES t4=Expression
	////;
	/// *
	// * free variable allows us to declare a variable that is global
	// * / //FreeVariable hidden(WS):
	////'free' var=TK_ID
	////;
	/// *
	// * allows us to declare a variable that is not global
	// * / //LocalVariable hidden(WS):
	////'local' var=TK_ID
	////;
	/// *
	// * This is similar to Expression but known to be of type.
	// * (Expression can also be of type) but if we know that
	// * this is a type we can exclude some possibilities.
	// *
	// * A 'typeExpression' can be simple like:
	// * Float
	// * or something more complicated like:
	// * Record(newPt: Pt,type: String)
	// * or it can be a function like:
	// * (Float,Integer) -> Float
	// *
	// * first we check for a function like: Integer -> Integer
	// * / //TypeExpression1 returns TypeExpression hidden(WS):
	////   =>(t2=TypeArguments KW_RARROW t3=TypeResult)
	////   | TypePrimaryExpression1
	////;
	/// *
	// * This is the same as TypeExpression except it does not allow
	// * the type to be extended by using a 'with' keyword. It is used
	// * in the 'where' rule because the 'with' in that case has a
	// * slightly different syntax.
	// * / //TypeExpression2 returns TypeExpression hidden(WS):
	////   =>(t92=TypeArguments KW_RARROW t93=TypeResult)
	////   | TypePrimaryExpression2
	////;
	/// *
	// * we use a type parameter list for parameters of category, package or domains
	// * Parameter list may be empty '()'.
	// * in this case parameters may be just ID or they may be nameID:typeID
	// *
	// * examples are:
	// * ()
	// * (String)
	// * (s:String)
	// * (String,Integer)
	// * (s:String,i:Integer)
	// * / //TypeParameterList hidden(WS):
	////tyname=KW_OPAREN par=TK_ID?
	////(KW_COLON par21=TypeExpression1)?
	////(KW_COMMA par2 += TK_ID (KW_COLON par22+=TypeExpression1)?)* KW_CPAREN;
	/// *
	// * we use type arguments for first part of function type, that is
	// * x in x-> y
	// * usually this is enclosed in parenthesis
	// * (x) in (x)-> y
	// * but if x is a single argument (Including Record, Union, etc.) then it does
	// * not need to be in parenthesis.
	// * / //TypeArguments hidden(WS):
	////  t=TypeLiteral |
	////  t2=PERCENT |
	////  t3='Type' |
	////  // usually, but not always type arguments are in parenthesis, and empty
	////  // parenthesis are allowed
	////  b1 ?= KW_OPAREN ((TK_ID KW_COLON)? t4=TypeExpression1)?
	////               ( KW_COMMA (TK_ID KW_COLON)? t16 +=TypeExpression1)* KW_CPAREN |
	////  t5='Record' KW_OPAREN t6=TypeExpression1
	////               (KW_COLON t22+=TypeExpression1)?
	////               (KW_COMMA t21+=TypeExpression1 (KW_COLON t23+=TypeExpression1)?)*
	////                KW_CPAREN |
	////  t9='Union' KW_OPAREN t10=TypeExpression1
	////              (KW_COLON t25+=TypeExpression1)?
	////              (KW_COMMA t24+=TypeExpression1 (KW_COLON t26+=TypeExpression1)?)*
	////              KW_CPAREN |
	////  t11='Join' KW_OPAREN t12=TypeExpression1 (KW_COMMA t13+=TypeExpression1)* KW_CPAREN |
	////  t15=TypeNameOrFunctionCall
	////;
	/// *
	// * we use type arguments for final part of function type, that is
	// * y in x-> y
	// * / //TypeResult hidden(WS):
	////  t=TypeLiteral |
	////  t2=PERCENT |
	////  tyname='Type' |
	////  tyname='Record' KW_OPAREN t7=TypeExpression1
	////               (KW_COLON t8+=TypeExpression1)?
	////               (KW_COMMA t21+=TypeExpression1 (KW_COLON t23+=TypeExpression1)?)*
	////                KW_CPAREN |
	////  tyname='Union' KW_OPAREN t10=TypeExpression1
	////              (KW_COLON t11+=TypeExpression1)?
	////              (KW_COMMA t24+=TypeExpression1 (KW_COLON t26+=TypeExpression1)?)*
	////              KW_CPAREN |
	////  tyname='Join' KW_OPAREN t12=TypeExpression1 (KW_COMMA t13+=TypeExpression1)* KW_CPAREN |
	////  t15=TypeNameOrFunctionCall
	////;
	/// *
	// * this matches various specific types
	// * / //TypePrimaryExpression1 returns TypePrimaryExpression hidden(WS):
	//// TypeLiteral
	//// | ({TypePrimaryExpression}t32=PERCENT)
	//// | ({TypePrimaryExpression}tyname='Type') // 'Type' is top of the category hierarchy
	//// | ({TypePrimaryExpression}tyname='Lisp') // 'Lisp' is used for native lisp function calls such as Say$Lisp
	//// | ({TypePrimaryExpression}KW_OPAREN t5=TypeExpression1 KW_CPAREN)
	//// | ({TypePrimaryExpression}tyname='Record' KW_OPAREN t7=TypeExpression1
	////               (KW_COLON t8+=TypeExpression1)?
	////               (KW_COMMA t21+=TypeExpression1 (KW_COLON t23+=TypeExpression1)?)*
	////                KW_CPAREN)
	//// | ({TypePrimaryExpression}tyname='Union' KW_OPAREN t10=TypeExpression1
	////              (KW_COLON t11+=TypeExpression1)?
	////              (KW_COMMA t24+=TypeExpression1 (KW_COLON t26+=TypeExpression1)?)*
	////              KW_CPAREN)
	//// | ({TypePrimaryExpression}tyname='Join'
	////    KW_OPAREN t13=TypeExpression1 (KW_COMMA t14+=TypeExpression1)* KW_CPAREN)
	//// | TypeNameOrFunctionCall
	//// | => TupleDefinition
	////;
	/// *
	// * This is the same as TypePrimaryExpression except it does not allow
	// * the type to be extended by using a 'with' keyword. It is used
	// * in the 'where' rule because the 'with' in that case has a
	// * slightly different syntax.
	// * / //TypePrimaryExpression2 returns TypePrimaryExpression hidden(WS):
	//// TypeLiteral
	//// | ({TypePrimaryExpression}t32=PERCENT)
	//// | ({TypePrimaryExpression}tyname='Type') // 'Type' is top of the category hierarchy
	//// | ({TypePrimaryExpression}tyname='Lisp') // 'Lisp' is used for native lisp function calls such as Say$Lisp
	//// | ({TypePrimaryExpression}KW_OPAREN t5=TypeExpression1 KW_CPAREN)
	//// | ({TypePrimaryExpression}tyname='Record' KW_OPAREN t7=TypeExpression1
	////               (KW_COLON t8+=TypeExpression1)?
	////               (KW_COMMA t21+=TypeExpression1 (KW_COLON t23+=TypeExpression1)?)*
	////                KW_CPAREN)
	//// | ({TypePrimaryExpression}tyname='Union' KW_OPAREN t10=TypeExpression1
	////              (KW_COLON t11+=TypeExpression1)?
	////              (KW_COMMA t24+=TypeExpression1 (KW_COLON t26+=TypeExpression1)?)*
	////              KW_CPAREN)
	//// | ({TypePrimaryExpression}tyname='Join'
	////    KW_OPAREN t13=TypeExpression1 (KW_COMMA t14+=TypeExpression1)* KW_CPAREN)
	//// | TypeNameOrFunctionCall2
	//// | => TupleDefinition
	////;
	/// * This rule will match:
	// * Float - an ID representation of a type
	// * List(Float) - a type function call
	// * List Float - a non-parenthesis form if only one parameter
	// *
	// * A type function is also known as a parameterised type or
	// * functor (not necessarily a true
	// * functor since it may not obey the axioms of a functor).
	// * If there is only one parameter then the parenthesis are optional
	// * / //TypeNameOrFunctionCall hidden(WS):
	////  tfnname=TK_ID
	////  (
	////    (KW_OPAREN (TK_ID KW_COLON)? t4=TypeExpression1? (KW_COMMA (TK_ID KW_COLON)? t25+=TypeExpression1)* KW_CPAREN)
	////    // optional curried function:
	////    (KW_OPAREN t44+=StatementExpression? (KW_COMMA t45+=Expression)* KW_CPAREN)*
	////    // option of no parenthesis for single parameter
	////    | => t6=TypePrimaryExpression1
	////    | => w=WithInline
	////  )?
	////;
	////TypeNameOrFunctionCall2 hidden(WS):
	////  tfnname=TK_ID
	////  (
	////    (KW_OPAREN (TK_ID KW_COLON)? t4=TypeExpression1? (KW_COMMA (TK_ID KW_COLON)? t25+=TypeExpression1)* KW_CPAREN)
	////    // optional curried function:
	////    (KW_OPAREN t44+=StatementExpression? (KW_COMMA t45+=Expression)* KW_CPAREN)*
	////    // option of no parenthesis for single parameter
	////    | => t6=TypePrimaryExpression1
	////  )?
	////;
	/// * This has a form like: (Integer,Float,String)
	// * like an array where each entry can be of a different type
	// * / //TupleDefinition hidden(WS):
	////  (KW_OPAREN t4=TypeExpression1 (KW_COMMA t25+=TypeExpression1)* KW_CPAREN)
	////;
	/// * Since SPAD supports dependent types then numbers and strings can occur here.
	// * Outstanding issues:
	// * 1) Float literals are parsed as elt(Int,Int) so we need to recognise this
	// * and convert to float literal
	// * 2) We need to be able to recognise exponent notation for floats
	// * 3) Integers without '-' prefix can be converted to PI or NNI
	// * 4) need to add hex or octal notation for integers (0xhhhh)
	// * 5) String and Character literals need to have backslash "\" doubled to
	// * "\\" otherwise xtext will interpret backslash as an escape character.
	// * 6) values following immediately after string literal such as "abc"d should
	// * represent an implied concat: concat("abc",d)
	// * / //TypeLiteral hidden(WS):
	////  t1=TK_INT |
	////  t22=TK_STRING |
	////// t3=FloatLiteral |
	////  t34=CharacterLiteral |
	////  t35=BooleanLiteral
	////;
	/// * In FunctionDefinition the algorithm is defined by a sequence of the
	// * following statements:
	// * / //Statement hidden(WS,TK_COMMENT):
	////    s1=Block |
	////    s3= StatementExpression |
	////    // 'if' can occur in an expression or in
	////    // a statement so we use '=>' to choose
	////    // expression if there is any ambiguity
	////    s4=IfStatement |
	////    s4b=IfElseStatement |
	////// s4c=IfThenStatement |
	////    s5=WhileStatement |
	////    s6=DoStatement |
	////    s7=ForStatement |
	////    s8=BreakStatement |
	////    s12=RepeatStatement |
	////    s9= IterateStatement |
	////// s11= ContinueStatement|
	////    s10= ReturnStatement |
	////// s11= Import |
	////    'error' e=Expression
	////;
	/// * allows multiple statements which are grouped by wrapping in
	// * braces (curly brackets) * / //Block hidden(WS,TK_COMMENT):
	////stname=KW_OCURLY KW_NEWLINE*
	////    (statemBl += Statement (KW_NEWLINE|KW_SEMICOLON)+)*
	////    KW_CCURLY
	////;
	/// *
	// * Gives a value or assigns a value to a variable or does conditional exit
	// *
	// * examples:
	// * x
	// * x:Int
	// * x,y:INT -- multiple assignment
	// * x:Int := 3
	// *
	// * x=y => 3
	// * / //StatementExpression hidden(WS,TK_COMMENT):
	////  //(ID COMMA)* // allow multiple assignment
	////  t=ConditionExpression // was Expression but changed so that 'if' statement
	////                        // does not clash with if-then-else expression
	////// (COLON t2=TypeExpression)?
	////// (BECOMES t3=Expression (BECOMES t33+=Expression)*)?
	////    (KW_ASSIGN t5=Block)?
	////    // breaks out of a block if predicate before '=>' is true then program
	////    // control leaves the block.
	////    // Put it here so that it can only occur at the top level of an expression.
	////    // if inside some complicated expression then it must be terminated with ';'.
	////    (KW_IMPLIES t4=Statement)?
	////;
	/// *
	// * for i in n..m repeat ... is 1
	// * for i in n..m by s repeat ...
	// * for i in list repeat ...
	// * for i in list for i in 1..length() repeat ...
	// * for i in list for i in 1.. repeat ...
	// * for j in n..m repeat loopBody
	// * for j in n..m | odd? j repeat
	// *
	// * To Do
	// * -----
	// * As a temporary measure we check for '..' as a suffix operator
	// * here, but we should really put this into expression?
	// *
	// * We need to allow conditions using BAR '|'
	// * / //ForStatement hidden(WS,TK_COMMENT):
	////'for' (
	////       stname=TK_ID 'in' t1=Expression KW_2DOT? //(=> '..' t2=Expression)?
	////       ('by' by1=Expression)?
	////// (=> BAR t2=PredicateOr)? // condition
	////       ('for' stname2+=TK_ID
	////        'in' t2+=Expression KW_2DOT?
	////        ('by' by2+=Expression)?
	////        )*
	////       ('while' t2+=Expression)*
	////) 'repeat' KW_NEWLINE? s1=Statement //('is' s2=Statement)?
	////;
	/// *
	// * while BoolExpr repeat loopBody
	// * / //WhileStatement hidden(WS,TK_COMMENT):
	////stname='while' (
	////       t2=Expression / *PredicateOr* /
	////) 'repeat' KW_NEWLINE? s1=Statement
	////;
	/// *
	// * do loopBody while BoolExpr
	// * / //DoStatement hidden(WS,TK_COMMENT):
	////stname='do' (
	////       s1=Statement
	////) 'while' KW_NEWLINE? t2=Expression / *PredicateOr* /
	////;
	/// *
	// * will repeat until we jump out. For instance by calling return.
	// * / //RepeatStatement hidden(WS,TK_COMMENT):
	////stname='repeat' (
	////       s1=Statement
	////)
	////;
	/// *
	// * iterate ...
	// * skips over the remainder of a loop
	// * / //IterateStatement hidden(WS,TK_COMMENT):
	////stname='iterate'
	////;
	/// *
	// * break leave current loop
	// * / //BreakStatement hidden(WS,TK_COMMENT):
	////stname='break'
	////;
	/// *
	// * return leave current function
	// * / //ReturnStatement hidden(WS):
	////stname='return' t2=Expression
	////;
	/// *
	// * import - use 'Import' instead
	// * / //ImportStatement hidden(WS):
	//// stname='import' t2=Expression
	////;
	/// * 'if' statement allows program flow to be switched
	// * forms:
	// * if boolean then
	// * if equation then
	// * if ... not ... and ...or ... then
	// * if ... then ... else ...
	// * note1:
	// * if ... then ... else ... always returns a value so we can use this
	// * on the right hand side of an assignment
	// * note2:
	// * since there is an explicit 'then' keyword there is no need to put
	// * the condition in brackets
	// *
	// * examples:
	// * a:= if x >0 then x else -x
	// * if R has Field then ...
	// * if myUnion case mtType then ...
	// *
	// * we also need to allow a form like this:
	// * if x >0 {
	// * then x
	// * else -x
	// * }
	// *
	// * also this form (this requires IfElseStatement rule):
	// * if x >0 then {
	// * x
	// * }
	// * else {
	// * -x
	// * }
	// * / //IfStatement hidden(WS,TK_COMMENT):
	////  'if' t2=Expression
	////// 'if' t2=ConditionExpression
	////  (
	////    'then' s1=Statement
	////    (=> 'else' s2=Statement)?
	////   |
	////    b?=KW_OCURLY
	////    KW_NEWLINE+ 'then' s11=Statement KW_NEWLINE*
	////    (=>'else' s12=Statement KW_NEWLINE*)?
	////    KW_CCURLY
	////  )
	////;
	////IfElseStatement hidden(WS,TK_COMMENT):
	////'else' s2=Statement
	////;
	/////////////// Expression syntax follows //////////////
	/// * This is the top level for expressions
	// *
	// * This level handles special cases such as:
	// * if x then y else z
	// * (x,y) +-> z
	// *
	// * We can consider expressions as elements of statements
	// * expressions contain no newlines unless preceded by underscore
	// * (which is handled by WS)
	// * / //Expression returns Expr hidden(WS,TK_COMMENT):
	////  (ifname='if' ifpred=Expression 'then' thenexp=Expression 'else' elseexp=Expression)
	////// | LPAREN t24=ConditionExpression (COMMA t25+=ConditionExpression)+ RPAREN (COLON rightType2 =TypeExpression)? GIVES ConditionExpression
	////  | ExitExpression
	////;
	/// *
	// * condition '=>' expr1 ';' expr2
	// * / //ExitExpression returns Expr hidden(WS,TK_COMMENT):
	////  ConditionExpression
	////  ({ExitExpression.left=current} op=KW_IMPLIES right = ConditionExpression KW_SEMICOLON r2=ConditionExpression)*
	////;
	/// *
	// * BAR "|" precedence: 108, 111
	// * / //ConditionExpression returns Expr hidden(WS,TK_COMMENT):
	////  OrExpression
	////  ({ConditionExpression.left=current} op=KW_BAR right = OrExpression )*
	////;
	/// *
	// * COMMA"," precedence: 110, 111
	// * / //CommaExpression returns Expr hidden(WS,TK_COMMENT):
	//// ConditionalAndExpression
	//// ({ConditionExpression.left=current} op=BAR right = ConditionalAndExpression )*
	////;
	/// *
	// * There is also another rule that looks for 'or' which is PredicateOr,
	// * this version is used in a general expression and the other version is
	// * used when we know we have a predicate.
	// * "or", precedence: 200, 201
	// * / //OrExpression returns Expr hidden(WS,TK_COMMENT):
	////  AndExpression
	////  ( {OrExpression.left=current} op='or' right = AndExpression)*
	////;
	/// *
	// * There is also another rule that looks for 'and' which is PredicateAnd,
	// * this version is used in a general expression and the other version is
	// * used when we know we have a predicate.
	// * "and", precedence: 250, 251
	// * / //AndExpression returns Expr hidden(WS,TK_COMMENT):
	////  InnerProdExpression
	////  ( {AndExpression.left=current} op='and' right = InnerProdExpression)*
	////;
	/// *
	// * This has multiple uses such as inner product and logical or.
	// *
	// * "\/", BACKSLASHSLASH precedence: 200, 201
	// *
	// * the backslash is duplicated here because it is the escape character for
	// * strings, it will not be duplicated when used.
	// * / //InnerProdExpression returns Expr hidden(WS,TK_COMMENT):
	////  OuterProdExpression
	////  ( {InnerProdExpression.left=current} op=KW_VEE right = OuterProdExpression)*
	////;
	/// *
	// * This has multiple uses such as outer product and logical and.
	// *
	// * "/\", SLASHBACKSLASH precedence: 250, 251
	// *
	// * the backslash is duplicated here because it is the escape character for
	// * strings, it will not be duplicated when used.
	// * / //OuterProdExpression returns Expr hidden(WS,TK_COMMENT):
	////  HasExpression
	////  ( {OuterProdExpression.left=current} op=KW_WEDGE right = HasExpression)*
	////;
	/// * Predicate which returns true if preceding value is of a given type
	// * example:
	// * if R has Field then ..
	// *
	// * "has", precedence: 400, 400
	// * / //HasExpression returns Expr hidden(WS,TK_COMMENT):
	////  CaseExpression
	////  ({HasExpression.left=current} op='has' rightType = TypeExpression1)*
	////;
	/// * Select from Union values
	// * example:
	// * if myUnion case mtType then ...
	// *
	// * "case", precedence: 400, 400
	// * / //CaseExpression returns Expr hidden(WS,TK_COMMENT):
	////  EqualityExpression
	////  ( {CaseExpression.left=current} op='case' right = EqualityExpression)?
	////;
	/// * used in list comprehension
	// *
	// * "in", precedence: 400, 400
	// * / / *InExpression returns Expr hidden(WS,TK_COMMENT):
	//  RelationalExpression
	//  ( {CaseExpression.left=current} op='in' right = RelationalExpression)?
	//;* / / *
	// * "~=", precedence: 400, 400
	// * "^=", precedence: 400, 400
	// * "=", precedence: 400, 400
	// * / //EqualityExpression returns Expr hidden(WS,TK_COMMENT):
	////  RelationalExpression
	////// ambiguous because EQ can be in top level expression
	////  ( {EqualityExpression.left=current}
	////   ( op=KW_EQ | op=KW_TILDEE | op=KW_HATE | (op=EQUALSDOLAR te=TK_ID))
	////   //(DOLAR te=ID)?
	////   right = RelationalExpression
	////  )*
	////;
	/// *
	// * ">=", precedence: 400, 400
	// * "<=", precedence: 400, 400
	// * ">>", precedence: 400, 400
	// * "<<", precedence: 400, 400
	// * ">", precedence: 400, 400
	// * "<", precedence: 400, 400
	// * / //RelationalExpression returns Expr hidden(WS,TK_COMMENT):
	////  IsExpression
	////  ( {RelationalExpression.left=current}
	////   ( op=KW_LT | op=KW_GT | op=KW_LE | op=KW_GE )
	////      right = IsExpression
	////  )?
	////;
	/// *
	// *
	// * "isnt", precedence: 400, 400
	// * "is", precedence: 400, 400
	// * / //IsExpression returns Expr hidden(WS,TK_COMMENT):
	////  SegmentExpression
	////  ({IsExpression.left=current} (op='is' | op='isnt') rightType = TypeExpression1)*
	////;
	/// *
	// * this is used to indicate a range:
	// * 1..4 means the range from 1 to 4
	// * 1.. means the range from 1 to infinity. This is used in cases where
	// * no top bounds is necessary, when the end point is determined by other
	// * means.
	// * "..", "SEGMENT", precedence: 401, 699, ["parse_Seg"]
	// * / //SegmentExpression returns Expr hidden(WS,TK_COMMENT):
	////  AdditiveExpression
	////  ( {SegmentExpression.left=current} op=KW_2DOT right = AdditiveExpression)*
	////;
	/// *
	// * add expression
	// * we include both '+' and '-' in the same case as this allows a
	// * multiple sequence like:
	// * a + b + c - d + e -f
	// *
	// * "-", precedence: 700, 701
	// * "+", precedence: 700, 701
	// * / //AdditiveExpression returns Expr hidden(WS,TK_COMMENT):
	////  ExquoExpression
	////  ( {AdditiveExpression.left=current}
	////    ( op=KW_PLUS | op=KW_MINUS | (op=PLUSDOLAR te=TK_ID) | (op=MINUSDOLAR te=TK_ID))
	////    right = ExquoExpression
	////  )*
	////;
	/// *
	// * "exquo", precedence: 800, 801
	// * / //ExquoExpression returns Expr hidden(WS,TK_COMMENT):
	////  DivisionExpression
	////  ({ExquoExpression.left=current} op='exquo' right = DivisionExpression)*
	////;
	/// *
	// * division expression
	// * "/", precedence: 800, 801
	// * / //DivisionExpression returns Expr hidden(WS,TK_COMMENT):
	////  QuoExpression
	////  ( {DivisionExpression.left=current}
	////   (op=KW_SLASH | (op=DIVDOLAR te=TK_ID))
	////   right = QuoExpression
	////  )*
	////;
	/// *
	// *"quo", precedence: 800, 801
	// * / //QuoExpression returns Expr hidden(WS,TK_COMMENT):
	////  ModExpression
	////  ({QuoExpression.left=current} op='quo' right = ModExpression)*
	////;
	/// *
	// *"mod", precedence: 800, 801
	// * / //ModExpression returns Expr hidden(WS,TK_COMMENT):
	////  RemExpression
	////  ({ModExpression.left=current} op='mod' right = RemExpression)*
	////;
	/// *
	// *"rem", precedence: 800, 801
	// * / //RemExpression returns Expr hidden(WS,TK_COMMENT):
	////  MultiplicativeExpression
	////  ({RemExpression.left=current} op='rem' right = MultiplicativeExpression)*
	////;
	/// *
	// * multiplication expression
	// * a * b * c
	// *
	// * "*", precedence: 800, 801
	// * / //MultiplicativeExpression returns Expr hidden(WS,TK_COMMENT):
	////  ExponentExpression
	////  ( {MultiplicativeExpression.left=current}
	////    (op=KW_STAR | (op=TIMESDOLAR te=TK_ID))
	////    right = ExponentExpression
	////  )*
	////;
	/// *
	// *
	// * "^", precedence: 901, 900
	// * "**", precedence: 901, 900
	// * / //ExponentExpression returns Expr hidden(WS,TK_COMMENT):
	////  MapDefinition
	////  ({ExponentExpression.left=current} (op=KW_HAT | op=KW_2STAR) right = MapDefinition)*
	////;
	/// * Map or Lambda expression
	// * var +-> function
	// *
	// * +-> is an infix operator meaning 'maps-to'
	// * It can be used to create a function literal (an anonymous function), so
	// * instead of:
	// * myFunct(x:Type):Type == if x >0 then x else -x
	// * we can have forms such as:
	// * x +-> if x >0 then x else -x
	// * or:
	// * (x,y) +-> if x >0 then y else -x
	// *
	// * fricas compatibility:
	// * "+->", precedence: 995, 112
	// * / //MapDefinition returns Expr hidden(WS,TK_COMMENT):
	////// (PretendExpression | LPAREN PretendExpression (COMMA t25+=PretendExpression)+ RPAREN) (COLON rightType2 =TypeExpression)?
	////  AssignExpression
	////  ({MapDefinition.left=current}
	////   op=KW_MAPSTO right = AssignExpression
	////   (par = TK_ID)? // optional parameter which function
	////                             // is applied to
	////  )*
	////;
	/// *
	// * an assign expression like this:
	// * x := y
	// * can also be an inner assign like this:
	// * x := (y := z)
	// * or just:
	// * x := y := z
	// *
	// * right is expression to allow forms like
	// * x := if y<0 then -y else y
	// * / //AssignExpression returns Expr hidden(WS,TK_COMMENT):
	////  PretendExpression
	////  ({AssignExpression.left=current} op=KW_ASSIGN (
	////   right = PretendExpression
	////   | ifname='if' ifpred=ConditionExpression 'then' thenexp=ConditionExpression 'else' elseexp=PretendExpression
	////   )
	////  )*
	////;
	/// *
	// * pretend Type: treat one type as another,
	// * only works if they have the same internal structure.
	// *
	// * Not very safe and should be avoided, if possible, unfortunately
	// * its not always possible to avoid.
	// *
	// * "pretend", precedence: 995, 996
	// * / // PretendExpression returns Expr hidden(WS,TK_COMMENT):
	////  CoerceExpression
	////  ({PretendExpression.left=current} op='pretend' rightType = TypeExpression1)*
	////;
	/// *
	// * "::", precedence: 996, 997
	// *
	// * although '::' and '@' apparently have the same precidence we want
	// * '@' to bind more tightly than '::'. As we can see in the following example:
	// * "dictionary"@String :: OutputForm.
	// * / //CoerceExpression returns Expr hidden(WS,TK_COMMENT):
	////  HintTypeExpression
	////  ({CoerceExpression.left=current} op=KW_2COLON rightType = TypeExpression1)*
	////;
	/// *
	// * "@", precedence: 996, 997
	// * / //HintTypeExpression returns Expr hidden(WS,TK_COMMENT):
	////  EltExpression
	////  ( {HintTypeExpression.left=current} op=KW_AT rightType = TypeExpression1)?
	////;
	/// * We treat these as part of the language
	// * : indicates type
	// * ! is part of name to indicate mutable
	// *
	// * ":", precedence: 996, 997
	// * "!", precedence: 1002, 1001
	// *
	// * / / *BangExpression returns Expr hidden(WS,TK_COMMENT):
	//  EqualityExpression
	//  ({AndExpression.left=current} op=AMPERSAND right = EqualityExpression)*
	//;* / / *
	// * "with", precedence: 2000, 400, ["parse_InfixWith"]
	// *
	// * / / *WithExpression returns Expr hidden(WS,TK_COMMENT):
	//  EqualityExpression
	//  ({AndExpression.left=current} op='with' right = EqualityExpression)*
	//;* / / * Elt is Lisp terminology for the use of '.' to select parameters
	// * the left expression is something that has selectable elements such as
	// * a list, array, string, Record or union, the right element should be a
	// * non-negative integer.
	// * / //EltExpression returns Expr hidden(WS,TK_COMMENT):
	////  ExplicitTypeExpression
	////  ( {EltExpression.left=current}
	////   op=KW_DOT right = ExplicitTypeExpression
	////  )*
	////;
	//////////////// unary expressions ////////////////////
	/// *
	// * '$'
	// * / //ExplicitTypeExpression returns Expr hidden(WS,TK_COMMENT):
	////  UnaryExpression
	////  ({ExplicitTypeExpression.left=current} op=KW_DOLLAR rightType = TypeExpression1)?
	////;
	/// * UnaryExpression
	// * unary prefixes:
	// * "~" TILDE : precedence 260, 259, nil
	// * ":" COLON : precedence 194, 195
	// * "-" MINUS : precedence 701, 700
	// * "#" HASH : precedence 999, 998
	// * "'" : precedence 999, 999, ["parse_Data"]
	// * unary suffixes
	// * ".." : range can be unary suffix
	// * / //UnaryExpression returns Expr hidden(WS,TK_COMMENT):
	////  PrimaryExpression |
	////  ({UnaryExpression} uop=KW_TILDE expr=UnaryExpression) |
	////// ({UnaryExpression} uop=COLON expr=UnaryExpression) |
	////  ({UnaryExpression} uop=KW_MINUS expr=UnaryExpression) |
	////  ({UnaryExpression} uop=MINUSDOLAR te=TK_ID expr=UnaryExpression) |
	////  ({UnaryExpression} uop=KW_SHARP expr=UnaryExpression) |
	////  ({UnaryExpression} uop='not' expr=PrimaryExpression) |
	////  ({UnaryExpression} uop=SUMLIST expr=PrimaryExpression) |
	////  ({UnaryExpression} uop=PRIMEPERCENT expr=PrimaryExpression) |
	////   e2=PERCENT |
	////  e3='Type' |
	////  e5='Record' KW_OPAREN e6=TypeExpression1
	////               (KW_COLON e22+=TypeExpression1)?
	////               (KW_COMMA e21+=TypeExpression1 (KW_COLON e23+=TypeExpression1)?)*
	////                KW_CPAREN |
	////  e9='Union' KW_OPAREN e10=TypeExpression1
	////              (KW_COLON e25+=TypeExpression1)?
	////              (KW_COMMA e24+=TypeExpression1 (KW_COLON e26+=TypeExpression1)?)*
	////              KW_CPAREN |
	////  e11='Join' KW_OPAREN e12=TypeExpression1 (KW_COMMA e13+=TypeExpression1)* KW_CPAREN
	////;
	/// *
	// *
	// * / / *UnaryExpressionHash returns Expr hidden(WS,TK_COMMENT):
	//// HASH? PrimaryExpression
	//  PrimaryExpression | ({UnaryExpressionHash} uop=HASH expr=UnaryExpressionHash)
	//;* / / *
	// *
	// * / //PrimaryExpression returns Expr hidden(WS,TK_COMMENT):
	////  PrimaryPrefix / * ( t2+=PrimarySuffix )* * /
	////;
	/// *
	// * Can contain an expression in parenthesis, this expression is
	// * 'StatementExpression' which means that it can contain an
	// * inner assignment.
	// *
	// * The comma option allows us to define a tuple
	// * / //PrimaryPrefix hidden(WS,TK_COMMENT):
	//// Literal
	//// | KW_OPAREN t4=Expression (KW_COMMA t25+=Expression)* KW_CPAREN =>(KW_COLON rightType3 =TypeExpression1)?
	//// | t7=NameOrFunctionCall
	////;
	/// * function call such as List(Integer)
	// * known as a parameterised type or functor (not necessarily a true functor since
	// * it may not obey the axioms of a functor)
	// * if there is only one parameter then the parenthesis are optional
	// *
	// * function binds most tightly
	// * / //NameOrFunctionCall hidden(WS,TK_COMMENT):
	////  (KW_QUOTE)?
	////  fnname=TK_ID (=> lsp=KW_DOLLAR 'Lisp'/ *t2=TypeExpression* /)?
	////  // option for parameters in parenthesis
	////  (
	////// LPAREN t4=StatementExpression? (COMMA t5+=Expression)* RPAREN //(COLON rightType2 =TypeExpression)?
	////    KW_OPAREN t4=Expression? (KW_COMMA t5+=Expression)* KW_CPAREN //(COLON rightType2 =TypeExpression)?
	////    // optional curried function:
	////    (KW_OPAREN t14+=Statement? (KW_COMMA t15+=Expression)* KW_CPAREN)*
	////    // option of no parenthesis for single parameter
	////    | => t6=PrimaryExpression
	////  )?
	////  => ((KW_COMMA TK_ID)* KW_COLON rightType2 =TypeExpression1)?
	////  // allow multiple assignment
	////  //=>(op=GIVES lambda = Expression 'xxx')?
	/////;
	/// * Literals are actual values of a given type
	// * Outstanding issues:
	// * 1) Float literals are parsed as elt(Int,Int) so we need to recognise this
	// * and convert to float literal
	// * 2) We need to be able to recognise exponent notation for floats
	// * 3) Integers without '-' prefix can be converted to PI or NNI
	// * 4) need to add hex or octal notation for integers (0xhhhh)
	// * 5) String and Character literals need to have backslash "\" doubled to
	// * "\\" otherwise xtext will interpret backslash as an escape character.
	// * 6) values following immediately after string literal such as "abc"d should
	// * represent an implied concat: concat("abc",d)
	// * / //Literal hidden(WS,TK_COMMENT):
	////  value=TK_INT
	////  | t2=TK_STRING (=> e1=NameOrFunctionCall =>(t31+=TK_STRING (=> e4+=NameOrFunctionCall)?)*)?
	//// | t3=FloatLiteral // conflicts with use of '.' for elt
	////  | ListLiteral
	////  | CharacterLiteral
	////  | BooleanLiteral
	////;
	/// * Contains a single character whereas a string contains multiple
	// * characters.
	// * / //CharacterLiteral hidden(WS,TK_COMMENT):
	//// KW_QUOTE c1=ANY_OTHER KW_QUOTE
	////;
	/// * This may not need to be specified here at the syntax level. Perhaps we
	// * should treat boolean as any other library defined type.
	// * / //BooleanLiteral hidden(WS,TK_COMMENT):
	//// litname = 'true' | litname = 'false'
	//// | litname = 'true' KW_OPAREN KW_CPAREN
	//// | litname = 'false' KW_OPAREN KW_CPAREN
	////;
	/// *
	// * a list literal may consist of:
	// * [] an empty list
	// * [a] a single element
	// * [a,b] multiple elements
	// * [a for b in c] a list comprehension
	// * / //ListLiteral hidden(WS,TK_COMMENT):
	//// litname = KW_OBRACK l2=Expression?
	////     (KW_COMMA t3+=Expression)*
	////     ('for' t14+=Expression 'in' l5+=Expression)?
	////     KW_CBRACK
	////; CurlyContentB_Labeled:
	//	"temp100";
	public CurlyContentB_LabeledElements getCurlyContentB_LabeledAccess() {
		return (pCurlyContentB_Labeled != null) ? pCurlyContentB_Labeled : (pCurlyContentB_Labeled = new CurlyContentB_LabeledElements());
	}
	
	public ParserRule getCurlyContentB_LabeledRule() {
		return getCurlyContentB_LabeledAccess().getRule();
	}
}
