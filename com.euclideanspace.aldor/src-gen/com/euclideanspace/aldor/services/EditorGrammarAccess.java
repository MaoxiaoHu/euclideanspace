/*
* generated by Xtext
*/
package com.euclideanspace.aldor.services;

import com.google.inject.Singleton;
import com.google.inject.Inject;

import java.util.List;

import org.eclipse.xtext.*;
import org.eclipse.xtext.service.GrammarProvider;
import org.eclipse.xtext.service.AbstractElementFinder.*;


@Singleton
public class EditorGrammarAccess extends AbstractGrammarElementFinder {
	
	
	public class ModelElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Model");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cGroup.eContents().get(0);
		private final Keyword cIncludeKeyword_0_0 = (Keyword)cGroup_0.eContents().get(0);
		private final Assignment cInsertAssignment_0_1 = (Assignment)cGroup_0.eContents().get(1);
		private final RuleCall cInsertTK_STRINGTerminalRuleCall_0_1_0 = (RuleCall)cInsertAssignment_0_1.eContents().get(0);
		private final Assignment cCcAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cCcCurlyContents_LabeledParserRuleCall_1_0 = (RuleCall)cCcAssignment_1.eContents().get(0);
		
		/// * Copyright 2014 Martin John Baker
		// *
		// * This file is part of EuclideanSpace.
		// *
		// * EuclideanSpace is free software: you can redistribute it and/or modify
		// * it under the terms of the GNU Affero General Public License as published by
		// * the Free Software Foundation, either version 3 of the License, or
		// * (at your option) any later version.
		// *
		// * EuclideanSpace is distributed in the hope that it will be useful,
		// * but WITHOUT ANY WARRANTY; without even the implied warranty of
		// * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
		// * GNU Affero General Public License for more details.
		// *
		// * You should have received a copy of the GNU Affero General Public License
		// * along with EuclideanSpace. If not, see <http://www.gnu.org/licenses/>.
		// * / / *
		// *
		// * Here we are using a LL(*) recursive-descent parser generator and this
		// * may not be able to exactly replicate axl.z which is a
		// * LALR(1) conflict-free grammar for Aldor.
		// * 
		// * known bugs
		// * ----------
		// * 1) customLexer: phantom semicolon after curly brackets is not yet conditional
		// * 2) ':' does not yet work properly. We want it to bind most tightly.
		// * 3) + or - as prefix operator.
		// * / / *
		// * replaces Goal rule in Aldor grammar
		// * 
		// * #include is not in axl.z grammar, I assume the includes are
		// * done before the grammar is called. So I have added include
		// * support here.
		// * 
		// * / Model hidden(WS, KW_NEWLINE):
		//	("#include" insert+=TK_STRING)* cc=CurlyContents_Labeled;
		public ParserRule getRule() { return rule; }

		//("#include" insert+=TK_STRING)* cc=CurlyContents_Labeled
		public Group getGroup() { return cGroup; }

		//("#include" insert+=TK_STRING)*
		public Group getGroup_0() { return cGroup_0; }

		//"#include"
		public Keyword getIncludeKeyword_0_0() { return cIncludeKeyword_0_0; }

		//insert+=TK_STRING
		public Assignment getInsertAssignment_0_1() { return cInsertAssignment_0_1; }

		//TK_STRING
		public RuleCall getInsertTK_STRINGTerminalRuleCall_0_1_0() { return cInsertTK_STRINGTerminalRuleCall_0_1_0; }

		//cc=CurlyContents_Labeled
		public Assignment getCcAssignment_1() { return cCcAssignment_1; }

		//CurlyContents_Labeled
		public RuleCall getCcCurlyContents_LabeledParserRuleCall_1_0() { return cCcCurlyContents_LabeledParserRuleCall_1_0; }
	}

	public class ErrorElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "error");
		private final Keyword cErrorKeyword = (Keyword)rule.eContents().get(1);
		
		//////////// end of lexer rules ///////////////
		/// * error seems to be defined externally in Aldor grammar
		// * so I have added this rule so it will compile
		// * / error hidden(WS, KW_NEWLINE):
		//	"error";
		public ParserRule getRule() { return rule; }

		//"error"
		public Keyword getErrorKeyword() { return cErrorKeyword; }
	}

	public class ExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Expression");
		private final RuleCall cEnlist1a_Labeled_Semicolon_ABParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//Expression hidden(WS, KW_NEWLINE):
		//	enlist1a_Labeled_Semicolon_AB;
		public ParserRule getRule() { return rule; }

		//enlist1a_Labeled_Semicolon_AB
		public RuleCall getEnlist1a_Labeled_Semicolon_ABParserRuleCall() { return cEnlist1a_Labeled_Semicolon_ABParserRuleCall; }
	}

	public class LabeledElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Labeled");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cCAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final RuleCall cCCommaParserRuleCall_0_0 = (RuleCall)cCAssignment_0.eContents().get(0);
		private final Assignment cDAssignment_1 = (Assignment)cAlternatives.eContents().get(1);
		private final RuleCall cDDeclarationParserRuleCall_1_0 = (RuleCall)cDAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cAlternatives.eContents().get(2);
		private final RuleCall cKW_ATTerminalRuleCall_2_0 = (RuleCall)cGroup_2.eContents().get(0);
		private final Assignment cAAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cAAtomParserRuleCall_2_1_0 = (RuleCall)cAAssignment_2_1.eContents().get(0);
		private final Assignment cLabAssignment_2_2 = (Assignment)cGroup_2.eContents().get(2);
		private final RuleCall cLabLabeledParserRuleCall_2_2_0 = (RuleCall)cLabAssignment_2_2.eContents().get(0);
		
		/// * An '.as' file is effectively a list of 'Labeled' 
		// * separated by semicolons
		// *
		// * Labeled can be an expression or a Declaration such
		// * as 'macro','extend','local','free','fluid','default'
		// * 'define','fix','inline','import' or 'export'.
		// * / Labeled hidden(WS, KW_NEWLINE):
		//	c=Comma | d=Declaration | KW_AT a=Atom lab=Labeled?;
		public ParserRule getRule() { return rule; }

		//c=Comma | d=Declaration | KW_AT a=Atom lab=Labeled?
		public Alternatives getAlternatives() { return cAlternatives; }

		//c=Comma
		public Assignment getCAssignment_0() { return cCAssignment_0; }

		//Comma
		public RuleCall getCCommaParserRuleCall_0_0() { return cCCommaParserRuleCall_0_0; }

		//d=Declaration
		public Assignment getDAssignment_1() { return cDAssignment_1; }

		//Declaration
		public RuleCall getDDeclarationParserRuleCall_1_0() { return cDDeclarationParserRuleCall_1_0; }

		//KW_AT a=Atom lab=Labeled?
		public Group getGroup_2() { return cGroup_2; }

		//KW_AT
		public RuleCall getKW_ATTerminalRuleCall_2_0() { return cKW_ATTerminalRuleCall_2_0; }

		//a=Atom
		public Assignment getAAssignment_2_1() { return cAAssignment_2_1; }

		//Atom
		public RuleCall getAAtomParserRuleCall_2_1_0() { return cAAtomParserRuleCall_2_1_0; }

		//lab=Labeled?
		public Assignment getLabAssignment_2_2() { return cLabAssignment_2_2; }

		//Labeled
		public RuleCall getLabLabeledParserRuleCall_2_2_0() { return cLabLabeledParserRuleCall_2_2_0; }
	}

	public class DeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Declaration");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Action cDeclarationMacroAction_0_0 = (Action)cGroup_0.eContents().get(0);
		private final Keyword cMacroKeyword_0_1 = (Keyword)cGroup_0.eContents().get(1);
		private final Assignment cMbAssignment_0_2 = (Assignment)cGroup_0.eContents().get(2);
		private final RuleCall cMbMacroBodyParserRuleCall_0_2_0 = (RuleCall)cMbAssignment_0_2.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Action cDeclarationExtendAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cExtendKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cSiAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cSiSigParserRuleCall_1_2_0 = (RuleCall)cSiAssignment_1_2.eContents().get(0);
		private final Group cGroup_2 = (Group)cAlternatives.eContents().get(2);
		private final Action cDeclarationLocalAction_2_0 = (Action)cGroup_2.eContents().get(0);
		private final Keyword cLocalKeyword_2_1 = (Keyword)cGroup_2.eContents().get(1);
		private final Assignment cSiAssignment_2_2 = (Assignment)cGroup_2.eContents().get(2);
		private final RuleCall cSiSigParserRuleCall_2_2_0 = (RuleCall)cSiAssignment_2_2.eContents().get(0);
		private final Group cGroup_3 = (Group)cAlternatives.eContents().get(3);
		private final Action cDeclarationFreeAction_3_0 = (Action)cGroup_3.eContents().get(0);
		private final Keyword cFreeKeyword_3_1 = (Keyword)cGroup_3.eContents().get(1);
		private final Assignment cSiAssignment_3_2 = (Assignment)cGroup_3.eContents().get(2);
		private final RuleCall cSiSigParserRuleCall_3_2_0 = (RuleCall)cSiAssignment_3_2.eContents().get(0);
		private final Group cGroup_4 = (Group)cAlternatives.eContents().get(4);
		private final Action cDeclarationFluidAction_4_0 = (Action)cGroup_4.eContents().get(0);
		private final Keyword cFluidKeyword_4_1 = (Keyword)cGroup_4.eContents().get(1);
		private final Assignment cSiAssignment_4_2 = (Assignment)cGroup_4.eContents().get(2);
		private final RuleCall cSiSigParserRuleCall_4_2_0 = (RuleCall)cSiAssignment_4_2.eContents().get(0);
		private final Group cGroup_5 = (Group)cAlternatives.eContents().get(5);
		private final Action cDeclarationDefaultAction_5_0 = (Action)cGroup_5.eContents().get(0);
		private final Keyword cDefaultKeyword_5_1 = (Keyword)cGroup_5.eContents().get(1);
		private final Assignment cSiAssignment_5_2 = (Assignment)cGroup_5.eContents().get(2);
		private final RuleCall cSiSigParserRuleCall_5_2_0 = (RuleCall)cSiAssignment_5_2.eContents().get(0);
		private final Group cGroup_6 = (Group)cAlternatives.eContents().get(6);
		private final Action cDeclarationDefineAction_6_0 = (Action)cGroup_6.eContents().get(0);
		private final Keyword cDefineKeyword_6_1 = (Keyword)cGroup_6.eContents().get(1);
		private final Assignment cSiAssignment_6_2 = (Assignment)cGroup_6.eContents().get(2);
		private final RuleCall cSiSigParserRuleCall_6_2_0 = (RuleCall)cSiAssignment_6_2.eContents().get(0);
		private final Group cGroup_7 = (Group)cAlternatives.eContents().get(7);
		private final Action cDeclarationFixAction_7_0 = (Action)cGroup_7.eContents().get(0);
		private final Keyword cFixKeyword_7_1 = (Keyword)cGroup_7.eContents().get(1);
		private final Assignment cSiAssignment_7_2 = (Assignment)cGroup_7.eContents().get(2);
		private final RuleCall cSiSigParserRuleCall_7_2_0 = (RuleCall)cSiAssignment_7_2.eContents().get(0);
		private final Group cGroup_8 = (Group)cAlternatives.eContents().get(8);
		private final Action cDeclarationInlineAction_8_0 = (Action)cGroup_8.eContents().get(0);
		private final Keyword cInlineKeyword_8_1 = (Keyword)cGroup_8.eContents().get(1);
		private final Assignment cSiAssignment_8_2 = (Assignment)cGroup_8.eContents().get(2);
		private final RuleCall cSiSigParserRuleCall_8_2_0 = (RuleCall)cSiAssignment_8_2.eContents().get(0);
		private final Assignment cFpAssignment_8_3 = (Assignment)cGroup_8.eContents().get(3);
		private final RuleCall cFpFromPartParserRuleCall_8_3_0 = (RuleCall)cFpAssignment_8_3.eContents().get(0);
		private final Group cGroup_9 = (Group)cAlternatives.eContents().get(9);
		private final Action cDeclarationImportAction_9_0 = (Action)cGroup_9.eContents().get(0);
		private final Keyword cImportKeyword_9_1 = (Keyword)cGroup_9.eContents().get(1);
		private final Assignment cSiAssignment_9_2 = (Assignment)cGroup_9.eContents().get(2);
		private final RuleCall cSiSigParserRuleCall_9_2_0 = (RuleCall)cSiAssignment_9_2.eContents().get(0);
		private final Assignment cFpAssignment_9_3 = (Assignment)cGroup_9.eContents().get(3);
		private final RuleCall cFpFromPartParserRuleCall_9_3_0 = (RuleCall)cFpAssignment_9_3.eContents().get(0);
		private final Group cGroup_10 = (Group)cAlternatives.eContents().get(10);
		private final Action cDeclarationExportAction_10_0 = (Action)cGroup_10.eContents().get(0);
		private final Assignment cEdAssignment_10_1 = (Assignment)cGroup_10.eContents().get(1);
		private final RuleCall cEdExportDeclParserRuleCall_10_1_0 = (RuleCall)cEdAssignment_10_1.eContents().get(0);
		
		/// *
		// * A Declaration starts with one of the following key
		// * words: 'macro','extend','local','free','fluid','default'
		// * 'define','fix','inline','import' or 'export'.
		// * / Declaration hidden(WS, KW_NEWLINE):
		//	{DeclarationMacro} "macro" mb=MacroBody | {DeclarationExtend} "extend" si=Sig | {DeclarationLocal} "local" si=Sig |
		//	{DeclarationFree} "free" si=Sig | {DeclarationFluid} "fluid" si=Sig | {DeclarationDefault} "default" si=Sig |
		//	{DeclarationDefine} "define" si=Sig | {DeclarationFix} "fix" si=Sig | {DeclarationInline} "inline" si=Sig?
		//	fp=FromPart? | {DeclarationImport} "import" si=Sig? fp=FromPart? | {DeclarationExport} ed=ExportDecl;
		public ParserRule getRule() { return rule; }

		//{DeclarationMacro} "macro" mb=MacroBody | {DeclarationExtend} "extend" si=Sig | {DeclarationLocal} "local" si=Sig |
		//{DeclarationFree} "free" si=Sig | {DeclarationFluid} "fluid" si=Sig | {DeclarationDefault} "default" si=Sig |
		//{DeclarationDefine} "define" si=Sig | {DeclarationFix} "fix" si=Sig | {DeclarationInline} "inline" si=Sig? fp=FromPart?
		//| {DeclarationImport} "import" si=Sig? fp=FromPart? | {DeclarationExport} ed=ExportDecl
		public Alternatives getAlternatives() { return cAlternatives; }

		//{DeclarationMacro} "macro" mb=MacroBody
		public Group getGroup_0() { return cGroup_0; }

		//{DeclarationMacro}
		public Action getDeclarationMacroAction_0_0() { return cDeclarationMacroAction_0_0; }

		//"macro"
		public Keyword getMacroKeyword_0_1() { return cMacroKeyword_0_1; }

		//mb=MacroBody
		public Assignment getMbAssignment_0_2() { return cMbAssignment_0_2; }

		//MacroBody
		public RuleCall getMbMacroBodyParserRuleCall_0_2_0() { return cMbMacroBodyParserRuleCall_0_2_0; }

		//{DeclarationExtend} "extend" si=Sig
		public Group getGroup_1() { return cGroup_1; }

		//{DeclarationExtend}
		public Action getDeclarationExtendAction_1_0() { return cDeclarationExtendAction_1_0; }

		//"extend"
		public Keyword getExtendKeyword_1_1() { return cExtendKeyword_1_1; }

		//si=Sig
		public Assignment getSiAssignment_1_2() { return cSiAssignment_1_2; }

		//Sig
		public RuleCall getSiSigParserRuleCall_1_2_0() { return cSiSigParserRuleCall_1_2_0; }

		//{DeclarationLocal} "local" si=Sig
		public Group getGroup_2() { return cGroup_2; }

		//{DeclarationLocal}
		public Action getDeclarationLocalAction_2_0() { return cDeclarationLocalAction_2_0; }

		//"local"
		public Keyword getLocalKeyword_2_1() { return cLocalKeyword_2_1; }

		//si=Sig
		public Assignment getSiAssignment_2_2() { return cSiAssignment_2_2; }

		//Sig
		public RuleCall getSiSigParserRuleCall_2_2_0() { return cSiSigParserRuleCall_2_2_0; }

		//{DeclarationFree} "free" si=Sig
		public Group getGroup_3() { return cGroup_3; }

		//{DeclarationFree}
		public Action getDeclarationFreeAction_3_0() { return cDeclarationFreeAction_3_0; }

		//"free"
		public Keyword getFreeKeyword_3_1() { return cFreeKeyword_3_1; }

		//si=Sig
		public Assignment getSiAssignment_3_2() { return cSiAssignment_3_2; }

		//Sig
		public RuleCall getSiSigParserRuleCall_3_2_0() { return cSiSigParserRuleCall_3_2_0; }

		//{DeclarationFluid} "fluid" si=Sig
		public Group getGroup_4() { return cGroup_4; }

		//{DeclarationFluid}
		public Action getDeclarationFluidAction_4_0() { return cDeclarationFluidAction_4_0; }

		//"fluid"
		public Keyword getFluidKeyword_4_1() { return cFluidKeyword_4_1; }

		//si=Sig
		public Assignment getSiAssignment_4_2() { return cSiAssignment_4_2; }

		//Sig
		public RuleCall getSiSigParserRuleCall_4_2_0() { return cSiSigParserRuleCall_4_2_0; }

		//{DeclarationDefault} "default" si=Sig
		public Group getGroup_5() { return cGroup_5; }

		//{DeclarationDefault}
		public Action getDeclarationDefaultAction_5_0() { return cDeclarationDefaultAction_5_0; }

		//"default"
		public Keyword getDefaultKeyword_5_1() { return cDefaultKeyword_5_1; }

		//si=Sig
		public Assignment getSiAssignment_5_2() { return cSiAssignment_5_2; }

		//Sig
		public RuleCall getSiSigParserRuleCall_5_2_0() { return cSiSigParserRuleCall_5_2_0; }

		//{DeclarationDefine} "define" si=Sig
		public Group getGroup_6() { return cGroup_6; }

		//{DeclarationDefine}
		public Action getDeclarationDefineAction_6_0() { return cDeclarationDefineAction_6_0; }

		//"define"
		public Keyword getDefineKeyword_6_1() { return cDefineKeyword_6_1; }

		//si=Sig
		public Assignment getSiAssignment_6_2() { return cSiAssignment_6_2; }

		//Sig
		public RuleCall getSiSigParserRuleCall_6_2_0() { return cSiSigParserRuleCall_6_2_0; }

		//{DeclarationFix} "fix" si=Sig
		public Group getGroup_7() { return cGroup_7; }

		//{DeclarationFix}
		public Action getDeclarationFixAction_7_0() { return cDeclarationFixAction_7_0; }

		//"fix"
		public Keyword getFixKeyword_7_1() { return cFixKeyword_7_1; }

		//si=Sig
		public Assignment getSiAssignment_7_2() { return cSiAssignment_7_2; }

		//Sig
		public RuleCall getSiSigParserRuleCall_7_2_0() { return cSiSigParserRuleCall_7_2_0; }

		//{DeclarationInline} "inline" si=Sig? fp=FromPart?
		public Group getGroup_8() { return cGroup_8; }

		//{DeclarationInline}
		public Action getDeclarationInlineAction_8_0() { return cDeclarationInlineAction_8_0; }

		//"inline"
		public Keyword getInlineKeyword_8_1() { return cInlineKeyword_8_1; }

		//si=Sig?
		public Assignment getSiAssignment_8_2() { return cSiAssignment_8_2; }

		//Sig
		public RuleCall getSiSigParserRuleCall_8_2_0() { return cSiSigParserRuleCall_8_2_0; }

		//fp=FromPart?
		public Assignment getFpAssignment_8_3() { return cFpAssignment_8_3; }

		//FromPart
		public RuleCall getFpFromPartParserRuleCall_8_3_0() { return cFpFromPartParserRuleCall_8_3_0; }

		//{DeclarationImport} "import" si=Sig? fp=FromPart?
		public Group getGroup_9() { return cGroup_9; }

		//{DeclarationImport}
		public Action getDeclarationImportAction_9_0() { return cDeclarationImportAction_9_0; }

		//"import"
		public Keyword getImportKeyword_9_1() { return cImportKeyword_9_1; }

		//si=Sig?
		public Assignment getSiAssignment_9_2() { return cSiAssignment_9_2; }

		//Sig
		public RuleCall getSiSigParserRuleCall_9_2_0() { return cSiSigParserRuleCall_9_2_0; }

		//fp=FromPart?
		public Assignment getFpAssignment_9_3() { return cFpAssignment_9_3; }

		//FromPart
		public RuleCall getFpFromPartParserRuleCall_9_3_0() { return cFpFromPartParserRuleCall_9_3_0; }

		//{DeclarationExport} ed=ExportDecl
		public Group getGroup_10() { return cGroup_10; }

		//{DeclarationExport}
		public Action getDeclarationExportAction_10_0() { return cDeclarationExportAction_10_0; }

		//ed=ExportDecl
		public Assignment getEdAssignment_10_1() { return cEdAssignment_10_1; }

		//ExportDecl
		public RuleCall getEdExportDeclParserRuleCall_10_1_0() { return cEdExportDeclParserRuleCall_10_1_0; }
	}

	public class ExportDeclElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ExportDecl");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Action cExportDeclAction_0_0 = (Action)cGroup_0.eContents().get(0);
		private final Keyword cExportKeyword_0_1 = (Keyword)cGroup_0.eContents().get(1);
		private final Assignment cSAssignment_0_2 = (Assignment)cGroup_0.eContents().get(2);
		private final RuleCall cSSigParserRuleCall_0_2_0 = (RuleCall)cSAssignment_0_2.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Group cGroup_1_0 = (Group)cGroup_1.eContents().get(0);
		private final Keyword cExportKeyword_1_0_0 = (Keyword)cGroup_1_0.eContents().get(0);
		private final Assignment cSAssignment_1_0_1 = (Assignment)cGroup_1_0.eContents().get(1);
		private final RuleCall cSSigParserRuleCall_1_0_1_0 = (RuleCall)cSAssignment_1_0_1.eContents().get(0);
		private final Assignment cTpAssignment_1_0_2 = (Assignment)cGroup_1_0.eContents().get(2);
		private final RuleCall cTpToPartParserRuleCall_1_0_2_0 = (RuleCall)cTpAssignment_1_0_2.eContents().get(0);
		private final Group cGroup_2 = (Group)cAlternatives.eContents().get(2);
		private final Group cGroup_2_0 = (Group)cGroup_2.eContents().get(0);
		private final Keyword cExportKeyword_2_0_0 = (Keyword)cGroup_2_0.eContents().get(0);
		private final Assignment cSAssignment_2_0_1 = (Assignment)cGroup_2_0.eContents().get(1);
		private final RuleCall cSSigParserRuleCall_2_0_1_0 = (RuleCall)cSAssignment_2_0_1.eContents().get(0);
		private final Assignment cFpAssignment_2_0_2 = (Assignment)cGroup_2_0.eContents().get(2);
		private final RuleCall cFpFromPartParserRuleCall_2_0_2_0 = (RuleCall)cFpAssignment_2_0_2.eContents().get(0);
		
		//ExportDecl hidden(WS, KW_NEWLINE):
		//	{ExportDecl} "export" s=Sig? | => ("export" s=Sig? tp=ToPart) | => ("export" s=Sig? fp=FromPart);
		public ParserRule getRule() { return rule; }

		//{ExportDecl} "export" s=Sig? | => ("export" s=Sig? tp=ToPart) | => ("export" s=Sig? fp=FromPart)
		public Alternatives getAlternatives() { return cAlternatives; }

		//{ExportDecl} "export" s=Sig?
		public Group getGroup_0() { return cGroup_0; }

		//{ExportDecl}
		public Action getExportDeclAction_0_0() { return cExportDeclAction_0_0; }

		//"export"
		public Keyword getExportKeyword_0_1() { return cExportKeyword_0_1; }

		//s=Sig?
		public Assignment getSAssignment_0_2() { return cSAssignment_0_2; }

		//Sig
		public RuleCall getSSigParserRuleCall_0_2_0() { return cSSigParserRuleCall_0_2_0; }

		//=> ("export" s=Sig? tp=ToPart)
		public Group getGroup_1() { return cGroup_1; }

		//"export" s=Sig? tp=ToPart
		public Group getGroup_1_0() { return cGroup_1_0; }

		//"export"
		public Keyword getExportKeyword_1_0_0() { return cExportKeyword_1_0_0; }

		//s=Sig?
		public Assignment getSAssignment_1_0_1() { return cSAssignment_1_0_1; }

		//Sig
		public RuleCall getSSigParserRuleCall_1_0_1_0() { return cSSigParserRuleCall_1_0_1_0; }

		//tp=ToPart
		public Assignment getTpAssignment_1_0_2() { return cTpAssignment_1_0_2; }

		//ToPart
		public RuleCall getTpToPartParserRuleCall_1_0_2_0() { return cTpToPartParserRuleCall_1_0_2_0; }

		//=> ("export" s=Sig? fp=FromPart)
		public Group getGroup_2() { return cGroup_2; }

		//"export" s=Sig? fp=FromPart
		public Group getGroup_2_0() { return cGroup_2_0; }

		//"export"
		public Keyword getExportKeyword_2_0_0() { return cExportKeyword_2_0_0; }

		//s=Sig?
		public Assignment getSAssignment_2_0_1() { return cSAssignment_2_0_1; }

		//Sig
		public RuleCall getSSigParserRuleCall_2_0_1_0() { return cSSigParserRuleCall_2_0_1_0; }

		//fp=FromPart
		public Assignment getFpAssignment_2_0_2() { return cFpAssignment_2_0_2; }

		//FromPart
		public RuleCall getFpFromPartParserRuleCall_2_0_2_0() { return cFpFromPartParserRuleCall_2_0_2_0; }
	}

	public class ToPartElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ToPart");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cToKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final RuleCall cInfixedParserRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		
		//ToPart hidden(WS, KW_NEWLINE):
		//	"to" Infixed;
		public ParserRule getRule() { return rule; }

		//"to" Infixed
		public Group getGroup() { return cGroup; }

		//"to"
		public Keyword getToKeyword_0() { return cToKeyword_0; }

		//Infixed
		public RuleCall getInfixedParserRuleCall_1() { return cInfixedParserRuleCall_1; }
	}

	public class FromPartElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "FromPart");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cFromKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final RuleCall cEnlist1_Infixed_Comma_ABParserRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		
		//FromPart hidden(WS, KW_NEWLINE):
		//	"from" enlist1_Infixed_Comma_AB;
		public ParserRule getRule() { return rule; }

		//"from" enlist1_Infixed_Comma_AB
		public Group getGroup() { return cGroup; }

		//"from"
		public Keyword getFromKeyword_0() { return cFromKeyword_0; }

		//enlist1_Infixed_Comma_AB
		public RuleCall getEnlist1_Infixed_Comma_ABParserRuleCall_1() { return cEnlist1_Infixed_Comma_ABParserRuleCall_1; }
	}

	public class MacroBodyElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "MacroBody");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cSigParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cExportDeclParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final Group cGroup_2 = (Group)cAlternatives.eContents().get(2);
		private final Keyword cImportKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final RuleCall cSigParserRuleCall_2_1 = (RuleCall)cGroup_2.eContents().get(1);
		private final Assignment cFpAssignment_2_2 = (Assignment)cGroup_2.eContents().get(2);
		private final RuleCall cFpFromPartParserRuleCall_2_2_0 = (RuleCall)cFpAssignment_2_2.eContents().get(0);
		
		//MacroBody hidden(WS, KW_NEWLINE):
		//	Sig | ExportDecl | "import" Sig fp=FromPart?;
		public ParserRule getRule() { return rule; }

		//Sig | ExportDecl | "import" Sig fp=FromPart?
		public Alternatives getAlternatives() { return cAlternatives; }

		//Sig
		public RuleCall getSigParserRuleCall_0() { return cSigParserRuleCall_0; }

		//ExportDecl
		public RuleCall getExportDeclParserRuleCall_1() { return cExportDeclParserRuleCall_1; }

		//"import" Sig fp=FromPart?
		public Group getGroup_2() { return cGroup_2; }

		//"import"
		public Keyword getImportKeyword_2_0() { return cImportKeyword_2_0; }

		//Sig
		public RuleCall getSigParserRuleCall_2_1() { return cSigParserRuleCall_2_1; }

		//fp=FromPart?
		public Assignment getFpAssignment_2_2() { return cFpAssignment_2_2; }

		//FromPart
		public RuleCall getFpFromPartParserRuleCall_2_2_0() { return cFpFromPartParserRuleCall_2_2_0; }
	}

	public class SigElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Sig");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cDeclBindingParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cBlockParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//Sig hidden(WS, KW_NEWLINE):
		//	DeclBinding | Block;
		public ParserRule getRule() { return rule; }

		//DeclBinding | Block
		public Alternatives getAlternatives() { return cAlternatives; }

		//DeclBinding
		public RuleCall getDeclBindingParserRuleCall_0() { return cDeclBindingParserRuleCall_0; }

		//Block
		public RuleCall getBlockParserRuleCall_1() { return cBlockParserRuleCall_1; }
	}

	public class DeclPartElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "DeclPart");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final RuleCall cKW_COLONTerminalRuleCall_0_0 = (RuleCall)cGroup_0.eContents().get(0);
		private final RuleCall cTypeParserRuleCall_0_1 = (RuleCall)cGroup_0.eContents().get(1);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final RuleCall cKW_COLONSTARTerminalRuleCall_1_0 = (RuleCall)cGroup_1.eContents().get(0);
		private final RuleCall cTypeParserRuleCall_1_1 = (RuleCall)cGroup_1.eContents().get(1);
		
		/// * declare type with ':' or ':*' * / DeclPart hidden(WS, KW_NEWLINE):
		//	KW_COLON Type | KW_COLONSTAR Type;
		public ParserRule getRule() { return rule; }

		//KW_COLON Type | KW_COLONSTAR Type
		public Alternatives getAlternatives() { return cAlternatives; }

		//KW_COLON Type
		public Group getGroup_0() { return cGroup_0; }

		//KW_COLON
		public RuleCall getKW_COLONTerminalRuleCall_0_0() { return cKW_COLONTerminalRuleCall_0_0; }

		//Type
		public RuleCall getTypeParserRuleCall_0_1() { return cTypeParserRuleCall_0_1; }

		//KW_COLONSTAR Type
		public Group getGroup_1() { return cGroup_1; }

		//KW_COLONSTAR
		public RuleCall getKW_COLONSTARTerminalRuleCall_1_0() { return cKW_COLONSTARTerminalRuleCall_1_0; }

		//Type
		public RuleCall getTypeParserRuleCall_1_1() { return cTypeParserRuleCall_1_1; }
	}

	public class CommaElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Comma");
		private final RuleCall cEnlist1_CommaItem_Comma_ABParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		/// *
		// * CommaItem (',' CommaItem)*
		// * / Comma hidden(WS, KW_NEWLINE):
		//	enlist1_CommaItem_Comma_AB;
		public ParserRule getRule() { return rule; }

		//enlist1_CommaItem_Comma_AB
		public RuleCall getEnlist1_CommaItem_Comma_ABParserRuleCall() { return cEnlist1_CommaItem_Comma_ABParserRuleCall; }
	}

	public class CommaItemElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "CommaItem");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cBinding_AnyStatementParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Group cGroup_1_0 = (Group)cGroup_1.eContents().get(0);
		private final Keyword cWhereKeyword_1_0_0 = (Keyword)cGroup_1_0.eContents().get(0);
		private final Assignment cCiAssignment_1_0_1 = (Assignment)cGroup_1_0.eContents().get(1);
		private final RuleCall cCiCommaItemParserRuleCall_1_0_1_0 = (RuleCall)cCiAssignment_1_0_1.eContents().get(0);
		
		//CommaItem hidden(WS, KW_NEWLINE):
		//	Binding_AnyStatement => ("where" ci+=CommaItem)*;
		public ParserRule getRule() { return rule; }

		//Binding_AnyStatement => ("where" ci+=CommaItem)*
		public Group getGroup() { return cGroup; }

		//Binding_AnyStatement
		public RuleCall getBinding_AnyStatementParserRuleCall_0() { return cBinding_AnyStatementParserRuleCall_0; }

		//=> ("where" ci+=CommaItem)*
		public Group getGroup_1() { return cGroup_1; }

		//"where" ci+=CommaItem
		public Group getGroup_1_0() { return cGroup_1_0; }

		//"where"
		public Keyword getWhereKeyword_1_0_0() { return cWhereKeyword_1_0_0; }

		//ci+=CommaItem
		public Assignment getCiAssignment_1_0_1() { return cCiAssignment_1_0_1; }

		//CommaItem
		public RuleCall getCiCommaItemParserRuleCall_1_0_1_0() { return cCiCommaItemParserRuleCall_1_0_1_0; }
	}

	public class DeclBindingElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "DeclBinding");
		private final RuleCall cBindingR_InfixedExprsDecl_AnyStatementParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		/// *
		// * DeclBinding
		// * / DeclBinding hidden(WS, KW_NEWLINE):
		//	BindingR_InfixedExprsDecl_AnyStatement;
		public ParserRule getRule() { return rule; }

		//BindingR_InfixedExprsDecl_AnyStatement
		public RuleCall getBindingR_InfixedExprsDecl_AnyStatementParserRuleCall() { return cBindingR_InfixedExprsDecl_AnyStatementParserRuleCall; }
	}

	public class InfixedExprsDeclElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "InfixedExprsDecl");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cInfixedExprsParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Assignment cDpAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cDpDeclPartParserRuleCall_1_0 = (RuleCall)cDpAssignment_1.eContents().get(0);
		
		//InfixedExprsDecl hidden(WS, KW_NEWLINE):
		//	InfixedExprs dp+=DeclPart*;
		public ParserRule getRule() { return rule; }

		//InfixedExprs dp+=DeclPart*
		public Group getGroup() { return cGroup; }

		//InfixedExprs
		public RuleCall getInfixedExprsParserRuleCall_0() { return cInfixedExprsParserRuleCall_0; }

		//dp+=DeclPart*
		public Assignment getDpAssignment_1() { return cDpAssignment_1; }

		//DeclPart
		public RuleCall getDpDeclPartParserRuleCall_1_0() { return cDpDeclPartParserRuleCall_1_0; }
	}

	public class InfixedExprsElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "InfixedExprs");
		private final RuleCall cEnlist1_InfixedExpr_Comma_ABParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//InfixedExprs hidden(WS, KW_NEWLINE):
		//	enlist1_InfixedExpr_Comma_AB;
		public ParserRule getRule() { return rule; }

		//enlist1_InfixedExpr_Comma_AB
		public RuleCall getEnlist1_InfixedExpr_Comma_ABParserRuleCall() { return cEnlist1_InfixedExpr_Comma_ABParserRuleCall; }
	}

	public class Binding_AnyStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Binding_AnyStatement");
		private final RuleCall cBindingL_Infixed_AnyStatementParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		/// *
		// * Bindings
		// * 
		// * Substituted Rules in Xtext:
		// * Binding_BalStatement
		// * Binding_AnyStatement
		// * Binding_BalStatement
		// * Binding_InfixedExprsDecl
		// * Binding_Collection
		// * Binding(E)
		// * : BindingL(Infixed,E)
		// * ;
		// * / Binding_AnyStatement hidden(WS, KW_NEWLINE):
		//	BindingL_Infixed_AnyStatement;
		public ParserRule getRule() { return rule; }

		//BindingL_Infixed_AnyStatement
		public RuleCall getBindingL_Infixed_AnyStatementParserRuleCall() { return cBindingL_Infixed_AnyStatementParserRuleCall; }
	}

	public class Binding_BalStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Binding_BalStatement");
		private final RuleCall cBindingL_Infixed_BalStatementParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//Binding_BalStatement hidden(WS, KW_NEWLINE):
		//	BindingL_Infixed_BalStatement;
		public ParserRule getRule() { return rule; }

		//BindingL_Infixed_BalStatement
		public RuleCall getBindingL_Infixed_BalStatementParserRuleCall() { return cBindingL_Infixed_BalStatementParserRuleCall; }
	}

	public class Binding_CollectionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Binding_Collection");
		private final RuleCall cBindingL_Infixed_CollectionParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//Binding_Collection hidden(WS, KW_NEWLINE):
		//	BindingL_Infixed_Collection;
		public ParserRule getRule() { return rule; }

		//BindingL_Infixed_Collection
		public RuleCall getBindingL_Infixed_CollectionParserRuleCall() { return cBindingL_Infixed_CollectionParserRuleCall; }
	}

	public class BindingL_Infixed_AnyStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "BindingL_Infixed_AnyStatement");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Group cGroup_0_0 = (Group)cGroup_0.eContents().get(0);
		private final Assignment cLftAssignment_0_0_0 = (Assignment)cGroup_0_0.eContents().get(0);
		private final RuleCall cLftInfixedParserRuleCall_0_0_0_0 = (RuleCall)cLftAssignment_0_0_0.eContents().get(0);
		private final Assignment cOpAssignment_0_0_1 = (Assignment)cGroup_0_0.eContents().get(1);
		private final Alternatives cOpAlternatives_0_0_1_0 = (Alternatives)cOpAssignment_0_0_1.eContents().get(0);
		private final RuleCall cOpKW_ASSIGNTerminalRuleCall_0_0_1_0_0 = (RuleCall)cOpAlternatives_0_0_1_0.eContents().get(0);
		private final RuleCall cOpKW_2EQTerminalRuleCall_0_0_1_0_1 = (RuleCall)cOpAlternatives_0_0_1_0.eContents().get(1);
		private final RuleCall cOpKW_MARROWTerminalRuleCall_0_0_1_0_2 = (RuleCall)cOpAlternatives_0_0_1_0.eContents().get(2);
		private final RuleCall cOpKW_MAPSTOTerminalRuleCall_0_0_1_0_3 = (RuleCall)cOpAlternatives_0_0_1_0.eContents().get(3);
		private final RuleCall cOpKW_MAPSTOSTARTerminalRuleCall_0_0_1_0_4 = (RuleCall)cOpAlternatives_0_0_1_0.eContents().get(4);
		private final Assignment cBiaAssignment_0_0_2 = (Assignment)cGroup_0_0.eContents().get(2);
		private final RuleCall cBiaBindingL_Infixed_AnyStatementParserRuleCall_0_0_2_0 = (RuleCall)cBiaAssignment_0_0_2.eContents().get(0);
		private final Assignment cBas9Assignment_1 = (Assignment)cAlternatives.eContents().get(1);
		private final RuleCall cBas9AnyStatementParserRuleCall_1_0 = (RuleCall)cBas9Assignment_1.eContents().get(0);
		
		/// * This rule allows any statement or new: Assign, Define or Lambda 
		//  * / BindingL_Infixed_AnyStatement hidden(WS, KW_NEWLINE):
		//	=> (lft=Infixed op=(KW_ASSIGN | KW_2EQ | KW_MARROW | KW_MAPSTO | KW_MAPSTOSTAR) bia=BindingL_Infixed_AnyStatement) |
		//	bas9=AnyStatement;
		public ParserRule getRule() { return rule; }

		//=> (lft=Infixed op=(KW_ASSIGN | KW_2EQ | KW_MARROW | KW_MAPSTO | KW_MAPSTOSTAR) bia=BindingL_Infixed_AnyStatement) |
		//bas9=AnyStatement
		public Alternatives getAlternatives() { return cAlternatives; }

		//=> (lft=Infixed op=(KW_ASSIGN | KW_2EQ | KW_MARROW | KW_MAPSTO | KW_MAPSTOSTAR) bia=BindingL_Infixed_AnyStatement)
		public Group getGroup_0() { return cGroup_0; }

		//lft=Infixed op=(KW_ASSIGN | KW_2EQ | KW_MARROW | KW_MAPSTO | KW_MAPSTOSTAR) bia=BindingL_Infixed_AnyStatement
		public Group getGroup_0_0() { return cGroup_0_0; }

		//lft=Infixed
		public Assignment getLftAssignment_0_0_0() { return cLftAssignment_0_0_0; }

		//Infixed
		public RuleCall getLftInfixedParserRuleCall_0_0_0_0() { return cLftInfixedParserRuleCall_0_0_0_0; }

		//op=(KW_ASSIGN | KW_2EQ | KW_MARROW | KW_MAPSTO | KW_MAPSTOSTAR)
		public Assignment getOpAssignment_0_0_1() { return cOpAssignment_0_0_1; }

		//KW_ASSIGN | KW_2EQ | KW_MARROW | KW_MAPSTO | KW_MAPSTOSTAR
		public Alternatives getOpAlternatives_0_0_1_0() { return cOpAlternatives_0_0_1_0; }

		//KW_ASSIGN
		public RuleCall getOpKW_ASSIGNTerminalRuleCall_0_0_1_0_0() { return cOpKW_ASSIGNTerminalRuleCall_0_0_1_0_0; }

		//KW_2EQ
		public RuleCall getOpKW_2EQTerminalRuleCall_0_0_1_0_1() { return cOpKW_2EQTerminalRuleCall_0_0_1_0_1; }

		//KW_MARROW
		public RuleCall getOpKW_MARROWTerminalRuleCall_0_0_1_0_2() { return cOpKW_MARROWTerminalRuleCall_0_0_1_0_2; }

		//KW_MAPSTO
		public RuleCall getOpKW_MAPSTOTerminalRuleCall_0_0_1_0_3() { return cOpKW_MAPSTOTerminalRuleCall_0_0_1_0_3; }

		//KW_MAPSTOSTAR
		public RuleCall getOpKW_MAPSTOSTARTerminalRuleCall_0_0_1_0_4() { return cOpKW_MAPSTOSTARTerminalRuleCall_0_0_1_0_4; }

		//bia=BindingL_Infixed_AnyStatement
		public Assignment getBiaAssignment_0_0_2() { return cBiaAssignment_0_0_2; }

		//BindingL_Infixed_AnyStatement
		public RuleCall getBiaBindingL_Infixed_AnyStatementParserRuleCall_0_0_2_0() { return cBiaBindingL_Infixed_AnyStatementParserRuleCall_0_0_2_0; }

		//bas9=AnyStatement
		public Assignment getBas9Assignment_1() { return cBas9Assignment_1; }

		//AnyStatement
		public RuleCall getBas9AnyStatementParserRuleCall_1_0() { return cBas9AnyStatementParserRuleCall_1_0; }
	}

	public class BindingL_Infixed_BalStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "BindingL_Infixed_BalStatement");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Group cGroup_0_0 = (Group)cGroup_0.eContents().get(0);
		private final Assignment cLftAssignment_0_0_0 = (Assignment)cGroup_0_0.eContents().get(0);
		private final RuleCall cLftInfixedParserRuleCall_0_0_0_0 = (RuleCall)cLftAssignment_0_0_0.eContents().get(0);
		private final Assignment cOpAssignment_0_0_1 = (Assignment)cGroup_0_0.eContents().get(1);
		private final Alternatives cOpAlternatives_0_0_1_0 = (Alternatives)cOpAssignment_0_0_1.eContents().get(0);
		private final RuleCall cOpKW_ASSIGNTerminalRuleCall_0_0_1_0_0 = (RuleCall)cOpAlternatives_0_0_1_0.eContents().get(0);
		private final RuleCall cOpKW_2EQTerminalRuleCall_0_0_1_0_1 = (RuleCall)cOpAlternatives_0_0_1_0.eContents().get(1);
		private final RuleCall cOpKW_MARROWTerminalRuleCall_0_0_1_0_2 = (RuleCall)cOpAlternatives_0_0_1_0.eContents().get(2);
		private final RuleCall cOpKW_MAPSTOTerminalRuleCall_0_0_1_0_3 = (RuleCall)cOpAlternatives_0_0_1_0.eContents().get(3);
		private final RuleCall cOpKW_MAPSTOSTARTerminalRuleCall_0_0_1_0_4 = (RuleCall)cOpAlternatives_0_0_1_0.eContents().get(4);
		private final Assignment cBiaAssignment_0_0_2 = (Assignment)cGroup_0_0.eContents().get(2);
		private final RuleCall cBiaBindingL_Infixed_BalStatementParserRuleCall_0_0_2_0 = (RuleCall)cBiaAssignment_0_0_2.eContents().get(0);
		private final Assignment cBas9Assignment_1 = (Assignment)cAlternatives.eContents().get(1);
		private final RuleCall cBas9BalStatementParserRuleCall_1_0 = (RuleCall)cBas9Assignment_1.eContents().get(0);
		
		//BindingL_Infixed_BalStatement hidden(WS, KW_NEWLINE):
		//	=> (lft=Infixed op=(KW_ASSIGN | KW_2EQ | KW_MARROW | KW_MAPSTO | KW_MAPSTOSTAR) bia=BindingL_Infixed_BalStatement) |
		//	bas9=BalStatement;
		public ParserRule getRule() { return rule; }

		//=> (lft=Infixed op=(KW_ASSIGN | KW_2EQ | KW_MARROW | KW_MAPSTO | KW_MAPSTOSTAR) bia=BindingL_Infixed_BalStatement) |
		//bas9=BalStatement
		public Alternatives getAlternatives() { return cAlternatives; }

		//=> (lft=Infixed op=(KW_ASSIGN | KW_2EQ | KW_MARROW | KW_MAPSTO | KW_MAPSTOSTAR) bia=BindingL_Infixed_BalStatement)
		public Group getGroup_0() { return cGroup_0; }

		//lft=Infixed op=(KW_ASSIGN | KW_2EQ | KW_MARROW | KW_MAPSTO | KW_MAPSTOSTAR) bia=BindingL_Infixed_BalStatement
		public Group getGroup_0_0() { return cGroup_0_0; }

		//lft=Infixed
		public Assignment getLftAssignment_0_0_0() { return cLftAssignment_0_0_0; }

		//Infixed
		public RuleCall getLftInfixedParserRuleCall_0_0_0_0() { return cLftInfixedParserRuleCall_0_0_0_0; }

		//op=(KW_ASSIGN | KW_2EQ | KW_MARROW | KW_MAPSTO | KW_MAPSTOSTAR)
		public Assignment getOpAssignment_0_0_1() { return cOpAssignment_0_0_1; }

		//KW_ASSIGN | KW_2EQ | KW_MARROW | KW_MAPSTO | KW_MAPSTOSTAR
		public Alternatives getOpAlternatives_0_0_1_0() { return cOpAlternatives_0_0_1_0; }

		//KW_ASSIGN
		public RuleCall getOpKW_ASSIGNTerminalRuleCall_0_0_1_0_0() { return cOpKW_ASSIGNTerminalRuleCall_0_0_1_0_0; }

		//KW_2EQ
		public RuleCall getOpKW_2EQTerminalRuleCall_0_0_1_0_1() { return cOpKW_2EQTerminalRuleCall_0_0_1_0_1; }

		//KW_MARROW
		public RuleCall getOpKW_MARROWTerminalRuleCall_0_0_1_0_2() { return cOpKW_MARROWTerminalRuleCall_0_0_1_0_2; }

		//KW_MAPSTO
		public RuleCall getOpKW_MAPSTOTerminalRuleCall_0_0_1_0_3() { return cOpKW_MAPSTOTerminalRuleCall_0_0_1_0_3; }

		//KW_MAPSTOSTAR
		public RuleCall getOpKW_MAPSTOSTARTerminalRuleCall_0_0_1_0_4() { return cOpKW_MAPSTOSTARTerminalRuleCall_0_0_1_0_4; }

		//bia=BindingL_Infixed_BalStatement
		public Assignment getBiaAssignment_0_0_2() { return cBiaAssignment_0_0_2; }

		//BindingL_Infixed_BalStatement
		public RuleCall getBiaBindingL_Infixed_BalStatementParserRuleCall_0_0_2_0() { return cBiaBindingL_Infixed_BalStatementParserRuleCall_0_0_2_0; }

		//bas9=BalStatement
		public Assignment getBas9Assignment_1() { return cBas9Assignment_1; }

		//BalStatement
		public RuleCall getBas9BalStatementParserRuleCall_1_0() { return cBas9BalStatementParserRuleCall_1_0; }
	}

	public class BindingL_Infixed_CollectionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "BindingL_Infixed_Collection");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Group cGroup_0_0 = (Group)cGroup_0.eContents().get(0);
		private final Assignment cLftAssignment_0_0_0 = (Assignment)cGroup_0_0.eContents().get(0);
		private final RuleCall cLftInfixedParserRuleCall_0_0_0_0 = (RuleCall)cLftAssignment_0_0_0.eContents().get(0);
		private final Assignment cOpAssignment_0_0_1 = (Assignment)cGroup_0_0.eContents().get(1);
		private final Alternatives cOpAlternatives_0_0_1_0 = (Alternatives)cOpAssignment_0_0_1.eContents().get(0);
		private final RuleCall cOpKW_ASSIGNTerminalRuleCall_0_0_1_0_0 = (RuleCall)cOpAlternatives_0_0_1_0.eContents().get(0);
		private final RuleCall cOpKW_2EQTerminalRuleCall_0_0_1_0_1 = (RuleCall)cOpAlternatives_0_0_1_0.eContents().get(1);
		private final RuleCall cOpKW_MARROWTerminalRuleCall_0_0_1_0_2 = (RuleCall)cOpAlternatives_0_0_1_0.eContents().get(2);
		private final RuleCall cOpKW_MAPSTOTerminalRuleCall_0_0_1_0_3 = (RuleCall)cOpAlternatives_0_0_1_0.eContents().get(3);
		private final RuleCall cOpKW_MAPSTOSTARTerminalRuleCall_0_0_1_0_4 = (RuleCall)cOpAlternatives_0_0_1_0.eContents().get(4);
		private final Assignment cBiaAssignment_0_0_2 = (Assignment)cGroup_0_0.eContents().get(2);
		private final RuleCall cBiaBindingL_Infixed_CollectionParserRuleCall_0_0_2_0 = (RuleCall)cBiaAssignment_0_0_2.eContents().get(0);
		private final Assignment cBas9Assignment_1 = (Assignment)cAlternatives.eContents().get(1);
		private final RuleCall cBas9CollectionParserRuleCall_1_0 = (RuleCall)cBas9Assignment_1.eContents().get(0);
		
		//BindingL_Infixed_Collection hidden(WS, KW_NEWLINE):
		//	=> (lft=Infixed op=(KW_ASSIGN | KW_2EQ | KW_MARROW | KW_MAPSTO | KW_MAPSTOSTAR) bia=BindingL_Infixed_Collection) |
		//	bas9=Collection;
		public ParserRule getRule() { return rule; }

		//=> (lft=Infixed op=(KW_ASSIGN | KW_2EQ | KW_MARROW | KW_MAPSTO | KW_MAPSTOSTAR) bia=BindingL_Infixed_Collection) |
		//bas9=Collection
		public Alternatives getAlternatives() { return cAlternatives; }

		//=> (lft=Infixed op=(KW_ASSIGN | KW_2EQ | KW_MARROW | KW_MAPSTO | KW_MAPSTOSTAR) bia=BindingL_Infixed_Collection)
		public Group getGroup_0() { return cGroup_0; }

		//lft=Infixed op=(KW_ASSIGN | KW_2EQ | KW_MARROW | KW_MAPSTO | KW_MAPSTOSTAR) bia=BindingL_Infixed_Collection
		public Group getGroup_0_0() { return cGroup_0_0; }

		//lft=Infixed
		public Assignment getLftAssignment_0_0_0() { return cLftAssignment_0_0_0; }

		//Infixed
		public RuleCall getLftInfixedParserRuleCall_0_0_0_0() { return cLftInfixedParserRuleCall_0_0_0_0; }

		//op=(KW_ASSIGN | KW_2EQ | KW_MARROW | KW_MAPSTO | KW_MAPSTOSTAR)
		public Assignment getOpAssignment_0_0_1() { return cOpAssignment_0_0_1; }

		//KW_ASSIGN | KW_2EQ | KW_MARROW | KW_MAPSTO | KW_MAPSTOSTAR
		public Alternatives getOpAlternatives_0_0_1_0() { return cOpAlternatives_0_0_1_0; }

		//KW_ASSIGN
		public RuleCall getOpKW_ASSIGNTerminalRuleCall_0_0_1_0_0() { return cOpKW_ASSIGNTerminalRuleCall_0_0_1_0_0; }

		//KW_2EQ
		public RuleCall getOpKW_2EQTerminalRuleCall_0_0_1_0_1() { return cOpKW_2EQTerminalRuleCall_0_0_1_0_1; }

		//KW_MARROW
		public RuleCall getOpKW_MARROWTerminalRuleCall_0_0_1_0_2() { return cOpKW_MARROWTerminalRuleCall_0_0_1_0_2; }

		//KW_MAPSTO
		public RuleCall getOpKW_MAPSTOTerminalRuleCall_0_0_1_0_3() { return cOpKW_MAPSTOTerminalRuleCall_0_0_1_0_3; }

		//KW_MAPSTOSTAR
		public RuleCall getOpKW_MAPSTOSTARTerminalRuleCall_0_0_1_0_4() { return cOpKW_MAPSTOSTARTerminalRuleCall_0_0_1_0_4; }

		//bia=BindingL_Infixed_Collection
		public Assignment getBiaAssignment_0_0_2() { return cBiaAssignment_0_0_2; }

		//BindingL_Infixed_Collection
		public RuleCall getBiaBindingL_Infixed_CollectionParserRuleCall_0_0_2_0() { return cBiaBindingL_Infixed_CollectionParserRuleCall_0_0_2_0; }

		//bas9=Collection
		public Assignment getBas9Assignment_1() { return cBas9Assignment_1; }

		//Collection
		public RuleCall getBas9CollectionParserRuleCall_1_0() { return cBas9CollectionParserRuleCall_1_0; }
	}

	public class BindingR_InfixedExprsDecl_AnyStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "BindingR_InfixedExprsDecl_AnyStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cInfixedExprsDeclParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Alternatives cAlternatives_1_0 = (Alternatives)cGroup_1.eContents().get(0);
		private final RuleCall cKW_ASSIGNTerminalRuleCall_1_0_0 = (RuleCall)cAlternatives_1_0.eContents().get(0);
		private final RuleCall cKW_2EQTerminalRuleCall_1_0_1 = (RuleCall)cAlternatives_1_0.eContents().get(1);
		private final RuleCall cKW_MARROWTerminalRuleCall_1_0_2 = (RuleCall)cAlternatives_1_0.eContents().get(2);
		private final RuleCall cKW_MAPSTOTerminalRuleCall_1_0_3 = (RuleCall)cAlternatives_1_0.eContents().get(3);
		private final RuleCall cKW_MAPSTOSTARTerminalRuleCall_1_0_4 = (RuleCall)cAlternatives_1_0.eContents().get(4);
		private final Assignment cBasAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cBasBinding_AnyStatementParserRuleCall_1_1_0 = (RuleCall)cBasAssignment_1_1.eContents().get(0);
		
		/// * Substituted Rules in Xtext:
		// * BindingR(InfixedExprsDecl,AnyStatement)
		// * BindingR(R,L)
		// * : R
		// * | R KW_Assign Binding(L)
		// * { $$ = abNewAssign(APOS($1),$1,$3); }
		// * | R KW_2EQ Binding(L)
		// * { $$ = abNewDefine(APOS($1),$1,$3); }
		// * | R KW_MARROW Binding(L)
		// * { $$ = abNewMDefine(APOS($1),$1,$3); }
		// * | R KW_MAPSTO Binding(L)
		// * { $$ = abNewLambda(APOS($1),$1,abZip,$3); }
		// * | R KW_MAPSTOStar Binding(L)
		// * { $$ = abNewPLambda(APOS($1),$1,abZip,$3); }
		// * ;
		// * / //BindingR_InfixedExprsDecl_AnyStatement hidden(WS,KW_NEWLINE):
		//// InfixedExprsDecl
		////| => (InfixedExprsDecl 'assign' bas=Binding_AnyStatement)
		////| => (InfixedExprsDecl KW_2EQ bas=Binding_AnyStatement)
		////| => (InfixedExprsDecl KW_MARROW bas=Binding_AnyStatement)
		////| => (InfixedExprsDecl KW_MAPSTO bas=Binding_AnyStatement)
		////| => (InfixedExprsDecl KW_MAPSTOSTAR bas=Binding_AnyStatement)
		////;
		//BindingR_InfixedExprsDecl_AnyStatement hidden(WS, KW_NEWLINE):
		//	InfixedExprsDecl ((KW_ASSIGN | KW_2EQ | KW_MARROW | KW_MAPSTO | KW_MAPSTOSTAR) bas=Binding_AnyStatement)?;
		public ParserRule getRule() { return rule; }

		//InfixedExprsDecl ((KW_ASSIGN | KW_2EQ | KW_MARROW | KW_MAPSTO | KW_MAPSTOSTAR) bas=Binding_AnyStatement)?
		public Group getGroup() { return cGroup; }

		//InfixedExprsDecl
		public RuleCall getInfixedExprsDeclParserRuleCall_0() { return cInfixedExprsDeclParserRuleCall_0; }

		//((KW_ASSIGN | KW_2EQ | KW_MARROW | KW_MAPSTO | KW_MAPSTOSTAR) bas=Binding_AnyStatement)?
		public Group getGroup_1() { return cGroup_1; }

		//KW_ASSIGN | KW_2EQ | KW_MARROW | KW_MAPSTO | KW_MAPSTOSTAR
		public Alternatives getAlternatives_1_0() { return cAlternatives_1_0; }

		//KW_ASSIGN
		public RuleCall getKW_ASSIGNTerminalRuleCall_1_0_0() { return cKW_ASSIGNTerminalRuleCall_1_0_0; }

		//KW_2EQ
		public RuleCall getKW_2EQTerminalRuleCall_1_0_1() { return cKW_2EQTerminalRuleCall_1_0_1; }

		//KW_MARROW
		public RuleCall getKW_MARROWTerminalRuleCall_1_0_2() { return cKW_MARROWTerminalRuleCall_1_0_2; }

		//KW_MAPSTO
		public RuleCall getKW_MAPSTOTerminalRuleCall_1_0_3() { return cKW_MAPSTOTerminalRuleCall_1_0_3; }

		//KW_MAPSTOSTAR
		public RuleCall getKW_MAPSTOSTARTerminalRuleCall_1_0_4() { return cKW_MAPSTOSTARTerminalRuleCall_1_0_4; }

		//bas=Binding_AnyStatement
		public Assignment getBasAssignment_1_1() { return cBasAssignment_1_1; }

		//Binding_AnyStatement
		public RuleCall getBasBinding_AnyStatementParserRuleCall_1_1_0() { return cBasBinding_AnyStatementParserRuleCall_1_1_0; }
	}

	public class AnyStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "AnyStatement");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Group cGroup_0_0 = (Group)cGroup_0.eContents().get(0);
		private final Keyword cIfKeyword_0_0_0 = (Keyword)cGroup_0_0.eContents().get(0);
		private final RuleCall cCommaItemParserRuleCall_0_0_1 = (RuleCall)cGroup_0_0.eContents().get(1);
		private final Keyword cThenKeyword_0_0_2 = (Keyword)cGroup_0_0.eContents().get(2);
		private final Assignment cBasAssignment_0_0_3 = (Assignment)cGroup_0_0.eContents().get(3);
		private final RuleCall cBasBinding_AnyStatementParserRuleCall_0_0_3_0 = (RuleCall)cBasAssignment_0_0_3.eContents().get(0);
		private final RuleCall cFlow_AnyStatementParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		/// *
		// * Statements
		// *
		// * It is easier to spot conflicts when explicitly handling dangling else.
		// * / AnyStatement hidden(WS, KW_NEWLINE):
		//	=> ("if" CommaItem "then" bas=Binding_AnyStatement) | Flow_AnyStatement;
		public ParserRule getRule() { return rule; }

		//=> ("if" CommaItem "then" bas=Binding_AnyStatement) | Flow_AnyStatement
		public Alternatives getAlternatives() { return cAlternatives; }

		//=> ("if" CommaItem "then" bas=Binding_AnyStatement)
		public Group getGroup_0() { return cGroup_0; }

		//"if" CommaItem "then" bas=Binding_AnyStatement
		public Group getGroup_0_0() { return cGroup_0_0; }

		//"if"
		public Keyword getIfKeyword_0_0_0() { return cIfKeyword_0_0_0; }

		//CommaItem
		public RuleCall getCommaItemParserRuleCall_0_0_1() { return cCommaItemParserRuleCall_0_0_1; }

		//"then"
		public Keyword getThenKeyword_0_0_2() { return cThenKeyword_0_0_2; }

		//bas=Binding_AnyStatement
		public Assignment getBasAssignment_0_0_3() { return cBasAssignment_0_0_3; }

		//Binding_AnyStatement
		public RuleCall getBasBinding_AnyStatementParserRuleCall_0_0_3_0() { return cBasBinding_AnyStatementParserRuleCall_0_0_3_0; }

		//Flow_AnyStatement
		public RuleCall getFlow_AnyStatementParserRuleCall_1() { return cFlow_AnyStatementParserRuleCall_1; }
	}

	public class BalStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "BalStatement");
		private final RuleCall cFlow_BalStatementParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		/// * 
		// * / BalStatement hidden(WS, KW_NEWLINE):
		//	Flow_BalStatement;
		public ParserRule getRule() { return rule; }

		//Flow_BalStatement
		public RuleCall getFlow_BalStatementParserRuleCall() { return cFlow_BalStatementParserRuleCall; }
	}

	public class Flow_AnyStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Flow_AnyStatement");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Assignment cCAssignment_0_0 = (Assignment)cGroup_0.eContents().get(0);
		private final RuleCall cCCollectionParserRuleCall_0_0_0 = (RuleCall)cCAssignment_0_0.eContents().get(0);
		private final Group cGroup_0_1 = (Group)cGroup_0.eContents().get(1);
		private final Assignment cStAssignment_0_1_0 = (Assignment)cGroup_0_1.eContents().get(0);
		private final Keyword cStImpliesKeyword_0_1_0_0 = (Keyword)cStAssignment_0_1_0.eContents().get(0);
		private final Assignment cBas2Assignment_0_1_1 = (Assignment)cGroup_0_1.eContents().get(1);
		private final RuleCall cBas2Binding_AnyStatementParserRuleCall_0_1_1_0 = (RuleCall)cBas2Assignment_0_1_1.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Assignment cStAssignment_1_0 = (Assignment)cGroup_1.eContents().get(0);
		private final Keyword cStIfKeyword_1_0_0 = (Keyword)cStAssignment_1_0.eContents().get(0);
		private final Assignment cCiAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cCiCommaItemParserRuleCall_1_1_0 = (RuleCall)cCiAssignment_1_1.eContents().get(0);
		private final Keyword cThenKeyword_1_2 = (Keyword)cGroup_1.eContents().get(2);
		private final Assignment cBbsAssignment_1_3 = (Assignment)cGroup_1.eContents().get(3);
		private final RuleCall cBbsBinding_BalStatementParserRuleCall_1_3_0 = (RuleCall)cBbsAssignment_1_3.eContents().get(0);
		private final Keyword cElseKeyword_1_4 = (Keyword)cGroup_1.eContents().get(4);
		private final Assignment cBasAssignment_1_5 = (Assignment)cGroup_1.eContents().get(5);
		private final RuleCall cBasBinding_AnyStatementParserRuleCall_1_5_0 = (RuleCall)cBasAssignment_1_5.eContents().get(0);
		private final Group cGroup_2 = (Group)cAlternatives.eContents().get(2);
		private final Group cGroup_2_0 = (Group)cGroup_2.eContents().get(0);
		private final RuleCall cIteratorsParserRuleCall_2_0_0 = (RuleCall)cGroup_2_0.eContents().get(0);
		private final Assignment cStAssignment_2_0_1 = (Assignment)cGroup_2_0.eContents().get(1);
		private final Keyword cStRepeatKeyword_2_0_1_0 = (Keyword)cStAssignment_2_0_1.eContents().get(0);
		private final Assignment cBas3Assignment_2_0_2 = (Assignment)cGroup_2_0.eContents().get(2);
		private final RuleCall cBas3Binding_AnyStatementParserRuleCall_2_0_2_0 = (RuleCall)cBas3Assignment_2_0_2.eContents().get(0);
		private final Group cGroup_3 = (Group)cAlternatives.eContents().get(3);
		private final Assignment cStAssignment_3_0 = (Assignment)cGroup_3.eContents().get(0);
		private final Keyword cStRepeatKeyword_3_0_0 = (Keyword)cStAssignment_3_0.eContents().get(0);
		private final Assignment cBasAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final RuleCall cBasBinding_AnyStatementParserRuleCall_3_1_0 = (RuleCall)cBasAssignment_3_1.eContents().get(0);
		private final Group cGroup_4 = (Group)cAlternatives.eContents().get(4);
		private final Assignment cStAssignment_4_0 = (Assignment)cGroup_4.eContents().get(0);
		private final Keyword cStTryKeyword_4_0_0 = (Keyword)cStAssignment_4_0.eContents().get(0);
		private final Assignment cBasAssignment_4_1 = (Assignment)cGroup_4.eContents().get(1);
		private final RuleCall cBasBinding_AnyStatementParserRuleCall_4_1_0 = (RuleCall)cBasAssignment_4_1.eContents().get(0);
		private final Alternatives cAlternatives_4_2 = (Alternatives)cGroup_4.eContents().get(2);
		private final Keyword cButKeyword_4_2_0 = (Keyword)cAlternatives_4_2.eContents().get(0);
		private final Keyword cCatchKeyword_4_2_1 = (Keyword)cAlternatives_4_2.eContents().get(1);
		private final Assignment cBe2Assignment_4_3 = (Assignment)cGroup_4.eContents().get(3);
		private final RuleCall cBe2ButExprParserRuleCall_4_3_0 = (RuleCall)cBe2Assignment_4_3.eContents().get(0);
		private final Assignment cApaAssignment_4_4 = (Assignment)cGroup_4.eContents().get(4);
		private final RuleCall cApaAlwaysPart_AnyStatementParserRuleCall_4_4_0 = (RuleCall)cApaAssignment_4_4.eContents().get(0);
		private final Group cGroup_5 = (Group)cAlternatives.eContents().get(5);
		private final Assignment cStAssignment_5_0 = (Assignment)cGroup_5.eContents().get(0);
		private final Keyword cStSelectKeyword_5_0_0 = (Keyword)cStAssignment_5_0.eContents().get(0);
		private final Assignment cBasAssignment_5_1 = (Assignment)cGroup_5.eContents().get(1);
		private final RuleCall cBasBinding_AnyStatementParserRuleCall_5_1_0 = (RuleCall)cBasAssignment_5_1.eContents().get(0);
		private final Keyword cInKeyword_5_2 = (Keyword)cGroup_5.eContents().get(2);
		private final Assignment cCaAssignment_5_3 = (Assignment)cGroup_5.eContents().get(3);
		private final RuleCall cCaCasesParserRuleCall_5_3_0 = (RuleCall)cCaAssignment_5_3.eContents().get(0);
		private final Group cGroup_6 = (Group)cAlternatives.eContents().get(6);
		private final Assignment cStAssignment_6_0 = (Assignment)cGroup_6.eContents().get(0);
		private final Keyword cStDoKeyword_6_0_0 = (Keyword)cStAssignment_6_0.eContents().get(0);
		private final Assignment cBasAssignment_6_1 = (Assignment)cGroup_6.eContents().get(1);
		private final RuleCall cBasBinding_AnyStatementParserRuleCall_6_1_0 = (RuleCall)cBasAssignment_6_1.eContents().get(0);
		private final Group cGroup_7 = (Group)cAlternatives.eContents().get(7);
		private final Assignment cStAssignment_7_0 = (Assignment)cGroup_7.eContents().get(0);
		private final Keyword cStDelayKeyword_7_0_0 = (Keyword)cStAssignment_7_0.eContents().get(0);
		private final Assignment cBasAssignment_7_1 = (Assignment)cGroup_7.eContents().get(1);
		private final RuleCall cBasBinding_AnyStatementParserRuleCall_7_1_0 = (RuleCall)cBasAssignment_7_1.eContents().get(0);
		private final Group cGroup_8 = (Group)cAlternatives.eContents().get(8);
		private final Assignment cStAssignment_8_0 = (Assignment)cGroup_8.eContents().get(0);
		private final Keyword cStReferenceKeyword_8_0_0 = (Keyword)cStAssignment_8_0.eContents().get(0);
		private final Assignment cBasAssignment_8_1 = (Assignment)cGroup_8.eContents().get(1);
		private final RuleCall cBasBinding_AnyStatementParserRuleCall_8_1_0 = (RuleCall)cBasAssignment_8_1.eContents().get(0);
		private final Group cGroup_9 = (Group)cAlternatives.eContents().get(9);
		private final Assignment cStAssignment_9_0 = (Assignment)cGroup_9.eContents().get(0);
		private final Keyword cStGenerateKeyword_9_0_0 = (Keyword)cStAssignment_9_0.eContents().get(0);
		private final Assignment cGbAssignment_9_1 = (Assignment)cGroup_9.eContents().get(1);
		private final RuleCall cGbGenBoundParserRuleCall_9_1_0 = (RuleCall)cGbAssignment_9_1.eContents().get(0);
		private final Assignment cBas4Assignment_9_2 = (Assignment)cGroup_9.eContents().get(2);
		private final RuleCall cBas4Binding_AnyStatementParserRuleCall_9_2_0 = (RuleCall)cBas4Assignment_9_2.eContents().get(0);
		private final Group cGroup_10 = (Group)cAlternatives.eContents().get(10);
		private final Assignment cStAssignment_10_0 = (Assignment)cGroup_10.eContents().get(0);
		private final Keyword cStAssertKeyword_10_0_0 = (Keyword)cStAssignment_10_0.eContents().get(0);
		private final Assignment cBasAssignment_10_1 = (Assignment)cGroup_10.eContents().get(1);
		private final RuleCall cBasBinding_AnyStatementParserRuleCall_10_1_0 = (RuleCall)cBasAssignment_10_1.eContents().get(0);
		private final Group cGroup_11 = (Group)cAlternatives.eContents().get(11);
		private final Assignment cStAssignment_11_0 = (Assignment)cGroup_11.eContents().get(0);
		private final Keyword cStIterateKeyword_11_0_0 = (Keyword)cStAssignment_11_0.eContents().get(0);
		private final Assignment cNAssignment_11_1 = (Assignment)cGroup_11.eContents().get(1);
		private final RuleCall cNNameParserRuleCall_11_1_0 = (RuleCall)cNAssignment_11_1.eContents().get(0);
		private final Group cGroup_12 = (Group)cAlternatives.eContents().get(12);
		private final Assignment cStAssignment_12_0 = (Assignment)cGroup_12.eContents().get(0);
		private final Keyword cStBreakKeyword_12_0_0 = (Keyword)cStAssignment_12_0.eContents().get(0);
		private final Assignment cNAssignment_12_1 = (Assignment)cGroup_12.eContents().get(1);
		private final RuleCall cNNameParserRuleCall_12_1_0 = (RuleCall)cNAssignment_12_1.eContents().get(0);
		private final Group cGroup_13 = (Group)cAlternatives.eContents().get(13);
		private final Assignment cStAssignment_13_0 = (Assignment)cGroup_13.eContents().get(0);
		private final Keyword cStReturnKeyword_13_0_0 = (Keyword)cStAssignment_13_0.eContents().get(0);
		private final Assignment cCAssignment_13_1 = (Assignment)cGroup_13.eContents().get(1);
		private final RuleCall cCCollectionParserRuleCall_13_1_0 = (RuleCall)cCAssignment_13_1.eContents().get(0);
		private final Group cGroup_14 = (Group)cAlternatives.eContents().get(14);
		private final Assignment cStAssignment_14_0 = (Assignment)cGroup_14.eContents().get(0);
		private final Keyword cStYieldKeyword_14_0_0 = (Keyword)cStAssignment_14_0.eContents().get(0);
		private final Assignment cBasAssignment_14_1 = (Assignment)cGroup_14.eContents().get(1);
		private final RuleCall cBasBinding_AnyStatementParserRuleCall_14_1_0 = (RuleCall)cBasAssignment_14_1.eContents().get(0);
		private final Group cGroup_15 = (Group)cAlternatives.eContents().get(15);
		private final Assignment cStAssignment_15_0 = (Assignment)cGroup_15.eContents().get(0);
		private final Keyword cStExceptKeyword_15_0_0 = (Keyword)cStAssignment_15_0.eContents().get(0);
		private final Assignment cBasAssignment_15_1 = (Assignment)cGroup_15.eContents().get(1);
		private final RuleCall cBasBinding_AnyStatementParserRuleCall_15_1_0 = (RuleCall)cBasAssignment_15_1.eContents().get(0);
		private final Group cGroup_16 = (Group)cAlternatives.eContents().get(16);
		private final Assignment cStAssignment_16_0 = (Assignment)cGroup_16.eContents().get(0);
		private final Keyword cStThrowKeyword_16_0_0 = (Keyword)cStAssignment_16_0.eContents().get(0);
		private final Assignment cBasAssignment_16_1 = (Assignment)cGroup_16.eContents().get(1);
		private final RuleCall cBasBinding_AnyStatementParserRuleCall_16_1_0 = (RuleCall)cBasAssignment_16_1.eContents().get(0);
		private final Group cGroup_17 = (Group)cAlternatives.eContents().get(17);
		private final Assignment cStAssignment_17_0 = (Assignment)cGroup_17.eContents().get(0);
		private final Keyword cStGotoKeyword_17_0_0 = (Keyword)cStAssignment_17_0.eContents().get(0);
		private final Assignment cI2Assignment_17_1 = (Assignment)cGroup_17.eContents().get(1);
		private final RuleCall cI2IdParserRuleCall_17_1_0 = (RuleCall)cI2Assignment_17_1.eContents().get(0);
		private final Assignment cStAssignment_18 = (Assignment)cAlternatives.eContents().get(18);
		private final Keyword cStNeverKeyword_18_0 = (Keyword)cStAssignment_18.eContents().get(0);
		
		/// * Substituted Rules in Xtext:
		//Flow(XX) -> Flow_AnyStatement or Flow_BalStatement
		////Flow(XX)
		////: Collection
		////| KW_If CommaItem KW_Then Binding_BalStatement KW_Else Binding(XX)
		////{ $$ = abNewIf(TPOS($1), TEST($2),$4,$6); }
		////| Collection KW_Implies Binding(XX)
		////{ $$ = abNewExit(TPOS($2), TEST($1),$3); }
		////| Iterators KW_Repeat Binding(XX)
		////{ $$ = abNewRepeatOL(TPOS($2),$3,$1); listFree(AbSyn)($1); }
		////| KW_Repeat Binding(XX)
		////{ $$ = abNewRepeat0(TPOS($1),$2); }
		////| KW_Try Binding_AnyStatement) KW_But ButExpr AlwaysPart(XX)
		////{ (void)parseDeprecated(KW_But, abNewNothing(TPOS($3))); $$ = abNewTry(TPOS($1),$2,$4->abSequence.argv[0], $4->abSequence.argv[1],$5); }
		////| KW_Try Binding_AnyStatement) KW_Catch ButExpr AlwaysPart(XX)
		////{ $$ = abNewTry(TPOS($1),$2,$4->abSequence.argv[0], $4->abSequence.argv[1],$5); }
		////| KW_Select Binding_AnyStatement) KW_In Cases
		////{ $$ = abNewSelect(TPOS($1),$2,$4); }
		////| KW_Do Binding(XX)
		////{ $$ = abNewDo(TPOS($1),$2); }
		////| KW_Delay Binding(XX)
		////{ $$ = abNewDelay(TPOS($1),$2); }
		////| KW_Reference Binding(XX)
		////{ $$ = abNewReference(TPOS($1),$2); }
		////| KW_Generate GenBound Binding(XX)
		////{ $$ = abNewGenerate(TPOS($1),$2,$3); }
		////| KW_Assert Binding(XX)
		////{ $$ = abNewAssert(TPOS($1),TEST($2)); }
		////| KW_Iterate opt(Name)
		////{ $$ = abNewIterate(TPOS($1),$2); }
		////| KW_Break opt(Name)
		////{ $$ = abNewBreak(TPOS($1),$2); }
		////| KW_Return opt(Collection)
		////{ $$ = abNewReturn(TPOS($1),$2); }
		////| KW_Yield Binding(XX)
		////{ $$ = abNewYield(TPOS($1),$2); }
		////| KW_Except Binding(XX)
		////{ $$ = parseDeprecated(KW_Except, abNewRaise(TPOS($1),$2)); }
		////| KW_Throw Binding(XX)
		////{ $$ = abNewRaise(TPOS($1),$2); }
		////| KW_Goto Id
		////{ $$ = abNewGoto(TPOS($1),$2); }
		////| KW_Never
		////{ $$ = abNewNever(TPOS($1)); }
		////;
		// * / Flow_AnyStatement hidden(WS, KW_NEWLINE):
		//	c=Collection (st="implies" bas2=Binding_AnyStatement)? // '.... for' or 'while ....'
		//	| st="if" ci=CommaItem "then" bbs=Binding_BalStatement => "else" bas=Binding_AnyStatement | // 'for .... in' or 'while ....'
		//	=> (Iterators st="repeat" bas3=Binding_AnyStatement) | st="repeat" bas=Binding_AnyStatement | st="try"
		//	bas=Binding_AnyStatement ("but" | "catch") be2=ButExpr apa=AlwaysPart_AnyStatement | st="select"
		//	bas=Binding_AnyStatement "in" ca=Cases | st="do" bas=Binding_AnyStatement | st="delay" bas=Binding_AnyStatement |
		//	st="reference" bas=Binding_AnyStatement | st="generate" gb=GenBound bas4=Binding_AnyStatement | st="assert"
		//	bas=Binding_AnyStatement | st="iterate" n=Name? | st="break" n=Name? | st="return" c=Collection? | st="yield"
		//	bas=Binding_AnyStatement | st="except" bas=Binding_AnyStatement | st="throw" bas=Binding_AnyStatement | st="goto"
		//	i2=Id | st="never";
		public ParserRule getRule() { return rule; }

		//c=Collection (st="implies" bas2=Binding_AnyStatement)? // '.... for' or 'while ....'
		//| st="if" ci=CommaItem "then" bbs=Binding_BalStatement => "else" bas=Binding_AnyStatement | // 'for .... in' or 'while ....'
		//=> (Iterators st="repeat" bas3=Binding_AnyStatement) | st="repeat" bas=Binding_AnyStatement | st="try"
		//bas=Binding_AnyStatement ("but" | "catch") be2=ButExpr apa=AlwaysPart_AnyStatement | st="select"
		//bas=Binding_AnyStatement "in" ca=Cases | st="do" bas=Binding_AnyStatement | st="delay" bas=Binding_AnyStatement |
		//st="reference" bas=Binding_AnyStatement | st="generate" gb=GenBound bas4=Binding_AnyStatement | st="assert"
		//bas=Binding_AnyStatement | st="iterate" n=Name? | st="break" n=Name? | st="return" c=Collection? | st="yield"
		//bas=Binding_AnyStatement | st="except" bas=Binding_AnyStatement | st="throw" bas=Binding_AnyStatement | st="goto" i2=Id
		//| st="never"
		public Alternatives getAlternatives() { return cAlternatives; }

		//c=Collection (st="implies" bas2=Binding_AnyStatement)?
		public Group getGroup_0() { return cGroup_0; }

		//c=Collection
		public Assignment getCAssignment_0_0() { return cCAssignment_0_0; }

		//Collection
		public RuleCall getCCollectionParserRuleCall_0_0_0() { return cCCollectionParserRuleCall_0_0_0; }

		//(st="implies" bas2=Binding_AnyStatement)?
		public Group getGroup_0_1() { return cGroup_0_1; }

		//st="implies"
		public Assignment getStAssignment_0_1_0() { return cStAssignment_0_1_0; }

		//"implies"
		public Keyword getStImpliesKeyword_0_1_0_0() { return cStImpliesKeyword_0_1_0_0; }

		//bas2=Binding_AnyStatement
		public Assignment getBas2Assignment_0_1_1() { return cBas2Assignment_0_1_1; }

		//Binding_AnyStatement
		public RuleCall getBas2Binding_AnyStatementParserRuleCall_0_1_1_0() { return cBas2Binding_AnyStatementParserRuleCall_0_1_1_0; }

		//st="if" ci=CommaItem "then" bbs=Binding_BalStatement => "else" bas=Binding_AnyStatement
		public Group getGroup_1() { return cGroup_1; }

		//st="if"
		public Assignment getStAssignment_1_0() { return cStAssignment_1_0; }

		//"if"
		public Keyword getStIfKeyword_1_0_0() { return cStIfKeyword_1_0_0; }

		//ci=CommaItem
		public Assignment getCiAssignment_1_1() { return cCiAssignment_1_1; }

		//CommaItem
		public RuleCall getCiCommaItemParserRuleCall_1_1_0() { return cCiCommaItemParserRuleCall_1_1_0; }

		//"then"
		public Keyword getThenKeyword_1_2() { return cThenKeyword_1_2; }

		//bbs=Binding_BalStatement
		public Assignment getBbsAssignment_1_3() { return cBbsAssignment_1_3; }

		//Binding_BalStatement
		public RuleCall getBbsBinding_BalStatementParserRuleCall_1_3_0() { return cBbsBinding_BalStatementParserRuleCall_1_3_0; }

		//=> "else"
		public Keyword getElseKeyword_1_4() { return cElseKeyword_1_4; }

		//bas=Binding_AnyStatement
		public Assignment getBasAssignment_1_5() { return cBasAssignment_1_5; }

		//Binding_AnyStatement
		public RuleCall getBasBinding_AnyStatementParserRuleCall_1_5_0() { return cBasBinding_AnyStatementParserRuleCall_1_5_0; }

		//// 'for .... in' or 'while ....'
		//=> (Iterators st="repeat" bas3=Binding_AnyStatement)
		public Group getGroup_2() { return cGroup_2; }

		//Iterators st="repeat" bas3=Binding_AnyStatement
		public Group getGroup_2_0() { return cGroup_2_0; }

		//Iterators
		public RuleCall getIteratorsParserRuleCall_2_0_0() { return cIteratorsParserRuleCall_2_0_0; }

		//st="repeat"
		public Assignment getStAssignment_2_0_1() { return cStAssignment_2_0_1; }

		//"repeat"
		public Keyword getStRepeatKeyword_2_0_1_0() { return cStRepeatKeyword_2_0_1_0; }

		//bas3=Binding_AnyStatement
		public Assignment getBas3Assignment_2_0_2() { return cBas3Assignment_2_0_2; }

		//Binding_AnyStatement
		public RuleCall getBas3Binding_AnyStatementParserRuleCall_2_0_2_0() { return cBas3Binding_AnyStatementParserRuleCall_2_0_2_0; }

		//st="repeat" bas=Binding_AnyStatement
		public Group getGroup_3() { return cGroup_3; }

		//st="repeat"
		public Assignment getStAssignment_3_0() { return cStAssignment_3_0; }

		//"repeat"
		public Keyword getStRepeatKeyword_3_0_0() { return cStRepeatKeyword_3_0_0; }

		//bas=Binding_AnyStatement
		public Assignment getBasAssignment_3_1() { return cBasAssignment_3_1; }

		//Binding_AnyStatement
		public RuleCall getBasBinding_AnyStatementParserRuleCall_3_1_0() { return cBasBinding_AnyStatementParserRuleCall_3_1_0; }

		//st="try" bas=Binding_AnyStatement ("but" | "catch") be2=ButExpr apa=AlwaysPart_AnyStatement
		public Group getGroup_4() { return cGroup_4; }

		//st="try"
		public Assignment getStAssignment_4_0() { return cStAssignment_4_0; }

		//"try"
		public Keyword getStTryKeyword_4_0_0() { return cStTryKeyword_4_0_0; }

		//bas=Binding_AnyStatement
		public Assignment getBasAssignment_4_1() { return cBasAssignment_4_1; }

		//Binding_AnyStatement
		public RuleCall getBasBinding_AnyStatementParserRuleCall_4_1_0() { return cBasBinding_AnyStatementParserRuleCall_4_1_0; }

		//"but" | "catch"
		public Alternatives getAlternatives_4_2() { return cAlternatives_4_2; }

		//"but"
		public Keyword getButKeyword_4_2_0() { return cButKeyword_4_2_0; }

		//"catch"
		public Keyword getCatchKeyword_4_2_1() { return cCatchKeyword_4_2_1; }

		//be2=ButExpr
		public Assignment getBe2Assignment_4_3() { return cBe2Assignment_4_3; }

		//ButExpr
		public RuleCall getBe2ButExprParserRuleCall_4_3_0() { return cBe2ButExprParserRuleCall_4_3_0; }

		//apa=AlwaysPart_AnyStatement
		public Assignment getApaAssignment_4_4() { return cApaAssignment_4_4; }

		//AlwaysPart_AnyStatement
		public RuleCall getApaAlwaysPart_AnyStatementParserRuleCall_4_4_0() { return cApaAlwaysPart_AnyStatementParserRuleCall_4_4_0; }

		//st="select" bas=Binding_AnyStatement "in" ca=Cases
		public Group getGroup_5() { return cGroup_5; }

		//st="select"
		public Assignment getStAssignment_5_0() { return cStAssignment_5_0; }

		//"select"
		public Keyword getStSelectKeyword_5_0_0() { return cStSelectKeyword_5_0_0; }

		//bas=Binding_AnyStatement
		public Assignment getBasAssignment_5_1() { return cBasAssignment_5_1; }

		//Binding_AnyStatement
		public RuleCall getBasBinding_AnyStatementParserRuleCall_5_1_0() { return cBasBinding_AnyStatementParserRuleCall_5_1_0; }

		//"in"
		public Keyword getInKeyword_5_2() { return cInKeyword_5_2; }

		//ca=Cases
		public Assignment getCaAssignment_5_3() { return cCaAssignment_5_3; }

		//Cases
		public RuleCall getCaCasesParserRuleCall_5_3_0() { return cCaCasesParserRuleCall_5_3_0; }

		//st="do" bas=Binding_AnyStatement
		public Group getGroup_6() { return cGroup_6; }

		//st="do"
		public Assignment getStAssignment_6_0() { return cStAssignment_6_0; }

		//"do"
		public Keyword getStDoKeyword_6_0_0() { return cStDoKeyword_6_0_0; }

		//bas=Binding_AnyStatement
		public Assignment getBasAssignment_6_1() { return cBasAssignment_6_1; }

		//Binding_AnyStatement
		public RuleCall getBasBinding_AnyStatementParserRuleCall_6_1_0() { return cBasBinding_AnyStatementParserRuleCall_6_1_0; }

		//st="delay" bas=Binding_AnyStatement
		public Group getGroup_7() { return cGroup_7; }

		//st="delay"
		public Assignment getStAssignment_7_0() { return cStAssignment_7_0; }

		//"delay"
		public Keyword getStDelayKeyword_7_0_0() { return cStDelayKeyword_7_0_0; }

		//bas=Binding_AnyStatement
		public Assignment getBasAssignment_7_1() { return cBasAssignment_7_1; }

		//Binding_AnyStatement
		public RuleCall getBasBinding_AnyStatementParserRuleCall_7_1_0() { return cBasBinding_AnyStatementParserRuleCall_7_1_0; }

		//st="reference" bas=Binding_AnyStatement
		public Group getGroup_8() { return cGroup_8; }

		//st="reference"
		public Assignment getStAssignment_8_0() { return cStAssignment_8_0; }

		//"reference"
		public Keyword getStReferenceKeyword_8_0_0() { return cStReferenceKeyword_8_0_0; }

		//bas=Binding_AnyStatement
		public Assignment getBasAssignment_8_1() { return cBasAssignment_8_1; }

		//Binding_AnyStatement
		public RuleCall getBasBinding_AnyStatementParserRuleCall_8_1_0() { return cBasBinding_AnyStatementParserRuleCall_8_1_0; }

		//st="generate" gb=GenBound bas4=Binding_AnyStatement
		public Group getGroup_9() { return cGroup_9; }

		//st="generate"
		public Assignment getStAssignment_9_0() { return cStAssignment_9_0; }

		//"generate"
		public Keyword getStGenerateKeyword_9_0_0() { return cStGenerateKeyword_9_0_0; }

		//gb=GenBound
		public Assignment getGbAssignment_9_1() { return cGbAssignment_9_1; }

		//GenBound
		public RuleCall getGbGenBoundParserRuleCall_9_1_0() { return cGbGenBoundParserRuleCall_9_1_0; }

		//bas4=Binding_AnyStatement
		public Assignment getBas4Assignment_9_2() { return cBas4Assignment_9_2; }

		//Binding_AnyStatement
		public RuleCall getBas4Binding_AnyStatementParserRuleCall_9_2_0() { return cBas4Binding_AnyStatementParserRuleCall_9_2_0; }

		//st="assert" bas=Binding_AnyStatement
		public Group getGroup_10() { return cGroup_10; }

		//st="assert"
		public Assignment getStAssignment_10_0() { return cStAssignment_10_0; }

		//"assert"
		public Keyword getStAssertKeyword_10_0_0() { return cStAssertKeyword_10_0_0; }

		//bas=Binding_AnyStatement
		public Assignment getBasAssignment_10_1() { return cBasAssignment_10_1; }

		//Binding_AnyStatement
		public RuleCall getBasBinding_AnyStatementParserRuleCall_10_1_0() { return cBasBinding_AnyStatementParserRuleCall_10_1_0; }

		//st="iterate" n=Name?
		public Group getGroup_11() { return cGroup_11; }

		//st="iterate"
		public Assignment getStAssignment_11_0() { return cStAssignment_11_0; }

		//"iterate"
		public Keyword getStIterateKeyword_11_0_0() { return cStIterateKeyword_11_0_0; }

		//n=Name?
		public Assignment getNAssignment_11_1() { return cNAssignment_11_1; }

		//Name
		public RuleCall getNNameParserRuleCall_11_1_0() { return cNNameParserRuleCall_11_1_0; }

		//st="break" n=Name?
		public Group getGroup_12() { return cGroup_12; }

		//st="break"
		public Assignment getStAssignment_12_0() { return cStAssignment_12_0; }

		//"break"
		public Keyword getStBreakKeyword_12_0_0() { return cStBreakKeyword_12_0_0; }

		//n=Name?
		public Assignment getNAssignment_12_1() { return cNAssignment_12_1; }

		//Name
		public RuleCall getNNameParserRuleCall_12_1_0() { return cNNameParserRuleCall_12_1_0; }

		//st="return" c=Collection?
		public Group getGroup_13() { return cGroup_13; }

		//st="return"
		public Assignment getStAssignment_13_0() { return cStAssignment_13_0; }

		//"return"
		public Keyword getStReturnKeyword_13_0_0() { return cStReturnKeyword_13_0_0; }

		//c=Collection?
		public Assignment getCAssignment_13_1() { return cCAssignment_13_1; }

		//Collection
		public RuleCall getCCollectionParserRuleCall_13_1_0() { return cCCollectionParserRuleCall_13_1_0; }

		//st="yield" bas=Binding_AnyStatement
		public Group getGroup_14() { return cGroup_14; }

		//st="yield"
		public Assignment getStAssignment_14_0() { return cStAssignment_14_0; }

		//"yield"
		public Keyword getStYieldKeyword_14_0_0() { return cStYieldKeyword_14_0_0; }

		//bas=Binding_AnyStatement
		public Assignment getBasAssignment_14_1() { return cBasAssignment_14_1; }

		//Binding_AnyStatement
		public RuleCall getBasBinding_AnyStatementParserRuleCall_14_1_0() { return cBasBinding_AnyStatementParserRuleCall_14_1_0; }

		//st="except" bas=Binding_AnyStatement
		public Group getGroup_15() { return cGroup_15; }

		//st="except"
		public Assignment getStAssignment_15_0() { return cStAssignment_15_0; }

		//"except"
		public Keyword getStExceptKeyword_15_0_0() { return cStExceptKeyword_15_0_0; }

		//bas=Binding_AnyStatement
		public Assignment getBasAssignment_15_1() { return cBasAssignment_15_1; }

		//Binding_AnyStatement
		public RuleCall getBasBinding_AnyStatementParserRuleCall_15_1_0() { return cBasBinding_AnyStatementParserRuleCall_15_1_0; }

		//st="throw" bas=Binding_AnyStatement
		public Group getGroup_16() { return cGroup_16; }

		//st="throw"
		public Assignment getStAssignment_16_0() { return cStAssignment_16_0; }

		//"throw"
		public Keyword getStThrowKeyword_16_0_0() { return cStThrowKeyword_16_0_0; }

		//bas=Binding_AnyStatement
		public Assignment getBasAssignment_16_1() { return cBasAssignment_16_1; }

		//Binding_AnyStatement
		public RuleCall getBasBinding_AnyStatementParserRuleCall_16_1_0() { return cBasBinding_AnyStatementParserRuleCall_16_1_0; }

		//st="goto" i2=Id
		public Group getGroup_17() { return cGroup_17; }

		//st="goto"
		public Assignment getStAssignment_17_0() { return cStAssignment_17_0; }

		//"goto"
		public Keyword getStGotoKeyword_17_0_0() { return cStGotoKeyword_17_0_0; }

		//i2=Id
		public Assignment getI2Assignment_17_1() { return cI2Assignment_17_1; }

		//Id
		public RuleCall getI2IdParserRuleCall_17_1_0() { return cI2IdParserRuleCall_17_1_0; }

		//st="never"
		public Assignment getStAssignment_18() { return cStAssignment_18; }

		//"never"
		public Keyword getStNeverKeyword_18_0() { return cStNeverKeyword_18_0; }
	}

	public class Flow_BalStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Flow_BalStatement");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Assignment cC2Assignment_0_0 = (Assignment)cGroup_0.eContents().get(0);
		private final RuleCall cC2CollectionParserRuleCall_0_0_0 = (RuleCall)cC2Assignment_0_0.eContents().get(0);
		private final Group cGroup_0_1 = (Group)cGroup_0.eContents().get(1);
		private final Assignment cSt2Assignment_0_1_0 = (Assignment)cGroup_0_1.eContents().get(0);
		private final Keyword cSt2ImpliesKeyword_0_1_0_0 = (Keyword)cSt2Assignment_0_1_0.eContents().get(0);
		private final Assignment cBbs3Assignment_0_1_1 = (Assignment)cGroup_0_1.eContents().get(1);
		private final RuleCall cBbs3Binding_BalStatementParserRuleCall_0_1_1_0 = (RuleCall)cBbs3Assignment_0_1_1.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Assignment cSt2Assignment_1_0 = (Assignment)cGroup_1.eContents().get(0);
		private final Keyword cSt2IfKeyword_1_0_0 = (Keyword)cSt2Assignment_1_0.eContents().get(0);
		private final Assignment cCi2Assignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cCi2CommaItemParserRuleCall_1_1_0 = (RuleCall)cCi2Assignment_1_1.eContents().get(0);
		private final Keyword cThenKeyword_1_2 = (Keyword)cGroup_1.eContents().get(2);
		private final Assignment cBbs4Assignment_1_3 = (Assignment)cGroup_1.eContents().get(3);
		private final RuleCall cBbs4Binding_BalStatementParserRuleCall_1_3_0 = (RuleCall)cBbs4Assignment_1_3.eContents().get(0);
		private final Keyword cElseKeyword_1_4 = (Keyword)cGroup_1.eContents().get(4);
		private final Assignment cBbs4Assignment_1_5 = (Assignment)cGroup_1.eContents().get(5);
		private final RuleCall cBbs4Binding_BalStatementParserRuleCall_1_5_0 = (RuleCall)cBbs4Assignment_1_5.eContents().get(0);
		private final Group cGroup_2 = (Group)cAlternatives.eContents().get(2);
		private final Group cGroup_2_0 = (Group)cGroup_2.eContents().get(0);
		private final RuleCall cIteratorsParserRuleCall_2_0_0 = (RuleCall)cGroup_2_0.eContents().get(0);
		private final Assignment cSt2Assignment_2_0_1 = (Assignment)cGroup_2_0.eContents().get(1);
		private final Keyword cSt2RepeatKeyword_2_0_1_0 = (Keyword)cSt2Assignment_2_0_1.eContents().get(0);
		private final Assignment cBbs3Assignment_2_0_2 = (Assignment)cGroup_2_0.eContents().get(2);
		private final RuleCall cBbs3Binding_BalStatementParserRuleCall_2_0_2_0 = (RuleCall)cBbs3Assignment_2_0_2.eContents().get(0);
		private final Group cGroup_3 = (Group)cAlternatives.eContents().get(3);
		private final Assignment cSt2Assignment_3_0 = (Assignment)cGroup_3.eContents().get(0);
		private final Keyword cSt2RepeatKeyword_3_0_0 = (Keyword)cSt2Assignment_3_0.eContents().get(0);
		private final Assignment cBbs5Assignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final RuleCall cBbs5Binding_BalStatementParserRuleCall_3_1_0 = (RuleCall)cBbs5Assignment_3_1.eContents().get(0);
		private final Group cGroup_4 = (Group)cAlternatives.eContents().get(4);
		private final Assignment cSt2Assignment_4_0 = (Assignment)cGroup_4.eContents().get(0);
		private final Keyword cSt2TryKeyword_4_0_0 = (Keyword)cSt2Assignment_4_0.eContents().get(0);
		private final Assignment cBbs2Assignment_4_1 = (Assignment)cGroup_4.eContents().get(1);
		private final RuleCall cBbs2Binding_AnyStatementParserRuleCall_4_1_0 = (RuleCall)cBbs2Assignment_4_1.eContents().get(0);
		private final Alternatives cAlternatives_4_2 = (Alternatives)cGroup_4.eContents().get(2);
		private final Keyword cButKeyword_4_2_0 = (Keyword)cAlternatives_4_2.eContents().get(0);
		private final Keyword cCatchKeyword_4_2_1 = (Keyword)cAlternatives_4_2.eContents().get(1);
		private final Assignment cBeAssignment_4_3 = (Assignment)cGroup_4.eContents().get(3);
		private final RuleCall cBeButExprParserRuleCall_4_3_0 = (RuleCall)cBeAssignment_4_3.eContents().get(0);
		private final Assignment cApbAssignment_4_4 = (Assignment)cGroup_4.eContents().get(4);
		private final RuleCall cApbAlwaysPart_BalStatementParserRuleCall_4_4_0 = (RuleCall)cApbAssignment_4_4.eContents().get(0);
		private final Group cGroup_5 = (Group)cAlternatives.eContents().get(5);
		private final Assignment cSt2Assignment_5_0 = (Assignment)cGroup_5.eContents().get(0);
		private final Keyword cSt2SelectKeyword_5_0_0 = (Keyword)cSt2Assignment_5_0.eContents().get(0);
		private final Assignment cBbs2Assignment_5_1 = (Assignment)cGroup_5.eContents().get(1);
		private final RuleCall cBbs2Binding_AnyStatementParserRuleCall_5_1_0 = (RuleCall)cBbs2Assignment_5_1.eContents().get(0);
		private final Keyword cInKeyword_5_2 = (Keyword)cGroup_5.eContents().get(2);
		private final Assignment cCa2Assignment_5_3 = (Assignment)cGroup_5.eContents().get(3);
		private final RuleCall cCa2CasesParserRuleCall_5_3_0 = (RuleCall)cCa2Assignment_5_3.eContents().get(0);
		private final Group cGroup_6 = (Group)cAlternatives.eContents().get(6);
		private final Assignment cSt2Assignment_6_0 = (Assignment)cGroup_6.eContents().get(0);
		private final Keyword cSt2DoKeyword_6_0_0 = (Keyword)cSt2Assignment_6_0.eContents().get(0);
		private final Assignment cBbs5Assignment_6_1 = (Assignment)cGroup_6.eContents().get(1);
		private final RuleCall cBbs5Binding_BalStatementParserRuleCall_6_1_0 = (RuleCall)cBbs5Assignment_6_1.eContents().get(0);
		private final Group cGroup_7 = (Group)cAlternatives.eContents().get(7);
		private final Assignment cSt2Assignment_7_0 = (Assignment)cGroup_7.eContents().get(0);
		private final Keyword cSt2DelayKeyword_7_0_0 = (Keyword)cSt2Assignment_7_0.eContents().get(0);
		private final Assignment cBbs5Assignment_7_1 = (Assignment)cGroup_7.eContents().get(1);
		private final RuleCall cBbs5Binding_BalStatementParserRuleCall_7_1_0 = (RuleCall)cBbs5Assignment_7_1.eContents().get(0);
		private final Group cGroup_8 = (Group)cAlternatives.eContents().get(8);
		private final Assignment cSt2Assignment_8_0 = (Assignment)cGroup_8.eContents().get(0);
		private final Keyword cSt2ReferenceKeyword_8_0_0 = (Keyword)cSt2Assignment_8_0.eContents().get(0);
		private final Assignment cBbs5Assignment_8_1 = (Assignment)cGroup_8.eContents().get(1);
		private final RuleCall cBbs5Binding_BalStatementParserRuleCall_8_1_0 = (RuleCall)cBbs5Assignment_8_1.eContents().get(0);
		private final Group cGroup_9 = (Group)cAlternatives.eContents().get(9);
		private final Assignment cSt2Assignment_9_0 = (Assignment)cGroup_9.eContents().get(0);
		private final Keyword cSt2GenerateKeyword_9_0_0 = (Keyword)cSt2Assignment_9_0.eContents().get(0);
		private final Assignment cGb2Assignment_9_1 = (Assignment)cGroup_9.eContents().get(1);
		private final RuleCall cGb2GenBoundParserRuleCall_9_1_0 = (RuleCall)cGb2Assignment_9_1.eContents().get(0);
		private final Assignment cBbs5Assignment_9_2 = (Assignment)cGroup_9.eContents().get(2);
		private final RuleCall cBbs5Binding_BalStatementParserRuleCall_9_2_0 = (RuleCall)cBbs5Assignment_9_2.eContents().get(0);
		private final Group cGroup_10 = (Group)cAlternatives.eContents().get(10);
		private final Assignment cSt2Assignment_10_0 = (Assignment)cGroup_10.eContents().get(0);
		private final Keyword cSt2AssertKeyword_10_0_0 = (Keyword)cSt2Assignment_10_0.eContents().get(0);
		private final Assignment cBbs5Assignment_10_1 = (Assignment)cGroup_10.eContents().get(1);
		private final RuleCall cBbs5Binding_BalStatementParserRuleCall_10_1_0 = (RuleCall)cBbs5Assignment_10_1.eContents().get(0);
		private final Group cGroup_11 = (Group)cAlternatives.eContents().get(11);
		private final Assignment cSt2Assignment_11_0 = (Assignment)cGroup_11.eContents().get(0);
		private final Keyword cSt2IterateKeyword_11_0_0 = (Keyword)cSt2Assignment_11_0.eContents().get(0);
		private final Assignment cN2Assignment_11_1 = (Assignment)cGroup_11.eContents().get(1);
		private final RuleCall cN2NameParserRuleCall_11_1_0 = (RuleCall)cN2Assignment_11_1.eContents().get(0);
		private final Group cGroup_12 = (Group)cAlternatives.eContents().get(12);
		private final Assignment cSt2Assignment_12_0 = (Assignment)cGroup_12.eContents().get(0);
		private final Keyword cSt2BreakKeyword_12_0_0 = (Keyword)cSt2Assignment_12_0.eContents().get(0);
		private final Assignment cN2Assignment_12_1 = (Assignment)cGroup_12.eContents().get(1);
		private final RuleCall cN2NameParserRuleCall_12_1_0 = (RuleCall)cN2Assignment_12_1.eContents().get(0);
		private final Group cGroup_13 = (Group)cAlternatives.eContents().get(13);
		private final Assignment cSt2Assignment_13_0 = (Assignment)cGroup_13.eContents().get(0);
		private final Keyword cSt2ReturnKeyword_13_0_0 = (Keyword)cSt2Assignment_13_0.eContents().get(0);
		private final Assignment cC2Assignment_13_1 = (Assignment)cGroup_13.eContents().get(1);
		private final RuleCall cC2CollectionParserRuleCall_13_1_0 = (RuleCall)cC2Assignment_13_1.eContents().get(0);
		private final Group cGroup_14 = (Group)cAlternatives.eContents().get(14);
		private final Assignment cSt2Assignment_14_0 = (Assignment)cGroup_14.eContents().get(0);
		private final Keyword cSt2YieldKeyword_14_0_0 = (Keyword)cSt2Assignment_14_0.eContents().get(0);
		private final Assignment cBbs5Assignment_14_1 = (Assignment)cGroup_14.eContents().get(1);
		private final RuleCall cBbs5Binding_BalStatementParserRuleCall_14_1_0 = (RuleCall)cBbs5Assignment_14_1.eContents().get(0);
		private final Group cGroup_15 = (Group)cAlternatives.eContents().get(15);
		private final Assignment cSt2Assignment_15_0 = (Assignment)cGroup_15.eContents().get(0);
		private final Keyword cSt2ExceptKeyword_15_0_0 = (Keyword)cSt2Assignment_15_0.eContents().get(0);
		private final Assignment cBbs5Assignment_15_1 = (Assignment)cGroup_15.eContents().get(1);
		private final RuleCall cBbs5Binding_BalStatementParserRuleCall_15_1_0 = (RuleCall)cBbs5Assignment_15_1.eContents().get(0);
		private final Group cGroup_16 = (Group)cAlternatives.eContents().get(16);
		private final Assignment cSt2Assignment_16_0 = (Assignment)cGroup_16.eContents().get(0);
		private final Keyword cSt2ThrowKeyword_16_0_0 = (Keyword)cSt2Assignment_16_0.eContents().get(0);
		private final Assignment cBbs5Assignment_16_1 = (Assignment)cGroup_16.eContents().get(1);
		private final RuleCall cBbs5Binding_BalStatementParserRuleCall_16_1_0 = (RuleCall)cBbs5Assignment_16_1.eContents().get(0);
		private final Group cGroup_17 = (Group)cAlternatives.eContents().get(17);
		private final Assignment cSt2Assignment_17_0 = (Assignment)cGroup_17.eContents().get(0);
		private final Keyword cSt2GotoKeyword_17_0_0 = (Keyword)cSt2Assignment_17_0.eContents().get(0);
		private final Assignment cI3Assignment_17_1 = (Assignment)cGroup_17.eContents().get(1);
		private final RuleCall cI3IdParserRuleCall_17_1_0 = (RuleCall)cI3Assignment_17_1.eContents().get(0);
		private final Assignment cSt2Assignment_18 = (Assignment)cAlternatives.eContents().get(18);
		private final Keyword cSt2NeverKeyword_18_0 = (Keyword)cSt2Assignment_18.eContents().get(0);
		
		/// *  * / Flow_BalStatement hidden(WS, KW_NEWLINE):
		//	c2=Collection (st2="implies" bbs3=Binding_BalStatement)? // '.... for' or 'while ....'
		//	| st2="if" ci2=CommaItem "then" bbs4+=Binding_BalStatement => "else" bbs4+=Binding_BalStatement | // 'for .... in' or 'while ....'
		//	=> (Iterators st2="repeat" bbs3=Binding_BalStatement) | st2="repeat" bbs5=Binding_BalStatement | st2="try"
		//	bbs2=Binding_AnyStatement ("but" | "catch") be=ButExpr apb=AlwaysPart_BalStatement | st2="select"
		//	bbs2=Binding_AnyStatement "in" ca2=Cases | st2="do" bbs5=Binding_BalStatement | st2="delay" bbs5=Binding_BalStatement
		//	| st2="reference" bbs5=Binding_BalStatement | st2="generate" gb2=GenBound bbs5=Binding_BalStatement | st2="assert"
		//	bbs5=Binding_BalStatement | st2="iterate" n2=Name? | st2="break" n2=Name? | st2="return" c2=Collection? | st2="yield"
		//	bbs5=Binding_BalStatement | st2="except" bbs5=Binding_BalStatement | st2="throw" bbs5=Binding_BalStatement |
		//	st2="goto" i3=Id | st2="never";
		public ParserRule getRule() { return rule; }

		//c2=Collection (st2="implies" bbs3=Binding_BalStatement)? // '.... for' or 'while ....'
		//| st2="if" ci2=CommaItem "then" bbs4+=Binding_BalStatement => "else" bbs4+=Binding_BalStatement | // 'for .... in' or 'while ....'
		//=> (Iterators st2="repeat" bbs3=Binding_BalStatement) | st2="repeat" bbs5=Binding_BalStatement | st2="try"
		//bbs2=Binding_AnyStatement ("but" | "catch") be=ButExpr apb=AlwaysPart_BalStatement | st2="select"
		//bbs2=Binding_AnyStatement "in" ca2=Cases | st2="do" bbs5=Binding_BalStatement | st2="delay" bbs5=Binding_BalStatement |
		//st2="reference" bbs5=Binding_BalStatement | st2="generate" gb2=GenBound bbs5=Binding_BalStatement | st2="assert"
		//bbs5=Binding_BalStatement | st2="iterate" n2=Name? | st2="break" n2=Name? | st2="return" c2=Collection? | st2="yield"
		//bbs5=Binding_BalStatement | st2="except" bbs5=Binding_BalStatement | st2="throw" bbs5=Binding_BalStatement | st2="goto"
		//i3=Id | st2="never"
		public Alternatives getAlternatives() { return cAlternatives; }

		//c2=Collection (st2="implies" bbs3=Binding_BalStatement)?
		public Group getGroup_0() { return cGroup_0; }

		//c2=Collection
		public Assignment getC2Assignment_0_0() { return cC2Assignment_0_0; }

		//Collection
		public RuleCall getC2CollectionParserRuleCall_0_0_0() { return cC2CollectionParserRuleCall_0_0_0; }

		//(st2="implies" bbs3=Binding_BalStatement)?
		public Group getGroup_0_1() { return cGroup_0_1; }

		//st2="implies"
		public Assignment getSt2Assignment_0_1_0() { return cSt2Assignment_0_1_0; }

		//"implies"
		public Keyword getSt2ImpliesKeyword_0_1_0_0() { return cSt2ImpliesKeyword_0_1_0_0; }

		//bbs3=Binding_BalStatement
		public Assignment getBbs3Assignment_0_1_1() { return cBbs3Assignment_0_1_1; }

		//Binding_BalStatement
		public RuleCall getBbs3Binding_BalStatementParserRuleCall_0_1_1_0() { return cBbs3Binding_BalStatementParserRuleCall_0_1_1_0; }

		//st2="if" ci2=CommaItem "then" bbs4+=Binding_BalStatement => "else" bbs4+=Binding_BalStatement
		public Group getGroup_1() { return cGroup_1; }

		//st2="if"
		public Assignment getSt2Assignment_1_0() { return cSt2Assignment_1_0; }

		//"if"
		public Keyword getSt2IfKeyword_1_0_0() { return cSt2IfKeyword_1_0_0; }

		//ci2=CommaItem
		public Assignment getCi2Assignment_1_1() { return cCi2Assignment_1_1; }

		//CommaItem
		public RuleCall getCi2CommaItemParserRuleCall_1_1_0() { return cCi2CommaItemParserRuleCall_1_1_0; }

		//"then"
		public Keyword getThenKeyword_1_2() { return cThenKeyword_1_2; }

		//bbs4+=Binding_BalStatement
		public Assignment getBbs4Assignment_1_3() { return cBbs4Assignment_1_3; }

		//Binding_BalStatement
		public RuleCall getBbs4Binding_BalStatementParserRuleCall_1_3_0() { return cBbs4Binding_BalStatementParserRuleCall_1_3_0; }

		//=> "else"
		public Keyword getElseKeyword_1_4() { return cElseKeyword_1_4; }

		//bbs4+=Binding_BalStatement
		public Assignment getBbs4Assignment_1_5() { return cBbs4Assignment_1_5; }

		//Binding_BalStatement
		public RuleCall getBbs4Binding_BalStatementParserRuleCall_1_5_0() { return cBbs4Binding_BalStatementParserRuleCall_1_5_0; }

		//// 'for .... in' or 'while ....'
		//=> (Iterators st2="repeat" bbs3=Binding_BalStatement)
		public Group getGroup_2() { return cGroup_2; }

		//Iterators st2="repeat" bbs3=Binding_BalStatement
		public Group getGroup_2_0() { return cGroup_2_0; }

		//Iterators
		public RuleCall getIteratorsParserRuleCall_2_0_0() { return cIteratorsParserRuleCall_2_0_0; }

		//st2="repeat"
		public Assignment getSt2Assignment_2_0_1() { return cSt2Assignment_2_0_1; }

		//"repeat"
		public Keyword getSt2RepeatKeyword_2_0_1_0() { return cSt2RepeatKeyword_2_0_1_0; }

		//bbs3=Binding_BalStatement
		public Assignment getBbs3Assignment_2_0_2() { return cBbs3Assignment_2_0_2; }

		//Binding_BalStatement
		public RuleCall getBbs3Binding_BalStatementParserRuleCall_2_0_2_0() { return cBbs3Binding_BalStatementParserRuleCall_2_0_2_0; }

		//st2="repeat" bbs5=Binding_BalStatement
		public Group getGroup_3() { return cGroup_3; }

		//st2="repeat"
		public Assignment getSt2Assignment_3_0() { return cSt2Assignment_3_0; }

		//"repeat"
		public Keyword getSt2RepeatKeyword_3_0_0() { return cSt2RepeatKeyword_3_0_0; }

		//bbs5=Binding_BalStatement
		public Assignment getBbs5Assignment_3_1() { return cBbs5Assignment_3_1; }

		//Binding_BalStatement
		public RuleCall getBbs5Binding_BalStatementParserRuleCall_3_1_0() { return cBbs5Binding_BalStatementParserRuleCall_3_1_0; }

		//st2="try" bbs2=Binding_AnyStatement ("but" | "catch") be=ButExpr apb=AlwaysPart_BalStatement
		public Group getGroup_4() { return cGroup_4; }

		//st2="try"
		public Assignment getSt2Assignment_4_0() { return cSt2Assignment_4_0; }

		//"try"
		public Keyword getSt2TryKeyword_4_0_0() { return cSt2TryKeyword_4_0_0; }

		//bbs2=Binding_AnyStatement
		public Assignment getBbs2Assignment_4_1() { return cBbs2Assignment_4_1; }

		//Binding_AnyStatement
		public RuleCall getBbs2Binding_AnyStatementParserRuleCall_4_1_0() { return cBbs2Binding_AnyStatementParserRuleCall_4_1_0; }

		//"but" | "catch"
		public Alternatives getAlternatives_4_2() { return cAlternatives_4_2; }

		//"but"
		public Keyword getButKeyword_4_2_0() { return cButKeyword_4_2_0; }

		//"catch"
		public Keyword getCatchKeyword_4_2_1() { return cCatchKeyword_4_2_1; }

		//be=ButExpr
		public Assignment getBeAssignment_4_3() { return cBeAssignment_4_3; }

		//ButExpr
		public RuleCall getBeButExprParserRuleCall_4_3_0() { return cBeButExprParserRuleCall_4_3_0; }

		//apb=AlwaysPart_BalStatement
		public Assignment getApbAssignment_4_4() { return cApbAssignment_4_4; }

		//AlwaysPart_BalStatement
		public RuleCall getApbAlwaysPart_BalStatementParserRuleCall_4_4_0() { return cApbAlwaysPart_BalStatementParserRuleCall_4_4_0; }

		//st2="select" bbs2=Binding_AnyStatement "in" ca2=Cases
		public Group getGroup_5() { return cGroup_5; }

		//st2="select"
		public Assignment getSt2Assignment_5_0() { return cSt2Assignment_5_0; }

		//"select"
		public Keyword getSt2SelectKeyword_5_0_0() { return cSt2SelectKeyword_5_0_0; }

		//bbs2=Binding_AnyStatement
		public Assignment getBbs2Assignment_5_1() { return cBbs2Assignment_5_1; }

		//Binding_AnyStatement
		public RuleCall getBbs2Binding_AnyStatementParserRuleCall_5_1_0() { return cBbs2Binding_AnyStatementParserRuleCall_5_1_0; }

		//"in"
		public Keyword getInKeyword_5_2() { return cInKeyword_5_2; }

		//ca2=Cases
		public Assignment getCa2Assignment_5_3() { return cCa2Assignment_5_3; }

		//Cases
		public RuleCall getCa2CasesParserRuleCall_5_3_0() { return cCa2CasesParserRuleCall_5_3_0; }

		//st2="do" bbs5=Binding_BalStatement
		public Group getGroup_6() { return cGroup_6; }

		//st2="do"
		public Assignment getSt2Assignment_6_0() { return cSt2Assignment_6_0; }

		//"do"
		public Keyword getSt2DoKeyword_6_0_0() { return cSt2DoKeyword_6_0_0; }

		//bbs5=Binding_BalStatement
		public Assignment getBbs5Assignment_6_1() { return cBbs5Assignment_6_1; }

		//Binding_BalStatement
		public RuleCall getBbs5Binding_BalStatementParserRuleCall_6_1_0() { return cBbs5Binding_BalStatementParserRuleCall_6_1_0; }

		//st2="delay" bbs5=Binding_BalStatement
		public Group getGroup_7() { return cGroup_7; }

		//st2="delay"
		public Assignment getSt2Assignment_7_0() { return cSt2Assignment_7_0; }

		//"delay"
		public Keyword getSt2DelayKeyword_7_0_0() { return cSt2DelayKeyword_7_0_0; }

		//bbs5=Binding_BalStatement
		public Assignment getBbs5Assignment_7_1() { return cBbs5Assignment_7_1; }

		//Binding_BalStatement
		public RuleCall getBbs5Binding_BalStatementParserRuleCall_7_1_0() { return cBbs5Binding_BalStatementParserRuleCall_7_1_0; }

		//st2="reference" bbs5=Binding_BalStatement
		public Group getGroup_8() { return cGroup_8; }

		//st2="reference"
		public Assignment getSt2Assignment_8_0() { return cSt2Assignment_8_0; }

		//"reference"
		public Keyword getSt2ReferenceKeyword_8_0_0() { return cSt2ReferenceKeyword_8_0_0; }

		//bbs5=Binding_BalStatement
		public Assignment getBbs5Assignment_8_1() { return cBbs5Assignment_8_1; }

		//Binding_BalStatement
		public RuleCall getBbs5Binding_BalStatementParserRuleCall_8_1_0() { return cBbs5Binding_BalStatementParserRuleCall_8_1_0; }

		//st2="generate" gb2=GenBound bbs5=Binding_BalStatement
		public Group getGroup_9() { return cGroup_9; }

		//st2="generate"
		public Assignment getSt2Assignment_9_0() { return cSt2Assignment_9_0; }

		//"generate"
		public Keyword getSt2GenerateKeyword_9_0_0() { return cSt2GenerateKeyword_9_0_0; }

		//gb2=GenBound
		public Assignment getGb2Assignment_9_1() { return cGb2Assignment_9_1; }

		//GenBound
		public RuleCall getGb2GenBoundParserRuleCall_9_1_0() { return cGb2GenBoundParserRuleCall_9_1_0; }

		//bbs5=Binding_BalStatement
		public Assignment getBbs5Assignment_9_2() { return cBbs5Assignment_9_2; }

		//Binding_BalStatement
		public RuleCall getBbs5Binding_BalStatementParserRuleCall_9_2_0() { return cBbs5Binding_BalStatementParserRuleCall_9_2_0; }

		//st2="assert" bbs5=Binding_BalStatement
		public Group getGroup_10() { return cGroup_10; }

		//st2="assert"
		public Assignment getSt2Assignment_10_0() { return cSt2Assignment_10_0; }

		//"assert"
		public Keyword getSt2AssertKeyword_10_0_0() { return cSt2AssertKeyword_10_0_0; }

		//bbs5=Binding_BalStatement
		public Assignment getBbs5Assignment_10_1() { return cBbs5Assignment_10_1; }

		//Binding_BalStatement
		public RuleCall getBbs5Binding_BalStatementParserRuleCall_10_1_0() { return cBbs5Binding_BalStatementParserRuleCall_10_1_0; }

		//st2="iterate" n2=Name?
		public Group getGroup_11() { return cGroup_11; }

		//st2="iterate"
		public Assignment getSt2Assignment_11_0() { return cSt2Assignment_11_0; }

		//"iterate"
		public Keyword getSt2IterateKeyword_11_0_0() { return cSt2IterateKeyword_11_0_0; }

		//n2=Name?
		public Assignment getN2Assignment_11_1() { return cN2Assignment_11_1; }

		//Name
		public RuleCall getN2NameParserRuleCall_11_1_0() { return cN2NameParserRuleCall_11_1_0; }

		//st2="break" n2=Name?
		public Group getGroup_12() { return cGroup_12; }

		//st2="break"
		public Assignment getSt2Assignment_12_0() { return cSt2Assignment_12_0; }

		//"break"
		public Keyword getSt2BreakKeyword_12_0_0() { return cSt2BreakKeyword_12_0_0; }

		//n2=Name?
		public Assignment getN2Assignment_12_1() { return cN2Assignment_12_1; }

		//Name
		public RuleCall getN2NameParserRuleCall_12_1_0() { return cN2NameParserRuleCall_12_1_0; }

		//st2="return" c2=Collection?
		public Group getGroup_13() { return cGroup_13; }

		//st2="return"
		public Assignment getSt2Assignment_13_0() { return cSt2Assignment_13_0; }

		//"return"
		public Keyword getSt2ReturnKeyword_13_0_0() { return cSt2ReturnKeyword_13_0_0; }

		//c2=Collection?
		public Assignment getC2Assignment_13_1() { return cC2Assignment_13_1; }

		//Collection
		public RuleCall getC2CollectionParserRuleCall_13_1_0() { return cC2CollectionParserRuleCall_13_1_0; }

		//st2="yield" bbs5=Binding_BalStatement
		public Group getGroup_14() { return cGroup_14; }

		//st2="yield"
		public Assignment getSt2Assignment_14_0() { return cSt2Assignment_14_0; }

		//"yield"
		public Keyword getSt2YieldKeyword_14_0_0() { return cSt2YieldKeyword_14_0_0; }

		//bbs5=Binding_BalStatement
		public Assignment getBbs5Assignment_14_1() { return cBbs5Assignment_14_1; }

		//Binding_BalStatement
		public RuleCall getBbs5Binding_BalStatementParserRuleCall_14_1_0() { return cBbs5Binding_BalStatementParserRuleCall_14_1_0; }

		//st2="except" bbs5=Binding_BalStatement
		public Group getGroup_15() { return cGroup_15; }

		//st2="except"
		public Assignment getSt2Assignment_15_0() { return cSt2Assignment_15_0; }

		//"except"
		public Keyword getSt2ExceptKeyword_15_0_0() { return cSt2ExceptKeyword_15_0_0; }

		//bbs5=Binding_BalStatement
		public Assignment getBbs5Assignment_15_1() { return cBbs5Assignment_15_1; }

		//Binding_BalStatement
		public RuleCall getBbs5Binding_BalStatementParserRuleCall_15_1_0() { return cBbs5Binding_BalStatementParserRuleCall_15_1_0; }

		//st2="throw" bbs5=Binding_BalStatement
		public Group getGroup_16() { return cGroup_16; }

		//st2="throw"
		public Assignment getSt2Assignment_16_0() { return cSt2Assignment_16_0; }

		//"throw"
		public Keyword getSt2ThrowKeyword_16_0_0() { return cSt2ThrowKeyword_16_0_0; }

		//bbs5=Binding_BalStatement
		public Assignment getBbs5Assignment_16_1() { return cBbs5Assignment_16_1; }

		//Binding_BalStatement
		public RuleCall getBbs5Binding_BalStatementParserRuleCall_16_1_0() { return cBbs5Binding_BalStatementParserRuleCall_16_1_0; }

		//st2="goto" i3=Id
		public Group getGroup_17() { return cGroup_17; }

		//st2="goto"
		public Assignment getSt2Assignment_17_0() { return cSt2Assignment_17_0; }

		//"goto"
		public Keyword getSt2GotoKeyword_17_0_0() { return cSt2GotoKeyword_17_0_0; }

		//i3=Id
		public Assignment getI3Assignment_17_1() { return cI3Assignment_17_1; }

		//Id
		public RuleCall getI3IdParserRuleCall_17_1_0() { return cI3IdParserRuleCall_17_1_0; }

		//st2="never"
		public Assignment getSt2Assignment_18() { return cSt2Assignment_18; }

		//"never"
		public Keyword getSt2NeverKeyword_18_0() { return cSt2NeverKeyword_18_0; }
	}

	public class GenBoundElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "GenBound");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cGenBoundAction_0 = (Action)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cToKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cCiAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cCiCommaItemParserRuleCall_1_1_0 = (RuleCall)cCiAssignment_1_1.eContents().get(0);
		private final Keyword cOfKeyword_1_2 = (Keyword)cGroup_1.eContents().get(2);
		
		//GenBound hidden(WS, KW_NEWLINE):
		//	{GenBound} ("to" ci=CommaItem "of")?;
		public ParserRule getRule() { return rule; }

		//{GenBound} ("to" ci=CommaItem "of")?
		public Group getGroup() { return cGroup; }

		//{GenBound}
		public Action getGenBoundAction_0() { return cGenBoundAction_0; }

		//("to" ci=CommaItem "of")?
		public Group getGroup_1() { return cGroup_1; }

		//"to"
		public Keyword getToKeyword_1_0() { return cToKeyword_1_0; }

		//ci=CommaItem
		public Assignment getCiAssignment_1_1() { return cCiAssignment_1_1; }

		//CommaItem
		public RuleCall getCiCommaItemParserRuleCall_1_1_0() { return cCiCommaItemParserRuleCall_1_1_0; }

		//"of"
		public Keyword getOfKeyword_1_2() { return cOfKeyword_1_2; }
	}

	public class ButExprElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ButExpr");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cButExprAction_0 = (Action)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Assignment cDbAssignment_1_0 = (Assignment)cGroup_1.eContents().get(0);
		private final RuleCall cDbDeclBindingParserRuleCall_1_0_0 = (RuleCall)cDbAssignment_1_0.eContents().get(0);
		private final Keyword cInKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cCaAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cCaCasesParserRuleCall_1_2_0 = (RuleCall)cCaAssignment_1_2.eContents().get(0);
		
		//ButExpr hidden(WS, KW_NEWLINE):
		//	{ButExpr} (db=DeclBinding "in" ca=Cases)?;
		public ParserRule getRule() { return rule; }

		//{ButExpr} (db=DeclBinding "in" ca=Cases)?
		public Group getGroup() { return cGroup; }

		//{ButExpr}
		public Action getButExprAction_0() { return cButExprAction_0; }

		//(db=DeclBinding "in" ca=Cases)?
		public Group getGroup_1() { return cGroup_1; }

		//db=DeclBinding
		public Assignment getDbAssignment_1_0() { return cDbAssignment_1_0; }

		//DeclBinding
		public RuleCall getDbDeclBindingParserRuleCall_1_0_0() { return cDbDeclBindingParserRuleCall_1_0_0; }

		//"in"
		public Keyword getInKeyword_1_1() { return cInKeyword_1_1; }

		//ca=Cases
		public Assignment getCaAssignment_1_2() { return cCaAssignment_1_2; }

		//Cases
		public RuleCall getCaCasesParserRuleCall_1_2_0() { return cCaCasesParserRuleCall_1_2_0; }
	}

	public class CasesElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Cases");
		private final RuleCall cBinding_CollectionParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//Cases hidden(WS, KW_NEWLINE):
		//	Binding_Collection;
		public ParserRule getRule() { return rule; }

		//Binding_Collection
		public RuleCall getBinding_CollectionParserRuleCall() { return cBinding_CollectionParserRuleCall; }
	}

	public class AlwaysPart_AnyStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "AlwaysPart_AnyStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cAlwaysPart_AnyStatementAction_0 = (Action)cGroup.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final Group cGroup_1_0 = (Group)cAlternatives_1.eContents().get(0);
		private final Keyword cAlwaysKeyword_1_0_0 = (Keyword)cGroup_1_0.eContents().get(0);
		private final Assignment cBas7Assignment_1_0_1 = (Assignment)cGroup_1_0.eContents().get(1);
		private final RuleCall cBas7Binding_AnyStatementParserRuleCall_1_0_1_0 = (RuleCall)cBas7Assignment_1_0_1.eContents().get(0);
		private final Group cGroup_1_1 = (Group)cAlternatives_1.eContents().get(1);
		private final Keyword cFinallyKeyword_1_1_0 = (Keyword)cGroup_1_1.eContents().get(0);
		private final Assignment cBas7Assignment_1_1_1 = (Assignment)cGroup_1_1.eContents().get(1);
		private final RuleCall cBas7Binding_AnyStatementParserRuleCall_1_1_1_0 = (RuleCall)cBas7Assignment_1_1_1.eContents().get(0);
		
		/// * Substituted Rules in Xtext:
		// * AlwaysPart(XX) -> AlwaysPart_AnyStatement
		// *                or AlwaysPart_BalStatement
		// * AlwaysPart(XX)
		// * : KW_Always Binding(XX)
		// * { (void)parseDeprecated(KW_Always, abNewNothing(TPOS($1))); $$ = $2; }
		// * | KW_Finally Binding(XX)
		// * { $$ = $2; }
		// * | Nothing
		////;
		// * / AlwaysPart_AnyStatement hidden(WS, KW_NEWLINE):
		//	{AlwaysPart_AnyStatement} ("always" bas7=Binding_AnyStatement | "finally" bas7=Binding_AnyStatement)?;
		public ParserRule getRule() { return rule; }

		//{AlwaysPart_AnyStatement} ("always" bas7=Binding_AnyStatement | "finally" bas7=Binding_AnyStatement)?
		public Group getGroup() { return cGroup; }

		//{AlwaysPart_AnyStatement}
		public Action getAlwaysPart_AnyStatementAction_0() { return cAlwaysPart_AnyStatementAction_0; }

		//("always" bas7=Binding_AnyStatement | "finally" bas7=Binding_AnyStatement)?
		public Alternatives getAlternatives_1() { return cAlternatives_1; }

		//"always" bas7=Binding_AnyStatement
		public Group getGroup_1_0() { return cGroup_1_0; }

		//"always"
		public Keyword getAlwaysKeyword_1_0_0() { return cAlwaysKeyword_1_0_0; }

		//bas7=Binding_AnyStatement
		public Assignment getBas7Assignment_1_0_1() { return cBas7Assignment_1_0_1; }

		//Binding_AnyStatement
		public RuleCall getBas7Binding_AnyStatementParserRuleCall_1_0_1_0() { return cBas7Binding_AnyStatementParserRuleCall_1_0_1_0; }

		//"finally" bas7=Binding_AnyStatement
		public Group getGroup_1_1() { return cGroup_1_1; }

		//"finally"
		public Keyword getFinallyKeyword_1_1_0() { return cFinallyKeyword_1_1_0; }

		//bas7=Binding_AnyStatement
		public Assignment getBas7Assignment_1_1_1() { return cBas7Assignment_1_1_1; }

		//Binding_AnyStatement
		public RuleCall getBas7Binding_AnyStatementParserRuleCall_1_1_1_0() { return cBas7Binding_AnyStatementParserRuleCall_1_1_1_0; }
	}

	public class AlwaysPart_BalStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "AlwaysPart_BalStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cAlwaysPart_BalStatementAction_0 = (Action)cGroup.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final Group cGroup_1_0 = (Group)cAlternatives_1.eContents().get(0);
		private final Keyword cAlwaysKeyword_1_0_0 = (Keyword)cGroup_1_0.eContents().get(0);
		private final Assignment cBas7Assignment_1_0_1 = (Assignment)cGroup_1_0.eContents().get(1);
		private final RuleCall cBas7Binding_BalStatementParserRuleCall_1_0_1_0 = (RuleCall)cBas7Assignment_1_0_1.eContents().get(0);
		private final Group cGroup_1_1 = (Group)cAlternatives_1.eContents().get(1);
		private final Keyword cFinallyKeyword_1_1_0 = (Keyword)cGroup_1_1.eContents().get(0);
		private final Assignment cBas7Assignment_1_1_1 = (Assignment)cGroup_1_1.eContents().get(1);
		private final RuleCall cBas7Binding_BalStatementParserRuleCall_1_1_1_0 = (RuleCall)cBas7Assignment_1_1_1.eContents().get(0);
		
		//AlwaysPart_BalStatement hidden(WS, KW_NEWLINE):
		//	{AlwaysPart_BalStatement} ("always" bas7=Binding_BalStatement | "finally" bas7=Binding_BalStatement)?;
		public ParserRule getRule() { return rule; }

		//{AlwaysPart_BalStatement} ("always" bas7=Binding_BalStatement | "finally" bas7=Binding_BalStatement)?
		public Group getGroup() { return cGroup; }

		//{AlwaysPart_BalStatement}
		public Action getAlwaysPart_BalStatementAction_0() { return cAlwaysPart_BalStatementAction_0; }

		//("always" bas7=Binding_BalStatement | "finally" bas7=Binding_BalStatement)?
		public Alternatives getAlternatives_1() { return cAlternatives_1; }

		//"always" bas7=Binding_BalStatement
		public Group getGroup_1_0() { return cGroup_1_0; }

		//"always"
		public Keyword getAlwaysKeyword_1_0_0() { return cAlwaysKeyword_1_0_0; }

		//bas7=Binding_BalStatement
		public Assignment getBas7Assignment_1_0_1() { return cBas7Assignment_1_0_1; }

		//Binding_BalStatement
		public RuleCall getBas7Binding_BalStatementParserRuleCall_1_0_1_0() { return cBas7Binding_BalStatementParserRuleCall_1_0_1_0; }

		//"finally" bas7=Binding_BalStatement
		public Group getGroup_1_1() { return cGroup_1_1; }

		//"finally"
		public Keyword getFinallyKeyword_1_1_0() { return cFinallyKeyword_1_1_0; }

		//bas7=Binding_BalStatement
		public Assignment getBas7Assignment_1_1_1() { return cBas7Assignment_1_1_1; }

		//Binding_BalStatement
		public RuleCall getBas7Binding_BalStatementParserRuleCall_1_1_1_0() { return cBas7Binding_BalStatementParserRuleCall_1_1_1_0; }
	}

	public class CollectionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Collection");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cInfixedParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Assignment cI3Assignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cI3IteratorsParserRuleCall_1_0 = (RuleCall)cI3Assignment_1.eContents().get(0);
		
		/// *
		// * infixed optionally followed by Iterators
		// * .... for .... in .... | ....
		// * while ....
		// * / Collection hidden(WS, KW_NEWLINE):
		//	Infixed i3= // iterators allow for zero cases
		//	Iterators;
		public ParserRule getRule() { return rule; }

		//Infixed i3= // iterators allow for zero cases
		//Iterators
		public Group getGroup() { return cGroup; }

		//Infixed
		public RuleCall getInfixedParserRuleCall_0() { return cInfixedParserRuleCall_0; }

		//i3= // iterators allow for zero cases
		//Iterators
		public Assignment getI3Assignment_1() { return cI3Assignment_1; }

		//// iterators allow for zero cases
		//Iterators
		public RuleCall getI3IteratorsParserRuleCall_1_0() { return cI3IteratorsParserRuleCall_1_0; }
	}

	public class IteratorsElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Iterators");
		private final RuleCall cIterators1ParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		/// * Zero or more iterators: for....in or while.... * / Iterators hidden(WS, KW_NEWLINE):
		//	Iterators1;
		public ParserRule getRule() { return rule; }

		//Iterators1
		public RuleCall getIterators1ParserRuleCall() { return cIterators1ParserRuleCall; }
	}

	public class Iterators1Elements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Iterators1");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cIterators1Action_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cItrAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cItrIteratorParserRuleCall_1_0 = (RuleCall)cItrAssignment_1.eContents().get(0);
		
		/// * Zero or more iterators: for....in or while.... * / Iterators1 hidden(WS, KW_NEWLINE):
		//	{Iterators1} itr+=Iterator*;
		public ParserRule getRule() { return rule; }

		//{Iterators1} itr+=Iterator*
		public Group getGroup() { return cGroup; }

		//{Iterators1}
		public Action getIterators1Action_0() { return cIterators1Action_0; }

		//itr+=Iterator*
		public Assignment getItrAssignment_1() { return cItrAssignment_1; }

		//Iterator
		public RuleCall getItrIteratorParserRuleCall_1_0() { return cItrIteratorParserRuleCall_1_0; }
	}

	public class IteratorElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Iterator");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Keyword cForKeyword_0_0 = (Keyword)cGroup_0.eContents().get(0);
		private final RuleCall cForLhsParserRuleCall_0_1 = (RuleCall)cGroup_0.eContents().get(1);
		private final Keyword cInKeyword_0_2 = (Keyword)cGroup_0.eContents().get(2);
		private final Assignment cIAssignment_0_3 = (Assignment)cGroup_0.eContents().get(3);
		private final RuleCall cIInfixedParserRuleCall_0_3_0 = (RuleCall)cIAssignment_0_3.eContents().get(0);
		private final Assignment cSpAssignment_0_4 = (Assignment)cGroup_0.eContents().get(4);
		private final RuleCall cSpSuchthatPartParserRuleCall_0_4_0 = (RuleCall)cSpAssignment_0_4.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Keyword cWhileKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cIAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cIInfixedParserRuleCall_1_1_0 = (RuleCall)cIAssignment_1_1.eContents().get(0);
		
		/// * Iterator: for....in or while.... * / Iterator hidden(WS, KW_NEWLINE):
		//	"for" ForLhs "in" i=Infixed sp=SuchthatPart? | "while" i=Infixed;
		public ParserRule getRule() { return rule; }

		//"for" ForLhs "in" i=Infixed sp=SuchthatPart? | "while" i=Infixed
		public Alternatives getAlternatives() { return cAlternatives; }

		//"for" ForLhs "in" i=Infixed sp=SuchthatPart?
		public Group getGroup_0() { return cGroup_0; }

		//"for"
		public Keyword getForKeyword_0_0() { return cForKeyword_0_0; }

		//ForLhs
		public RuleCall getForLhsParserRuleCall_0_1() { return cForLhsParserRuleCall_0_1; }

		//"in"
		public Keyword getInKeyword_0_2() { return cInKeyword_0_2; }

		//i=Infixed
		public Assignment getIAssignment_0_3() { return cIAssignment_0_3; }

		//Infixed
		public RuleCall getIInfixedParserRuleCall_0_3_0() { return cIInfixedParserRuleCall_0_3_0; }

		//sp=SuchthatPart?
		public Assignment getSpAssignment_0_4() { return cSpAssignment_0_4; }

		//SuchthatPart
		public RuleCall getSpSuchthatPartParserRuleCall_0_4_0() { return cSpSuchthatPartParserRuleCall_0_4_0; }

		//"while" i=Infixed
		public Group getGroup_1() { return cGroup_1; }

		//"while"
		public Keyword getWhileKeyword_1_0() { return cWhileKeyword_1_0; }

		//i=Infixed
		public Assignment getIAssignment_1_1() { return cIAssignment_1_1; }

		//Infixed
		public RuleCall getIInfixedParserRuleCall_1_1_0() { return cIInfixedParserRuleCall_1_1_0; }
	}

	public class ForLhsElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ForLhs");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Alternatives cAlternatives_0 = (Alternatives)cGroup.eContents().get(0);
		private final Keyword cFreeKeyword_0_0 = (Keyword)cAlternatives_0.eContents().get(0);
		private final Keyword cLocalKeyword_0_1 = (Keyword)cAlternatives_0.eContents().get(1);
		private final Keyword cFluidKeyword_0_2 = (Keyword)cAlternatives_0.eContents().get(2);
		private final RuleCall cInfixedParserRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		
		//ForLhs hidden(WS, KW_NEWLINE):
		//	("free" | "local" | "fluid")? Infixed;
		public ParserRule getRule() { return rule; }

		//("free" | "local" | "fluid")? Infixed
		public Group getGroup() { return cGroup; }

		//("free" | "local" | "fluid")?
		public Alternatives getAlternatives_0() { return cAlternatives_0; }

		//"free"
		public Keyword getFreeKeyword_0_0() { return cFreeKeyword_0_0; }

		//"local"
		public Keyword getLocalKeyword_0_1() { return cLocalKeyword_0_1; }

		//"fluid"
		public Keyword getFluidKeyword_0_2() { return cFluidKeyword_0_2; }

		//Infixed
		public RuleCall getInfixedParserRuleCall_1() { return cInfixedParserRuleCall_1; }
	}

	public class SuchthatPartElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "SuchthatPart");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cKW_BARTerminalRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final RuleCall cInfixedParserRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		
		//SuchthatPart hidden(WS, KW_NEWLINE):
		//	KW_BAR Infixed;
		public ParserRule getRule() { return rule; }

		//KW_BAR Infixed
		public Group getGroup() { return cGroup; }

		//KW_BAR
		public RuleCall getKW_BARTerminalRuleCall_0() { return cKW_BARTerminalRuleCall_0; }

		//Infixed
		public RuleCall getInfixedParserRuleCall_1() { return cInfixedParserRuleCall_1; }
	}

	public class InfixedElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Infixed");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Assignment cIfxAssignment_0_0 = (Assignment)cGroup_0.eContents().get(0);
		private final RuleCall cIfxInfixedExprParserRuleCall_0_0_0 = (RuleCall)cIfxAssignment_0_0.eContents().get(0);
		private final Assignment cDpAssignment_0_1 = (Assignment)cGroup_0.eContents().get(1);
		private final RuleCall cDpDeclPartParserRuleCall_0_1_0 = (RuleCall)cDpAssignment_0_1.eContents().get(0);
		private final Assignment cBAssignment_1 = (Assignment)cAlternatives.eContents().get(1);
		private final RuleCall cBBlockParserRuleCall_1_0 = (RuleCall)cBAssignment_1.eContents().get(0);
		
		/// *
		// * Infixed Expressions
		// * Either:
		// * an expression
		// * or a typed expression
		// * or a block (CurlyContents_Labeled inside curly brackets)
		// * / Infixed hidden(WS, KW_NEWLINE):
		//	ifx=InfixedExpr dp=DeclPart? | b=Block;
		public ParserRule getRule() { return rule; }

		//ifx=InfixedExpr dp=DeclPart? | b=Block
		public Alternatives getAlternatives() { return cAlternatives; }

		//ifx=InfixedExpr dp=DeclPart?
		public Group getGroup_0() { return cGroup_0; }

		//ifx=InfixedExpr
		public Assignment getIfxAssignment_0_0() { return cIfxAssignment_0_0; }

		//InfixedExpr
		public RuleCall getIfxInfixedExprParserRuleCall_0_0_0() { return cIfxInfixedExprParserRuleCall_0_0_0; }

		//dp=DeclPart?
		public Assignment getDpAssignment_0_1() { return cDpAssignment_0_1; }

		//DeclPart
		public RuleCall getDpDeclPartParserRuleCall_0_1_0() { return cDpDeclPartParserRuleCall_0_1_0; }

		//b=Block
		public Assignment getBAssignment_1() { return cBAssignment_1; }

		//Block
		public RuleCall getBBlockParserRuleCall_1_0() { return cBBlockParserRuleCall_1_0; }
	}

	public class InfixedExprElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "InfixedExpr");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cE11_OpParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cE3ParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		/// *
		// * if we enable 'returns Expr' then 'E11_E12' replaces id in AST
		// * / / *returns Expr* / InfixedExpr hidden(WS, KW_NEWLINE): // prefix operation
		//	E11_Op | // infix operation
		//	=> E3;
		public ParserRule getRule() { return rule; }

		//// prefix operation
		//E11_Op | // infix operation
		//=> E3
		public Alternatives getAlternatives() { return cAlternatives; }

		//// prefix operation
		//E11_Op
		public RuleCall getE11_OpParserRuleCall_0() { return cE11_OpParserRuleCall_0; }

		//// infix operation
		//=> E3
		public RuleCall getE3ParserRuleCall_1() { return cE3ParserRuleCall_1; }
	}

	public class E3Elements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "E3");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cE4ParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cE3LeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOpAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final Alternatives cOpAlternatives_1_1_0 = (Alternatives)cOpAssignment_1_1.eContents().get(0);
		private final Keyword cOpAndKeyword_1_1_0_0 = (Keyword)cOpAlternatives_1_1_0.eContents().get(0);
		private final Keyword cOpOrKeyword_1_1_0_1 = (Keyword)cOpAlternatives_1_1_0.eContents().get(1);
		private final RuleCall cOpLatticeTokParserRuleCall_1_1_0_2 = (RuleCall)cOpAlternatives_1_1_0.eContents().get(2);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightE4ParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		/// *
		// * 'and','or' logic operators
		// * need to allow a 'qualified op', that is an operation followed by '$' and a type
		// * / E3 returns Expr hidden(WS, KW_NEWLINE):
		//	E4 ({E3.left=current} op=("and" / *QualOp_LatticeTok* / | "or" | LatticeTok) right=E4)*;
		public ParserRule getRule() { return rule; }

		//E4 ({E3.left=current} op=("and" / *QualOp_LatticeTok* / | "or" | LatticeTok) right=E4)*
		public Group getGroup() { return cGroup; }

		//E4
		public RuleCall getE4ParserRuleCall_0() { return cE4ParserRuleCall_0; }

		//({E3.left=current} op=("and" / *QualOp_LatticeTok* / | "or" | LatticeTok) right=E4)*
		public Group getGroup_1() { return cGroup_1; }

		//{E3.left=current}
		public Action getE3LeftAction_1_0() { return cE3LeftAction_1_0; }

		//op=("and" / *QualOp_LatticeTok* / | "or" | LatticeTok)
		public Assignment getOpAssignment_1_1() { return cOpAssignment_1_1; }

		//"and" / *QualOp_LatticeTok* / | "or" | LatticeTok
		public Alternatives getOpAlternatives_1_1_0() { return cOpAlternatives_1_1_0; }

		//"and"
		public Keyword getOpAndKeyword_1_1_0_0() { return cOpAndKeyword_1_1_0_0; }

		//"or"
		public Keyword getOpOrKeyword_1_1_0_1() { return cOpOrKeyword_1_1_0_1; }

		//LatticeTok
		public RuleCall getOpLatticeTokParserRuleCall_1_1_0_2() { return cOpLatticeTokParserRuleCall_1_1_0_2; }

		//right=E4
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }

		//E4
		public RuleCall getRightE4ParserRuleCall_1_2_0() { return cRightE4ParserRuleCall_1_2_0; }
	}

	public class E4Elements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "E4");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cE5ParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cE4LeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOpAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final Alternatives cOpAlternatives_1_1_0 = (Alternatives)cOpAssignment_1_1.eContents().get(0);
		private final Keyword cOpHasKeyword_1_1_0_0 = (Keyword)cOpAlternatives_1_1_0.eContents().get(0);
		private final RuleCall cOpRelationTokParserRuleCall_1_1_0_1 = (RuleCall)cOpAlternatives_1_1_0.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightE5ParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		/// * relation operators
		// * in YACC version this rule also includes relation operators as prefix
		// * but for Antlr we need to move prefix operators somewhere else
		// * 
		// * need to allow a 'qualified op', that is an operation followed by '$' and a type
		// * / //| (RelationOp {E4.left=current} right+=E5)
		//E4 returns Expr hidden(WS, KW_NEWLINE):
		//	E5 ({E4.left=current} op=("has" / *RelationOp* / | RelationTok) right=E5)*;
		public ParserRule getRule() { return rule; }

		//E5 ({E4.left=current} op=("has" / *RelationOp* / | RelationTok) right=E5)*
		public Group getGroup() { return cGroup; }

		//E5
		public RuleCall getE5ParserRuleCall_0() { return cE5ParserRuleCall_0; }

		//({E4.left=current} op=("has" / *RelationOp* / | RelationTok) right=E5)*
		public Group getGroup_1() { return cGroup_1; }

		//{E4.left=current}
		public Action getE4LeftAction_1_0() { return cE4LeftAction_1_0; }

		//op=("has" / *RelationOp* / | RelationTok)
		public Assignment getOpAssignment_1_1() { return cOpAssignment_1_1; }

		//"has" / *RelationOp* / | RelationTok
		public Alternatives getOpAlternatives_1_1_0() { return cOpAlternatives_1_1_0; }

		//"has"
		public Keyword getOpHasKeyword_1_1_0_0() { return cOpHasKeyword_1_1_0_0; }

		//RelationTok
		public RuleCall getOpRelationTokParserRuleCall_1_1_0_1() { return cOpRelationTokParserRuleCall_1_1_0_1; }

		//right=E5
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }

		//E5
		public RuleCall getRightE5ParserRuleCall_1_2_0() { return cRightE5ParserRuleCall_1_2_0; }
	}

	public class E5Elements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "E5");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cE6ParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cE5LeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOpAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOpSegTokParserRuleCall_1_1_0 = (RuleCall)cOpAssignment_1_1.eContents().get(0);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightE6ParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		/// * segment operators: '..' and 'by'
		// * in YACC version this rule also includes segment operators as postfix
		// * but for Antlr we need to move postfix operators somewhere else
		// * 
		// * need to allow a 'qualified op', that is an operation followed by '$' and a type
		// * / //=>
		////| (left=E6 {E5.left=current} op5+=SegOp)
		//E5 returns Expr hidden(WS, KW_NEWLINE):
		//	E6 ({E5.left=current} op=SegTok / *SegOp* / right=E6)*;
		public ParserRule getRule() { return rule; }

		//E6 ({E5.left=current} op=SegTok / *SegOp* / right=E6)*
		public Group getGroup() { return cGroup; }

		//E6
		public RuleCall getE6ParserRuleCall_0() { return cE6ParserRuleCall_0; }

		//({E5.left=current} op=SegTok / *SegOp* / right=E6)*
		public Group getGroup_1() { return cGroup_1; }

		//{E5.left=current}
		public Action getE5LeftAction_1_0() { return cE5LeftAction_1_0; }

		//op=SegTok
		public Assignment getOpAssignment_1_1() { return cOpAssignment_1_1; }

		//SegTok
		public RuleCall getOpSegTokParserRuleCall_1_1_0() { return cOpSegTokParserRuleCall_1_1_0; }

		/// *SegOp* / right=E6
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }

		//E6
		public RuleCall getRightE6ParserRuleCall_1_2_0() { return cRightE6ParserRuleCall_1_2_0; }
	}

	public class E6Elements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "E6");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cE7ParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cE6LeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOpAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOpPlusTokParserRuleCall_1_1_0 = (RuleCall)cOpAssignment_1_1.eContents().get(0);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightE7ParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		/// *
		// * in YACC version this rule also includes relation operators as prefix (unary plus)
		// * but for Antlr we need to move prefix operators somewhere else
		// * 
		// * need to allow a 'qualified op', that is an operation followed by '$' and a type
		// * / //| (op6+=PlusOp right=E7)
		//E6 returns Expr hidden(WS, KW_NEWLINE):
		//	E7 ({E6.left=current} op=PlusTok / *PlusOp* / right=E7)*;
		public ParserRule getRule() { return rule; }

		//E7 ({E6.left=current} op=PlusTok / *PlusOp* / right=E7)*
		public Group getGroup() { return cGroup; }

		//E7
		public RuleCall getE7ParserRuleCall_0() { return cE7ParserRuleCall_0; }

		//({E6.left=current} op=PlusTok / *PlusOp* / right=E7)*
		public Group getGroup_1() { return cGroup_1; }

		//{E6.left=current}
		public Action getE6LeftAction_1_0() { return cE6LeftAction_1_0; }

		//op=PlusTok
		public Assignment getOpAssignment_1_1() { return cOpAssignment_1_1; }

		//PlusTok
		public RuleCall getOpPlusTokParserRuleCall_1_1_0() { return cOpPlusTokParserRuleCall_1_1_0; }

		/// *PlusOp* / right=E7
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }

		//E7
		public RuleCall getRightE7ParserRuleCall_1_2_0() { return cRightE7ParserRuleCall_1_2_0; }
	}

	public class E7Elements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "E7");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cE8ParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cE7LeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOpAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOpQuotientTokParserRuleCall_1_1_0 = (RuleCall)cOpAssignment_1_1.eContents().get(0);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightE8ParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		/// *
		// * quotient operations
		// * 
		// * need to allow a 'qualified op', that is an operation followed by '$' and a type
		// * / E7 returns Expr hidden(WS, KW_NEWLINE):
		//	E8 ({E7.left=current} op=QuotientTok / *QuotientOp* / right=E8)*;
		public ParserRule getRule() { return rule; }

		//E8 ({E7.left=current} op=QuotientTok / *QuotientOp* / right=E8)*
		public Group getGroup() { return cGroup; }

		//E8
		public RuleCall getE8ParserRuleCall_0() { return cE8ParserRuleCall_0; }

		//({E7.left=current} op=QuotientTok / *QuotientOp* / right=E8)*
		public Group getGroup_1() { return cGroup_1; }

		//{E7.left=current}
		public Action getE7LeftAction_1_0() { return cE7LeftAction_1_0; }

		//op=QuotientTok
		public Assignment getOpAssignment_1_1() { return cOpAssignment_1_1; }

		//QuotientTok
		public RuleCall getOpQuotientTokParserRuleCall_1_1_0() { return cOpQuotientTokParserRuleCall_1_1_0; }

		/// *QuotientOp* / right=E8
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }

		//E8
		public RuleCall getRightE8ParserRuleCall_1_2_0() { return cRightE8ParserRuleCall_1_2_0; }
	}

	public class E8Elements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "E8");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cE9ParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cE8LeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOpAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOpTimesTokParserRuleCall_1_1_0 = (RuleCall)cOpAssignment_1_1.eContents().get(0);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightE9ParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		/// *
		// * multiplication operations
		// * 
		// * need to allow a 'qualified op', that is an operation followed by '$' and a type
		// * / E8 returns Expr hidden(WS, KW_NEWLINE):
		//	E9 ({E8.left=current} op=TimesTok / *TimesOp* / right=E9)*;
		public ParserRule getRule() { return rule; }

		//E9 ({E8.left=current} op=TimesTok / *TimesOp* / right=E9)*
		public Group getGroup() { return cGroup; }

		//E9
		public RuleCall getE9ParserRuleCall_0() { return cE9ParserRuleCall_0; }

		//({E8.left=current} op=TimesTok / *TimesOp* / right=E9)*
		public Group getGroup_1() { return cGroup_1; }

		//{E8.left=current}
		public Action getE8LeftAction_1_0() { return cE8LeftAction_1_0; }

		//op=TimesTok
		public Assignment getOpAssignment_1_1() { return cOpAssignment_1_1; }

		//TimesTok
		public RuleCall getOpTimesTokParserRuleCall_1_1_0() { return cOpTimesTokParserRuleCall_1_1_0; }

		/// *TimesOp* / right=E9
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }

		//E9
		public RuleCall getRightE9ParserRuleCall_1_2_0() { return cRightE9ParserRuleCall_1_2_0; }
	}

	public class E9Elements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "E9");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cE11_E12ParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cE9LeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOpAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOpPowerTokParserRuleCall_1_1_0 = (RuleCall)cOpAssignment_1_1.eContents().get(0);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightE11_E12ParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		/// *
		// * exponent operations
		// * 
		// * need to allow a 'qualified op', that is an operation followed by '$' and a type
		// * / E9 returns Expr hidden(WS, KW_NEWLINE):
		//	E11_E12 ({E9.left=current} op=PowerTok / *PowerOp* / right=E11_E12)*;
		public ParserRule getRule() { return rule; }

		//E11_E12 ({E9.left=current} op=PowerTok / *PowerOp* / right=E11_E12)*
		public Group getGroup() { return cGroup; }

		//E11_E12
		public RuleCall getE11_E12ParserRuleCall_0() { return cE11_E12ParserRuleCall_0; }

		//({E9.left=current} op=PowerTok / *PowerOp* / right=E11_E12)*
		public Group getGroup_1() { return cGroup_1; }

		//{E9.left=current}
		public Action getE9LeftAction_1_0() { return cE9LeftAction_1_0; }

		//op=PowerTok
		public Assignment getOpAssignment_1_1() { return cOpAssignment_1_1; }

		//PowerTok
		public RuleCall getOpPowerTokParserRuleCall_1_1_0() { return cOpPowerTokParserRuleCall_1_1_0; }

		/// *PowerOp* / right=E11_E12
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }

		//E11_E12
		public RuleCall getRightE11_E12ParserRuleCall_1_2_0() { return cRightE11_E12ParserRuleCall_1_2_0; }
	}

	public class E11_E12Elements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "E11_E12");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cE12ParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cE11_E12LeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Alternatives cAlternatives_1_1 = (Alternatives)cGroup_1.eContents().get(1);
		private final Assignment cOpAssignment_1_1_0 = (Assignment)cAlternatives_1_1.eContents().get(0);
		private final RuleCall cOpKW_2COLONTerminalRuleCall_1_1_0_0 = (RuleCall)cOpAssignment_1_1_0.eContents().get(0);
		private final Assignment cOpAssignment_1_1_1 = (Assignment)cAlternatives_1_1.eContents().get(1);
		private final RuleCall cOpKW_ATTerminalRuleCall_1_1_1_0 = (RuleCall)cOpAssignment_1_1_1.eContents().get(0);
		private final Assignment cOpAssignment_1_1_2 = (Assignment)cAlternatives_1_1.eContents().get(2);
		private final Keyword cOpPretendKeyword_1_1_2_0 = (Keyword)cOpAssignment_1_1_2.eContents().get(0);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightE12ParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		/// *
		// * This version of E11 is used in the middle of the precedence stack
		// * / E11_E12 returns Expr hidden(WS, KW_NEWLINE):
		//	E12 ({E11_E12.left=current} (op=KW_2COLON | op=KW_AT | op="pretend") right=E12)*;
		public ParserRule getRule() { return rule; }

		//E12 ({E11_E12.left=current} (op=KW_2COLON | op=KW_AT | op="pretend") right=E12)*
		public Group getGroup() { return cGroup; }

		//E12
		public RuleCall getE12ParserRuleCall_0() { return cE12ParserRuleCall_0; }

		//({E11_E12.left=current} (op=KW_2COLON | op=KW_AT | op="pretend") right=E12)*
		public Group getGroup_1() { return cGroup_1; }

		//{E11_E12.left=current}
		public Action getE11_E12LeftAction_1_0() { return cE11_E12LeftAction_1_0; }

		//op=KW_2COLON | op=KW_AT | op="pretend"
		public Alternatives getAlternatives_1_1() { return cAlternatives_1_1; }

		//op=KW_2COLON
		public Assignment getOpAssignment_1_1_0() { return cOpAssignment_1_1_0; }

		//KW_2COLON
		public RuleCall getOpKW_2COLONTerminalRuleCall_1_1_0_0() { return cOpKW_2COLONTerminalRuleCall_1_1_0_0; }

		//op=KW_AT
		public Assignment getOpAssignment_1_1_1() { return cOpAssignment_1_1_1; }

		//KW_AT
		public RuleCall getOpKW_ATTerminalRuleCall_1_1_1_0() { return cOpKW_ATTerminalRuleCall_1_1_1_0; }

		//op="pretend"
		public Assignment getOpAssignment_1_1_2() { return cOpAssignment_1_1_2; }

		//"pretend"
		public Keyword getOpPretendKeyword_1_1_2_0() { return cOpPretendKeyword_1_1_2_0; }

		//right=E12
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }

		//E12
		public RuleCall getRightE12ParserRuleCall_1_2_0() { return cRightE12ParserRuleCall_1_2_0; }
	}

	public class E11_OpElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "E11_Op");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cOpParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cE11_OpLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Alternatives cAlternatives_1_1 = (Alternatives)cGroup_1.eContents().get(1);
		private final Assignment cOpAssignment_1_1_0 = (Assignment)cAlternatives_1_1.eContents().get(0);
		private final RuleCall cOpKW_2COLONTerminalRuleCall_1_1_0_0 = (RuleCall)cOpAssignment_1_1_0.eContents().get(0);
		private final Assignment cOpAssignment_1_1_1 = (Assignment)cAlternatives_1_1.eContents().get(1);
		private final RuleCall cOpKW_ATTerminalRuleCall_1_1_1_0 = (RuleCall)cOpAssignment_1_1_1.eContents().get(0);
		private final Assignment cOpAssignment_1_1_2 = (Assignment)cAlternatives_1_1.eContents().get(2);
		private final Keyword cOpPretendKeyword_1_1_2_0 = (Keyword)cOpAssignment_1_1_2.eContents().get(0);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightE12ParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		/// *
		// * prefix operation
		// * 
		// * This version of E11 is used at the top of the precedence stack in
		// * 'InfixedExpr'
		// * / E11_Op returns Expr hidden(WS, KW_NEWLINE):
		//	Op ({E11_Op.left=current} (op=KW_2COLON | op=KW_AT | op="pretend") right=E12)*;
		public ParserRule getRule() { return rule; }

		//Op ({E11_Op.left=current} (op=KW_2COLON | op=KW_AT | op="pretend") right=E12)*
		public Group getGroup() { return cGroup; }

		//Op
		public RuleCall getOpParserRuleCall_0() { return cOpParserRuleCall_0; }

		//({E11_Op.left=current} (op=KW_2COLON | op=KW_AT | op="pretend") right=E12)*
		public Group getGroup_1() { return cGroup_1; }

		//{E11_Op.left=current}
		public Action getE11_OpLeftAction_1_0() { return cE11_OpLeftAction_1_0; }

		//op=KW_2COLON | op=KW_AT | op="pretend"
		public Alternatives getAlternatives_1_1() { return cAlternatives_1_1; }

		//op=KW_2COLON
		public Assignment getOpAssignment_1_1_0() { return cOpAssignment_1_1_0; }

		//KW_2COLON
		public RuleCall getOpKW_2COLONTerminalRuleCall_1_1_0_0() { return cOpKW_2COLONTerminalRuleCall_1_1_0_0; }

		//op=KW_AT
		public Assignment getOpAssignment_1_1_1() { return cOpAssignment_1_1_1; }

		//KW_AT
		public RuleCall getOpKW_ATTerminalRuleCall_1_1_1_0() { return cOpKW_ATTerminalRuleCall_1_1_1_0; }

		//op="pretend"
		public Assignment getOpAssignment_1_1_2() { return cOpAssignment_1_1_2; }

		//"pretend"
		public Keyword getOpPretendKeyword_1_1_2_0() { return cOpPretendKeyword_1_1_2_0; }

		//right=E12
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }

		//E12
		public RuleCall getRightE12ParserRuleCall_1_2_0() { return cRightE12ParserRuleCall_1_2_0; }
	}

	public class TypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Type");
		private final RuleCall cE11_E12ParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		/// *
		// * use this rule when we know it is a type.
		// * That is in 'DeclPart' where it follows '$'
		// * / Type hidden(WS, KW_NEWLINE):
		//	E11_E12;
		public ParserRule getRule() { return rule; }

		//E11_E12
		public RuleCall getE11_E12ParserRuleCall() { return cE11_E12ParserRuleCall; }
	}

	public class E12Elements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "E12");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cE13ParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cE12LeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOpAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOpArrowOpParserRuleCall_1_1_0 = (RuleCall)cOpAssignment_1_1.eContents().get(0);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightE13ParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//E12 returns Expr hidden(WS, KW_NEWLINE):
		//	E13 ({E12.left=current} op=ArrowOp right=E13)*;
		public ParserRule getRule() { return rule; }

		//E13 ({E12.left=current} op=ArrowOp right=E13)*
		public Group getGroup() { return cGroup; }

		//E13
		public RuleCall getE13ParserRuleCall_0() { return cE13ParserRuleCall_0; }

		//({E12.left=current} op=ArrowOp right=E13)*
		public Group getGroup_1() { return cGroup_1; }

		//{E12.left=current}
		public Action getE12LeftAction_1_0() { return cE12LeftAction_1_0; }

		//op=ArrowOp
		public Assignment getOpAssignment_1_1() { return cOpAssignment_1_1; }

		//ArrowOp
		public RuleCall getOpArrowOpParserRuleCall_1_1_0() { return cOpArrowOpParserRuleCall_1_1_0; }

		//right=E13
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }

		//E13
		public RuleCall getRightE13ParserRuleCall_1_2_0() { return cRightE13ParserRuleCall_1_2_0; }
	}

	public class E13Elements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "E13");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cE14ParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cE13LeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOpAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOpKW_DOLLARTerminalRuleCall_1_1_0 = (RuleCall)cOpAssignment_1_1.eContents().get(0);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightQualTailParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//E13 returns Expr hidden(WS, KW_NEWLINE):
		//	E14 ({E13.left=current} op=KW_DOLLAR right=QualTail)*;
		public ParserRule getRule() { return rule; }

		//E14 ({E13.left=current} op=KW_DOLLAR right=QualTail)*
		public Group getGroup() { return cGroup; }

		//E14
		public RuleCall getE14ParserRuleCall_0() { return cE14ParserRuleCall_0; }

		//({E13.left=current} op=KW_DOLLAR right=QualTail)*
		public Group getGroup_1() { return cGroup_1; }

		//{E13.left=current}
		public Action getE13LeftAction_1_0() { return cE13LeftAction_1_0; }

		//op=KW_DOLLAR
		public Assignment getOpAssignment_1_1() { return cOpAssignment_1_1; }

		//KW_DOLLAR
		public RuleCall getOpKW_DOLLARTerminalRuleCall_1_1_0() { return cOpKW_DOLLARTerminalRuleCall_1_1_0; }

		//right=QualTail
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }

		//QualTail
		public RuleCall getRightQualTailParserRuleCall_1_2_0() { return cRightQualTailParserRuleCall_1_2_0; }
	}

	public class QualTailElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "QualTail");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cLeftJuxtaposedParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Group cGroup_1_0 = (Group)cGroup_1.eContents().get(0);
		private final RuleCall cKW_DOLLARTerminalRuleCall_1_0_0 = (RuleCall)cGroup_1_0.eContents().get(0);
		private final Assignment cQtAssignment_1_0_1 = (Assignment)cGroup_1_0.eContents().get(1);
		private final RuleCall cQtQualTailParserRuleCall_1_0_1_0 = (RuleCall)cQtAssignment_1_0_1.eContents().get(0);
		
		//QualTail hidden(WS, KW_NEWLINE):
		//	LeftJuxtaposed => (KW_DOLLAR qt=QualTail)?;
		public ParserRule getRule() { return rule; }

		//LeftJuxtaposed => (KW_DOLLAR qt=QualTail)?
		public Group getGroup() { return cGroup; }

		//LeftJuxtaposed
		public RuleCall getLeftJuxtaposedParserRuleCall_0() { return cLeftJuxtaposedParserRuleCall_0; }

		//=> (KW_DOLLAR qt=QualTail)?
		public Group getGroup_1() { return cGroup_1; }

		//KW_DOLLAR qt=QualTail
		public Group getGroup_1_0() { return cGroup_1_0; }

		//KW_DOLLAR
		public RuleCall getKW_DOLLARTerminalRuleCall_1_0_0() { return cKW_DOLLARTerminalRuleCall_1_0_0; }

		//qt=QualTail
		public Assignment getQtAssignment_1_0_1() { return cQtAssignment_1_0_1; }

		//QualTail
		public RuleCall getQtQualTailParserRuleCall_1_0_1_0() { return cQtQualTailParserRuleCall_1_0_1_0; }
	}

	public class OpQualTailElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "OpQualTail");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNamAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNamMoleculeParserRuleCall_0_0 = (RuleCall)cNamAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Group cGroup_1_0 = (Group)cGroup_1.eContents().get(0);
		private final RuleCall cKW_DOLLARTerminalRuleCall_1_0_0 = (RuleCall)cGroup_1_0.eContents().get(0);
		private final RuleCall cOpQualTailParserRuleCall_1_0_1 = (RuleCall)cGroup_1_0.eContents().get(1);
		
		//OpQualTail hidden(WS, KW_NEWLINE):
		//	nam=Molecule => (KW_DOLLAR OpQualTail)?;
		public ParserRule getRule() { return rule; }

		//nam=Molecule => (KW_DOLLAR OpQualTail)?
		public Group getGroup() { return cGroup; }

		//nam=Molecule
		public Assignment getNamAssignment_0() { return cNamAssignment_0; }

		//Molecule
		public RuleCall getNamMoleculeParserRuleCall_0_0() { return cNamMoleculeParserRuleCall_0_0; }

		//=> (KW_DOLLAR OpQualTail)?
		public Group getGroup_1() { return cGroup_1; }

		//KW_DOLLAR OpQualTail
		public Group getGroup_1_0() { return cGroup_1_0; }

		//KW_DOLLAR
		public RuleCall getKW_DOLLARTerminalRuleCall_1_0_0() { return cKW_DOLLARTerminalRuleCall_1_0_0; }

		//OpQualTail
		public RuleCall getOpQualTailParserRuleCall_1_0_1() { return cOpQualTailParserRuleCall_1_0_1; }
	}

	public class E14Elements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "E14");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Group cGroup_0_0 = (Group)cGroup_0.eContents().get(0);
		private final Assignment cE15leftAssignment_0_0_0 = (Assignment)cGroup_0_0.eContents().get(0);
		private final RuleCall cE15leftE15ParserRuleCall_0_0_0_0 = (RuleCall)cE15leftAssignment_0_0_0.eContents().get(0);
		private final Assignment cOpAssignment_0_0_1 = (Assignment)cGroup_0_0.eContents().get(1);
		private final Keyword cOpWithKeyword_0_0_1_0 = (Keyword)cOpAssignment_0_0_1.eContents().get(0);
		private final Assignment cDmAssignment_0_0_2 = (Assignment)cGroup_0_0.eContents().get(2);
		private final RuleCall cDmDeclMoleculeParserRuleCall_0_0_2_0 = (RuleCall)cDmAssignment_0_0_2.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Group cGroup_1_0 = (Group)cGroup_1.eContents().get(0);
		private final Assignment cE15leftAssignment_1_0_0 = (Assignment)cGroup_1_0.eContents().get(0);
		private final RuleCall cE15leftE15ParserRuleCall_1_0_0_0 = (RuleCall)cE15leftAssignment_1_0_0.eContents().get(0);
		private final Assignment cOpAssignment_1_0_1 = (Assignment)cGroup_1_0.eContents().get(1);
		private final Keyword cOpAddKeyword_1_0_1_0 = (Keyword)cOpAssignment_1_0_1.eContents().get(0);
		private final Assignment cDmAssignment_1_0_2 = (Assignment)cGroup_1_0.eContents().get(2);
		private final RuleCall cDmDeclMoleculeParserRuleCall_1_0_2_0 = (RuleCall)cDmAssignment_1_0_2.eContents().get(0);
		private final Group cGroup_2 = (Group)cAlternatives.eContents().get(2);
		private final Group cGroup_2_0 = (Group)cGroup_2.eContents().get(0);
		private final Assignment cE15leftAssignment_2_0_0 = (Assignment)cGroup_2_0.eContents().get(0);
		private final RuleCall cE15leftE15ParserRuleCall_2_0_0_0 = (RuleCall)cE15leftAssignment_2_0_0.eContents().get(0);
		private final Assignment cOpAssignment_2_0_1 = (Assignment)cGroup_2_0.eContents().get(1);
		private final Keyword cOpExceptKeyword_2_0_1_0 = (Keyword)cOpAssignment_2_0_1.eContents().get(0);
		private final Assignment cE15rightAssignment_2_0_2 = (Assignment)cGroup_2_0.eContents().get(2);
		private final RuleCall cE15rightE15ParserRuleCall_2_0_2_0 = (RuleCall)cE15rightAssignment_2_0_2.eContents().get(0);
		private final Group cGroup_3 = (Group)cAlternatives.eContents().get(3);
		private final Group cGroup_3_0 = (Group)cGroup_3.eContents().get(0);
		private final Assignment cE15leftAssignment_3_0_0 = (Assignment)cGroup_3_0.eContents().get(0);
		private final RuleCall cE15leftE15ParserRuleCall_3_0_0_0 = (RuleCall)cE15leftAssignment_3_0_0.eContents().get(0);
		private final Assignment cOpAssignment_3_0_1 = (Assignment)cGroup_3_0.eContents().get(1);
		private final Keyword cOpThrowKeyword_3_0_1_0 = (Keyword)cOpAssignment_3_0_1.eContents().get(0);
		private final Assignment cE15rightAssignment_3_0_2 = (Assignment)cGroup_3_0.eContents().get(2);
		private final RuleCall cE15rightE15ParserRuleCall_3_0_2_0 = (RuleCall)cE15rightAssignment_3_0_2.eContents().get(0);
		private final Assignment cE15leftAssignment_4 = (Assignment)cAlternatives.eContents().get(4);
		private final RuleCall cE15leftE15ParserRuleCall_4_0 = (RuleCall)cE15leftAssignment_4.eContents().get(0);
		
		//E14 hidden(WS, KW_NEWLINE):
		//	=> (e15left=E15? op="with" dm=DeclMolecule) | => (e15left=E15? op="add" dm=DeclMolecule) | => (e15left=E15 op="except"
		//	e15right=E15) | => (e15left=E15 op="throw" e15right=E15) | e15left=E15;
		public ParserRule getRule() { return rule; }

		//=> (e15left=E15? op="with" dm=DeclMolecule) | => (e15left=E15? op="add" dm=DeclMolecule) | => (e15left=E15 op="except"
		//e15right=E15) | => (e15left=E15 op="throw" e15right=E15) | e15left=E15
		public Alternatives getAlternatives() { return cAlternatives; }

		//=> (e15left=E15? op="with" dm=DeclMolecule)
		public Group getGroup_0() { return cGroup_0; }

		//e15left=E15? op="with" dm=DeclMolecule
		public Group getGroup_0_0() { return cGroup_0_0; }

		//e15left=E15?
		public Assignment getE15leftAssignment_0_0_0() { return cE15leftAssignment_0_0_0; }

		//E15
		public RuleCall getE15leftE15ParserRuleCall_0_0_0_0() { return cE15leftE15ParserRuleCall_0_0_0_0; }

		//op="with"
		public Assignment getOpAssignment_0_0_1() { return cOpAssignment_0_0_1; }

		//"with"
		public Keyword getOpWithKeyword_0_0_1_0() { return cOpWithKeyword_0_0_1_0; }

		//dm=DeclMolecule
		public Assignment getDmAssignment_0_0_2() { return cDmAssignment_0_0_2; }

		//DeclMolecule
		public RuleCall getDmDeclMoleculeParserRuleCall_0_0_2_0() { return cDmDeclMoleculeParserRuleCall_0_0_2_0; }

		//=> (e15left=E15? op="add" dm=DeclMolecule)
		public Group getGroup_1() { return cGroup_1; }

		//e15left=E15? op="add" dm=DeclMolecule
		public Group getGroup_1_0() { return cGroup_1_0; }

		//e15left=E15?
		public Assignment getE15leftAssignment_1_0_0() { return cE15leftAssignment_1_0_0; }

		//E15
		public RuleCall getE15leftE15ParserRuleCall_1_0_0_0() { return cE15leftE15ParserRuleCall_1_0_0_0; }

		//op="add"
		public Assignment getOpAssignment_1_0_1() { return cOpAssignment_1_0_1; }

		//"add"
		public Keyword getOpAddKeyword_1_0_1_0() { return cOpAddKeyword_1_0_1_0; }

		//dm=DeclMolecule
		public Assignment getDmAssignment_1_0_2() { return cDmAssignment_1_0_2; }

		//DeclMolecule
		public RuleCall getDmDeclMoleculeParserRuleCall_1_0_2_0() { return cDmDeclMoleculeParserRuleCall_1_0_2_0; }

		//=> (e15left=E15 op="except" e15right=E15)
		public Group getGroup_2() { return cGroup_2; }

		//e15left=E15 op="except" e15right=E15
		public Group getGroup_2_0() { return cGroup_2_0; }

		//e15left=E15
		public Assignment getE15leftAssignment_2_0_0() { return cE15leftAssignment_2_0_0; }

		//E15
		public RuleCall getE15leftE15ParserRuleCall_2_0_0_0() { return cE15leftE15ParserRuleCall_2_0_0_0; }

		//op="except"
		public Assignment getOpAssignment_2_0_1() { return cOpAssignment_2_0_1; }

		//"except"
		public Keyword getOpExceptKeyword_2_0_1_0() { return cOpExceptKeyword_2_0_1_0; }

		//e15right=E15
		public Assignment getE15rightAssignment_2_0_2() { return cE15rightAssignment_2_0_2; }

		//E15
		public RuleCall getE15rightE15ParserRuleCall_2_0_2_0() { return cE15rightE15ParserRuleCall_2_0_2_0; }

		//=> (e15left=E15 op="throw" e15right=E15)
		public Group getGroup_3() { return cGroup_3; }

		//e15left=E15 op="throw" e15right=E15
		public Group getGroup_3_0() { return cGroup_3_0; }

		//e15left=E15
		public Assignment getE15leftAssignment_3_0_0() { return cE15leftAssignment_3_0_0; }

		//E15
		public RuleCall getE15leftE15ParserRuleCall_3_0_0_0() { return cE15leftE15ParserRuleCall_3_0_0_0; }

		//op="throw"
		public Assignment getOpAssignment_3_0_1() { return cOpAssignment_3_0_1; }

		//"throw"
		public Keyword getOpThrowKeyword_3_0_1_0() { return cOpThrowKeyword_3_0_1_0; }

		//e15right=E15
		public Assignment getE15rightAssignment_3_0_2() { return cE15rightAssignment_3_0_2; }

		//E15
		public RuleCall getE15rightE15ParserRuleCall_3_0_2_0() { return cE15rightE15ParserRuleCall_3_0_2_0; }

		//e15left=E15
		public Assignment getE15leftAssignment_4() { return cE15leftAssignment_4; }

		//E15
		public RuleCall getE15leftE15ParserRuleCall_4_0() { return cE15leftE15ParserRuleCall_4_0; }
	}

	public class E15Elements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "E15");
		private final RuleCall cApplicationParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//E15 hidden(WS, KW_NEWLINE):
		//	Application;
		public ParserRule getRule() { return rule; }

		//Application
		public RuleCall getApplicationParserRuleCall() { return cApplicationParserRuleCall; }
	}

	public class OpElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Op");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Action cOpAction_0_0 = (Action)cGroup_0.eContents().get(0);
		private final Assignment cAopAssignment_0_1 = (Assignment)cGroup_0.eContents().get(1);
		private final RuleCall cAopArrowOpParserRuleCall_0_1_0 = (RuleCall)cAopAssignment_0_1.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Action cOpAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cAopAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cAopLatticeOpParserRuleCall_1_1_0 = (RuleCall)cAopAssignment_1_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cAlternatives.eContents().get(2);
		private final Action cOpAction_2_0 = (Action)cGroup_2.eContents().get(0);
		private final Assignment cAopAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cAopRelationOpParserRuleCall_2_1_0 = (RuleCall)cAopAssignment_2_1.eContents().get(0);
		private final Group cGroup_3 = (Group)cAlternatives.eContents().get(3);
		private final Action cOpAction_3_0 = (Action)cGroup_3.eContents().get(0);
		private final Assignment cAopAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final RuleCall cAopSegOpParserRuleCall_3_1_0 = (RuleCall)cAopAssignment_3_1.eContents().get(0);
		private final Group cGroup_4 = (Group)cAlternatives.eContents().get(4);
		private final Action cOpAction_4_0 = (Action)cGroup_4.eContents().get(0);
		private final Assignment cAopAssignment_4_1 = (Assignment)cGroup_4.eContents().get(1);
		private final RuleCall cAopPlusOpParserRuleCall_4_1_0 = (RuleCall)cAopAssignment_4_1.eContents().get(0);
		private final Group cGroup_5 = (Group)cAlternatives.eContents().get(5);
		private final Action cOpAction_5_0 = (Action)cGroup_5.eContents().get(0);
		private final Assignment cAopAssignment_5_1 = (Assignment)cGroup_5.eContents().get(1);
		private final RuleCall cAopQuotientOpParserRuleCall_5_1_0 = (RuleCall)cAopAssignment_5_1.eContents().get(0);
		private final Group cGroup_6 = (Group)cAlternatives.eContents().get(6);
		private final Action cOpAction_6_0 = (Action)cGroup_6.eContents().get(0);
		private final Assignment cAopAssignment_6_1 = (Assignment)cGroup_6.eContents().get(1);
		private final RuleCall cAopTimesOpParserRuleCall_6_1_0 = (RuleCall)cAopAssignment_6_1.eContents().get(0);
		private final Group cGroup_7 = (Group)cAlternatives.eContents().get(7);
		private final Action cOpAction_7_0 = (Action)cGroup_7.eContents().get(0);
		private final Assignment cAopAssignment_7_1 = (Assignment)cGroup_7.eContents().get(1);
		private final RuleCall cAopPowerOpParserRuleCall_7_1_0 = (RuleCall)cAopAssignment_7_1.eContents().get(0);
		
		/// *
		// * Infixed Operations
		// * / Op hidden(WS, KW_NEWLINE):
		//	{Op} aop=ArrowOp | {Op} aop=LatticeOp | {Op} aop=RelationOp | {Op} aop=SegOp | {Op} aop=PlusOp | {Op} aop=QuotientOp |
		//	{Op} aop=TimesOp | {Op} aop=PowerOp;
		public ParserRule getRule() { return rule; }

		//{Op} aop=ArrowOp | {Op} aop=LatticeOp | {Op} aop=RelationOp | {Op} aop=SegOp | {Op} aop=PlusOp | {Op} aop=QuotientOp |
		//{Op} aop=TimesOp | {Op} aop=PowerOp
		public Alternatives getAlternatives() { return cAlternatives; }

		//{Op} aop=ArrowOp
		public Group getGroup_0() { return cGroup_0; }

		//{Op}
		public Action getOpAction_0_0() { return cOpAction_0_0; }

		//aop=ArrowOp
		public Assignment getAopAssignment_0_1() { return cAopAssignment_0_1; }

		//ArrowOp
		public RuleCall getAopArrowOpParserRuleCall_0_1_0() { return cAopArrowOpParserRuleCall_0_1_0; }

		//{Op} aop=LatticeOp
		public Group getGroup_1() { return cGroup_1; }

		//{Op}
		public Action getOpAction_1_0() { return cOpAction_1_0; }

		//aop=LatticeOp
		public Assignment getAopAssignment_1_1() { return cAopAssignment_1_1; }

		//LatticeOp
		public RuleCall getAopLatticeOpParserRuleCall_1_1_0() { return cAopLatticeOpParserRuleCall_1_1_0; }

		//{Op} aop=RelationOp
		public Group getGroup_2() { return cGroup_2; }

		//{Op}
		public Action getOpAction_2_0() { return cOpAction_2_0; }

		//aop=RelationOp
		public Assignment getAopAssignment_2_1() { return cAopAssignment_2_1; }

		//RelationOp
		public RuleCall getAopRelationOpParserRuleCall_2_1_0() { return cAopRelationOpParserRuleCall_2_1_0; }

		//{Op} aop=SegOp
		public Group getGroup_3() { return cGroup_3; }

		//{Op}
		public Action getOpAction_3_0() { return cOpAction_3_0; }

		//aop=SegOp
		public Assignment getAopAssignment_3_1() { return cAopAssignment_3_1; }

		//SegOp
		public RuleCall getAopSegOpParserRuleCall_3_1_0() { return cAopSegOpParserRuleCall_3_1_0; }

		//{Op} aop=PlusOp
		public Group getGroup_4() { return cGroup_4; }

		//{Op}
		public Action getOpAction_4_0() { return cOpAction_4_0; }

		//aop=PlusOp
		public Assignment getAopAssignment_4_1() { return cAopAssignment_4_1; }

		//PlusOp
		public RuleCall getAopPlusOpParserRuleCall_4_1_0() { return cAopPlusOpParserRuleCall_4_1_0; }

		//{Op} aop=QuotientOp
		public Group getGroup_5() { return cGroup_5; }

		//{Op}
		public Action getOpAction_5_0() { return cOpAction_5_0; }

		//aop=QuotientOp
		public Assignment getAopAssignment_5_1() { return cAopAssignment_5_1; }

		//QuotientOp
		public RuleCall getAopQuotientOpParserRuleCall_5_1_0() { return cAopQuotientOpParserRuleCall_5_1_0; }

		//{Op} aop=TimesOp
		public Group getGroup_6() { return cGroup_6; }

		//{Op}
		public Action getOpAction_6_0() { return cOpAction_6_0; }

		//aop=TimesOp
		public Assignment getAopAssignment_6_1() { return cAopAssignment_6_1; }

		//TimesOp
		public RuleCall getAopTimesOpParserRuleCall_6_1_0() { return cAopTimesOpParserRuleCall_6_1_0; }

		//{Op} aop=PowerOp
		public Group getGroup_7() { return cGroup_7; }

		//{Op}
		public Action getOpAction_7_0() { return cOpAction_7_0; }

		//aop=PowerOp
		public Assignment getAopAssignment_7_1() { return cAopAssignment_7_1; }

		//PowerOp
		public RuleCall getAopPowerOpParserRuleCall_7_1_0() { return cAopPowerOpParserRuleCall_7_1_0; }
	}

	public class NakedOpElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "NakedOp");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cUnqualOp_ArrowTokParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cUnqualOp_LatticeTokParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cUnqualOp_RelationTokParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cUnqualOp_SegTokParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cUnqualOp_PlusTokParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		private final RuleCall cUnqualOp_QuotientTokParserRuleCall_5 = (RuleCall)cAlternatives.eContents().get(5);
		private final RuleCall cUnqualOp_TimesTokParserRuleCall_6 = (RuleCall)cAlternatives.eContents().get(6);
		private final RuleCall cUnqualOp_PowerTokParserRuleCall_7 = (RuleCall)cAlternatives.eContents().get(7);
		
		//NakedOp hidden(WS, KW_NEWLINE):
		//	UnqualOp_ArrowTok | UnqualOp_LatticeTok | UnqualOp_RelationTok | UnqualOp_SegTok | UnqualOp_PlusTok |
		//	UnqualOp_QuotientTok | UnqualOp_TimesTok | UnqualOp_PowerTok;
		public ParserRule getRule() { return rule; }

		//UnqualOp_ArrowTok | UnqualOp_LatticeTok | UnqualOp_RelationTok | UnqualOp_SegTok | UnqualOp_PlusTok |
		//UnqualOp_QuotientTok | UnqualOp_TimesTok | UnqualOp_PowerTok
		public Alternatives getAlternatives() { return cAlternatives; }

		//UnqualOp_ArrowTok
		public RuleCall getUnqualOp_ArrowTokParserRuleCall_0() { return cUnqualOp_ArrowTokParserRuleCall_0; }

		//UnqualOp_LatticeTok
		public RuleCall getUnqualOp_LatticeTokParserRuleCall_1() { return cUnqualOp_LatticeTokParserRuleCall_1; }

		//UnqualOp_RelationTok
		public RuleCall getUnqualOp_RelationTokParserRuleCall_2() { return cUnqualOp_RelationTokParserRuleCall_2; }

		//UnqualOp_SegTok
		public RuleCall getUnqualOp_SegTokParserRuleCall_3() { return cUnqualOp_SegTokParserRuleCall_3; }

		//UnqualOp_PlusTok
		public RuleCall getUnqualOp_PlusTokParserRuleCall_4() { return cUnqualOp_PlusTokParserRuleCall_4; }

		//UnqualOp_QuotientTok
		public RuleCall getUnqualOp_QuotientTokParserRuleCall_5() { return cUnqualOp_QuotientTokParserRuleCall_5; }

		//UnqualOp_TimesTok
		public RuleCall getUnqualOp_TimesTokParserRuleCall_6() { return cUnqualOp_TimesTokParserRuleCall_6; }

		//UnqualOp_PowerTok
		public RuleCall getUnqualOp_PowerTokParserRuleCall_7() { return cUnqualOp_PowerTokParserRuleCall_7; }
	}

	public class ArrowOpElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ArrowOp");
		private final RuleCall cQualOp_ArrowTokParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//ArrowOp hidden(WS, KW_NEWLINE):
		//	QualOp_ArrowTok;
		public ParserRule getRule() { return rule; }

		//QualOp_ArrowTok
		public RuleCall getQualOp_ArrowTokParserRuleCall() { return cQualOp_ArrowTokParserRuleCall; }
	}

	public class LatticeOpElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "LatticeOp");
		private final RuleCall cQualOp_LatticeTokParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//LatticeOp hidden(WS, KW_NEWLINE):
		//	QualOp_LatticeTok;
		public ParserRule getRule() { return rule; }

		//QualOp_LatticeTok
		public RuleCall getQualOp_LatticeTokParserRuleCall() { return cQualOp_LatticeTokParserRuleCall; }
	}

	public class RelationOpElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "RelationOp");
		private final RuleCall cQualOp_RelationTokParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//RelationOp hidden(WS, KW_NEWLINE):
		//	QualOp_RelationTok;
		public ParserRule getRule() { return rule; }

		//QualOp_RelationTok
		public RuleCall getQualOp_RelationTokParserRuleCall() { return cQualOp_RelationTokParserRuleCall; }
	}

	public class SegOpElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "SegOp");
		private final RuleCall cQualOp_SegTokParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//SegOp hidden(WS, KW_NEWLINE):
		//	QualOp_SegTok;
		public ParserRule getRule() { return rule; }

		//QualOp_SegTok
		public RuleCall getQualOp_SegTokParserRuleCall() { return cQualOp_SegTokParserRuleCall; }
	}

	public class PlusOpElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PlusOp");
		private final RuleCall cQualOp_PlusTokParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//PlusOp hidden(WS, KW_NEWLINE):
		//	QualOp_PlusTok;
		public ParserRule getRule() { return rule; }

		//QualOp_PlusTok
		public RuleCall getQualOp_PlusTokParserRuleCall() { return cQualOp_PlusTokParserRuleCall; }
	}

	public class QuotientOpElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "QuotientOp");
		private final RuleCall cQualOp_QuotientTokParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//QuotientOp hidden(WS, KW_NEWLINE):
		//	QualOp_QuotientTok;
		public ParserRule getRule() { return rule; }

		//QualOp_QuotientTok
		public RuleCall getQualOp_QuotientTokParserRuleCall() { return cQualOp_QuotientTokParserRuleCall; }
	}

	public class TimesOpElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "TimesOp");
		private final RuleCall cQualOp_TimesTokParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//TimesOp hidden(WS, KW_NEWLINE):
		//	QualOp_TimesTok;
		public ParserRule getRule() { return rule; }

		//QualOp_TimesTok
		public RuleCall getQualOp_TimesTokParserRuleCall() { return cQualOp_TimesTokParserRuleCall; }
	}

	public class PowerOpElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PowerOp");
		private final RuleCall cQualOp_PowerTokParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//PowerOp hidden(WS, KW_NEWLINE):
		//	QualOp_PowerTok;
		public ParserRule getRule() { return rule; }

		//QualOp_PowerTok
		public RuleCall getQualOp_PowerTokParserRuleCall() { return cQualOp_PowerTokParserRuleCall; }
	}

	public class ArrowTokElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ArrowTok");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cKW_RARROWTerminalRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cKW_LARROWTerminalRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cKW_MAPSTARTerminalRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		/// * in Aldor grammar this is ArrowTok<tok> * / ArrowTok hidden(WS, KW_NEWLINE):
		//	KW_RARROW | KW_LARROW | KW_MAPSTAR;
		public ParserRule getRule() { return rule; }

		//KW_RARROW | KW_LARROW | KW_MAPSTAR
		public Alternatives getAlternatives() { return cAlternatives; }

		//KW_RARROW
		public RuleCall getKW_RARROWTerminalRuleCall_0() { return cKW_RARROWTerminalRuleCall_0; }

		//KW_LARROW
		public RuleCall getKW_LARROWTerminalRuleCall_1() { return cKW_LARROWTerminalRuleCall_1; }

		//KW_MAPSTAR
		public RuleCall getKW_MAPSTARTerminalRuleCall_2() { return cKW_MAPSTARTerminalRuleCall_2; }
	}

	public class LatticeTokElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "LatticeTok");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cKW_VEETerminalRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cKW_WEDGETerminalRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		/// * in Aldor grammar this is LatticeTok<tok> * / LatticeTok hidden(WS, KW_NEWLINE):
		//	KW_VEE | KW_WEDGE;
		public ParserRule getRule() { return rule; }

		//KW_VEE | KW_WEDGE
		public Alternatives getAlternatives() { return cAlternatives; }

		//KW_VEE
		public RuleCall getKW_VEETerminalRuleCall_0() { return cKW_VEETerminalRuleCall_0; }

		//KW_WEDGE
		public RuleCall getKW_WEDGETerminalRuleCall_1() { return cKW_WEDGETerminalRuleCall_1; }
	}

	public class RelationTokElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "RelationTok");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cKW_EQTerminalRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cKW_TILDEETerminalRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cKW_HATETerminalRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cKW_GETerminalRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cKW_GTTerminalRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		private final RuleCall cKW_2GTTerminalRuleCall_5 = (RuleCall)cAlternatives.eContents().get(5);
		private final RuleCall cKW_LETerminalRuleCall_6 = (RuleCall)cAlternatives.eContents().get(6);
		private final RuleCall cKW_LTTerminalRuleCall_7 = (RuleCall)cAlternatives.eContents().get(7);
		private final RuleCall cKW_2LTTerminalRuleCall_8 = (RuleCall)cAlternatives.eContents().get(8);
		private final Keyword cIsKeyword_9 = (Keyword)cAlternatives.eContents().get(9);
		private final Keyword cIsntKeyword_10 = (Keyword)cAlternatives.eContents().get(10);
		private final Keyword cCaseKeyword_11 = (Keyword)cAlternatives.eContents().get(11);
		
		/// * in Aldor grammar this is RelationTok<tok> * / RelationTok hidden(WS, KW_NEWLINE):
		//	KW_EQ | KW_TILDEE | KW_HATE | KW_GE | KW_GT | KW_2GT | KW_LE | KW_LT | KW_2LT | "is" | "isnt" | "case";
		public ParserRule getRule() { return rule; }

		//KW_EQ | KW_TILDEE | KW_HATE | KW_GE | KW_GT | KW_2GT | KW_LE | KW_LT | KW_2LT | "is" | "isnt" | "case"
		public Alternatives getAlternatives() { return cAlternatives; }

		//KW_EQ
		public RuleCall getKW_EQTerminalRuleCall_0() { return cKW_EQTerminalRuleCall_0; }

		//KW_TILDEE
		public RuleCall getKW_TILDEETerminalRuleCall_1() { return cKW_TILDEETerminalRuleCall_1; }

		//KW_HATE
		public RuleCall getKW_HATETerminalRuleCall_2() { return cKW_HATETerminalRuleCall_2; }

		//KW_GE
		public RuleCall getKW_GETerminalRuleCall_3() { return cKW_GETerminalRuleCall_3; }

		//KW_GT
		public RuleCall getKW_GTTerminalRuleCall_4() { return cKW_GTTerminalRuleCall_4; }

		//KW_2GT
		public RuleCall getKW_2GTTerminalRuleCall_5() { return cKW_2GTTerminalRuleCall_5; }

		//KW_LE
		public RuleCall getKW_LETerminalRuleCall_6() { return cKW_LETerminalRuleCall_6; }

		//KW_LT
		public RuleCall getKW_LTTerminalRuleCall_7() { return cKW_LTTerminalRuleCall_7; }

		//KW_2LT
		public RuleCall getKW_2LTTerminalRuleCall_8() { return cKW_2LTTerminalRuleCall_8; }

		//"is"
		public Keyword getIsKeyword_9() { return cIsKeyword_9; }

		//"isnt"
		public Keyword getIsntKeyword_10() { return cIsntKeyword_10; }

		//"case"
		public Keyword getCaseKeyword_11() { return cCaseKeyword_11; }
	}

	public class SegTokElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "SegTok");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cKW_2DOTTerminalRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final Keyword cByKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		
		/// * in Aldor grammar this is SegTok<tok> * / SegTok hidden(WS, KW_NEWLINE):
		//	KW_2DOT | "by";
		public ParserRule getRule() { return rule; }

		//KW_2DOT | "by"
		public Alternatives getAlternatives() { return cAlternatives; }

		//KW_2DOT
		public RuleCall getKW_2DOTTerminalRuleCall_0() { return cKW_2DOTTerminalRuleCall_0; }

		//"by"
		public Keyword getByKeyword_1() { return cByKeyword_1; }
	}

	public class PlusTokElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PlusTok");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cKW_PLUSTerminalRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cKW_MINUSTerminalRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cKW_PLUSMINUSTerminalRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		/// * in Aldor grammar this is PlusTok<tok> * / PlusTok hidden(WS, KW_NEWLINE):
		//	KW_PLUS | KW_MINUS | KW_PLUSMINUS;
		public ParserRule getRule() { return rule; }

		//KW_PLUS | KW_MINUS | KW_PLUSMINUS
		public Alternatives getAlternatives() { return cAlternatives; }

		//KW_PLUS
		public RuleCall getKW_PLUSTerminalRuleCall_0() { return cKW_PLUSTerminalRuleCall_0; }

		//KW_MINUS
		public RuleCall getKW_MINUSTerminalRuleCall_1() { return cKW_MINUSTerminalRuleCall_1; }

		//KW_PLUSMINUS
		public RuleCall getKW_PLUSMINUSTerminalRuleCall_2() { return cKW_PLUSMINUSTerminalRuleCall_2; }
	}

	public class QuotientTokElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "QuotientTok");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cModKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cQuoKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cRemKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		private final Keyword cExquoKeyword_3 = (Keyword)cAlternatives.eContents().get(3);
		
		/// * in Aldor grammar this is QuotientTok<tok> * / QuotientTok hidden(WS, KW_NEWLINE):
		//	"mod" | "quo" | "rem" | "exquo";
		public ParserRule getRule() { return rule; }

		//"mod" | "quo" | "rem" | "exquo"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"mod"
		public Keyword getModKeyword_0() { return cModKeyword_0; }

		//"quo"
		public Keyword getQuoKeyword_1() { return cQuoKeyword_1; }

		//"rem"
		public Keyword getRemKeyword_2() { return cRemKeyword_2; }

		//"exquo"
		public Keyword getExquoKeyword_3() { return cExquoKeyword_3; }
	}

	public class TimesTokElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "TimesTok");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cKW_STARTerminalRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cKW_SLASHTerminalRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cKW_BACKSLASHTerminalRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		/// * in Aldor grammar this is TimesTok<tok> * / TimesTok hidden(WS, KW_NEWLINE):
		//	KW_STAR | KW_SLASH | KW_BACKSLASH;
		public ParserRule getRule() { return rule; }

		//KW_STAR | KW_SLASH | KW_BACKSLASH
		public Alternatives getAlternatives() { return cAlternatives; }

		//KW_STAR
		public RuleCall getKW_STARTerminalRuleCall_0() { return cKW_STARTerminalRuleCall_0; }

		//KW_SLASH
		public RuleCall getKW_SLASHTerminalRuleCall_1() { return cKW_SLASHTerminalRuleCall_1; }

		//KW_BACKSLASH
		public RuleCall getKW_BACKSLASHTerminalRuleCall_2() { return cKW_BACKSLASHTerminalRuleCall_2; }
	}

	public class PowerTokElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PowerTok");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cKW_2STARTerminalRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cKW_HATTerminalRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		/// * in Aldor grammar this is PowerTok<tok> * / PowerTok hidden(WS, KW_NEWLINE):
		//	KW_2STAR | KW_HAT;
		public ParserRule getRule() { return rule; }

		//KW_2STAR | KW_HAT
		public Alternatives getAlternatives() { return cAlternatives; }

		//KW_2STAR
		public RuleCall getKW_2STARTerminalRuleCall_0() { return cKW_2STARTerminalRuleCall_0; }

		//KW_HAT
		public RuleCall getKW_HATTerminalRuleCall_1() { return cKW_HATTerminalRuleCall_1; }
	}

	public class ApplicationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Application");
		private final RuleCall cRightJuxtaposedParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		/// *
		// * Function Application
		// * We can express function application by using bracket notation like this:
		// * f(a1, ..., an)
		// * So the function is expressed as a prefix to its arguments.
		// * If there is only one argument then Aldor also allows us to express
		// * function application by using juxtaposed expressions.
		// * 
		// * There are two additional forms for specifying a prefix
		// * application to one argument: juxtaposition and an infix dot.
		// * 
		// * f a
		// * f.a
		// * 
		// * The second of these forms is completely equivalent to
		// * f(a); the first is equivalent in a free-standing occurrence
		// * but associates differently -- to the right, rather than
		// * the left:
		// * 
		// *  f a b c      -- is equivalent to (f (a (b c)))
		// *  f.a.b.c      -- is equivalent to (((f.a).b).c)
		// *  f(a)(b)(c)   -- is equivalent to (((f(a))(b))(c))
		// *
		// * / Application hidden(WS, KW_NEWLINE):
		//	RightJuxtaposed;
		public ParserRule getRule() { return rule; }

		//RightJuxtaposed
		public RuleCall getRightJuxtaposedParserRuleCall() { return cRightJuxtaposedParserRuleCall; }
	}

	public class RightJuxtaposedElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "RightJuxtaposed");
		private final RuleCall cJright_MoleculeParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		/// *
		// * implements 'function application' as described above including juxtaposition
		// * / RightJuxtaposed hidden(WS, KW_NEWLINE):
		//	Jright_Molecule;
		public ParserRule getRule() { return rule; }

		//Jright_Molecule
		public RuleCall getJright_MoleculeParserRuleCall() { return cJright_MoleculeParserRuleCall; }
	}

	public class LeftJuxtaposedElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "LeftJuxtaposed");
		private final RuleCall cJleft_MoleculeParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		/// * Molecule followed by 0 or more BlockEnclosures (bracketed terms)
		// * or variants on that theme.
		// * / LeftJuxtaposed hidden(WS, KW_NEWLINE):
		//	Jleft_Molecule;
		public ParserRule getRule() { return rule; }

		//Jleft_Molecule
		public RuleCall getJleft_MoleculeParserRuleCall() { return cJleft_MoleculeParserRuleCall; }
	}

	public class Jright_MoleculeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Jright_Molecule");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final RuleCall cJleft_MoleculeParserRuleCall_0_0 = (RuleCall)cGroup_0.eContents().get(0);
		private final Assignment cRightAssignment_0_1 = (Assignment)cGroup_0.eContents().get(1);
		private final RuleCall cRightJright_AtomParserRuleCall_0_1_0 = (RuleCall)cRightAssignment_0_1.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Keyword cNotKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cRightAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cRightJright_AtomParserRuleCall_1_1_0 = (RuleCall)cRightAssignment_1_1.eContents().get(0);
		
		/// * 
		// * implements 'function application' as described above including juxtaposition
		// *
		// * substituted version of axl.z code:
		// * Jright(H) : Jleft(H) | Jleft(H) Jright(Atom)
		// * | 'not' Jright(Atom)
		// * / Jright_Molecule hidden(WS, KW_NEWLINE):
		//	Jleft_Molecule right=Jright_Atom? | "not" right=Jright_Atom;
		public ParserRule getRule() { return rule; }

		//Jleft_Molecule right=Jright_Atom? | "not" right=Jright_Atom
		public Alternatives getAlternatives() { return cAlternatives; }

		//Jleft_Molecule right=Jright_Atom?
		public Group getGroup_0() { return cGroup_0; }

		//Jleft_Molecule
		public RuleCall getJleft_MoleculeParserRuleCall_0_0() { return cJleft_MoleculeParserRuleCall_0_0; }

		//right=Jright_Atom?
		public Assignment getRightAssignment_0_1() { return cRightAssignment_0_1; }

		//Jright_Atom
		public RuleCall getRightJright_AtomParserRuleCall_0_1_0() { return cRightJright_AtomParserRuleCall_0_1_0; }

		//"not" right=Jright_Atom
		public Group getGroup_1() { return cGroup_1; }

		//"not"
		public Keyword getNotKeyword_1_0() { return cNotKeyword_1_0; }

		//right=Jright_Atom
		public Assignment getRightAssignment_1_1() { return cRightAssignment_1_1; }

		//Jright_Atom
		public RuleCall getRightJright_AtomParserRuleCall_1_1_0() { return cRightJright_AtomParserRuleCall_1_1_0; }
	}

	public class Jright_AtomElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Jright_Atom");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final RuleCall cJleft_AtomParserRuleCall_0_0 = (RuleCall)cGroup_0.eContents().get(0);
		private final Assignment cRight2Assignment_0_1 = (Assignment)cGroup_0.eContents().get(1);
		private final RuleCall cRight2Jright_AtomParserRuleCall_0_1_0 = (RuleCall)cRight2Assignment_0_1.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Keyword cNotKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cRight2Assignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cRight2Jright_AtomParserRuleCall_1_1_0 = (RuleCall)cRight2Assignment_1_1.eContents().get(0);
		
		//Jright_Atom hidden(WS, KW_NEWLINE):
		//	Jleft_Atom right2=Jright_Atom? | "not" right2=Jright_Atom;
		public ParserRule getRule() { return rule; }

		//Jleft_Atom right2=Jright_Atom? | "not" right2=Jright_Atom
		public Alternatives getAlternatives() { return cAlternatives; }

		//Jleft_Atom right2=Jright_Atom?
		public Group getGroup_0() { return cGroup_0; }

		//Jleft_Atom
		public RuleCall getJleft_AtomParserRuleCall_0_0() { return cJleft_AtomParserRuleCall_0_0; }

		//right2=Jright_Atom?
		public Assignment getRight2Assignment_0_1() { return cRight2Assignment_0_1; }

		//Jright_Atom
		public RuleCall getRight2Jright_AtomParserRuleCall_0_1_0() { return cRight2Jright_AtomParserRuleCall_0_1_0; }

		//"not" right2=Jright_Atom
		public Group getGroup_1() { return cGroup_1; }

		//"not"
		public Keyword getNotKeyword_1_0() { return cNotKeyword_1_0; }

		//right2=Jright_Atom
		public Assignment getRight2Assignment_1_1() { return cRight2Assignment_1_1; }

		//Jright_Atom
		public RuleCall getRight2Jright_AtomParserRuleCall_1_1_0() { return cRight2Jright_AtomParserRuleCall_1_1_0; }
	}

	public class Jleft_MoleculeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Jleft_Molecule");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Keyword cNotKeyword_0_0 = (Keyword)cGroup_0.eContents().get(0);
		private final Assignment cBeAssignment_0_1 = (Assignment)cGroup_0.eContents().get(1);
		private final RuleCall cBeBlockEnclosureParserRuleCall_0_1_0 = (RuleCall)cBeAssignment_0_1.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Group cGroup_1_0 = (Group)cGroup_1.eContents().get(0);
		private final Assignment cMAssignment_1_0_0 = (Assignment)cGroup_1_0.eContents().get(0);
		private final RuleCall cMMoleculeParserRuleCall_1_0_0_0 = (RuleCall)cMAssignment_1_0_0.eContents().get(0);
		private final Assignment cBeAssignment_1_0_1 = (Assignment)cGroup_1_0.eContents().get(1);
		private final RuleCall cBeBlockEnclosureParserRuleCall_1_0_1_0 = (RuleCall)cBeAssignment_1_0_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cAlternatives.eContents().get(2);
		private final Assignment cMAssignment_2_0 = (Assignment)cGroup_2.eContents().get(0);
		private final RuleCall cMMoleculeParserRuleCall_2_0_0 = (RuleCall)cMAssignment_2_0.eContents().get(0);
		private final Group cGroup_2_1 = (Group)cGroup_2.eContents().get(1);
		private final RuleCall cKW_DOTTerminalRuleCall_2_1_0 = (RuleCall)cGroup_2_1.eContents().get(0);
		private final Assignment cBmAssignment_2_1_1 = (Assignment)cGroup_2_1.eContents().get(1);
		private final RuleCall cBmBlockMoleculeParserRuleCall_2_1_1_0 = (RuleCall)cBmAssignment_2_1_1.eContents().get(0);
		
		/// * Molecule followed by 0 or more BlockEnclosures (bracketed terms)
		// * or variants on that theme.
		// * 
		// * matches:
		// * - Molecule - no argument
		// * - 'not' BlockEnclosure - not has one argument
		// * - (*) BlockEnclosure
		// * - (*) '.' BlockMolecule
		// * 
		// * substituted version of axl.z code:
		// * Jleft(H) : H | 'not' BlockEnclosure
		// *              | Jleft(H) BlockEnclosure
		// *              | Jleft(H) KW_DOT BlockMolecule ;
		// * / Jleft_Molecule hidden(WS, KW_NEWLINE):
		//	"not" be+=BlockEnclosure | => (m=Molecule be+=BlockEnclosure*) | m=Molecule (KW_DOT bm+=BlockMolecule)*;
		public ParserRule getRule() { return rule; }

		//"not" be+=BlockEnclosure | => (m=Molecule be+=BlockEnclosure*) | m=Molecule (KW_DOT bm+=BlockMolecule)*
		public Alternatives getAlternatives() { return cAlternatives; }

		//"not" be+=BlockEnclosure
		public Group getGroup_0() { return cGroup_0; }

		//"not"
		public Keyword getNotKeyword_0_0() { return cNotKeyword_0_0; }

		//be+=BlockEnclosure
		public Assignment getBeAssignment_0_1() { return cBeAssignment_0_1; }

		//BlockEnclosure
		public RuleCall getBeBlockEnclosureParserRuleCall_0_1_0() { return cBeBlockEnclosureParserRuleCall_0_1_0; }

		//=> (m=Molecule be+=BlockEnclosure*)
		public Group getGroup_1() { return cGroup_1; }

		//m=Molecule be+=BlockEnclosure*
		public Group getGroup_1_0() { return cGroup_1_0; }

		//m=Molecule
		public Assignment getMAssignment_1_0_0() { return cMAssignment_1_0_0; }

		//Molecule
		public RuleCall getMMoleculeParserRuleCall_1_0_0_0() { return cMMoleculeParserRuleCall_1_0_0_0; }

		//be+=BlockEnclosure*
		public Assignment getBeAssignment_1_0_1() { return cBeAssignment_1_0_1; }

		//BlockEnclosure
		public RuleCall getBeBlockEnclosureParserRuleCall_1_0_1_0() { return cBeBlockEnclosureParserRuleCall_1_0_1_0; }

		//m=Molecule (KW_DOT bm+=BlockMolecule)*
		public Group getGroup_2() { return cGroup_2; }

		//m=Molecule
		public Assignment getMAssignment_2_0() { return cMAssignment_2_0; }

		//Molecule
		public RuleCall getMMoleculeParserRuleCall_2_0_0() { return cMMoleculeParserRuleCall_2_0_0; }

		//(KW_DOT bm+=BlockMolecule)*
		public Group getGroup_2_1() { return cGroup_2_1; }

		//KW_DOT
		public RuleCall getKW_DOTTerminalRuleCall_2_1_0() { return cKW_DOTTerminalRuleCall_2_1_0; }

		//bm+=BlockMolecule
		public Assignment getBmAssignment_2_1_1() { return cBmAssignment_2_1_1; }

		//BlockMolecule
		public RuleCall getBmBlockMoleculeParserRuleCall_2_1_1_0() { return cBmBlockMoleculeParserRuleCall_2_1_1_0; }
	}

	public class Jleft_AtomElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Jleft_Atom");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Keyword cNotKeyword_0_0 = (Keyword)cGroup_0.eContents().get(0);
		private final Assignment cBeAssignment_0_1 = (Assignment)cGroup_0.eContents().get(1);
		private final RuleCall cBeBlockEnclosureParserRuleCall_0_1_0 = (RuleCall)cBeAssignment_0_1.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Group cGroup_1_0 = (Group)cGroup_1.eContents().get(0);
		private final Assignment cAAssignment_1_0_0 = (Assignment)cGroup_1_0.eContents().get(0);
		private final RuleCall cAAtomParserRuleCall_1_0_0_0 = (RuleCall)cAAssignment_1_0_0.eContents().get(0);
		private final Assignment cBeAssignment_1_0_1 = (Assignment)cGroup_1_0.eContents().get(1);
		private final RuleCall cBeBlockEnclosureParserRuleCall_1_0_1_0 = (RuleCall)cBeAssignment_1_0_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cAlternatives.eContents().get(2);
		private final Assignment cAAssignment_2_0 = (Assignment)cGroup_2.eContents().get(0);
		private final RuleCall cAAtomParserRuleCall_2_0_0 = (RuleCall)cAAssignment_2_0.eContents().get(0);
		private final Group cGroup_2_1 = (Group)cGroup_2.eContents().get(1);
		private final RuleCall cKW_DOTTerminalRuleCall_2_1_0 = (RuleCall)cGroup_2_1.eContents().get(0);
		private final Assignment cBm4Assignment_2_1_1 = (Assignment)cGroup_2_1.eContents().get(1);
		private final RuleCall cBm4BlockMoleculeParserRuleCall_2_1_1_0 = (RuleCall)cBm4Assignment_2_1_1.eContents().get(0);
		
		/// * 
		// * matches:
		// * - Atom - no argument
		// * - 'not' BlockEnclosure - not has one argument
		// * - (*) BlockEnclosure
		// * - (*) '.' BlockMolecule
		// * 
		// * substituted version of axl.z code:
		// * Jleft(H) : H | 'not' BlockEnclosure
		// *              | Jleft(H) BlockEnclosure
		// *              | Jleft(H) KW_DOT BlockMolecule ;
		// * / Jleft_Atom hidden(WS, KW_NEWLINE):
		//	"not" be+=BlockEnclosure | => (a=Atom be+=BlockEnclosure*) | a=Atom (KW_DOT bm4+=BlockMolecule)*;
		public ParserRule getRule() { return rule; }

		//"not" be+=BlockEnclosure | => (a=Atom be+=BlockEnclosure*) | a=Atom (KW_DOT bm4+=BlockMolecule)*
		public Alternatives getAlternatives() { return cAlternatives; }

		//"not" be+=BlockEnclosure
		public Group getGroup_0() { return cGroup_0; }

		//"not"
		public Keyword getNotKeyword_0_0() { return cNotKeyword_0_0; }

		//be+=BlockEnclosure
		public Assignment getBeAssignment_0_1() { return cBeAssignment_0_1; }

		//BlockEnclosure
		public RuleCall getBeBlockEnclosureParserRuleCall_0_1_0() { return cBeBlockEnclosureParserRuleCall_0_1_0; }

		//=> (a=Atom be+=BlockEnclosure*)
		public Group getGroup_1() { return cGroup_1; }

		//a=Atom be+=BlockEnclosure*
		public Group getGroup_1_0() { return cGroup_1_0; }

		//a=Atom
		public Assignment getAAssignment_1_0_0() { return cAAssignment_1_0_0; }

		//Atom
		public RuleCall getAAtomParserRuleCall_1_0_0_0() { return cAAtomParserRuleCall_1_0_0_0; }

		//be+=BlockEnclosure*
		public Assignment getBeAssignment_1_0_1() { return cBeAssignment_1_0_1; }

		//BlockEnclosure
		public RuleCall getBeBlockEnclosureParserRuleCall_1_0_1_0() { return cBeBlockEnclosureParserRuleCall_1_0_1_0; }

		//a=Atom (KW_DOT bm4+=BlockMolecule)*
		public Group getGroup_2() { return cGroup_2; }

		//a=Atom
		public Assignment getAAssignment_2_0() { return cAAssignment_2_0; }

		//Atom
		public RuleCall getAAtomParserRuleCall_2_0_0() { return cAAtomParserRuleCall_2_0_0; }

		//(KW_DOT bm4+=BlockMolecule)*
		public Group getGroup_2_1() { return cGroup_2_1; }

		//KW_DOT
		public RuleCall getKW_DOTTerminalRuleCall_2_1_0() { return cKW_DOTTerminalRuleCall_2_1_0; }

		//bm4+=BlockMolecule
		public Assignment getBm4Assignment_2_1_1() { return cBm4Assignment_2_1_1; }

		//BlockMolecule
		public RuleCall getBm4BlockMoleculeParserRuleCall_2_1_1_0() { return cBm4BlockMoleculeParserRuleCall_2_1_1_0; }
	}

	public class MoleculeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Molecule");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cAtomParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cEnclosureParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		/// *
		// * Indivisible Expressions
		// * / Molecule hidden(WS, KW_NEWLINE):
		//	Atom | Enclosure;
		public ParserRule getRule() { return rule; }

		//=> Atom | Enclosure
		public Alternatives getAlternatives() { return cAlternatives; }

		//=> Atom
		public RuleCall getAtomParserRuleCall_0() { return cAtomParserRuleCall_0; }

		//Enclosure
		public RuleCall getEnclosureParserRuleCall_1() { return cEnclosureParserRuleCall_1; }
	}

	public class EnclosureElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Enclosure");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cParenedParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cBracketedParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cQuotedIdsParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		/// * expression in brackets parenthesis or quotes * / Enclosure hidden(WS, KW_NEWLINE):
		//	Parened | Bracketed | QuotedIds;
		public ParserRule getRule() { return rule; }

		//Parened | Bracketed | QuotedIds
		public Alternatives getAlternatives() { return cAlternatives; }

		//Parened
		public RuleCall getParenedParserRuleCall_0() { return cParenedParserRuleCall_0; }

		//Bracketed
		public RuleCall getBracketedParserRuleCall_1() { return cBracketedParserRuleCall_1; }

		//QuotedIds
		public RuleCall getQuotedIdsParserRuleCall_2() { return cQuotedIdsParserRuleCall_2; }
	}

	public class DeclMoleculeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "DeclMolecule");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Action cDeclMoleculeAction_0_0 = (Action)cGroup_0.eContents().get(0);
		private final Assignment cAAssignment_0_1 = (Assignment)cGroup_0.eContents().get(1);
		private final RuleCall cAApplicationParserRuleCall_0_1_0 = (RuleCall)cAAssignment_0_1.eContents().get(0);
		private final Assignment cBAssignment_1 = (Assignment)cAlternatives.eContents().get(1);
		private final RuleCall cBBlockParserRuleCall_1_0 = (RuleCall)cBAssignment_1.eContents().get(0);
		
		/// *
		// * function application, block or infixed
		// * follows 'add' or 'with'
		// * / DeclMolecule hidden(WS, KW_NEWLINE):
		//	{DeclMolecule} a=Application? | b=Block;
		public ParserRule getRule() { return rule; }

		//{DeclMolecule} a=Application? | b=Block
		public Alternatives getAlternatives() { return cAlternatives; }

		//{DeclMolecule} a=Application?
		public Group getGroup_0() { return cGroup_0; }

		//{DeclMolecule}
		public Action getDeclMoleculeAction_0_0() { return cDeclMoleculeAction_0_0; }

		//a=Application?
		public Assignment getAAssignment_0_1() { return cAAssignment_0_1; }

		//Application
		public RuleCall getAApplicationParserRuleCall_0_1_0() { return cAApplicationParserRuleCall_0_1_0; }

		//b=Block
		public Assignment getBAssignment_1() { return cBAssignment_1; }

		//Block
		public RuleCall getBBlockParserRuleCall_1_0() { return cBBlockParserRuleCall_1_0; }
	}

	public class BlockMoleculeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "BlockMolecule");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cAtomParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cEnclosureParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cBlockParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		/// * atom, enclosure: (....),[....],"...." or block {....}
		// * Used by Jleft_Molecule and Jleft_Atom
		// * / BlockMolecule hidden(WS, KW_NEWLINE):
		//	Atom | Enclosure | Block;
		public ParserRule getRule() { return rule; }

		//Atom | Enclosure | Block
		public Alternatives getAlternatives() { return cAlternatives; }

		//Atom
		public RuleCall getAtomParserRuleCall_0() { return cAtomParserRuleCall_0; }

		//Enclosure
		public RuleCall getEnclosureParserRuleCall_1() { return cEnclosureParserRuleCall_1; }

		//Block
		public RuleCall getBlockParserRuleCall_2() { return cBlockParserRuleCall_2; }
	}

	public class BlockEnclosureElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "BlockEnclosure");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cEnclosureParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cBlockParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		/// * enclosure: (....),[....],"...." or block {....} * / BlockEnclosure hidden(WS, KW_NEWLINE):
		//	Enclosure | Block;
		public ParserRule getRule() { return rule; }

		//Enclosure | Block
		public Alternatives getAlternatives() { return cAlternatives; }

		//Enclosure
		public RuleCall getEnclosureParserRuleCall_0() { return cEnclosureParserRuleCall_0; }

		//Block
		public RuleCall getBlockParserRuleCall_1() { return cBlockParserRuleCall_1; }
	}

	public class BlockElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Block");
		private final RuleCall cCurly_LabeledParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		/// * CurlyContents_Labeled inside curly brackets * / Block hidden(WS, KW_NEWLINE): // Piled(Expression)|
		//	Curly_Labeled;
		public ParserRule getRule() { return rule; }

		//// Piled(Expression)|
		//Curly_Labeled
		public RuleCall getCurly_LabeledParserRuleCall() { return cCurly_LabeledParserRuleCall; }
	}

	public class ParenedElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Parened");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cOpAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cOpKW_OPARENTerminalRuleCall_0_0 = (RuleCall)cOpAssignment_0.eContents().get(0);
		private final Assignment cEAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cEExpressionParserRuleCall_1_0 = (RuleCall)cEAssignment_1.eContents().get(0);
		private final RuleCall cKW_CPARENTerminalRuleCall_2 = (RuleCall)cGroup.eContents().get(2);
		
		/// * expression in parenthesis * / Parened hidden(WS, KW_NEWLINE):
		//	op=KW_OPAREN e=Expression? KW_CPAREN;
		public ParserRule getRule() { return rule; }

		//op=KW_OPAREN e=Expression? KW_CPAREN
		public Group getGroup() { return cGroup; }

		//op=KW_OPAREN
		public Assignment getOpAssignment_0() { return cOpAssignment_0; }

		//KW_OPAREN
		public RuleCall getOpKW_OPARENTerminalRuleCall_0_0() { return cOpKW_OPARENTerminalRuleCall_0_0; }

		//e=Expression?
		public Assignment getEAssignment_1() { return cEAssignment_1; }

		//Expression
		public RuleCall getEExpressionParserRuleCall_1_0() { return cEExpressionParserRuleCall_1_0; }

		//KW_CPAREN
		public RuleCall getKW_CPARENTerminalRuleCall_2() { return cKW_CPARENTerminalRuleCall_2; }
	}

	public class BracketedElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Bracketed");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cOpAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cOpKW_OBRACKTerminalRuleCall_0_0 = (RuleCall)cOpAssignment_0.eContents().get(0);
		private final Assignment cEAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cEExpressionParserRuleCall_1_0 = (RuleCall)cEAssignment_1.eContents().get(0);
		private final RuleCall cKW_CBRACKTerminalRuleCall_2 = (RuleCall)cGroup.eContents().get(2);
		
		/// * expression in brackets * / Bracketed hidden(WS, KW_NEWLINE):
		//	op=KW_OBRACK e=Expression? KW_CBRACK;
		public ParserRule getRule() { return rule; }

		//op=KW_OBRACK e=Expression? KW_CBRACK
		public Group getGroup() { return cGroup; }

		//op=KW_OBRACK
		public Assignment getOpAssignment_0() { return cOpAssignment_0; }

		//KW_OBRACK
		public RuleCall getOpKW_OBRACKTerminalRuleCall_0_0() { return cOpKW_OBRACKTerminalRuleCall_0_0; }

		//e=Expression?
		public Assignment getEAssignment_1() { return cEAssignment_1; }

		//Expression
		public RuleCall getEExpressionParserRuleCall_1_0() { return cEExpressionParserRuleCall_1_0; }

		//KW_CBRACK
		public RuleCall getKW_CBRACKTerminalRuleCall_2() { return cKW_CBRACKTerminalRuleCall_2; }
	}

	public class QuotedIdsElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "QuotedIds");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cQuotedIdsAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cOpAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cOpKW_QUOTETerminalRuleCall_1_0 = (RuleCall)cOpAssignment_1.eContents().get(0);
		private final Assignment cNAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cNNamesParserRuleCall_2_0 = (RuleCall)cNAssignment_2.eContents().get(0);
		private final RuleCall cKW_QUOTETerminalRuleCall_3 = (RuleCall)cGroup.eContents().get(3);
		
		/// * names in quotes * / QuotedIds hidden(WS, KW_NEWLINE):
		//	{QuotedIds} op=KW_QUOTE n=Names? KW_QUOTE;
		public ParserRule getRule() { return rule; }

		//{QuotedIds} op=KW_QUOTE n=Names? KW_QUOTE
		public Group getGroup() { return cGroup; }

		//{QuotedIds}
		public Action getQuotedIdsAction_0() { return cQuotedIdsAction_0; }

		//op=KW_QUOTE
		public Assignment getOpAssignment_1() { return cOpAssignment_1; }

		//KW_QUOTE
		public RuleCall getOpKW_QUOTETerminalRuleCall_1_0() { return cOpKW_QUOTETerminalRuleCall_1_0; }

		//n=Names?
		public Assignment getNAssignment_2() { return cNAssignment_2; }

		//Names
		public RuleCall getNNamesParserRuleCall_2_0() { return cNNamesParserRuleCall_2_0; }

		//KW_QUOTE
		public RuleCall getKW_QUOTETerminalRuleCall_3() { return cKW_QUOTETerminalRuleCall_3; }
	}

	public class NamesElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Names");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cFirstNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cFirstNameTK_IDTerminalRuleCall_0_0 = (RuleCall)cFirstNameAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final RuleCall cKW_COMMATerminalRuleCall_1_0 = (RuleCall)cGroup_1.eContents().get(0);
		private final Assignment cSubsequentNamesAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cSubsequentNamesTK_IDTerminalRuleCall_1_1_0 = (RuleCall)cSubsequentNamesAssignment_1_1.eContents().get(0);
		
		/// * names seperated by commas * / Names hidden(WS, KW_NEWLINE):
		//	firstName=TK_ID (KW_COMMA subsequentNames+=TK_ID)*;
		public ParserRule getRule() { return rule; }

		//firstName=TK_ID (KW_COMMA subsequentNames+=TK_ID)*
		public Group getGroup() { return cGroup; }

		//firstName=TK_ID
		public Assignment getFirstNameAssignment_0() { return cFirstNameAssignment_0; }

		//TK_ID
		public RuleCall getFirstNameTK_IDTerminalRuleCall_0_0() { return cFirstNameTK_IDTerminalRuleCall_0_0; }

		//(KW_COMMA subsequentNames+=TK_ID)*
		public Group getGroup_1() { return cGroup_1; }

		//KW_COMMA
		public RuleCall getKW_COMMATerminalRuleCall_1_0() { return cKW_COMMATerminalRuleCall_1_0; }

		//subsequentNames+=TK_ID
		public Assignment getSubsequentNamesAssignment_1_1() { return cSubsequentNamesAssignment_1_1; }

		//TK_ID
		public RuleCall getSubsequentNamesTK_IDTerminalRuleCall_1_1_0() { return cSubsequentNamesTK_IDTerminalRuleCall_1_1_0; }
	}

	public class AtomElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Atom");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cIdenAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final RuleCall cIdenIdParserRuleCall_0_0 = (RuleCall)cIdenAssignment_0.eContents().get(0);
		private final Assignment cLitAssignment_1 = (Assignment)cAlternatives.eContents().get(1);
		private final RuleCall cLitLiteralParserRuleCall_1_0 = (RuleCall)cLitAssignment_1.eContents().get(0);
		
		/// *
		// * identifier or literal
		// * / Atom hidden(WS, KW_NEWLINE):
		//	iden=Id | lit=Literal;
		public ParserRule getRule() { return rule; }

		//iden=Id | lit=Literal
		public Alternatives getAlternatives() { return cAlternatives; }

		//iden=Id
		public Assignment getIdenAssignment_0() { return cIdenAssignment_0; }

		//Id
		public RuleCall getIdenIdParserRuleCall_0_0() { return cIdenIdParserRuleCall_0_0; }

		//lit=Literal
		public Assignment getLitAssignment_1() { return cLitAssignment_1; }

		//Literal
		public RuleCall getLitLiteralParserRuleCall_1_0() { return cLitLiteralParserRuleCall_1_0; }
	}

	public class NameElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Name");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Action cNameAction_0_0 = (Action)cGroup_0.eContents().get(0);
		private final Assignment cNameAssignment_0_1 = (Assignment)cGroup_0.eContents().get(1);
		private final RuleCall cNameIdParserRuleCall_0_1_0 = (RuleCall)cNameAssignment_0_1.eContents().get(0);
		private final Assignment cNoAssignment_1 = (Assignment)cAlternatives.eContents().get(1);
		private final RuleCall cNoNakedOpParserRuleCall_1_0 = (RuleCall)cNoAssignment_1.eContents().get(0);
		
		/// * called from Flow_AnyStatement and Flow_BalStatement * / Name hidden(WS, KW_NEWLINE):
		//	{Name} name=Id | no=NakedOp;
		public ParserRule getRule() { return rule; }

		//{Name} name=Id | no=NakedOp
		public Alternatives getAlternatives() { return cAlternatives; }

		//{Name} name=Id
		public Group getGroup_0() { return cGroup_0; }

		//{Name}
		public Action getNameAction_0_0() { return cNameAction_0_0; }

		//name=Id
		public Assignment getNameAssignment_0_1() { return cNameAssignment_0_1; }

		//Id
		public RuleCall getNameIdParserRuleCall_0_1_0() { return cNameIdParserRuleCall_0_1_0; }

		//no=NakedOp
		public Assignment getNoAssignment_1() { return cNoAssignment_1; }

		//NakedOp
		public RuleCall getNoNakedOpParserRuleCall_1_0() { return cNoNakedOpParserRuleCall_1_0; }
	}

	public class IdElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Id");
		private final Assignment cNameAssignment = (Assignment)rule.eContents().get(1);
		private final Alternatives cNameAlternatives_0 = (Alternatives)cNameAssignment.eContents().get(0);
		private final RuleCall cNameTK_IDTerminalRuleCall_0_0 = (RuleCall)cNameAlternatives_0.eContents().get(0);
		private final RuleCall cNameKW_SHARPTerminalRuleCall_0_1 = (RuleCall)cNameAlternatives_0.eContents().get(1);
		private final RuleCall cNameKW_TILDETerminalRuleCall_0_2 = (RuleCall)cNameAlternatives_0.eContents().get(2);
		
		/// * original Aldor grammar uses abNewOfToken which is defined
		// * in Aldor file absyn.c: Abstract syntax construction and
		// * manipulation.
		// * / Id hidden(WS, KW_NEWLINE):
		//	name=(TK_ID | KW_SHARP | KW_TILDE);
		public ParserRule getRule() { return rule; }

		//name=(TK_ID | KW_SHARP | KW_TILDE)
		public Assignment getNameAssignment() { return cNameAssignment; }

		//TK_ID | KW_SHARP | KW_TILDE
		public Alternatives getNameAlternatives_0() { return cNameAlternatives_0; }

		//TK_ID
		public RuleCall getNameTK_IDTerminalRuleCall_0_0() { return cNameTK_IDTerminalRuleCall_0_0; }

		//KW_SHARP
		public RuleCall getNameKW_SHARPTerminalRuleCall_0_1() { return cNameKW_SHARPTerminalRuleCall_0_1; }

		//KW_TILDE
		public RuleCall getNameKW_TILDETerminalRuleCall_0_2() { return cNameKW_TILDETerminalRuleCall_0_2; }
	}

	public class LiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Literal");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Group cGroup_0_0 = (Group)cGroup_0.eContents().get(0);
		private final Group cGroup_0_0_0 = (Group)cGroup_0_0.eContents().get(0);
		private final RuleCall cTK_INTTerminalRuleCall_0_0_0_0 = (RuleCall)cGroup_0_0_0.eContents().get(0);
		private final RuleCall cKW_DOTTerminalRuleCall_0_0_0_1 = (RuleCall)cGroup_0_0_0.eContents().get(1);
		private final RuleCall cTK_FLOATTerminalRuleCall_0_0_1 = (RuleCall)cGroup_0_0.eContents().get(1);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Group cGroup_1_0 = (Group)cGroup_1.eContents().get(0);
		private final Group cGroup_1_0_0 = (Group)cGroup_1_0.eContents().get(0);
		private final RuleCall cTK_INTTerminalRuleCall_1_0_0_0 = (RuleCall)cGroup_1_0_0.eContents().get(0);
		private final RuleCall cKW_DOTTerminalRuleCall_1_0_0_1 = (RuleCall)cGroup_1_0_0.eContents().get(1);
		private final RuleCall cTK_INTTerminalRuleCall_1_1 = (RuleCall)cGroup_1.eContents().get(1);
		private final RuleCall cTK_STRINGTerminalRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		/// * string, integer or float literal * / Literal hidden(WS, KW_NEWLINE): // example 2.4e5 or 2e5
		//	=> ((TK_INT KW_DOT)? TK_FLOAT) // example 2.4 or 2
		//	| => (TK_INT KW_DOT)? TK_INT | // example "abc"
		//	TK_STRING;
		public ParserRule getRule() { return rule; }

		//// example 2.4e5 or 2e5
		//=> ((TK_INT KW_DOT)? TK_FLOAT) // example 2.4 or 2
		//| => (TK_INT KW_DOT)? TK_INT | // example "abc"
		//TK_STRING
		public Alternatives getAlternatives() { return cAlternatives; }

		//// example 2.4e5 or 2e5
		//=> ((TK_INT KW_DOT)? TK_FLOAT)
		public Group getGroup_0() { return cGroup_0; }

		//(TK_INT KW_DOT)? TK_FLOAT
		public Group getGroup_0_0() { return cGroup_0_0; }

		//(TK_INT KW_DOT)?
		public Group getGroup_0_0_0() { return cGroup_0_0_0; }

		//TK_INT
		public RuleCall getTK_INTTerminalRuleCall_0_0_0_0() { return cTK_INTTerminalRuleCall_0_0_0_0; }

		//KW_DOT
		public RuleCall getKW_DOTTerminalRuleCall_0_0_0_1() { return cKW_DOTTerminalRuleCall_0_0_0_1; }

		//TK_FLOAT
		public RuleCall getTK_FLOATTerminalRuleCall_0_0_1() { return cTK_FLOATTerminalRuleCall_0_0_1; }

		//=> (TK_INT KW_DOT)? TK_INT
		public Group getGroup_1() { return cGroup_1; }

		//=> (TK_INT KW_DOT)?
		public Group getGroup_1_0() { return cGroup_1_0; }

		//TK_INT KW_DOT
		public Group getGroup_1_0_0() { return cGroup_1_0_0; }

		//TK_INT
		public RuleCall getTK_INTTerminalRuleCall_1_0_0_0() { return cTK_INTTerminalRuleCall_1_0_0_0; }

		//KW_DOT
		public RuleCall getKW_DOTTerminalRuleCall_1_0_0_1() { return cKW_DOTTerminalRuleCall_1_0_0_1; }

		//TK_INT
		public RuleCall getTK_INTTerminalRuleCall_1_1() { return cTK_INTTerminalRuleCall_1_1; }

		//// example "abc"
		//TK_STRING
		public RuleCall getTK_STRINGTerminalRuleCall_2() { return cTK_STRINGTerminalRuleCall_2; }
	}

	public class UnqualOp_ArrowTokElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "UnqualOp_ArrowTok");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cArrowTokParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Action cArrowTokAction_1 = (Action)cGroup.eContents().get(1);
		
		/// *
		// * Meta-rules
		// * / / * Substituted Rules in Xtext:
		// * UnqualOp(ArrowTok)
		// * UnqualOp(LatticeTok)
		// * UnqualOp(RelationTok)
		// * UnqualOp(SegTok)
		// * UnqualOp(PlusTok)
		// * UnqualOp(QuotientTok)
		// * UnqualOp(TimesTok)
		// * UnqualOp(PowerTok)
		// * UnqualOp(op)
		// * : op
		// * { $$ = abNewOfToken(AB_Id, $1); }
		// * ;
		// * / UnqualOp_ArrowTok hidden(WS, KW_NEWLINE):
		//	ArrowTok {ArrowTok};
		public ParserRule getRule() { return rule; }

		//ArrowTok {ArrowTok}
		public Group getGroup() { return cGroup; }

		//ArrowTok
		public RuleCall getArrowTokParserRuleCall_0() { return cArrowTokParserRuleCall_0; }

		//{ArrowTok}
		public Action getArrowTokAction_1() { return cArrowTokAction_1; }
	}

	public class UnqualOp_LatticeTokElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "UnqualOp_LatticeTok");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cLatticeTokParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Action cLatticeTokAction_1 = (Action)cGroup.eContents().get(1);
		
		//UnqualOp_LatticeTok hidden(WS, KW_NEWLINE):
		//	LatticeTok {LatticeTok};
		public ParserRule getRule() { return rule; }

		//LatticeTok {LatticeTok}
		public Group getGroup() { return cGroup; }

		//LatticeTok
		public RuleCall getLatticeTokParserRuleCall_0() { return cLatticeTokParserRuleCall_0; }

		//{LatticeTok}
		public Action getLatticeTokAction_1() { return cLatticeTokAction_1; }
	}

	public class UnqualOp_RelationTokElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "UnqualOp_RelationTok");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cRelationTokParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Action cRelationTokAction_1 = (Action)cGroup.eContents().get(1);
		
		//UnqualOp_RelationTok hidden(WS, KW_NEWLINE):
		//	RelationTok {RelationTok};
		public ParserRule getRule() { return rule; }

		//RelationTok {RelationTok}
		public Group getGroup() { return cGroup; }

		//RelationTok
		public RuleCall getRelationTokParserRuleCall_0() { return cRelationTokParserRuleCall_0; }

		//{RelationTok}
		public Action getRelationTokAction_1() { return cRelationTokAction_1; }
	}

	public class UnqualOp_SegTokElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "UnqualOp_SegTok");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cSegTokParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Action cSegTokAction_1 = (Action)cGroup.eContents().get(1);
		
		//UnqualOp_SegTok hidden(WS, KW_NEWLINE):
		//	SegTok {SegTok};
		public ParserRule getRule() { return rule; }

		//SegTok {SegTok}
		public Group getGroup() { return cGroup; }

		//SegTok
		public RuleCall getSegTokParserRuleCall_0() { return cSegTokParserRuleCall_0; }

		//{SegTok}
		public Action getSegTokAction_1() { return cSegTokAction_1; }
	}

	public class UnqualOp_PlusTokElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "UnqualOp_PlusTok");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cPlusTokParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Action cPlusTokAction_1 = (Action)cGroup.eContents().get(1);
		
		//UnqualOp_PlusTok hidden(WS, KW_NEWLINE):
		//	PlusTok {PlusTok};
		public ParserRule getRule() { return rule; }

		//PlusTok {PlusTok}
		public Group getGroup() { return cGroup; }

		//PlusTok
		public RuleCall getPlusTokParserRuleCall_0() { return cPlusTokParserRuleCall_0; }

		//{PlusTok}
		public Action getPlusTokAction_1() { return cPlusTokAction_1; }
	}

	public class UnqualOp_QuotientTokElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "UnqualOp_QuotientTok");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cQuotientTokParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Action cQuotientTokAction_1 = (Action)cGroup.eContents().get(1);
		
		//UnqualOp_QuotientTok hidden(WS, KW_NEWLINE):
		//	QuotientTok {QuotientTok};
		public ParserRule getRule() { return rule; }

		//QuotientTok {QuotientTok}
		public Group getGroup() { return cGroup; }

		//QuotientTok
		public RuleCall getQuotientTokParserRuleCall_0() { return cQuotientTokParserRuleCall_0; }

		//{QuotientTok}
		public Action getQuotientTokAction_1() { return cQuotientTokAction_1; }
	}

	public class UnqualOp_TimesTokElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "UnqualOp_TimesTok");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cTimesTokParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Action cTimesTokAction_1 = (Action)cGroup.eContents().get(1);
		
		//UnqualOp_TimesTok hidden(WS, KW_NEWLINE):
		//	TimesTok {TimesTok};
		public ParserRule getRule() { return rule; }

		//TimesTok {TimesTok}
		public Group getGroup() { return cGroup; }

		//TimesTok
		public RuleCall getTimesTokParserRuleCall_0() { return cTimesTokParserRuleCall_0; }

		//{TimesTok}
		public Action getTimesTokAction_1() { return cTimesTokAction_1; }
	}

	public class UnqualOp_PowerTokElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "UnqualOp_PowerTok");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cPowerTokParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Action cPowerTokAction_1 = (Action)cGroup.eContents().get(1);
		
		//UnqualOp_PowerTok hidden(WS, KW_NEWLINE):
		//	PowerTok {PowerTok};
		public ParserRule getRule() { return rule; }

		//PowerTok {PowerTok}
		public Group getGroup() { return cGroup; }

		//PowerTok
		public RuleCall getPowerTokParserRuleCall_0() { return cPowerTokParserRuleCall_0; }

		//{PowerTok}
		public Action getPowerTokAction_1() { return cPowerTokAction_1; }
	}

	public class QualOp_ArrowTokElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "QualOp_ArrowTok");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cQualOp_ArrowTokAction_0 = (Action)cGroup.eContents().get(0);
		private final RuleCall cArrowTokParserRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Group cGroup_2_0 = (Group)cGroup_2.eContents().get(0);
		private final RuleCall cKW_DOLLARTerminalRuleCall_2_0_0 = (RuleCall)cGroup_2_0.eContents().get(0);
		private final Assignment cOqtAssignment_2_0_1 = (Assignment)cGroup_2_0.eContents().get(1);
		private final RuleCall cOqtOpQualTailParserRuleCall_2_0_1_0 = (RuleCall)cOqtAssignment_2_0_1.eContents().get(0);
		
		/// * Substituted Rules in Xtext:
		// * QualOp(ArrowTok)
		// * QualOp(LatticeTok)
		// * QualOp(RelationTok)
		// * QualOp(SegTok)
		// * QualOp(PlusTok)
		// * QualOp(QuotientTok)
		// * QualOp(TimesTok)
		// * QualOp(PowerTok)
		// * QualOp(op)
		// * : op
		// * { $$ = abNewOfToken(AB_Id, $1); }
		// * | op KW_DOLLAR OpQualTail
		// * { $$ = abNewQualify(TPOS($1), abNewOfToken(AB_Id, $1), $3); }
		// * ;
		// * / QualOp_ArrowTok hidden(WS, KW_NEWLINE):
		//	{QualOp_ArrowTok} ArrowTok => (KW_DOLLAR oqt=OpQualTail)?;
		public ParserRule getRule() { return rule; }

		//{QualOp_ArrowTok} ArrowTok => (KW_DOLLAR oqt=OpQualTail)?
		public Group getGroup() { return cGroup; }

		//{QualOp_ArrowTok}
		public Action getQualOp_ArrowTokAction_0() { return cQualOp_ArrowTokAction_0; }

		//ArrowTok
		public RuleCall getArrowTokParserRuleCall_1() { return cArrowTokParserRuleCall_1; }

		//=> (KW_DOLLAR oqt=OpQualTail)?
		public Group getGroup_2() { return cGroup_2; }

		//KW_DOLLAR oqt=OpQualTail
		public Group getGroup_2_0() { return cGroup_2_0; }

		//KW_DOLLAR
		public RuleCall getKW_DOLLARTerminalRuleCall_2_0_0() { return cKW_DOLLARTerminalRuleCall_2_0_0; }

		//oqt=OpQualTail
		public Assignment getOqtAssignment_2_0_1() { return cOqtAssignment_2_0_1; }

		//OpQualTail
		public RuleCall getOqtOpQualTailParserRuleCall_2_0_1_0() { return cOqtOpQualTailParserRuleCall_2_0_1_0; }
	}

	public class QualOp_LatticeTokElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "QualOp_LatticeTok");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cQualOp_LatticeTokAction_0 = (Action)cGroup.eContents().get(0);
		private final RuleCall cLatticeTokParserRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Group cGroup_2_0 = (Group)cGroup_2.eContents().get(0);
		private final RuleCall cKW_DOLLARTerminalRuleCall_2_0_0 = (RuleCall)cGroup_2_0.eContents().get(0);
		private final Assignment cOqtAssignment_2_0_1 = (Assignment)cGroup_2_0.eContents().get(1);
		private final RuleCall cOqtOpQualTailParserRuleCall_2_0_1_0 = (RuleCall)cOqtAssignment_2_0_1.eContents().get(0);
		
		//QualOp_LatticeTok hidden(WS, KW_NEWLINE):
		//	{QualOp_LatticeTok} LatticeTok => (KW_DOLLAR oqt=OpQualTail)?;
		public ParserRule getRule() { return rule; }

		//{QualOp_LatticeTok} LatticeTok => (KW_DOLLAR oqt=OpQualTail)?
		public Group getGroup() { return cGroup; }

		//{QualOp_LatticeTok}
		public Action getQualOp_LatticeTokAction_0() { return cQualOp_LatticeTokAction_0; }

		//LatticeTok
		public RuleCall getLatticeTokParserRuleCall_1() { return cLatticeTokParserRuleCall_1; }

		//=> (KW_DOLLAR oqt=OpQualTail)?
		public Group getGroup_2() { return cGroup_2; }

		//KW_DOLLAR oqt=OpQualTail
		public Group getGroup_2_0() { return cGroup_2_0; }

		//KW_DOLLAR
		public RuleCall getKW_DOLLARTerminalRuleCall_2_0_0() { return cKW_DOLLARTerminalRuleCall_2_0_0; }

		//oqt=OpQualTail
		public Assignment getOqtAssignment_2_0_1() { return cOqtAssignment_2_0_1; }

		//OpQualTail
		public RuleCall getOqtOpQualTailParserRuleCall_2_0_1_0() { return cOqtOpQualTailParserRuleCall_2_0_1_0; }
	}

	public class QualOp_RelationTokElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "QualOp_RelationTok");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cQualOp_RelationTokAction_0 = (Action)cGroup.eContents().get(0);
		private final RuleCall cRelationTokParserRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Assignment cOpAssignment_2_0 = (Assignment)cGroup_2.eContents().get(0);
		private final RuleCall cOpKW_DOLLARTerminalRuleCall_2_0_0 = (RuleCall)cOpAssignment_2_0.eContents().get(0);
		private final Assignment cOqtAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cOqtOpQualTailParserRuleCall_2_1_0 = (RuleCall)cOqtAssignment_2_1.eContents().get(0);
		
		/// *InfixedExpr has non-LL(*) decision due to recursive rule
		// * invocations reachable from alts 1,2.  Resolve by left-factoring
		// * or using syntactic predicates or using backtrack=true option.
		// * 
		// * RelationTok is KW_EQ | KW_TILDEE | KW_HATE |
		// * KW_GE | KW_GT | KW_2GT |
		// * KW_LE | KW_LT | KW_2LT |
		// * 'is' | 'isnt' | 'case' ;
		// * / QualOp_RelationTok hidden(WS, KW_NEWLINE): //	'temp99'
		//	{QualOp_RelationTok} RelationTok (op+=KW_DOLLAR oqt=OpQualTail)?;
		public ParserRule getRule() { return rule; }

		////	'temp99'
		//{QualOp_RelationTok} RelationTok (op+=KW_DOLLAR oqt=OpQualTail)?
		public Group getGroup() { return cGroup; }

		////	'temp99'
		//{QualOp_RelationTok}
		public Action getQualOp_RelationTokAction_0() { return cQualOp_RelationTokAction_0; }

		//RelationTok
		public RuleCall getRelationTokParserRuleCall_1() { return cRelationTokParserRuleCall_1; }

		//(op+=KW_DOLLAR oqt=OpQualTail)?
		public Group getGroup_2() { return cGroup_2; }

		//op+=KW_DOLLAR
		public Assignment getOpAssignment_2_0() { return cOpAssignment_2_0; }

		//KW_DOLLAR
		public RuleCall getOpKW_DOLLARTerminalRuleCall_2_0_0() { return cOpKW_DOLLARTerminalRuleCall_2_0_0; }

		//oqt=OpQualTail
		public Assignment getOqtAssignment_2_1() { return cOqtAssignment_2_1; }

		//OpQualTail
		public RuleCall getOqtOpQualTailParserRuleCall_2_1_0() { return cOqtOpQualTailParserRuleCall_2_1_0; }
	}

	public class QualOp_SegTokElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "QualOp_SegTok");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cQualOp_SegTokAction_0 = (Action)cGroup.eContents().get(0);
		private final RuleCall cSegTokParserRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final RuleCall cKW_DOLLARTerminalRuleCall_2_0 = (RuleCall)cGroup_2.eContents().get(0);
		private final Assignment cOqtAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cOqtOpQualTailParserRuleCall_2_1_0 = (RuleCall)cOqtAssignment_2_1.eContents().get(0);
		
		//QualOp_SegTok hidden(WS, KW_NEWLINE):
		//	{QualOp_SegTok} SegTok (KW_DOLLAR oqt=OpQualTail)?;
		public ParserRule getRule() { return rule; }

		//{QualOp_SegTok} SegTok (KW_DOLLAR oqt=OpQualTail)?
		public Group getGroup() { return cGroup; }

		//{QualOp_SegTok}
		public Action getQualOp_SegTokAction_0() { return cQualOp_SegTokAction_0; }

		//SegTok
		public RuleCall getSegTokParserRuleCall_1() { return cSegTokParserRuleCall_1; }

		//(KW_DOLLAR oqt=OpQualTail)?
		public Group getGroup_2() { return cGroup_2; }

		//KW_DOLLAR
		public RuleCall getKW_DOLLARTerminalRuleCall_2_0() { return cKW_DOLLARTerminalRuleCall_2_0; }

		//oqt=OpQualTail
		public Assignment getOqtAssignment_2_1() { return cOqtAssignment_2_1; }

		//OpQualTail
		public RuleCall getOqtOpQualTailParserRuleCall_2_1_0() { return cOqtOpQualTailParserRuleCall_2_1_0; }
	}

	public class QualOp_PlusTokElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "QualOp_PlusTok");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cQualOp_PlusTokAction_0 = (Action)cGroup.eContents().get(0);
		private final RuleCall cPlusTokParserRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final RuleCall cKW_DOLLARTerminalRuleCall_2_0 = (RuleCall)cGroup_2.eContents().get(0);
		private final Assignment cOqtAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cOqtOpQualTailParserRuleCall_2_1_0 = (RuleCall)cOqtAssignment_2_1.eContents().get(0);
		
		//QualOp_PlusTok hidden(WS, KW_NEWLINE):
		//	{QualOp_PlusTok} PlusTok (KW_DOLLAR oqt=OpQualTail)?;
		public ParserRule getRule() { return rule; }

		//{QualOp_PlusTok} PlusTok (KW_DOLLAR oqt=OpQualTail)?
		public Group getGroup() { return cGroup; }

		//{QualOp_PlusTok}
		public Action getQualOp_PlusTokAction_0() { return cQualOp_PlusTokAction_0; }

		//PlusTok
		public RuleCall getPlusTokParserRuleCall_1() { return cPlusTokParserRuleCall_1; }

		//(KW_DOLLAR oqt=OpQualTail)?
		public Group getGroup_2() { return cGroup_2; }

		//KW_DOLLAR
		public RuleCall getKW_DOLLARTerminalRuleCall_2_0() { return cKW_DOLLARTerminalRuleCall_2_0; }

		//oqt=OpQualTail
		public Assignment getOqtAssignment_2_1() { return cOqtAssignment_2_1; }

		//OpQualTail
		public RuleCall getOqtOpQualTailParserRuleCall_2_1_0() { return cOqtOpQualTailParserRuleCall_2_1_0; }
	}

	public class QualOp_QuotientTokElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "QualOp_QuotientTok");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cQualOp_QuotientTokAction_0 = (Action)cGroup.eContents().get(0);
		private final RuleCall cQuotientTokParserRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final RuleCall cKW_DOLLARTerminalRuleCall_2_0 = (RuleCall)cGroup_2.eContents().get(0);
		private final Assignment cOqtAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cOqtOpQualTailParserRuleCall_2_1_0 = (RuleCall)cOqtAssignment_2_1.eContents().get(0);
		
		//QualOp_QuotientTok hidden(WS, KW_NEWLINE):
		//	{QualOp_QuotientTok} QuotientTok (KW_DOLLAR oqt=OpQualTail)?;
		public ParserRule getRule() { return rule; }

		//{QualOp_QuotientTok} QuotientTok (KW_DOLLAR oqt=OpQualTail)?
		public Group getGroup() { return cGroup; }

		//{QualOp_QuotientTok}
		public Action getQualOp_QuotientTokAction_0() { return cQualOp_QuotientTokAction_0; }

		//QuotientTok
		public RuleCall getQuotientTokParserRuleCall_1() { return cQuotientTokParserRuleCall_1; }

		//(KW_DOLLAR oqt=OpQualTail)?
		public Group getGroup_2() { return cGroup_2; }

		//KW_DOLLAR
		public RuleCall getKW_DOLLARTerminalRuleCall_2_0() { return cKW_DOLLARTerminalRuleCall_2_0; }

		//oqt=OpQualTail
		public Assignment getOqtAssignment_2_1() { return cOqtAssignment_2_1; }

		//OpQualTail
		public RuleCall getOqtOpQualTailParserRuleCall_2_1_0() { return cOqtOpQualTailParserRuleCall_2_1_0; }
	}

	public class QualOp_TimesTokElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "QualOp_TimesTok");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cQualOp_TimesTokAction_0 = (Action)cGroup.eContents().get(0);
		private final RuleCall cTimesTokParserRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final RuleCall cKW_DOLLARTerminalRuleCall_2_0 = (RuleCall)cGroup_2.eContents().get(0);
		private final Assignment cOqtAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cOqtOpQualTailParserRuleCall_2_1_0 = (RuleCall)cOqtAssignment_2_1.eContents().get(0);
		
		//QualOp_TimesTok hidden(WS, KW_NEWLINE):
		//	{QualOp_TimesTok} TimesTok (KW_DOLLAR oqt=OpQualTail)?;
		public ParserRule getRule() { return rule; }

		//{QualOp_TimesTok} TimesTok (KW_DOLLAR oqt=OpQualTail)?
		public Group getGroup() { return cGroup; }

		//{QualOp_TimesTok}
		public Action getQualOp_TimesTokAction_0() { return cQualOp_TimesTokAction_0; }

		//TimesTok
		public RuleCall getTimesTokParserRuleCall_1() { return cTimesTokParserRuleCall_1; }

		//(KW_DOLLAR oqt=OpQualTail)?
		public Group getGroup_2() { return cGroup_2; }

		//KW_DOLLAR
		public RuleCall getKW_DOLLARTerminalRuleCall_2_0() { return cKW_DOLLARTerminalRuleCall_2_0; }

		//oqt=OpQualTail
		public Assignment getOqtAssignment_2_1() { return cOqtAssignment_2_1; }

		//OpQualTail
		public RuleCall getOqtOpQualTailParserRuleCall_2_1_0() { return cOqtOpQualTailParserRuleCall_2_1_0; }
	}

	public class QualOp_PowerTokElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "QualOp_PowerTok");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cQualOp_PowerTokAction_0 = (Action)cGroup.eContents().get(0);
		private final RuleCall cPowerTokParserRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final RuleCall cKW_DOLLARTerminalRuleCall_2_0 = (RuleCall)cGroup_2.eContents().get(0);
		private final Assignment cOqtAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cOqtOpQualTailParserRuleCall_2_1_0 = (RuleCall)cOqtAssignment_2_1.eContents().get(0);
		
		//QualOp_PowerTok hidden(WS, KW_NEWLINE):
		//	{QualOp_PowerTok} PowerTok (KW_DOLLAR oqt=OpQualTail)?;
		public ParserRule getRule() { return rule; }

		//{QualOp_PowerTok} PowerTok (KW_DOLLAR oqt=OpQualTail)?
		public Group getGroup() { return cGroup; }

		//{QualOp_PowerTok}
		public Action getQualOp_PowerTokAction_0() { return cQualOp_PowerTokAction_0; }

		//PowerTok
		public RuleCall getPowerTokParserRuleCall_1() { return cPowerTokParserRuleCall_1; }

		//(KW_DOLLAR oqt=OpQualTail)?
		public Group getGroup_2() { return cGroup_2; }

		//KW_DOLLAR
		public RuleCall getKW_DOLLARTerminalRuleCall_2_0() { return cKW_DOLLARTerminalRuleCall_2_0; }

		//oqt=OpQualTail
		public Assignment getOqtAssignment_2_1() { return cOqtAssignment_2_1; }

		//OpQualTail
		public RuleCall getOqtOpQualTailParserRuleCall_2_1_0() { return cOqtOpQualTailParserRuleCall_2_1_0; }
	}

	public class PreDocumentElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PreDocument");
		private final RuleCall cTK_PREDOCTerminalRuleCall = (RuleCall)rule.eContents().get(1);
		
		/// * ++ Doc. * / / * Substituted Rules in Xtext:
		// * E is E from PileContents(E)
		// * / //Doc(E)
		////: PreDocument E PostDocument
		////{
		////$$ = $2;
		////if($3) $$ = abNewDocumented(APOS($3),$$,$3);
		////if($1) $$ = abNewDocumented(APOS($$),$$,$1);
		////}
		////;
		////PreDocument hidden(WS,KW_NEWLINE):
		////  PreDocumentList
		////;
		////PostDocument hidden(WS,KW_NEWLINE):
		////  PostDocumentList
		////;
		/// * list of lines starting with -- * / PreDocument hidden(WS, KW_NEWLINE):
		//	TK_PREDOC*;
		public ParserRule getRule() { return rule; }

		//TK_PREDOC*
		public RuleCall getTK_PREDOCTerminalRuleCall() { return cTK_PREDOCTerminalRuleCall; }
	}

	public class PostDocumentElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PostDocument");
		private final RuleCall cTK_POSTDOCTerminalRuleCall = (RuleCall)rule.eContents().get(1);
		
		/// * list of lines starting with ++ * / PostDocument hidden(WS, KW_NEWLINE):
		//	TK_POSTDOC*;
		public ParserRule getRule() { return rule; }

		//TK_POSTDOC*
		public RuleCall getTK_POSTDOCTerminalRuleCall() { return cTK_POSTDOCTerminalRuleCall; }
	}

	public class Enlist1_CommaItem_Comma_ABElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "enlist1_CommaItem_Comma_AB");
		private final RuleCall cEnlister1_CommaItem_CommaParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		/// * CommaItem (',' CommaItem)*
		// * / enlist1_CommaItem_Comma_AB hidden(WS, KW_NEWLINE):
		//	enlister1_CommaItem_Comma;
		public ParserRule getRule() { return rule; }

		//enlister1_CommaItem_Comma
		public RuleCall getEnlister1_CommaItem_CommaParserRuleCall() { return cEnlister1_CommaItem_CommaParserRuleCall; }
	}

	public class Enlist1_Infixed_Comma_ABElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "enlist1_Infixed_Comma_AB");
		private final RuleCall cEnlister1_Infixed_CommaParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		/// * Infixed (',' Infixed)*
		// * / enlist1_Infixed_Comma_AB hidden(WS, KW_NEWLINE):
		//	enlister1_Infixed_Comma;
		public ParserRule getRule() { return rule; }

		//enlister1_Infixed_Comma
		public RuleCall getEnlister1_Infixed_CommaParserRuleCall() { return cEnlister1_Infixed_CommaParserRuleCall; }
	}

	public class Enlist1_InfixedExpr_Comma_ABElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "enlist1_InfixedExpr_Comma_AB");
		private final RuleCall cEnlister1_InfixedExpr_CommaParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		/// * InfixedExpr (',' InfixedExpr)*
		// * / enlist1_InfixedExpr_Comma_AB hidden(WS, KW_NEWLINE):
		//	enlister1_InfixedExpr_Comma;
		public ParserRule getRule() { return rule; }

		//enlister1_InfixedExpr_Comma
		public RuleCall getEnlister1_InfixedExpr_CommaParserRuleCall() { return cEnlister1_InfixedExpr_CommaParserRuleCall; }
	}

	public class Enlister1_CommaItem_CommaElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "enlister1_CommaItem_Comma");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cCommaItemParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final RuleCall cKW_COMMATerminalRuleCall_1_0 = (RuleCall)cGroup_1.eContents().get(0);
		private final Assignment cCiAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cCiCommaItemParserRuleCall_1_1_0 = (RuleCall)cCiAssignment_1_1.eContents().get(0);
		
		/// * CommaItem (',' CommaItem)*
		// * / enlister1_CommaItem_Comma hidden(WS, KW_NEWLINE):
		//	CommaItem (KW_COMMA ci+=CommaItem)*;
		public ParserRule getRule() { return rule; }

		//CommaItem (KW_COMMA ci+=CommaItem)*
		public Group getGroup() { return cGroup; }

		//CommaItem
		public RuleCall getCommaItemParserRuleCall_0() { return cCommaItemParserRuleCall_0; }

		//(KW_COMMA ci+=CommaItem)*
		public Group getGroup_1() { return cGroup_1; }

		//KW_COMMA
		public RuleCall getKW_COMMATerminalRuleCall_1_0() { return cKW_COMMATerminalRuleCall_1_0; }

		//ci+=CommaItem
		public Assignment getCiAssignment_1_1() { return cCiAssignment_1_1; }

		//CommaItem
		public RuleCall getCiCommaItemParserRuleCall_1_1_0() { return cCiCommaItemParserRuleCall_1_1_0; }
	}

	public class Enlister1_Infixed_CommaElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "enlister1_Infixed_Comma");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cInfixedParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final RuleCall cKW_COMMATerminalRuleCall_1_0 = (RuleCall)cGroup_1.eContents().get(0);
		private final Assignment cI2Assignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cI2InfixedParserRuleCall_1_1_0 = (RuleCall)cI2Assignment_1_1.eContents().get(0);
		
		/// * Infixed (',' Infixed)*
		// * / enlister1_Infixed_Comma hidden(WS, KW_NEWLINE):
		//	Infixed (KW_COMMA i2+=Infixed)*;
		public ParserRule getRule() { return rule; }

		//Infixed (KW_COMMA i2+=Infixed)*
		public Group getGroup() { return cGroup; }

		//Infixed
		public RuleCall getInfixedParserRuleCall_0() { return cInfixedParserRuleCall_0; }

		//(KW_COMMA i2+=Infixed)*
		public Group getGroup_1() { return cGroup_1; }

		//KW_COMMA
		public RuleCall getKW_COMMATerminalRuleCall_1_0() { return cKW_COMMATerminalRuleCall_1_0; }

		//i2+=Infixed
		public Assignment getI2Assignment_1_1() { return cI2Assignment_1_1; }

		//Infixed
		public RuleCall getI2InfixedParserRuleCall_1_1_0() { return cI2InfixedParserRuleCall_1_1_0; }
	}

	public class Enlister1_InfixedExpr_CommaElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "enlister1_InfixedExpr_Comma");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cInfixedExprParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final RuleCall cKW_COMMATerminalRuleCall_1_0 = (RuleCall)cGroup_1.eContents().get(0);
		private final Assignment cIeAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cIeInfixedExprParserRuleCall_1_1_0 = (RuleCall)cIeAssignment_1_1.eContents().get(0);
		
		/// * InfixedExpr (',' InfixedExpr)*
		// * / enlister1_InfixedExpr_Comma hidden(WS, KW_NEWLINE):
		//	InfixedExpr (KW_COMMA ie+=InfixedExpr)*;
		public ParserRule getRule() { return rule; }

		//InfixedExpr (KW_COMMA ie+=InfixedExpr)*
		public Group getGroup() { return cGroup; }

		//InfixedExpr
		public RuleCall getInfixedExprParserRuleCall_0() { return cInfixedExprParserRuleCall_0; }

		//(KW_COMMA ie+=InfixedExpr)*
		public Group getGroup_1() { return cGroup_1; }

		//KW_COMMA
		public RuleCall getKW_COMMATerminalRuleCall_1_0() { return cKW_COMMATerminalRuleCall_1_0; }

		//ie+=InfixedExpr
		public Assignment getIeAssignment_1_1() { return cIeAssignment_1_1; }

		//InfixedExpr
		public RuleCall getIeInfixedExprParserRuleCall_1_1_0() { return cIeInfixedExprParserRuleCall_1_1_0; }
	}

	public class Enlist1a_Labeled_Semicolon_ABElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "enlist1a_Labeled_Semicolon_AB");
		private final RuleCall cEnlister1a_Labeled_SemicolonParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		/// * A list of (at least one) statement(s)
		// * seperated by semicolons (one or more)  and optionally ending with
		// * a semicolon (zero or more)
		// * 
		// * AB_Sequence
		// * / enlist1a_Labeled_Semicolon_AB hidden(WS, KW_NEWLINE):
		//	enlister1a_Labeled_Semicolon;
		public ParserRule getRule() { return rule; }

		//enlister1a_Labeled_Semicolon
		public RuleCall getEnlister1a_Labeled_SemicolonParserRuleCall() { return cEnlister1a_Labeled_SemicolonParserRuleCall; }
	}

	public class Enlister1a_Labeled_SemicolonElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "enlister1a_Labeled_Semicolon");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cStatemntsAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cStatemntsLabeledParserRuleCall_0_0 = (RuleCall)cStatemntsAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final RuleCall cKW_SEMICOLONTerminalRuleCall_1_0 = (RuleCall)cGroup_1.eContents().get(0);
		private final Assignment cStatemntsAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cStatemntsLabeledParserRuleCall_1_1_0 = (RuleCall)cStatemntsAssignment_1_1.eContents().get(0);
		private final RuleCall cKW_SEMICOLONTerminalRuleCall_2 = (RuleCall)cGroup.eContents().get(2);
		
		/// * A list of (at least one) statement(s)
		// * seperated by (one or more) semicolons and optionally ending with
		// * a semicolon (zero or more)
		// * 
		// * Aldor axl.z grammar defines this in a left recursive way so
		// * we have to change to non-recursive structure here.
		// * / enlister1a_Labeled_Semicolon hidden(WS, KW_NEWLINE):
		//	statemnts+=Labeled (KW_SEMICOLON+ statemnts+=Labeled)* KW_SEMICOLON*;
		public ParserRule getRule() { return rule; }

		//statemnts+=Labeled (KW_SEMICOLON+ statemnts+=Labeled)* KW_SEMICOLON*
		public Group getGroup() { return cGroup; }

		//statemnts+=Labeled
		public Assignment getStatemntsAssignment_0() { return cStatemntsAssignment_0; }

		//Labeled
		public RuleCall getStatemntsLabeledParserRuleCall_0_0() { return cStatemntsLabeledParserRuleCall_0_0; }

		//(KW_SEMICOLON+ statemnts+=Labeled)*
		public Group getGroup_1() { return cGroup_1; }

		//KW_SEMICOLON+
		public RuleCall getKW_SEMICOLONTerminalRuleCall_1_0() { return cKW_SEMICOLONTerminalRuleCall_1_0; }

		//statemnts+=Labeled
		public Assignment getStatemntsAssignment_1_1() { return cStatemntsAssignment_1_1; }

		//Labeled
		public RuleCall getStatemntsLabeledParserRuleCall_1_1_0() { return cStatemntsLabeledParserRuleCall_1_1_0; }

		//KW_SEMICOLON*
		public RuleCall getKW_SEMICOLONTerminalRuleCall_2() { return cKW_SEMICOLONTerminalRuleCall_2; }
	}

	public class Curly_LabeledElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Curly_Labeled");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cKW_OCURLYTerminalRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final RuleCall cCurlyContents_LabeledParserRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final RuleCall cKW_CCURLYTerminalRuleCall_2 = (RuleCall)cGroup.eContents().get(2);
		
		/// * Substituted Rules in Xtext:
		// * Piled(Expression)
		// * 
		// * / / * Piled * / //Piled(E)
		////: KW_SetTab PileContents(E) KW_BackTab
		////{ $$ = abOneOrNewOfList(AB_Sequence,$2); listFree(AbSyn)($2); }
		////;
		/// * Substituted Rules in Xtext:
		// * Curly(Labeled)
		// * 
		// * / Curly_Labeled hidden(WS, KW_NEWLINE):
		//	KW_OCURLY CurlyContents_Labeled KW_CCURLY;
		public ParserRule getRule() { return rule; }

		//KW_OCURLY CurlyContents_Labeled KW_CCURLY
		public Group getGroup() { return cGroup; }

		//KW_OCURLY
		public RuleCall getKW_OCURLYTerminalRuleCall_0() { return cKW_OCURLYTerminalRuleCall_0; }

		//CurlyContents_Labeled
		public RuleCall getCurlyContents_LabeledParserRuleCall_1() { return cCurlyContents_LabeledParserRuleCall_1; }

		//KW_CCURLY
		public RuleCall getKW_CCURLYTerminalRuleCall_2() { return cKW_CCURLYTerminalRuleCall_2; }
	}

	public class CurlyContents_LabeledElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "CurlyContents_Labeled");
		private final RuleCall cCurlyContentsList_LabeledParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		/// * A list of (at least one) statement(s)
		// * seperated by (one or more) semicolons and optionally ending with
		// * a semicolon (zero or more)
		// * 
		// * This is similar to enlister1a_Labeled_Semicolon;
		// * 
		// * statements can have pre or post comments
		// * 
		// * called by Curly_Labeled and Model
		// * / CurlyContents_Labeled hidden(WS, KW_NEWLINE):
		//	CurlyContentsList_Labeled;
		public ParserRule getRule() { return rule; }

		//CurlyContentsList_Labeled
		public RuleCall getCurlyContentsList_LabeledParserRuleCall() { return cCurlyContentsList_LabeledParserRuleCall; }
	}

	public class CurlyContentsList_LabeledElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "CurlyContentsList_Labeled");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cStatemtsAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cStatemtsCurlyContentB_LabeledParserRuleCall_0_0 = (RuleCall)cStatemtsAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final RuleCall cKW_SEMICOLONTerminalRuleCall_1_0 = (RuleCall)cGroup_1.eContents().get(0);
		private final Assignment cStatemtsAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cStatemtsCurlyContentB_LabeledParserRuleCall_1_1_0 = (RuleCall)cStatemtsAssignment_1_1.eContents().get(0);
		private final RuleCall cKW_SEMICOLONTerminalRuleCall_2 = (RuleCall)cGroup.eContents().get(2);
		
		/// * A list of (at least one) statement(s)
		// * seperated by (one or more) semicolons and optionally ending with
		// * a semicolon (zero or more)
		// * 
		// * This is similar to enlister1a_Labeled_Semicolon
		// * 
		// * statements can have pre or post comments
		// * / CurlyContentsList_Labeled hidden(WS, KW_NEWLINE):
		//	statemts+=CurlyContentB_Labeled //(statemts += CurlyContentB_Labeled?)
		//	(KW_SEMICOLON+ statemts+=CurlyContentB_Labeled)* // need to change this line to:
		//	//(KW_SEMICOLON* statemts += CurlyContentB_Labeled)*
		//	// that is make semicolons optional but that causes non-LL(*) grammar
		//	KW_SEMICOLON*;
		public ParserRule getRule() { return rule; }

		//statemts+=CurlyContentB_Labeled //(statemts += CurlyContentB_Labeled?)
		//(KW_SEMICOLON+ statemts+=CurlyContentB_Labeled)* // need to change this line to:
		////(KW_SEMICOLON* statemts += CurlyContentB_Labeled)*
		//// that is make semicolons optional but that causes non-LL(*) grammar
		//KW_SEMICOLON*
		public Group getGroup() { return cGroup; }

		//statemts+=CurlyContentB_Labeled
		public Assignment getStatemtsAssignment_0() { return cStatemtsAssignment_0; }

		//CurlyContentB_Labeled
		public RuleCall getStatemtsCurlyContentB_LabeledParserRuleCall_0_0() { return cStatemtsCurlyContentB_LabeledParserRuleCall_0_0; }

		//(KW_SEMICOLON+ statemts+=CurlyContentB_Labeled)*
		public Group getGroup_1() { return cGroup_1; }

		//KW_SEMICOLON+
		public RuleCall getKW_SEMICOLONTerminalRuleCall_1_0() { return cKW_SEMICOLONTerminalRuleCall_1_0; }

		//statemts+=CurlyContentB_Labeled
		public Assignment getStatemtsAssignment_1_1() { return cStatemtsAssignment_1_1; }

		//CurlyContentB_Labeled
		public RuleCall getStatemtsCurlyContentB_LabeledParserRuleCall_1_1_0() { return cStatemtsCurlyContentB_LabeledParserRuleCall_1_1_0; }

		//// need to change this line to:
		////(KW_SEMICOLON* statemts += CurlyContentB_Labeled)*
		//// that is make semicolons optional but that causes non-LL(*) grammar
		//KW_SEMICOLON*
		public RuleCall getKW_SEMICOLONTerminalRuleCall_2() { return cKW_SEMICOLONTerminalRuleCall_2; }
	}

	public class CurlyContentB_LabeledElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "CurlyContentB_Labeled");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cPredAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cPredPreDocumentParserRuleCall_0_0 = (RuleCall)cPredAssignment_0.eContents().get(0);
		private final Assignment cLAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cLLabeledParserRuleCall_1_0 = (RuleCall)cLAssignment_1.eContents().get(0);
		private final Assignment cPdAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cPdPostDocumentParserRuleCall_2_0 = (RuleCall)cPdAssignment_2.eContents().get(0);
		
		/// * List of 'Labeled' each one is terminated by semicolon
		// * 
		// * This rule is left recursive in the Aldor grammar so I have
		// * to change it here.
		// * / //CurlyContent1_Labeled
		////: Nothing
		////| CurlyContent1_Labeled cca=CurlyContentA_Labeled
		////;
		/// * Substituted Rules in Xtext:
		// * CurlyContentA(E) E is from CurlyContent1(E)
		// * 
		// * / //CurlyContentA_Labeled
		////: CurlyContentB_Labeled KW_SEMICOLON pd=PostDocument
		////| error KW_SEMICOLON PostDocument
		////;
		/// * Substituted Rules in Xtext:
		// * CurlyContentB(E) E is from CurlyContentA(E)
		// * or CurlyContentsList(E)
		// * 
		// * / CurlyContentB_Labeled hidden(WS, KW_NEWLINE):
		//	pred=PreDocument l=Labeled pd=PostDocument;
		public ParserRule getRule() { return rule; }

		//pred=PreDocument l=Labeled pd=PostDocument
		public Group getGroup() { return cGroup; }

		//pred=PreDocument
		public Assignment getPredAssignment_0() { return cPredAssignment_0; }

		//PreDocument
		public RuleCall getPredPreDocumentParserRuleCall_0_0() { return cPredPreDocumentParserRuleCall_0_0; }

		//l=Labeled
		public Assignment getLAssignment_1() { return cLAssignment_1; }

		//Labeled
		public RuleCall getLLabeledParserRuleCall_1_0() { return cLLabeledParserRuleCall_1_0; }

		//pd=PostDocument
		public Assignment getPdAssignment_2() { return cPdAssignment_2; }

		//PostDocument
		public RuleCall getPdPostDocumentParserRuleCall_2_0() { return cPdPostDocumentParserRuleCall_2_0; }
	}
	
	
	private ModelElements pModel;
	private TerminalRule tTK_ID;
	private TerminalRule tWS;
	private TerminalRule tKW_NEWLINE;
	private TerminalRule tTK_PREDOC;
	private TerminalRule tTK_POSTDOC;
	private TerminalRule tTK_STRING;
	private TerminalRule tTK_INT;
	private TerminalRule tTK_FLOAT;
	private TerminalRule tKW_QUOTE;
	private TerminalRule tKW_OPAREN;
	private TerminalRule tKW_CPAREN;
	private TerminalRule tKW_OCURLY;
	private TerminalRule tKW_CCURLY;
	private TerminalRule tKW_OBRACK;
	private TerminalRule tKW_CBRACK;
	private TerminalRule tKW_2LT;
	private TerminalRule tKW_2GT;
	private TerminalRule tKW_MARROW;
	private TerminalRule tKW_BAR;
	private TerminalRule tKW_DOT;
	private TerminalRule tKW_2COLON;
	private TerminalRule tKW_COLONSTAR;
	private TerminalRule tKW_COLON;
	private TerminalRule tKW_AT;
	private TerminalRule tKW_COMMA;
	private TerminalRule tKW_SEMICOLON;
	private TerminalRule tKW_2STAR;
	private TerminalRule tKW_STAR;
	private TerminalRule tKW_PLUS;
	private TerminalRule tKW_MINUS;
	private TerminalRule tKW_PLUSMINUS;
	private TerminalRule tKW_LT;
	private TerminalRule tKW_GT;
	private TerminalRule tKW_LE;
	private TerminalRule tKW_GE;
	private TerminalRule tKW_EQ;
	private TerminalRule tKW_TILDEE;
	private TerminalRule tKW_HATE;
	private TerminalRule tKW_TILDE;
	private TerminalRule tKW_HAT;
	private TerminalRule tKW_2DOT;
	private TerminalRule tKW_SHARP;
	private TerminalRule tKW_AMPERSAND;
	private TerminalRule tKW_DOLLAR;
	private TerminalRule tKW_SLASH;
	private TerminalRule tKW_BACKSLASH;
	private TerminalRule tKW_WEDGE;
	private TerminalRule tKW_VEE;
	private TerminalRule tKW_IMPLIES;
	private TerminalRule tKW_ASSIGN;
	private TerminalRule tKW_2EQ;
	private TerminalRule tKW_RARROW;
	private TerminalRule tKW_LARROW;
	private TerminalRule tKW_MAPSTO;
	private TerminalRule tKW_MAPSTOSTAR;
	private TerminalRule tKW_MAPSTAR;
	private TerminalRule tANY_OTHER;
	private ErrorElements pError;
	private ExpressionElements pExpression;
	private LabeledElements pLabeled;
	private DeclarationElements pDeclaration;
	private ExportDeclElements pExportDecl;
	private ToPartElements pToPart;
	private FromPartElements pFromPart;
	private MacroBodyElements pMacroBody;
	private SigElements pSig;
	private DeclPartElements pDeclPart;
	private CommaElements pComma;
	private CommaItemElements pCommaItem;
	private DeclBindingElements pDeclBinding;
	private InfixedExprsDeclElements pInfixedExprsDecl;
	private InfixedExprsElements pInfixedExprs;
	private Binding_AnyStatementElements pBinding_AnyStatement;
	private Binding_BalStatementElements pBinding_BalStatement;
	private Binding_CollectionElements pBinding_Collection;
	private BindingL_Infixed_AnyStatementElements pBindingL_Infixed_AnyStatement;
	private BindingL_Infixed_BalStatementElements pBindingL_Infixed_BalStatement;
	private BindingL_Infixed_CollectionElements pBindingL_Infixed_Collection;
	private BindingR_InfixedExprsDecl_AnyStatementElements pBindingR_InfixedExprsDecl_AnyStatement;
	private AnyStatementElements pAnyStatement;
	private BalStatementElements pBalStatement;
	private Flow_AnyStatementElements pFlow_AnyStatement;
	private Flow_BalStatementElements pFlow_BalStatement;
	private GenBoundElements pGenBound;
	private ButExprElements pButExpr;
	private CasesElements pCases;
	private AlwaysPart_AnyStatementElements pAlwaysPart_AnyStatement;
	private AlwaysPart_BalStatementElements pAlwaysPart_BalStatement;
	private CollectionElements pCollection;
	private IteratorsElements pIterators;
	private Iterators1Elements pIterators1;
	private IteratorElements pIterator;
	private ForLhsElements pForLhs;
	private SuchthatPartElements pSuchthatPart;
	private InfixedElements pInfixed;
	private InfixedExprElements pInfixedExpr;
	private E3Elements pE3;
	private E4Elements pE4;
	private E5Elements pE5;
	private E6Elements pE6;
	private E7Elements pE7;
	private E8Elements pE8;
	private E9Elements pE9;
	private E11_E12Elements pE11_E12;
	private E11_OpElements pE11_Op;
	private TypeElements pType;
	private E12Elements pE12;
	private E13Elements pE13;
	private QualTailElements pQualTail;
	private OpQualTailElements pOpQualTail;
	private E14Elements pE14;
	private E15Elements pE15;
	private OpElements pOp;
	private NakedOpElements pNakedOp;
	private ArrowOpElements pArrowOp;
	private LatticeOpElements pLatticeOp;
	private RelationOpElements pRelationOp;
	private SegOpElements pSegOp;
	private PlusOpElements pPlusOp;
	private QuotientOpElements pQuotientOp;
	private TimesOpElements pTimesOp;
	private PowerOpElements pPowerOp;
	private ArrowTokElements pArrowTok;
	private LatticeTokElements pLatticeTok;
	private RelationTokElements pRelationTok;
	private SegTokElements pSegTok;
	private PlusTokElements pPlusTok;
	private QuotientTokElements pQuotientTok;
	private TimesTokElements pTimesTok;
	private PowerTokElements pPowerTok;
	private ApplicationElements pApplication;
	private RightJuxtaposedElements pRightJuxtaposed;
	private LeftJuxtaposedElements pLeftJuxtaposed;
	private Jright_MoleculeElements pJright_Molecule;
	private Jright_AtomElements pJright_Atom;
	private Jleft_MoleculeElements pJleft_Molecule;
	private Jleft_AtomElements pJleft_Atom;
	private MoleculeElements pMolecule;
	private EnclosureElements pEnclosure;
	private DeclMoleculeElements pDeclMolecule;
	private BlockMoleculeElements pBlockMolecule;
	private BlockEnclosureElements pBlockEnclosure;
	private BlockElements pBlock;
	private ParenedElements pParened;
	private BracketedElements pBracketed;
	private QuotedIdsElements pQuotedIds;
	private NamesElements pNames;
	private AtomElements pAtom;
	private NameElements pName;
	private IdElements pId;
	private LiteralElements pLiteral;
	private UnqualOp_ArrowTokElements pUnqualOp_ArrowTok;
	private UnqualOp_LatticeTokElements pUnqualOp_LatticeTok;
	private UnqualOp_RelationTokElements pUnqualOp_RelationTok;
	private UnqualOp_SegTokElements pUnqualOp_SegTok;
	private UnqualOp_PlusTokElements pUnqualOp_PlusTok;
	private UnqualOp_QuotientTokElements pUnqualOp_QuotientTok;
	private UnqualOp_TimesTokElements pUnqualOp_TimesTok;
	private UnqualOp_PowerTokElements pUnqualOp_PowerTok;
	private QualOp_ArrowTokElements pQualOp_ArrowTok;
	private QualOp_LatticeTokElements pQualOp_LatticeTok;
	private QualOp_RelationTokElements pQualOp_RelationTok;
	private QualOp_SegTokElements pQualOp_SegTok;
	private QualOp_PlusTokElements pQualOp_PlusTok;
	private QualOp_QuotientTokElements pQualOp_QuotientTok;
	private QualOp_TimesTokElements pQualOp_TimesTok;
	private QualOp_PowerTokElements pQualOp_PowerTok;
	private PreDocumentElements pPreDocument;
	private PostDocumentElements pPostDocument;
	private Enlist1_CommaItem_Comma_ABElements pEnlist1_CommaItem_Comma_AB;
	private Enlist1_Infixed_Comma_ABElements pEnlist1_Infixed_Comma_AB;
	private Enlist1_InfixedExpr_Comma_ABElements pEnlist1_InfixedExpr_Comma_AB;
	private Enlister1_CommaItem_CommaElements pEnlister1_CommaItem_Comma;
	private Enlister1_Infixed_CommaElements pEnlister1_Infixed_Comma;
	private Enlister1_InfixedExpr_CommaElements pEnlister1_InfixedExpr_Comma;
	private Enlist1a_Labeled_Semicolon_ABElements pEnlist1a_Labeled_Semicolon_AB;
	private Enlister1a_Labeled_SemicolonElements pEnlister1a_Labeled_Semicolon;
	private Curly_LabeledElements pCurly_Labeled;
	private CurlyContents_LabeledElements pCurlyContents_Labeled;
	private CurlyContentsList_LabeledElements pCurlyContentsList_Labeled;
	private CurlyContentB_LabeledElements pCurlyContentB_Labeled;
	
	private final Grammar grammar;

	@Inject
	public EditorGrammarAccess(GrammarProvider grammarProvider) {
		this.grammar = internalFindGrammar(grammarProvider);
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("com.euclideanspace.aldor.Editor".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	
	public Grammar getGrammar() {
		return grammar;
	}
	

	
	/// * Copyright 2014 Martin John Baker
	// *
	// * This file is part of EuclideanSpace.
	// *
	// * EuclideanSpace is free software: you can redistribute it and/or modify
	// * it under the terms of the GNU Affero General Public License as published by
	// * the Free Software Foundation, either version 3 of the License, or
	// * (at your option) any later version.
	// *
	// * EuclideanSpace is distributed in the hope that it will be useful,
	// * but WITHOUT ANY WARRANTY; without even the implied warranty of
	// * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
	// * GNU Affero General Public License for more details.
	// *
	// * You should have received a copy of the GNU Affero General Public License
	// * along with EuclideanSpace. If not, see <http://www.gnu.org/licenses/>.
	// * / / *
	// *
	// * Here we are using a LL(*) recursive-descent parser generator and this
	// * may not be able to exactly replicate axl.z which is a
	// * LALR(1) conflict-free grammar for Aldor.
	// * 
	// * known bugs
	// * ----------
	// * 1) customLexer: phantom semicolon after curly brackets is not yet conditional
	// * 2) ':' does not yet work properly. We want it to bind most tightly.
	// * 3) + or - as prefix operator.
	// * / / *
	// * replaces Goal rule in Aldor grammar
	// * 
	// * #include is not in axl.z grammar, I assume the includes are
	// * done before the grammar is called. So I have added include
	// * support here.
	// * 
	// * / Model hidden(WS, KW_NEWLINE):
	//	("#include" insert+=TK_STRING)* cc=CurlyContents_Labeled;
	public ModelElements getModelAccess() {
		return (pModel != null) ? pModel : (pModel = new ModelElements());
	}
	
	public ParserRule getModelRule() {
		return getModelAccess().getRule();
	}

	//////////// start of lexer rules ///////////////
	/// * ID consists of alpha (upper or lower case) followed by alphanumeric
	// * any other character can stand in for alpha if prefixed by '_'
	// * for instance a multiply function is often named '_*'
	// * IDs can also end with ? or ! where:
	// * '?' indicates a function which returns a boolean value
	// * '!' indicates a function which changes an existing domain value
	// * (in a mutable domain)
	// * / terminal TK_ID:
	//	("a".."z" | "A".."Z" | "_" .) ("a".."z" | "A".."Z" | "_" . | "0".."9")* "!"? "?"?;
	public TerminalRule getTK_IDRule() {
		return (tTK_ID != null) ? tTK_ID : (tTK_ID = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "TK_ID"));
	} 

	/// * whitespace on single line overrides default whitespace
	// * does not include newline unless it follows underscore.
	// * I would have liked to do this as follows:
	// * terminal WS : (' '|'\t'|'_'(('\r'|'\n')+))+;
	// * problem: unfortunately use of underscore in this way masks the use of underscore
	// * in ID. We therefore need to remove this type of underscore in a
	// * preprocessor
	// * / terminal WS:
	//	(" " | "\t")+;
	public TerminalRule getWSRule() {
		return (tWS != null) ? tWS : (tWS = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "WS"));
	} 

	/// * at least one newline or carriage return character.
	// * This is not included with WS because whitespace is significant in Aldor/SPAD.
	// * We usually absorb newlines like this: NL+ which absorbs any number of
	// * blank lines and it also supports both the Linux and the Windows forms of
	// * newlines.
	// * {KW_NewLine, 0,"\n", 0, 0, 0, 0, 0, 0, 1, 0, 0, 0},
	// * / terminal KW_NEWLINE:
	//	"\r" | "\n";
	public TerminalRule getKW_NEWLINERule() {
		return (tKW_NEWLINE != null) ? tKW_NEWLINE : (tKW_NEWLINE = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "KW_NEWLINE"));
	} 

	/// * overwriting TK_COMMENTS we do not want Java syntax (//) but Aldor/spad syntax (--)
	// * This absorbs everything from '--' or '++' to the end of the line (but not
	// * including the newline or carriage return characters)
	// * 
	// *  {TK_PREDOC, 0,"TK_PREDOC", 1, 1, 0, 0, 0, 0, 1, 0, 170, 0},
	//    {TK_POSTDOC, 0,"TK_POSTDOC", 1, 1, 0, 0, 0, 0, 1, 0, 170, 0},
	//    {TK_COMMENT, 0,"TK_COMMENT", 1, 1, 0, 0, 0, 0, 1, 0, 170, 0},
	// * / //terminal TK_COMMENT :
	////  ('--'|'++') !('\n'|'\r')* ;//('\r'|'\n')?;
	////('\r'|'\n')?;
	//terminal TK_PREDOC:
	//	"--" !("\n" | "\r")*;
	public TerminalRule getTK_PREDOCRule() {
		return (tTK_PREDOC != null) ? tTK_PREDOC : (tTK_PREDOC = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "TK_PREDOC"));
	} 

	////('\r'|'\n')?;
	//terminal TK_POSTDOC:
	//	"++" !("\n" | "\r")*;
	public TerminalRule getTK_POSTDOCRule() {
		return (tTK_POSTDOC != null) ? tTK_POSTDOC : (tTK_POSTDOC = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "TK_POSTDOC"));
	} 

	/// * string literals are enclosed in double quotes
	// *         {TK_STRING, 0,"TK_STRING", 1, 0, 0, 0, 0, 0, 1, 0, 170, 0},
	// * / terminal TK_STRING:
	//	"\"" !"\""* "\"";
	public TerminalRule getTK_STRINGRule() {
		return (tTK_STRING != null) ? tTK_STRING : (tTK_STRING = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "TK_STRING"));
	} 

	/// *
	// * Integer Literal
	// *
	// * {TK_INT, 0,"TK_INT", 1, 0, 0, 0, 0, 0, 1, 0, 170, 0},
	// * / terminal TK_INT returns ecore::EInt:
	//	"0".."9"+;
	public TerminalRule getTK_INTRule() {
		return (tTK_INT != null) ? tTK_INT : (tTK_INT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "TK_INT"));
	} 

	/// *
	// * Floating Point Literal
	// * This must be defined after: integer literal, otherwise integers will be hidden.
	// * 
	// * For a discussion about how to implement floats see this page:
	// * http://www.euclideanspace.com/software/development/eclipse/xtext/grammar/lexer/index.htm#float
	// * / terminal TK_FLOAT:
	//	TK_INT ("e" | "E") ("+" | "-")? TK_INT;
	public TerminalRule getTK_FLOATRule() {
		return (tTK_FLOAT != null) ? tTK_FLOAT : (tTK_FLOAT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "TK_FLOAT"));
	} 

	/// * grouping
	// * {KW_OBBrack, 0,"[|", 0, 0, 1, 0, 0, 0, 1, 0, 0, 0},
	// * {KW_OBCurly, 0,"{|", 0, 0, 1, 0, 0, 0, 1, 0, 0, 0},
	// * {KW_OBParen, 0,"(|", 0, 0, 1, 0, 0, 0, 1, 0, 0, 0},
	// * 
	// * {KW_CBBrack, 0,"|]", 0, 0, 0, 1, 0, 0, 1, 0, 0, 0},
	// * {KW_CBCurly, 0,"|}", 0, 0, 0, 1, 0, 0, 1, 0, 0, 0},
	// * {KW_CBParen, 0,"|)", 0, 0, 0, 1, 0, 0, 1, 0, 0, 0},
	// * {KW_2Bar, 0,"||", 0, 0, 0, 0, 0, 1, 1, 0, 0, 0},
	// * 
	// * / / * '
	// * {KW_QUOTE, 0,"'", 0, 0, 0, 0, 0, 0, 1, 0, 0, 0},
	// * / terminal KW_QUOTE:
	//	"\'";
	public TerminalRule getKW_QUOTERule() {
		return (tKW_QUOTE != null) ? tKW_QUOTE : (tKW_QUOTE = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "KW_QUOTE"));
	} 

	/// * (
	// * {KW_OPAREN, 0,"(", 0, 0, 1, 0, 0, 0, 1, 0, 0, 0},
	// * / terminal KW_OPAREN:
	//	"(";
	public TerminalRule getKW_OPARENRule() {
		return (tKW_OPAREN != null) ? tKW_OPAREN : (tKW_OPAREN = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "KW_OPAREN"));
	} 

	/// * )
	// * {KW_CPAREN, 0,")", 0, 0, 0, 1, 0, 0, 1, 0, 0, 0},
	// * / terminal KW_CPAREN:
	//	")";
	public TerminalRule getKW_CPARENRule() {
		return (tKW_CPAREN != null) ? tKW_CPAREN : (tKW_CPAREN = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "KW_CPAREN"));
	} 

	/// * {
	// * {KW_OCURLY, 0,"{", 0, 0, 1, 0, 0, 0, 1, 0, 0, 0},
	// * / terminal KW_OCURLY:
	//	"{";
	public TerminalRule getKW_OCURLYRule() {
		return (tKW_OCURLY != null) ? tKW_OCURLY : (tKW_OCURLY = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "KW_OCURLY"));
	} 

	/// * }
	// * {KW_CCURLY, 0,"}", 0, 0, 0, 1, 0, 0, 1, 0, 0, 0},
	// * / terminal KW_CCURLY:
	//	"}";
	public TerminalRule getKW_CCURLYRule() {
		return (tKW_CCURLY != null) ? tKW_CCURLY : (tKW_CCURLY = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "KW_CCURLY"));
	} 

	/// * [
	// * {KW_OBRACK, 0,"[", 0, 0, 1, 0, 0, 0, 1, 0, 0, 0},
	// * / terminal KW_OBRACK:
	//	"[";
	public TerminalRule getKW_OBRACKRule() {
		return (tKW_OBRACK != null) ? tKW_OBRACK : (tKW_OBRACK = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "KW_OBRACK"));
	} 

	/// * ]
	// * {KW_CBRACK, 0,"]", 0, 0, 0, 1, 0, 0, 1, 0, 0, 0},
	// * / terminal KW_CBRACK:
	//	"]";
	public TerminalRule getKW_CBRACKRule() {
		return (tKW_CBRACK != null) ? tKW_CBRACK : (tKW_CBRACK = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "KW_CBRACK"));
	} 

	/// *
	//terminal LBANANA '(|';
	//terminal RBANANA '|)';
	//terminal EBRACKET '[__]';
	//terminal EBRACKET2 '[]';
	//terminal EBRACE '{__}';
	//terminal EBRACE2 '{}';
	//terminal LBANANABRACKET '[|';
	//terminal RBANANABRACKET '|]';
	//terminal EBANANABRACKET '[|__|]';
	//terminal EBANANABRACKET2 '[||]';
	//terminal LBANANABRACE '{|';
	//terminal RBANANABRACE '|}';
	//terminal EBANANABRACE '{|__|}';
	//terminal EBANANABRACE2 '{||}'; * / / * <<
	// * {KW_2LT, 0,"<<", 0, 0, 0, 0, 0, 0, 1, 1, 100, 0},
	// * / terminal KW_2LT:
	//	"<<";
	public TerminalRule getKW_2LTRule() {
		return (tKW_2LT != null) ? tKW_2LT : (tKW_2LT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "KW_2LT"));
	} 

	/// * >>
	// * {KW_2GT, 0,">>", 0, 0, 0, 0, 0, 0, 1, 1, 100, 0},
	// * / terminal KW_2GT:
	//	">>";
	public TerminalRule getKW_2GTRule() {
		return (tKW_2GT != null) ? tKW_2GT : (tKW_2GT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "KW_2GT"));
	} 

	/// *terminal QUOTE "'";
	//terminal BACKQUOTE "`";* / // operators
	/// * ==> MDEF or MARROW
	// * {KW_MARROW, 0,"==>", 0, 0, 0, 0, 1, 0, 0, 1, 25, 0},
	// * / terminal KW_MARROW:
	//	"==>";
	public TerminalRule getKW_MARROWRule() {
		return (tKW_MARROW != null) ? tKW_MARROW : (tKW_MARROW = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "KW_MARROW"));
	} 

	/// * |
	// * {KW_Bar, 0,"|", 0, 0, 0, 0, 0, 0, 1, 0, 0, 0},
	// * / terminal KW_BAR:
	//	"|";
	public TerminalRule getKW_BARRule() {
		return (tKW_BAR != null) ? tKW_BAR : (tKW_BAR = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "KW_BAR"));
	} 

	/// * .
	// * {KW_DOT, 0,".", 0, 0, 0, 0, 1, 0, 1, 1, 170, 0},
	// * / terminal KW_DOT:
	//	".";
	public TerminalRule getKW_DOTRule() {
		return (tKW_DOT != null) ? tKW_DOT : (tKW_DOT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "KW_DOT"));
	} 

	/// * :: 2Colon or coerce
	// * {KW_2Colon, 0,"::", 0, 0, 0, 0, 1, 0, 1, 1, 150, 0},
	// * / terminal KW_2COLON:
	//	"::";
	public TerminalRule getKW_2COLONRule() {
		return (tKW_2COLON != null) ? tKW_2COLON : (tKW_2COLON = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "KW_2COLON"));
	} 

	/// * :*
	// * {KW_ColonStar, 0,":*", 0, 0, 0, 0, 1, 0, 1, 1, 36, 0},
	// * / terminal KW_COLONSTAR:
	//	":*";
	public TerminalRule getKW_COLONSTARRule() {
		return (tKW_COLONSTAR != null) ? tKW_COLONSTAR : (tKW_COLONSTAR = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "KW_COLONSTAR"));
	} 

	/// * :
	// * {KW_Colon, 0,":", 0, 0, 0, 0, 1, 0, 1, 1, 36, 0},
	// * / terminal KW_COLON:
	//	":";
	public TerminalRule getKW_COLONRule() {
		return (tKW_COLON != null) ? tKW_COLON : (tKW_COLON = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "KW_COLON"));
	} 

	/// * @
	// * {KW_At, 0,"@", 0, 0, 0, 0, 0, 0, 1, 1, 150, 0},
	// * / terminal KW_AT:
	//	"@";
	public TerminalRule getKW_ATRule() {
		return (tKW_AT != null) ? tKW_AT : (tKW_AT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "KW_AT"));
	} 

	/// * , 
	// * {KW_Comma, 0,",", 0, 0, 0, 0, 1, 0, 1, 1, 11, 0},
	// * / terminal KW_COMMA:
	//	",";
	public TerminalRule getKW_COMMARule() {
		return (tKW_COMMA != null) ? tKW_COMMA : (tKW_COMMA = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "KW_COMMA"));
	} 

	/// * ;
	// * {KW_SEMICOLON, 0,";", 0, 0, 0, 0, 0, 0, 1, 0, 10, 0},
	// * / terminal KW_SEMICOLON:
	//	";";
	public TerminalRule getKW_SEMICOLONRule() {
		return (tKW_SEMICOLON != null) ? tKW_SEMICOLON : (tKW_SEMICOLON = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "KW_SEMICOLON"));
	} 

	/// * ** 2star or power
	// * {KW_2STAR, 0,"**", 0, 0, 0, 0, 0, 0, 1, 1, 140, 0},
	// * / terminal KW_2STAR:
	//	"**";
	public TerminalRule getKW_2STARRule() {
		return (tKW_2STAR != null) ? tKW_2STAR : (tKW_2STAR = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "KW_2STAR"));
	} 

	/// * * times or star
	// * {KW_STAR, 0,"*", 0, 0, 0, 0, 0, 0, 1, 1, 130, 0},
	// * / terminal KW_STAR:
	//	"*";
	public TerminalRule getKW_STARRule() {
		return (tKW_STAR != null) ? tKW_STAR : (tKW_STAR = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "KW_STAR"));
	} 

	/// * + plus
	// * {KW_PLUS, 0,"+", 0, 0, 0, 0, 0, 0, 1, 1, 120, 0},
	// * / terminal KW_PLUS:
	//	"+";
	public TerminalRule getKW_PLUSRule() {
		return (tKW_PLUS != null) ? tKW_PLUS : (tKW_PLUS = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "KW_PLUS"));
	} 

	/// * -
	// * {KW_MINUS, 0,"-", 0, 0, 0, 0, 0, 0, 1, 1, 120, 0},
	// * / terminal KW_MINUS:
	//	"-";
	public TerminalRule getKW_MINUSRule() {
		return (tKW_MINUS != null) ? tKW_MINUS : (tKW_MINUS = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "KW_MINUS"));
	} 

	/// * +-
	// * {KW_PLUSMINUS, 0,"+-", 0, 0, 0, 0, 0, 0, 1, 1, 120, 0},
	// * / terminal KW_PLUSMINUS:
	//	"+-";
	public TerminalRule getKW_PLUSMINUSRule() {
		return (tKW_PLUSMINUS != null) ? tKW_PLUSMINUS : (tKW_PLUSMINUS = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "KW_PLUSMINUS"));
	} 

	/// * <
	// * {KW_GT, 0,">", 0, 0, 0, 0, 0, 0, 1, 1, 100, 0},
	// * {KW_GE, 0,">=", 0, 0, 0, 0, 0, 0, 1, 1, 100, 0},
	// * {KW_LT, 0,"<", 0, 0, 0, 0, 0, 0, 1, 1, 100, 0},
	// * {KW_LE, 0,"<=", 0, 0, 0, 0, 0, 0, 1, 1, 100, 0},
	// * / terminal KW_LT:
	//	"<";
	public TerminalRule getKW_LTRule() {
		return (tKW_LT != null) ? tKW_LT : (tKW_LT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "KW_LT"));
	} 

	/// * > * / terminal KW_GT:
	//	">";
	public TerminalRule getKW_GTRule() {
		return (tKW_GT != null) ? tKW_GT : (tKW_GT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "KW_GT"));
	} 

	/// * <= * / terminal KW_LE:
	//	"<=";
	public TerminalRule getKW_LERule() {
		return (tKW_LE != null) ? tKW_LE : (tKW_LE = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "KW_LE"));
	} 

	/// * >= * / terminal KW_GE:
	//	">=";
	public TerminalRule getKW_GERule() {
		return (tKW_GE != null) ? tKW_GE : (tKW_GE = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "KW_GE"));
	} 

	/// * = equal
	// * {KW_EQ, 0,"=", 0, 0, 0, 0, 0, 0, 1, 1, 100, 0},
	// * / terminal KW_EQ:
	//	"=";
	public TerminalRule getKW_EQRule() {
		return (tKW_EQ != null) ? tKW_EQ : (tKW_EQ = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "KW_EQ"));
	} 

	/// * ~= not-equal or tilde-equal
	// * {KW_TILDEE, 0,"~=", 0, 0, 0, 0, 0, 0, 1, 1, 90, 0},
	// * / terminal KW_TILDEE:
	//	"~=";
	public TerminalRule getKW_TILDEERule() {
		return (tKW_TILDEE != null) ? tKW_TILDEE : (tKW_TILDEE = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "KW_TILDEE"));
	} 

	/// * ^= hat-equal
	// * {KW_HATE, 0,"^=", 0, 0, 0, 0, 0, 0, 1, 1, 90, 0},
	// * / terminal KW_HATE:
	//	"^=";
	public TerminalRule getKW_HATERule() {
		return (tKW_HATE != null) ? tKW_HATE : (tKW_HATE = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "KW_HATE"));
	} 

	/// * ~
	// * {KW_TILDE, 0,"~", 0, 0, 0, 0, 0, 0, 0, 1, 150, 0},
	// * / terminal KW_TILDE:
	//	"~";
	public TerminalRule getKW_TILDERule() {
		return (tKW_TILDE != null) ? tKW_TILDE : (tKW_TILDE = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "KW_TILDE"));
	} 

	/// * ^ hat or carat
	// * {KW_HAT, 0,"^", 0, 0, 0, 0, 0, 0, 1, 1, 140, 0},
	// * / terminal KW_HAT:
	//	"^";
	public TerminalRule getKW_HATRule() {
		return (tKW_HAT != null) ? tKW_HAT : (tKW_HAT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "KW_HAT"));
	} 

	/// * .. 2Dot or seg
	// *{KW_2DOT, 0,"..", 0, 0, 0, 0, 0, 0, 1, 1, 110, 0},
	// * 
	// * / terminal KW_2DOT:
	//	"..";
	public TerminalRule getKW_2DOTRule() {
		return (tKW_2DOT != null) ? tKW_2DOT : (tKW_2DOT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "KW_2DOT"));
	} 

	/// * # Hash or Sharp
	// * {KW_SHARP, 0,"#", 0, 0, 0, 0, 0, 0, 1, 0, 0, 0},
	// * / terminal KW_SHARP:
	//	"#";
	public TerminalRule getKW_SHARPRule() {
		return (tKW_SHARP != null) ? tKW_SHARP : (tKW_SHARP = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "KW_SHARP"));
	} 

	/// * &
	// * {KW_Ampersand, 0,"&", 0, 0, 0, 0, 0, 0, 1, 0, 160, 0},
	// * / terminal KW_AMPERSAND:
	//	"&";
	public TerminalRule getKW_AMPERSANDRule() {
		return (tKW_AMPERSAND != null) ? tKW_AMPERSAND : (tKW_AMPERSAND = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "KW_AMPERSAND"));
	} 

	/// * $
	// * {KW_DOLLAR, 0,"$", 0, 0, 0, 0, 1, 0, 0, 1, 70, 0},
	// * / terminal KW_DOLLAR:
	//	"$";
	public TerminalRule getKW_DOLLARRule() {
		return (tKW_DOLLAR != null) ? tKW_DOLLAR : (tKW_DOLLAR = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "KW_DOLLAR"));
	} 

	/// * /
	// * {KW_SLASH, 0,"/", 0, 0, 0, 0, 0, 0, 1, 1, 130, 0},
	// * / terminal KW_SLASH:
	//	"/";
	public TerminalRule getKW_SLASHRule() {
		return (tKW_SLASH != null) ? tKW_SLASH : (tKW_SLASH = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "KW_SLASH"));
	} 

	/// *
	// * {KW_BACKSLASH, 0,"\\", 0, 0, 0, 0, 0, 0, 1, 1, 130, 0},
	// * / terminal KW_BACKSLASH:
	//	"\\";
	public TerminalRule getKW_BACKSLASHRule() {
		return (tKW_BACKSLASH != null) ? tKW_BACKSLASH : (tKW_BACKSLASH = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "KW_BACKSLASH"));
	} 

	////terminal SLASHSLASH: '//';
	////terminal BACKSLASHBACKSLASH: '\\\\';
	/// * '/\\' SLASH-BACKSLASH or wedge
	// * outer product or logical 'and'
	// * {KW_WEDGE, 0,"/\\", 0, 0, 0, 0, 0, 0, 1, 1, 40, 0},
	// * / terminal KW_WEDGE:
	//	"/\\";
	public TerminalRule getKW_WEDGERule() {
		return (tKW_WEDGE != null) ? tKW_WEDGE : (tKW_WEDGE = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "KW_WEDGE"));
	} 

	/// * \\/ BACKSLASH-SLASH or vee
	// * inner product or logical 'or'
	// * {KW_VEE, 0,"\\/", 0, 0, 0, 0, 0, 0, 1, 1, 40, 0},
	// * / terminal KW_VEE:
	//	"\\/";
	public TerminalRule getKW_VEERule() {
		return (tKW_VEE != null) ? tKW_VEE : (tKW_VEE = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "KW_VEE"));
	} 

	/// * *$ multiply with specific type* / //terminal TIMESDOLAR: '*$';
	/// * /$ divide with specific type* / //terminal DIVDOLAR: '/$';
	/// * +$ add with specific type* / //terminal PLUSDOLAR: '+$';
	/// * -$ subtract or minus with specific type* / //terminal MINUSDOLAR: '-$';
	/// * =$ equals with specific type* / //terminal EQUALSDOLAR: '=$';
	/// * '=>' implies or exit
	// * {KW_Implies, 0,"=>", 0, 0, 0, 0, 0, 0, 1, 1, 35, 0},
	// * / terminal KW_IMPLIES:
	//	"=>";
	public TerminalRule getKW_IMPLIESRule() {
		return (tKW_IMPLIES != null) ? tKW_IMPLIES : (tKW_IMPLIES = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "KW_IMPLIES"));
	} 

	/// * := Assign or Becomes
	// * {KW_Assign, 0,":=", 0, 0, 0, 0, 1, 0, 0, 1, 20, 0},
	// * / terminal KW_ASSIGN:
	//	":=";
	public TerminalRule getKW_ASSIGNRule() {
		return (tKW_ASSIGN != null) ? tKW_ASSIGN : (tKW_ASSIGN = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "KW_ASSIGN"));
	} 

	/// * == 2eq or def
	// * {KW_2EQ, 0,"==", 0, 0, 0, 0, 1, 0, 0, 1, 25, 0},
	// * / terminal KW_2EQ:
	//	"==";
	public TerminalRule getKW_2EQRule() {
		return (tKW_2EQ != null) ? tKW_2EQ : (tKW_2EQ = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "KW_2EQ"));
	} 

	/// * -> right-arrow
	// * {KW_RARROW, 0,"->", 0, 0, 0, 0, 0, 0, 0, 1, 80, 0},
	// * / terminal KW_RARROW:
	//	"->";
	public TerminalRule getKW_RARROWRule() {
		return (tKW_RARROW != null) ? tKW_RARROW : (tKW_RARROW = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "KW_RARROW"));
	} 

	//terminal KW_LARROW:
	//	"<-";
	public TerminalRule getKW_LARROWRule() {
		return (tKW_LARROW != null) ? tKW_LARROW : (tKW_LARROW = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "KW_LARROW"));
	} 

	/// * +-> gives or maps-to
	// * {KW_MAPSTO, 0,"+->", 0, 0, 0, 0, 1, 0, 1, 1, 30, 0},
	// * / terminal KW_MAPSTO:
	//	"+->";
	public TerminalRule getKW_MAPSTORule() {
		return (tKW_MAPSTO != null) ? tKW_MAPSTO : (tKW_MAPSTO = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "KW_MAPSTO"));
	} 

	/// * +->*
	// * {KW_MAPSTOStar, 0,"+->*", 0, 0, 0, 0, 1, 0, 1, 1, 30, 0},
	// * / terminal KW_MAPSTOSTAR:
	//	"+->*";
	public TerminalRule getKW_MAPSTOSTARRule() {
		return (tKW_MAPSTOSTAR != null) ? tKW_MAPSTOSTAR : (tKW_MAPSTOSTAR = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "KW_MAPSTOSTAR"));
	} 

	/// * ->* gives or maps-to
	// * {KW_MAPSTAR, 0,"->*", 0, 0, 0, 0, 0, 0, 0, 1, 80, 0},
	// * / terminal KW_MAPSTAR:
	//	"->*";
	public TerminalRule getKW_MAPSTARRule() {
		return (tKW_MAPSTAR != null) ? tKW_MAPSTAR : (tKW_MAPSTAR = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "KW_MAPSTAR"));
	} 

	/// * % represents an instance of this type * / //terminal PERCENT: '%';
	/// * '% * / //terminal PRIMEPERCENT: "'%";
	/// * ... * / //terminal ELLIPSIS: '...';
	/// * +/ takes the sum of a list * / //terminal SUMLIST: '+/';
	//terminal ANY_OTHER:
	//	.;
	public TerminalRule getANY_OTHERRule() {
		return (tANY_OTHER != null) ? tANY_OTHER : (tANY_OTHER = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "ANY_OTHER"));
	} 

	//////////// end of lexer rules ///////////////
	/// * error seems to be defined externally in Aldor grammar
	// * so I have added this rule so it will compile
	// * / error hidden(WS, KW_NEWLINE):
	//	"error";
	public ErrorElements getErrorAccess() {
		return (pError != null) ? pError : (pError = new ErrorElements());
	}
	
	public ParserRule getErrorRule() {
		return getErrorAccess().getRule();
	}

	//Expression hidden(WS, KW_NEWLINE):
	//	enlist1a_Labeled_Semicolon_AB;
	public ExpressionElements getExpressionAccess() {
		return (pExpression != null) ? pExpression : (pExpression = new ExpressionElements());
	}
	
	public ParserRule getExpressionRule() {
		return getExpressionAccess().getRule();
	}

	/// * An '.as' file is effectively a list of 'Labeled' 
	// * separated by semicolons
	// *
	// * Labeled can be an expression or a Declaration such
	// * as 'macro','extend','local','free','fluid','default'
	// * 'define','fix','inline','import' or 'export'.
	// * / Labeled hidden(WS, KW_NEWLINE):
	//	c=Comma | d=Declaration | KW_AT a=Atom lab=Labeled?;
	public LabeledElements getLabeledAccess() {
		return (pLabeled != null) ? pLabeled : (pLabeled = new LabeledElements());
	}
	
	public ParserRule getLabeledRule() {
		return getLabeledAccess().getRule();
	}

	/// *
	// * A Declaration starts with one of the following key
	// * words: 'macro','extend','local','free','fluid','default'
	// * 'define','fix','inline','import' or 'export'.
	// * / Declaration hidden(WS, KW_NEWLINE):
	//	{DeclarationMacro} "macro" mb=MacroBody | {DeclarationExtend} "extend" si=Sig | {DeclarationLocal} "local" si=Sig |
	//	{DeclarationFree} "free" si=Sig | {DeclarationFluid} "fluid" si=Sig | {DeclarationDefault} "default" si=Sig |
	//	{DeclarationDefine} "define" si=Sig | {DeclarationFix} "fix" si=Sig | {DeclarationInline} "inline" si=Sig?
	//	fp=FromPart? | {DeclarationImport} "import" si=Sig? fp=FromPart? | {DeclarationExport} ed=ExportDecl;
	public DeclarationElements getDeclarationAccess() {
		return (pDeclaration != null) ? pDeclaration : (pDeclaration = new DeclarationElements());
	}
	
	public ParserRule getDeclarationRule() {
		return getDeclarationAccess().getRule();
	}

	//ExportDecl hidden(WS, KW_NEWLINE):
	//	{ExportDecl} "export" s=Sig? | => ("export" s=Sig? tp=ToPart) | => ("export" s=Sig? fp=FromPart);
	public ExportDeclElements getExportDeclAccess() {
		return (pExportDecl != null) ? pExportDecl : (pExportDecl = new ExportDeclElements());
	}
	
	public ParserRule getExportDeclRule() {
		return getExportDeclAccess().getRule();
	}

	//ToPart hidden(WS, KW_NEWLINE):
	//	"to" Infixed;
	public ToPartElements getToPartAccess() {
		return (pToPart != null) ? pToPart : (pToPart = new ToPartElements());
	}
	
	public ParserRule getToPartRule() {
		return getToPartAccess().getRule();
	}

	//FromPart hidden(WS, KW_NEWLINE):
	//	"from" enlist1_Infixed_Comma_AB;
	public FromPartElements getFromPartAccess() {
		return (pFromPart != null) ? pFromPart : (pFromPart = new FromPartElements());
	}
	
	public ParserRule getFromPartRule() {
		return getFromPartAccess().getRule();
	}

	//MacroBody hidden(WS, KW_NEWLINE):
	//	Sig | ExportDecl | "import" Sig fp=FromPart?;
	public MacroBodyElements getMacroBodyAccess() {
		return (pMacroBody != null) ? pMacroBody : (pMacroBody = new MacroBodyElements());
	}
	
	public ParserRule getMacroBodyRule() {
		return getMacroBodyAccess().getRule();
	}

	//Sig hidden(WS, KW_NEWLINE):
	//	DeclBinding | Block;
	public SigElements getSigAccess() {
		return (pSig != null) ? pSig : (pSig = new SigElements());
	}
	
	public ParserRule getSigRule() {
		return getSigAccess().getRule();
	}

	/// * declare type with ':' or ':*' * / DeclPart hidden(WS, KW_NEWLINE):
	//	KW_COLON Type | KW_COLONSTAR Type;
	public DeclPartElements getDeclPartAccess() {
		return (pDeclPart != null) ? pDeclPart : (pDeclPart = new DeclPartElements());
	}
	
	public ParserRule getDeclPartRule() {
		return getDeclPartAccess().getRule();
	}

	/// *
	// * CommaItem (',' CommaItem)*
	// * / Comma hidden(WS, KW_NEWLINE):
	//	enlist1_CommaItem_Comma_AB;
	public CommaElements getCommaAccess() {
		return (pComma != null) ? pComma : (pComma = new CommaElements());
	}
	
	public ParserRule getCommaRule() {
		return getCommaAccess().getRule();
	}

	//CommaItem hidden(WS, KW_NEWLINE):
	//	Binding_AnyStatement => ("where" ci+=CommaItem)*;
	public CommaItemElements getCommaItemAccess() {
		return (pCommaItem != null) ? pCommaItem : (pCommaItem = new CommaItemElements());
	}
	
	public ParserRule getCommaItemRule() {
		return getCommaItemAccess().getRule();
	}

	/// *
	// * DeclBinding
	// * / DeclBinding hidden(WS, KW_NEWLINE):
	//	BindingR_InfixedExprsDecl_AnyStatement;
	public DeclBindingElements getDeclBindingAccess() {
		return (pDeclBinding != null) ? pDeclBinding : (pDeclBinding = new DeclBindingElements());
	}
	
	public ParserRule getDeclBindingRule() {
		return getDeclBindingAccess().getRule();
	}

	//InfixedExprsDecl hidden(WS, KW_NEWLINE):
	//	InfixedExprs dp+=DeclPart*;
	public InfixedExprsDeclElements getInfixedExprsDeclAccess() {
		return (pInfixedExprsDecl != null) ? pInfixedExprsDecl : (pInfixedExprsDecl = new InfixedExprsDeclElements());
	}
	
	public ParserRule getInfixedExprsDeclRule() {
		return getInfixedExprsDeclAccess().getRule();
	}

	//InfixedExprs hidden(WS, KW_NEWLINE):
	//	enlist1_InfixedExpr_Comma_AB;
	public InfixedExprsElements getInfixedExprsAccess() {
		return (pInfixedExprs != null) ? pInfixedExprs : (pInfixedExprs = new InfixedExprsElements());
	}
	
	public ParserRule getInfixedExprsRule() {
		return getInfixedExprsAccess().getRule();
	}

	/// *
	// * Bindings
	// * 
	// * Substituted Rules in Xtext:
	// * Binding_BalStatement
	// * Binding_AnyStatement
	// * Binding_BalStatement
	// * Binding_InfixedExprsDecl
	// * Binding_Collection
	// * Binding(E)
	// * : BindingL(Infixed,E)
	// * ;
	// * / Binding_AnyStatement hidden(WS, KW_NEWLINE):
	//	BindingL_Infixed_AnyStatement;
	public Binding_AnyStatementElements getBinding_AnyStatementAccess() {
		return (pBinding_AnyStatement != null) ? pBinding_AnyStatement : (pBinding_AnyStatement = new Binding_AnyStatementElements());
	}
	
	public ParserRule getBinding_AnyStatementRule() {
		return getBinding_AnyStatementAccess().getRule();
	}

	//Binding_BalStatement hidden(WS, KW_NEWLINE):
	//	BindingL_Infixed_BalStatement;
	public Binding_BalStatementElements getBinding_BalStatementAccess() {
		return (pBinding_BalStatement != null) ? pBinding_BalStatement : (pBinding_BalStatement = new Binding_BalStatementElements());
	}
	
	public ParserRule getBinding_BalStatementRule() {
		return getBinding_BalStatementAccess().getRule();
	}

	//Binding_Collection hidden(WS, KW_NEWLINE):
	//	BindingL_Infixed_Collection;
	public Binding_CollectionElements getBinding_CollectionAccess() {
		return (pBinding_Collection != null) ? pBinding_Collection : (pBinding_Collection = new Binding_CollectionElements());
	}
	
	public ParserRule getBinding_CollectionRule() {
		return getBinding_CollectionAccess().getRule();
	}

	/// * This rule allows any statement or new: Assign, Define or Lambda 
	//  * / BindingL_Infixed_AnyStatement hidden(WS, KW_NEWLINE):
	//	=> (lft=Infixed op=(KW_ASSIGN | KW_2EQ | KW_MARROW | KW_MAPSTO | KW_MAPSTOSTAR) bia=BindingL_Infixed_AnyStatement) |
	//	bas9=AnyStatement;
	public BindingL_Infixed_AnyStatementElements getBindingL_Infixed_AnyStatementAccess() {
		return (pBindingL_Infixed_AnyStatement != null) ? pBindingL_Infixed_AnyStatement : (pBindingL_Infixed_AnyStatement = new BindingL_Infixed_AnyStatementElements());
	}
	
	public ParserRule getBindingL_Infixed_AnyStatementRule() {
		return getBindingL_Infixed_AnyStatementAccess().getRule();
	}

	//BindingL_Infixed_BalStatement hidden(WS, KW_NEWLINE):
	//	=> (lft=Infixed op=(KW_ASSIGN | KW_2EQ | KW_MARROW | KW_MAPSTO | KW_MAPSTOSTAR) bia=BindingL_Infixed_BalStatement) |
	//	bas9=BalStatement;
	public BindingL_Infixed_BalStatementElements getBindingL_Infixed_BalStatementAccess() {
		return (pBindingL_Infixed_BalStatement != null) ? pBindingL_Infixed_BalStatement : (pBindingL_Infixed_BalStatement = new BindingL_Infixed_BalStatementElements());
	}
	
	public ParserRule getBindingL_Infixed_BalStatementRule() {
		return getBindingL_Infixed_BalStatementAccess().getRule();
	}

	//BindingL_Infixed_Collection hidden(WS, KW_NEWLINE):
	//	=> (lft=Infixed op=(KW_ASSIGN | KW_2EQ | KW_MARROW | KW_MAPSTO | KW_MAPSTOSTAR) bia=BindingL_Infixed_Collection) |
	//	bas9=Collection;
	public BindingL_Infixed_CollectionElements getBindingL_Infixed_CollectionAccess() {
		return (pBindingL_Infixed_Collection != null) ? pBindingL_Infixed_Collection : (pBindingL_Infixed_Collection = new BindingL_Infixed_CollectionElements());
	}
	
	public ParserRule getBindingL_Infixed_CollectionRule() {
		return getBindingL_Infixed_CollectionAccess().getRule();
	}

	/// * Substituted Rules in Xtext:
	// * BindingR(InfixedExprsDecl,AnyStatement)
	// * BindingR(R,L)
	// * : R
	// * | R KW_Assign Binding(L)
	// * { $$ = abNewAssign(APOS($1),$1,$3); }
	// * | R KW_2EQ Binding(L)
	// * { $$ = abNewDefine(APOS($1),$1,$3); }
	// * | R KW_MARROW Binding(L)
	// * { $$ = abNewMDefine(APOS($1),$1,$3); }
	// * | R KW_MAPSTO Binding(L)
	// * { $$ = abNewLambda(APOS($1),$1,abZip,$3); }
	// * | R KW_MAPSTOStar Binding(L)
	// * { $$ = abNewPLambda(APOS($1),$1,abZip,$3); }
	// * ;
	// * / //BindingR_InfixedExprsDecl_AnyStatement hidden(WS,KW_NEWLINE):
	//// InfixedExprsDecl
	////| => (InfixedExprsDecl 'assign' bas=Binding_AnyStatement)
	////| => (InfixedExprsDecl KW_2EQ bas=Binding_AnyStatement)
	////| => (InfixedExprsDecl KW_MARROW bas=Binding_AnyStatement)
	////| => (InfixedExprsDecl KW_MAPSTO bas=Binding_AnyStatement)
	////| => (InfixedExprsDecl KW_MAPSTOSTAR bas=Binding_AnyStatement)
	////;
	//BindingR_InfixedExprsDecl_AnyStatement hidden(WS, KW_NEWLINE):
	//	InfixedExprsDecl ((KW_ASSIGN | KW_2EQ | KW_MARROW | KW_MAPSTO | KW_MAPSTOSTAR) bas=Binding_AnyStatement)?;
	public BindingR_InfixedExprsDecl_AnyStatementElements getBindingR_InfixedExprsDecl_AnyStatementAccess() {
		return (pBindingR_InfixedExprsDecl_AnyStatement != null) ? pBindingR_InfixedExprsDecl_AnyStatement : (pBindingR_InfixedExprsDecl_AnyStatement = new BindingR_InfixedExprsDecl_AnyStatementElements());
	}
	
	public ParserRule getBindingR_InfixedExprsDecl_AnyStatementRule() {
		return getBindingR_InfixedExprsDecl_AnyStatementAccess().getRule();
	}

	/// *
	// * Statements
	// *
	// * It is easier to spot conflicts when explicitly handling dangling else.
	// * / AnyStatement hidden(WS, KW_NEWLINE):
	//	=> ("if" CommaItem "then" bas=Binding_AnyStatement) | Flow_AnyStatement;
	public AnyStatementElements getAnyStatementAccess() {
		return (pAnyStatement != null) ? pAnyStatement : (pAnyStatement = new AnyStatementElements());
	}
	
	public ParserRule getAnyStatementRule() {
		return getAnyStatementAccess().getRule();
	}

	/// * 
	// * / BalStatement hidden(WS, KW_NEWLINE):
	//	Flow_BalStatement;
	public BalStatementElements getBalStatementAccess() {
		return (pBalStatement != null) ? pBalStatement : (pBalStatement = new BalStatementElements());
	}
	
	public ParserRule getBalStatementRule() {
		return getBalStatementAccess().getRule();
	}

	/// * Substituted Rules in Xtext:
	//Flow(XX) -> Flow_AnyStatement or Flow_BalStatement
	////Flow(XX)
	////: Collection
	////| KW_If CommaItem KW_Then Binding_BalStatement KW_Else Binding(XX)
	////{ $$ = abNewIf(TPOS($1), TEST($2),$4,$6); }
	////| Collection KW_Implies Binding(XX)
	////{ $$ = abNewExit(TPOS($2), TEST($1),$3); }
	////| Iterators KW_Repeat Binding(XX)
	////{ $$ = abNewRepeatOL(TPOS($2),$3,$1); listFree(AbSyn)($1); }
	////| KW_Repeat Binding(XX)
	////{ $$ = abNewRepeat0(TPOS($1),$2); }
	////| KW_Try Binding_AnyStatement) KW_But ButExpr AlwaysPart(XX)
	////{ (void)parseDeprecated(KW_But, abNewNothing(TPOS($3))); $$ = abNewTry(TPOS($1),$2,$4->abSequence.argv[0], $4->abSequence.argv[1],$5); }
	////| KW_Try Binding_AnyStatement) KW_Catch ButExpr AlwaysPart(XX)
	////{ $$ = abNewTry(TPOS($1),$2,$4->abSequence.argv[0], $4->abSequence.argv[1],$5); }
	////| KW_Select Binding_AnyStatement) KW_In Cases
	////{ $$ = abNewSelect(TPOS($1),$2,$4); }
	////| KW_Do Binding(XX)
	////{ $$ = abNewDo(TPOS($1),$2); }
	////| KW_Delay Binding(XX)
	////{ $$ = abNewDelay(TPOS($1),$2); }
	////| KW_Reference Binding(XX)
	////{ $$ = abNewReference(TPOS($1),$2); }
	////| KW_Generate GenBound Binding(XX)
	////{ $$ = abNewGenerate(TPOS($1),$2,$3); }
	////| KW_Assert Binding(XX)
	////{ $$ = abNewAssert(TPOS($1),TEST($2)); }
	////| KW_Iterate opt(Name)
	////{ $$ = abNewIterate(TPOS($1),$2); }
	////| KW_Break opt(Name)
	////{ $$ = abNewBreak(TPOS($1),$2); }
	////| KW_Return opt(Collection)
	////{ $$ = abNewReturn(TPOS($1),$2); }
	////| KW_Yield Binding(XX)
	////{ $$ = abNewYield(TPOS($1),$2); }
	////| KW_Except Binding(XX)
	////{ $$ = parseDeprecated(KW_Except, abNewRaise(TPOS($1),$2)); }
	////| KW_Throw Binding(XX)
	////{ $$ = abNewRaise(TPOS($1),$2); }
	////| KW_Goto Id
	////{ $$ = abNewGoto(TPOS($1),$2); }
	////| KW_Never
	////{ $$ = abNewNever(TPOS($1)); }
	////;
	// * / Flow_AnyStatement hidden(WS, KW_NEWLINE):
	//	c=Collection (st="implies" bas2=Binding_AnyStatement)? // '.... for' or 'while ....'
	//	| st="if" ci=CommaItem "then" bbs=Binding_BalStatement => "else" bas=Binding_AnyStatement | // 'for .... in' or 'while ....'
	//	=> (Iterators st="repeat" bas3=Binding_AnyStatement) | st="repeat" bas=Binding_AnyStatement | st="try"
	//	bas=Binding_AnyStatement ("but" | "catch") be2=ButExpr apa=AlwaysPart_AnyStatement | st="select"
	//	bas=Binding_AnyStatement "in" ca=Cases | st="do" bas=Binding_AnyStatement | st="delay" bas=Binding_AnyStatement |
	//	st="reference" bas=Binding_AnyStatement | st="generate" gb=GenBound bas4=Binding_AnyStatement | st="assert"
	//	bas=Binding_AnyStatement | st="iterate" n=Name? | st="break" n=Name? | st="return" c=Collection? | st="yield"
	//	bas=Binding_AnyStatement | st="except" bas=Binding_AnyStatement | st="throw" bas=Binding_AnyStatement | st="goto"
	//	i2=Id | st="never";
	public Flow_AnyStatementElements getFlow_AnyStatementAccess() {
		return (pFlow_AnyStatement != null) ? pFlow_AnyStatement : (pFlow_AnyStatement = new Flow_AnyStatementElements());
	}
	
	public ParserRule getFlow_AnyStatementRule() {
		return getFlow_AnyStatementAccess().getRule();
	}

	/// *  * / Flow_BalStatement hidden(WS, KW_NEWLINE):
	//	c2=Collection (st2="implies" bbs3=Binding_BalStatement)? // '.... for' or 'while ....'
	//	| st2="if" ci2=CommaItem "then" bbs4+=Binding_BalStatement => "else" bbs4+=Binding_BalStatement | // 'for .... in' or 'while ....'
	//	=> (Iterators st2="repeat" bbs3=Binding_BalStatement) | st2="repeat" bbs5=Binding_BalStatement | st2="try"
	//	bbs2=Binding_AnyStatement ("but" | "catch") be=ButExpr apb=AlwaysPart_BalStatement | st2="select"
	//	bbs2=Binding_AnyStatement "in" ca2=Cases | st2="do" bbs5=Binding_BalStatement | st2="delay" bbs5=Binding_BalStatement
	//	| st2="reference" bbs5=Binding_BalStatement | st2="generate" gb2=GenBound bbs5=Binding_BalStatement | st2="assert"
	//	bbs5=Binding_BalStatement | st2="iterate" n2=Name? | st2="break" n2=Name? | st2="return" c2=Collection? | st2="yield"
	//	bbs5=Binding_BalStatement | st2="except" bbs5=Binding_BalStatement | st2="throw" bbs5=Binding_BalStatement |
	//	st2="goto" i3=Id | st2="never";
	public Flow_BalStatementElements getFlow_BalStatementAccess() {
		return (pFlow_BalStatement != null) ? pFlow_BalStatement : (pFlow_BalStatement = new Flow_BalStatementElements());
	}
	
	public ParserRule getFlow_BalStatementRule() {
		return getFlow_BalStatementAccess().getRule();
	}

	//GenBound hidden(WS, KW_NEWLINE):
	//	{GenBound} ("to" ci=CommaItem "of")?;
	public GenBoundElements getGenBoundAccess() {
		return (pGenBound != null) ? pGenBound : (pGenBound = new GenBoundElements());
	}
	
	public ParserRule getGenBoundRule() {
		return getGenBoundAccess().getRule();
	}

	//ButExpr hidden(WS, KW_NEWLINE):
	//	{ButExpr} (db=DeclBinding "in" ca=Cases)?;
	public ButExprElements getButExprAccess() {
		return (pButExpr != null) ? pButExpr : (pButExpr = new ButExprElements());
	}
	
	public ParserRule getButExprRule() {
		return getButExprAccess().getRule();
	}

	//Cases hidden(WS, KW_NEWLINE):
	//	Binding_Collection;
	public CasesElements getCasesAccess() {
		return (pCases != null) ? pCases : (pCases = new CasesElements());
	}
	
	public ParserRule getCasesRule() {
		return getCasesAccess().getRule();
	}

	/// * Substituted Rules in Xtext:
	// * AlwaysPart(XX) -> AlwaysPart_AnyStatement
	// *                or AlwaysPart_BalStatement
	// * AlwaysPart(XX)
	// * : KW_Always Binding(XX)
	// * { (void)parseDeprecated(KW_Always, abNewNothing(TPOS($1))); $$ = $2; }
	// * | KW_Finally Binding(XX)
	// * { $$ = $2; }
	// * | Nothing
	////;
	// * / AlwaysPart_AnyStatement hidden(WS, KW_NEWLINE):
	//	{AlwaysPart_AnyStatement} ("always" bas7=Binding_AnyStatement | "finally" bas7=Binding_AnyStatement)?;
	public AlwaysPart_AnyStatementElements getAlwaysPart_AnyStatementAccess() {
		return (pAlwaysPart_AnyStatement != null) ? pAlwaysPart_AnyStatement : (pAlwaysPart_AnyStatement = new AlwaysPart_AnyStatementElements());
	}
	
	public ParserRule getAlwaysPart_AnyStatementRule() {
		return getAlwaysPart_AnyStatementAccess().getRule();
	}

	//AlwaysPart_BalStatement hidden(WS, KW_NEWLINE):
	//	{AlwaysPart_BalStatement} ("always" bas7=Binding_BalStatement | "finally" bas7=Binding_BalStatement)?;
	public AlwaysPart_BalStatementElements getAlwaysPart_BalStatementAccess() {
		return (pAlwaysPart_BalStatement != null) ? pAlwaysPart_BalStatement : (pAlwaysPart_BalStatement = new AlwaysPart_BalStatementElements());
	}
	
	public ParserRule getAlwaysPart_BalStatementRule() {
		return getAlwaysPart_BalStatementAccess().getRule();
	}

	/// *
	// * infixed optionally followed by Iterators
	// * .... for .... in .... | ....
	// * while ....
	// * / Collection hidden(WS, KW_NEWLINE):
	//	Infixed i3= // iterators allow for zero cases
	//	Iterators;
	public CollectionElements getCollectionAccess() {
		return (pCollection != null) ? pCollection : (pCollection = new CollectionElements());
	}
	
	public ParserRule getCollectionRule() {
		return getCollectionAccess().getRule();
	}

	/// * Zero or more iterators: for....in or while.... * / Iterators hidden(WS, KW_NEWLINE):
	//	Iterators1;
	public IteratorsElements getIteratorsAccess() {
		return (pIterators != null) ? pIterators : (pIterators = new IteratorsElements());
	}
	
	public ParserRule getIteratorsRule() {
		return getIteratorsAccess().getRule();
	}

	/// * Zero or more iterators: for....in or while.... * / Iterators1 hidden(WS, KW_NEWLINE):
	//	{Iterators1} itr+=Iterator*;
	public Iterators1Elements getIterators1Access() {
		return (pIterators1 != null) ? pIterators1 : (pIterators1 = new Iterators1Elements());
	}
	
	public ParserRule getIterators1Rule() {
		return getIterators1Access().getRule();
	}

	/// * Iterator: for....in or while.... * / Iterator hidden(WS, KW_NEWLINE):
	//	"for" ForLhs "in" i=Infixed sp=SuchthatPart? | "while" i=Infixed;
	public IteratorElements getIteratorAccess() {
		return (pIterator != null) ? pIterator : (pIterator = new IteratorElements());
	}
	
	public ParserRule getIteratorRule() {
		return getIteratorAccess().getRule();
	}

	//ForLhs hidden(WS, KW_NEWLINE):
	//	("free" | "local" | "fluid")? Infixed;
	public ForLhsElements getForLhsAccess() {
		return (pForLhs != null) ? pForLhs : (pForLhs = new ForLhsElements());
	}
	
	public ParserRule getForLhsRule() {
		return getForLhsAccess().getRule();
	}

	//SuchthatPart hidden(WS, KW_NEWLINE):
	//	KW_BAR Infixed;
	public SuchthatPartElements getSuchthatPartAccess() {
		return (pSuchthatPart != null) ? pSuchthatPart : (pSuchthatPart = new SuchthatPartElements());
	}
	
	public ParserRule getSuchthatPartRule() {
		return getSuchthatPartAccess().getRule();
	}

	/// *
	// * Infixed Expressions
	// * Either:
	// * an expression
	// * or a typed expression
	// * or a block (CurlyContents_Labeled inside curly brackets)
	// * / Infixed hidden(WS, KW_NEWLINE):
	//	ifx=InfixedExpr dp=DeclPart? | b=Block;
	public InfixedElements getInfixedAccess() {
		return (pInfixed != null) ? pInfixed : (pInfixed = new InfixedElements());
	}
	
	public ParserRule getInfixedRule() {
		return getInfixedAccess().getRule();
	}

	/// *
	// * if we enable 'returns Expr' then 'E11_E12' replaces id in AST
	// * / / *returns Expr* / InfixedExpr hidden(WS, KW_NEWLINE): // prefix operation
	//	E11_Op | // infix operation
	//	=> E3;
	public InfixedExprElements getInfixedExprAccess() {
		return (pInfixedExpr != null) ? pInfixedExpr : (pInfixedExpr = new InfixedExprElements());
	}
	
	public ParserRule getInfixedExprRule() {
		return getInfixedExprAccess().getRule();
	}

	/// *
	// * 'and','or' logic operators
	// * need to allow a 'qualified op', that is an operation followed by '$' and a type
	// * / E3 returns Expr hidden(WS, KW_NEWLINE):
	//	E4 ({E3.left=current} op=("and" / *QualOp_LatticeTok* / | "or" | LatticeTok) right=E4)*;
	public E3Elements getE3Access() {
		return (pE3 != null) ? pE3 : (pE3 = new E3Elements());
	}
	
	public ParserRule getE3Rule() {
		return getE3Access().getRule();
	}

	/// * relation operators
	// * in YACC version this rule also includes relation operators as prefix
	// * but for Antlr we need to move prefix operators somewhere else
	// * 
	// * need to allow a 'qualified op', that is an operation followed by '$' and a type
	// * / //| (RelationOp {E4.left=current} right+=E5)
	//E4 returns Expr hidden(WS, KW_NEWLINE):
	//	E5 ({E4.left=current} op=("has" / *RelationOp* / | RelationTok) right=E5)*;
	public E4Elements getE4Access() {
		return (pE4 != null) ? pE4 : (pE4 = new E4Elements());
	}
	
	public ParserRule getE4Rule() {
		return getE4Access().getRule();
	}

	/// * segment operators: '..' and 'by'
	// * in YACC version this rule also includes segment operators as postfix
	// * but for Antlr we need to move postfix operators somewhere else
	// * 
	// * need to allow a 'qualified op', that is an operation followed by '$' and a type
	// * / //=>
	////| (left=E6 {E5.left=current} op5+=SegOp)
	//E5 returns Expr hidden(WS, KW_NEWLINE):
	//	E6 ({E5.left=current} op=SegTok / *SegOp* / right=E6)*;
	public E5Elements getE5Access() {
		return (pE5 != null) ? pE5 : (pE5 = new E5Elements());
	}
	
	public ParserRule getE5Rule() {
		return getE5Access().getRule();
	}

	/// *
	// * in YACC version this rule also includes relation operators as prefix (unary plus)
	// * but for Antlr we need to move prefix operators somewhere else
	// * 
	// * need to allow a 'qualified op', that is an operation followed by '$' and a type
	// * / //| (op6+=PlusOp right=E7)
	//E6 returns Expr hidden(WS, KW_NEWLINE):
	//	E7 ({E6.left=current} op=PlusTok / *PlusOp* / right=E7)*;
	public E6Elements getE6Access() {
		return (pE6 != null) ? pE6 : (pE6 = new E6Elements());
	}
	
	public ParserRule getE6Rule() {
		return getE6Access().getRule();
	}

	/// *
	// * quotient operations
	// * 
	// * need to allow a 'qualified op', that is an operation followed by '$' and a type
	// * / E7 returns Expr hidden(WS, KW_NEWLINE):
	//	E8 ({E7.left=current} op=QuotientTok / *QuotientOp* / right=E8)*;
	public E7Elements getE7Access() {
		return (pE7 != null) ? pE7 : (pE7 = new E7Elements());
	}
	
	public ParserRule getE7Rule() {
		return getE7Access().getRule();
	}

	/// *
	// * multiplication operations
	// * 
	// * need to allow a 'qualified op', that is an operation followed by '$' and a type
	// * / E8 returns Expr hidden(WS, KW_NEWLINE):
	//	E9 ({E8.left=current} op=TimesTok / *TimesOp* / right=E9)*;
	public E8Elements getE8Access() {
		return (pE8 != null) ? pE8 : (pE8 = new E8Elements());
	}
	
	public ParserRule getE8Rule() {
		return getE8Access().getRule();
	}

	/// *
	// * exponent operations
	// * 
	// * need to allow a 'qualified op', that is an operation followed by '$' and a type
	// * / E9 returns Expr hidden(WS, KW_NEWLINE):
	//	E11_E12 ({E9.left=current} op=PowerTok / *PowerOp* / right=E11_E12)*;
	public E9Elements getE9Access() {
		return (pE9 != null) ? pE9 : (pE9 = new E9Elements());
	}
	
	public ParserRule getE9Rule() {
		return getE9Access().getRule();
	}

	/// *
	// * This version of E11 is used in the middle of the precedence stack
	// * / E11_E12 returns Expr hidden(WS, KW_NEWLINE):
	//	E12 ({E11_E12.left=current} (op=KW_2COLON | op=KW_AT | op="pretend") right=E12)*;
	public E11_E12Elements getE11_E12Access() {
		return (pE11_E12 != null) ? pE11_E12 : (pE11_E12 = new E11_E12Elements());
	}
	
	public ParserRule getE11_E12Rule() {
		return getE11_E12Access().getRule();
	}

	/// *
	// * prefix operation
	// * 
	// * This version of E11 is used at the top of the precedence stack in
	// * 'InfixedExpr'
	// * / E11_Op returns Expr hidden(WS, KW_NEWLINE):
	//	Op ({E11_Op.left=current} (op=KW_2COLON | op=KW_AT | op="pretend") right=E12)*;
	public E11_OpElements getE11_OpAccess() {
		return (pE11_Op != null) ? pE11_Op : (pE11_Op = new E11_OpElements());
	}
	
	public ParserRule getE11_OpRule() {
		return getE11_OpAccess().getRule();
	}

	/// *
	// * use this rule when we know it is a type.
	// * That is in 'DeclPart' where it follows '$'
	// * / Type hidden(WS, KW_NEWLINE):
	//	E11_E12;
	public TypeElements getTypeAccess() {
		return (pType != null) ? pType : (pType = new TypeElements());
	}
	
	public ParserRule getTypeRule() {
		return getTypeAccess().getRule();
	}

	//E12 returns Expr hidden(WS, KW_NEWLINE):
	//	E13 ({E12.left=current} op=ArrowOp right=E13)*;
	public E12Elements getE12Access() {
		return (pE12 != null) ? pE12 : (pE12 = new E12Elements());
	}
	
	public ParserRule getE12Rule() {
		return getE12Access().getRule();
	}

	//E13 returns Expr hidden(WS, KW_NEWLINE):
	//	E14 ({E13.left=current} op=KW_DOLLAR right=QualTail)*;
	public E13Elements getE13Access() {
		return (pE13 != null) ? pE13 : (pE13 = new E13Elements());
	}
	
	public ParserRule getE13Rule() {
		return getE13Access().getRule();
	}

	//QualTail hidden(WS, KW_NEWLINE):
	//	LeftJuxtaposed => (KW_DOLLAR qt=QualTail)?;
	public QualTailElements getQualTailAccess() {
		return (pQualTail != null) ? pQualTail : (pQualTail = new QualTailElements());
	}
	
	public ParserRule getQualTailRule() {
		return getQualTailAccess().getRule();
	}

	//OpQualTail hidden(WS, KW_NEWLINE):
	//	nam=Molecule => (KW_DOLLAR OpQualTail)?;
	public OpQualTailElements getOpQualTailAccess() {
		return (pOpQualTail != null) ? pOpQualTail : (pOpQualTail = new OpQualTailElements());
	}
	
	public ParserRule getOpQualTailRule() {
		return getOpQualTailAccess().getRule();
	}

	//E14 hidden(WS, KW_NEWLINE):
	//	=> (e15left=E15? op="with" dm=DeclMolecule) | => (e15left=E15? op="add" dm=DeclMolecule) | => (e15left=E15 op="except"
	//	e15right=E15) | => (e15left=E15 op="throw" e15right=E15) | e15left=E15;
	public E14Elements getE14Access() {
		return (pE14 != null) ? pE14 : (pE14 = new E14Elements());
	}
	
	public ParserRule getE14Rule() {
		return getE14Access().getRule();
	}

	//E15 hidden(WS, KW_NEWLINE):
	//	Application;
	public E15Elements getE15Access() {
		return (pE15 != null) ? pE15 : (pE15 = new E15Elements());
	}
	
	public ParserRule getE15Rule() {
		return getE15Access().getRule();
	}

	/// *
	// * Infixed Operations
	// * / Op hidden(WS, KW_NEWLINE):
	//	{Op} aop=ArrowOp | {Op} aop=LatticeOp | {Op} aop=RelationOp | {Op} aop=SegOp | {Op} aop=PlusOp | {Op} aop=QuotientOp |
	//	{Op} aop=TimesOp | {Op} aop=PowerOp;
	public OpElements getOpAccess() {
		return (pOp != null) ? pOp : (pOp = new OpElements());
	}
	
	public ParserRule getOpRule() {
		return getOpAccess().getRule();
	}

	//NakedOp hidden(WS, KW_NEWLINE):
	//	UnqualOp_ArrowTok | UnqualOp_LatticeTok | UnqualOp_RelationTok | UnqualOp_SegTok | UnqualOp_PlusTok |
	//	UnqualOp_QuotientTok | UnqualOp_TimesTok | UnqualOp_PowerTok;
	public NakedOpElements getNakedOpAccess() {
		return (pNakedOp != null) ? pNakedOp : (pNakedOp = new NakedOpElements());
	}
	
	public ParserRule getNakedOpRule() {
		return getNakedOpAccess().getRule();
	}

	//ArrowOp hidden(WS, KW_NEWLINE):
	//	QualOp_ArrowTok;
	public ArrowOpElements getArrowOpAccess() {
		return (pArrowOp != null) ? pArrowOp : (pArrowOp = new ArrowOpElements());
	}
	
	public ParserRule getArrowOpRule() {
		return getArrowOpAccess().getRule();
	}

	//LatticeOp hidden(WS, KW_NEWLINE):
	//	QualOp_LatticeTok;
	public LatticeOpElements getLatticeOpAccess() {
		return (pLatticeOp != null) ? pLatticeOp : (pLatticeOp = new LatticeOpElements());
	}
	
	public ParserRule getLatticeOpRule() {
		return getLatticeOpAccess().getRule();
	}

	//RelationOp hidden(WS, KW_NEWLINE):
	//	QualOp_RelationTok;
	public RelationOpElements getRelationOpAccess() {
		return (pRelationOp != null) ? pRelationOp : (pRelationOp = new RelationOpElements());
	}
	
	public ParserRule getRelationOpRule() {
		return getRelationOpAccess().getRule();
	}

	//SegOp hidden(WS, KW_NEWLINE):
	//	QualOp_SegTok;
	public SegOpElements getSegOpAccess() {
		return (pSegOp != null) ? pSegOp : (pSegOp = new SegOpElements());
	}
	
	public ParserRule getSegOpRule() {
		return getSegOpAccess().getRule();
	}

	//PlusOp hidden(WS, KW_NEWLINE):
	//	QualOp_PlusTok;
	public PlusOpElements getPlusOpAccess() {
		return (pPlusOp != null) ? pPlusOp : (pPlusOp = new PlusOpElements());
	}
	
	public ParserRule getPlusOpRule() {
		return getPlusOpAccess().getRule();
	}

	//QuotientOp hidden(WS, KW_NEWLINE):
	//	QualOp_QuotientTok;
	public QuotientOpElements getQuotientOpAccess() {
		return (pQuotientOp != null) ? pQuotientOp : (pQuotientOp = new QuotientOpElements());
	}
	
	public ParserRule getQuotientOpRule() {
		return getQuotientOpAccess().getRule();
	}

	//TimesOp hidden(WS, KW_NEWLINE):
	//	QualOp_TimesTok;
	public TimesOpElements getTimesOpAccess() {
		return (pTimesOp != null) ? pTimesOp : (pTimesOp = new TimesOpElements());
	}
	
	public ParserRule getTimesOpRule() {
		return getTimesOpAccess().getRule();
	}

	//PowerOp hidden(WS, KW_NEWLINE):
	//	QualOp_PowerTok;
	public PowerOpElements getPowerOpAccess() {
		return (pPowerOp != null) ? pPowerOp : (pPowerOp = new PowerOpElements());
	}
	
	public ParserRule getPowerOpRule() {
		return getPowerOpAccess().getRule();
	}

	/// * in Aldor grammar this is ArrowTok<tok> * / ArrowTok hidden(WS, KW_NEWLINE):
	//	KW_RARROW | KW_LARROW | KW_MAPSTAR;
	public ArrowTokElements getArrowTokAccess() {
		return (pArrowTok != null) ? pArrowTok : (pArrowTok = new ArrowTokElements());
	}
	
	public ParserRule getArrowTokRule() {
		return getArrowTokAccess().getRule();
	}

	/// * in Aldor grammar this is LatticeTok<tok> * / LatticeTok hidden(WS, KW_NEWLINE):
	//	KW_VEE | KW_WEDGE;
	public LatticeTokElements getLatticeTokAccess() {
		return (pLatticeTok != null) ? pLatticeTok : (pLatticeTok = new LatticeTokElements());
	}
	
	public ParserRule getLatticeTokRule() {
		return getLatticeTokAccess().getRule();
	}

	/// * in Aldor grammar this is RelationTok<tok> * / RelationTok hidden(WS, KW_NEWLINE):
	//	KW_EQ | KW_TILDEE | KW_HATE | KW_GE | KW_GT | KW_2GT | KW_LE | KW_LT | KW_2LT | "is" | "isnt" | "case";
	public RelationTokElements getRelationTokAccess() {
		return (pRelationTok != null) ? pRelationTok : (pRelationTok = new RelationTokElements());
	}
	
	public ParserRule getRelationTokRule() {
		return getRelationTokAccess().getRule();
	}

	/// * in Aldor grammar this is SegTok<tok> * / SegTok hidden(WS, KW_NEWLINE):
	//	KW_2DOT | "by";
	public SegTokElements getSegTokAccess() {
		return (pSegTok != null) ? pSegTok : (pSegTok = new SegTokElements());
	}
	
	public ParserRule getSegTokRule() {
		return getSegTokAccess().getRule();
	}

	/// * in Aldor grammar this is PlusTok<tok> * / PlusTok hidden(WS, KW_NEWLINE):
	//	KW_PLUS | KW_MINUS | KW_PLUSMINUS;
	public PlusTokElements getPlusTokAccess() {
		return (pPlusTok != null) ? pPlusTok : (pPlusTok = new PlusTokElements());
	}
	
	public ParserRule getPlusTokRule() {
		return getPlusTokAccess().getRule();
	}

	/// * in Aldor grammar this is QuotientTok<tok> * / QuotientTok hidden(WS, KW_NEWLINE):
	//	"mod" | "quo" | "rem" | "exquo";
	public QuotientTokElements getQuotientTokAccess() {
		return (pQuotientTok != null) ? pQuotientTok : (pQuotientTok = new QuotientTokElements());
	}
	
	public ParserRule getQuotientTokRule() {
		return getQuotientTokAccess().getRule();
	}

	/// * in Aldor grammar this is TimesTok<tok> * / TimesTok hidden(WS, KW_NEWLINE):
	//	KW_STAR | KW_SLASH | KW_BACKSLASH;
	public TimesTokElements getTimesTokAccess() {
		return (pTimesTok != null) ? pTimesTok : (pTimesTok = new TimesTokElements());
	}
	
	public ParserRule getTimesTokRule() {
		return getTimesTokAccess().getRule();
	}

	/// * in Aldor grammar this is PowerTok<tok> * / PowerTok hidden(WS, KW_NEWLINE):
	//	KW_2STAR | KW_HAT;
	public PowerTokElements getPowerTokAccess() {
		return (pPowerTok != null) ? pPowerTok : (pPowerTok = new PowerTokElements());
	}
	
	public ParserRule getPowerTokRule() {
		return getPowerTokAccess().getRule();
	}

	/// *
	// * Function Application
	// * We can express function application by using bracket notation like this:
	// * f(a1, ..., an)
	// * So the function is expressed as a prefix to its arguments.
	// * If there is only one argument then Aldor also allows us to express
	// * function application by using juxtaposed expressions.
	// * 
	// * There are two additional forms for specifying a prefix
	// * application to one argument: juxtaposition and an infix dot.
	// * 
	// * f a
	// * f.a
	// * 
	// * The second of these forms is completely equivalent to
	// * f(a); the first is equivalent in a free-standing occurrence
	// * but associates differently -- to the right, rather than
	// * the left:
	// * 
	// *  f a b c      -- is equivalent to (f (a (b c)))
	// *  f.a.b.c      -- is equivalent to (((f.a).b).c)
	// *  f(a)(b)(c)   -- is equivalent to (((f(a))(b))(c))
	// *
	// * / Application hidden(WS, KW_NEWLINE):
	//	RightJuxtaposed;
	public ApplicationElements getApplicationAccess() {
		return (pApplication != null) ? pApplication : (pApplication = new ApplicationElements());
	}
	
	public ParserRule getApplicationRule() {
		return getApplicationAccess().getRule();
	}

	/// *
	// * implements 'function application' as described above including juxtaposition
	// * / RightJuxtaposed hidden(WS, KW_NEWLINE):
	//	Jright_Molecule;
	public RightJuxtaposedElements getRightJuxtaposedAccess() {
		return (pRightJuxtaposed != null) ? pRightJuxtaposed : (pRightJuxtaposed = new RightJuxtaposedElements());
	}
	
	public ParserRule getRightJuxtaposedRule() {
		return getRightJuxtaposedAccess().getRule();
	}

	/// * Molecule followed by 0 or more BlockEnclosures (bracketed terms)
	// * or variants on that theme.
	// * / LeftJuxtaposed hidden(WS, KW_NEWLINE):
	//	Jleft_Molecule;
	public LeftJuxtaposedElements getLeftJuxtaposedAccess() {
		return (pLeftJuxtaposed != null) ? pLeftJuxtaposed : (pLeftJuxtaposed = new LeftJuxtaposedElements());
	}
	
	public ParserRule getLeftJuxtaposedRule() {
		return getLeftJuxtaposedAccess().getRule();
	}

	/// * 
	// * implements 'function application' as described above including juxtaposition
	// *
	// * substituted version of axl.z code:
	// * Jright(H) : Jleft(H) | Jleft(H) Jright(Atom)
	// * | 'not' Jright(Atom)
	// * / Jright_Molecule hidden(WS, KW_NEWLINE):
	//	Jleft_Molecule right=Jright_Atom? | "not" right=Jright_Atom;
	public Jright_MoleculeElements getJright_MoleculeAccess() {
		return (pJright_Molecule != null) ? pJright_Molecule : (pJright_Molecule = new Jright_MoleculeElements());
	}
	
	public ParserRule getJright_MoleculeRule() {
		return getJright_MoleculeAccess().getRule();
	}

	//Jright_Atom hidden(WS, KW_NEWLINE):
	//	Jleft_Atom right2=Jright_Atom? | "not" right2=Jright_Atom;
	public Jright_AtomElements getJright_AtomAccess() {
		return (pJright_Atom != null) ? pJright_Atom : (pJright_Atom = new Jright_AtomElements());
	}
	
	public ParserRule getJright_AtomRule() {
		return getJright_AtomAccess().getRule();
	}

	/// * Molecule followed by 0 or more BlockEnclosures (bracketed terms)
	// * or variants on that theme.
	// * 
	// * matches:
	// * - Molecule - no argument
	// * - 'not' BlockEnclosure - not has one argument
	// * - (*) BlockEnclosure
	// * - (*) '.' BlockMolecule
	// * 
	// * substituted version of axl.z code:
	// * Jleft(H) : H | 'not' BlockEnclosure
	// *              | Jleft(H) BlockEnclosure
	// *              | Jleft(H) KW_DOT BlockMolecule ;
	// * / Jleft_Molecule hidden(WS, KW_NEWLINE):
	//	"not" be+=BlockEnclosure | => (m=Molecule be+=BlockEnclosure*) | m=Molecule (KW_DOT bm+=BlockMolecule)*;
	public Jleft_MoleculeElements getJleft_MoleculeAccess() {
		return (pJleft_Molecule != null) ? pJleft_Molecule : (pJleft_Molecule = new Jleft_MoleculeElements());
	}
	
	public ParserRule getJleft_MoleculeRule() {
		return getJleft_MoleculeAccess().getRule();
	}

	/// * 
	// * matches:
	// * - Atom - no argument
	// * - 'not' BlockEnclosure - not has one argument
	// * - (*) BlockEnclosure
	// * - (*) '.' BlockMolecule
	// * 
	// * substituted version of axl.z code:
	// * Jleft(H) : H | 'not' BlockEnclosure
	// *              | Jleft(H) BlockEnclosure
	// *              | Jleft(H) KW_DOT BlockMolecule ;
	// * / Jleft_Atom hidden(WS, KW_NEWLINE):
	//	"not" be+=BlockEnclosure | => (a=Atom be+=BlockEnclosure*) | a=Atom (KW_DOT bm4+=BlockMolecule)*;
	public Jleft_AtomElements getJleft_AtomAccess() {
		return (pJleft_Atom != null) ? pJleft_Atom : (pJleft_Atom = new Jleft_AtomElements());
	}
	
	public ParserRule getJleft_AtomRule() {
		return getJleft_AtomAccess().getRule();
	}

	/// *
	// * Indivisible Expressions
	// * / Molecule hidden(WS, KW_NEWLINE):
	//	Atom | Enclosure;
	public MoleculeElements getMoleculeAccess() {
		return (pMolecule != null) ? pMolecule : (pMolecule = new MoleculeElements());
	}
	
	public ParserRule getMoleculeRule() {
		return getMoleculeAccess().getRule();
	}

	/// * expression in brackets parenthesis or quotes * / Enclosure hidden(WS, KW_NEWLINE):
	//	Parened | Bracketed | QuotedIds;
	public EnclosureElements getEnclosureAccess() {
		return (pEnclosure != null) ? pEnclosure : (pEnclosure = new EnclosureElements());
	}
	
	public ParserRule getEnclosureRule() {
		return getEnclosureAccess().getRule();
	}

	/// *
	// * function application, block or infixed
	// * follows 'add' or 'with'
	// * / DeclMolecule hidden(WS, KW_NEWLINE):
	//	{DeclMolecule} a=Application? | b=Block;
	public DeclMoleculeElements getDeclMoleculeAccess() {
		return (pDeclMolecule != null) ? pDeclMolecule : (pDeclMolecule = new DeclMoleculeElements());
	}
	
	public ParserRule getDeclMoleculeRule() {
		return getDeclMoleculeAccess().getRule();
	}

	/// * atom, enclosure: (....),[....],"...." or block {....}
	// * Used by Jleft_Molecule and Jleft_Atom
	// * / BlockMolecule hidden(WS, KW_NEWLINE):
	//	Atom | Enclosure | Block;
	public BlockMoleculeElements getBlockMoleculeAccess() {
		return (pBlockMolecule != null) ? pBlockMolecule : (pBlockMolecule = new BlockMoleculeElements());
	}
	
	public ParserRule getBlockMoleculeRule() {
		return getBlockMoleculeAccess().getRule();
	}

	/// * enclosure: (....),[....],"...." or block {....} * / BlockEnclosure hidden(WS, KW_NEWLINE):
	//	Enclosure | Block;
	public BlockEnclosureElements getBlockEnclosureAccess() {
		return (pBlockEnclosure != null) ? pBlockEnclosure : (pBlockEnclosure = new BlockEnclosureElements());
	}
	
	public ParserRule getBlockEnclosureRule() {
		return getBlockEnclosureAccess().getRule();
	}

	/// * CurlyContents_Labeled inside curly brackets * / Block hidden(WS, KW_NEWLINE): // Piled(Expression)|
	//	Curly_Labeled;
	public BlockElements getBlockAccess() {
		return (pBlock != null) ? pBlock : (pBlock = new BlockElements());
	}
	
	public ParserRule getBlockRule() {
		return getBlockAccess().getRule();
	}

	/// * expression in parenthesis * / Parened hidden(WS, KW_NEWLINE):
	//	op=KW_OPAREN e=Expression? KW_CPAREN;
	public ParenedElements getParenedAccess() {
		return (pParened != null) ? pParened : (pParened = new ParenedElements());
	}
	
	public ParserRule getParenedRule() {
		return getParenedAccess().getRule();
	}

	/// * expression in brackets * / Bracketed hidden(WS, KW_NEWLINE):
	//	op=KW_OBRACK e=Expression? KW_CBRACK;
	public BracketedElements getBracketedAccess() {
		return (pBracketed != null) ? pBracketed : (pBracketed = new BracketedElements());
	}
	
	public ParserRule getBracketedRule() {
		return getBracketedAccess().getRule();
	}

	/// * names in quotes * / QuotedIds hidden(WS, KW_NEWLINE):
	//	{QuotedIds} op=KW_QUOTE n=Names? KW_QUOTE;
	public QuotedIdsElements getQuotedIdsAccess() {
		return (pQuotedIds != null) ? pQuotedIds : (pQuotedIds = new QuotedIdsElements());
	}
	
	public ParserRule getQuotedIdsRule() {
		return getQuotedIdsAccess().getRule();
	}

	/// * names seperated by commas * / Names hidden(WS, KW_NEWLINE):
	//	firstName=TK_ID (KW_COMMA subsequentNames+=TK_ID)*;
	public NamesElements getNamesAccess() {
		return (pNames != null) ? pNames : (pNames = new NamesElements());
	}
	
	public ParserRule getNamesRule() {
		return getNamesAccess().getRule();
	}

	/// *
	// * identifier or literal
	// * / Atom hidden(WS, KW_NEWLINE):
	//	iden=Id | lit=Literal;
	public AtomElements getAtomAccess() {
		return (pAtom != null) ? pAtom : (pAtom = new AtomElements());
	}
	
	public ParserRule getAtomRule() {
		return getAtomAccess().getRule();
	}

	/// * called from Flow_AnyStatement and Flow_BalStatement * / Name hidden(WS, KW_NEWLINE):
	//	{Name} name=Id | no=NakedOp;
	public NameElements getNameAccess() {
		return (pName != null) ? pName : (pName = new NameElements());
	}
	
	public ParserRule getNameRule() {
		return getNameAccess().getRule();
	}

	/// * original Aldor grammar uses abNewOfToken which is defined
	// * in Aldor file absyn.c: Abstract syntax construction and
	// * manipulation.
	// * / Id hidden(WS, KW_NEWLINE):
	//	name=(TK_ID | KW_SHARP | KW_TILDE);
	public IdElements getIdAccess() {
		return (pId != null) ? pId : (pId = new IdElements());
	}
	
	public ParserRule getIdRule() {
		return getIdAccess().getRule();
	}

	/// * string, integer or float literal * / Literal hidden(WS, KW_NEWLINE): // example 2.4e5 or 2e5
	//	=> ((TK_INT KW_DOT)? TK_FLOAT) // example 2.4 or 2
	//	| => (TK_INT KW_DOT)? TK_INT | // example "abc"
	//	TK_STRING;
	public LiteralElements getLiteralAccess() {
		return (pLiteral != null) ? pLiteral : (pLiteral = new LiteralElements());
	}
	
	public ParserRule getLiteralRule() {
		return getLiteralAccess().getRule();
	}

	/// *
	// * Meta-rules
	// * / / * Substituted Rules in Xtext:
	// * UnqualOp(ArrowTok)
	// * UnqualOp(LatticeTok)
	// * UnqualOp(RelationTok)
	// * UnqualOp(SegTok)
	// * UnqualOp(PlusTok)
	// * UnqualOp(QuotientTok)
	// * UnqualOp(TimesTok)
	// * UnqualOp(PowerTok)
	// * UnqualOp(op)
	// * : op
	// * { $$ = abNewOfToken(AB_Id, $1); }
	// * ;
	// * / UnqualOp_ArrowTok hidden(WS, KW_NEWLINE):
	//	ArrowTok {ArrowTok};
	public UnqualOp_ArrowTokElements getUnqualOp_ArrowTokAccess() {
		return (pUnqualOp_ArrowTok != null) ? pUnqualOp_ArrowTok : (pUnqualOp_ArrowTok = new UnqualOp_ArrowTokElements());
	}
	
	public ParserRule getUnqualOp_ArrowTokRule() {
		return getUnqualOp_ArrowTokAccess().getRule();
	}

	//UnqualOp_LatticeTok hidden(WS, KW_NEWLINE):
	//	LatticeTok {LatticeTok};
	public UnqualOp_LatticeTokElements getUnqualOp_LatticeTokAccess() {
		return (pUnqualOp_LatticeTok != null) ? pUnqualOp_LatticeTok : (pUnqualOp_LatticeTok = new UnqualOp_LatticeTokElements());
	}
	
	public ParserRule getUnqualOp_LatticeTokRule() {
		return getUnqualOp_LatticeTokAccess().getRule();
	}

	//UnqualOp_RelationTok hidden(WS, KW_NEWLINE):
	//	RelationTok {RelationTok};
	public UnqualOp_RelationTokElements getUnqualOp_RelationTokAccess() {
		return (pUnqualOp_RelationTok != null) ? pUnqualOp_RelationTok : (pUnqualOp_RelationTok = new UnqualOp_RelationTokElements());
	}
	
	public ParserRule getUnqualOp_RelationTokRule() {
		return getUnqualOp_RelationTokAccess().getRule();
	}

	//UnqualOp_SegTok hidden(WS, KW_NEWLINE):
	//	SegTok {SegTok};
	public UnqualOp_SegTokElements getUnqualOp_SegTokAccess() {
		return (pUnqualOp_SegTok != null) ? pUnqualOp_SegTok : (pUnqualOp_SegTok = new UnqualOp_SegTokElements());
	}
	
	public ParserRule getUnqualOp_SegTokRule() {
		return getUnqualOp_SegTokAccess().getRule();
	}

	//UnqualOp_PlusTok hidden(WS, KW_NEWLINE):
	//	PlusTok {PlusTok};
	public UnqualOp_PlusTokElements getUnqualOp_PlusTokAccess() {
		return (pUnqualOp_PlusTok != null) ? pUnqualOp_PlusTok : (pUnqualOp_PlusTok = new UnqualOp_PlusTokElements());
	}
	
	public ParserRule getUnqualOp_PlusTokRule() {
		return getUnqualOp_PlusTokAccess().getRule();
	}

	//UnqualOp_QuotientTok hidden(WS, KW_NEWLINE):
	//	QuotientTok {QuotientTok};
	public UnqualOp_QuotientTokElements getUnqualOp_QuotientTokAccess() {
		return (pUnqualOp_QuotientTok != null) ? pUnqualOp_QuotientTok : (pUnqualOp_QuotientTok = new UnqualOp_QuotientTokElements());
	}
	
	public ParserRule getUnqualOp_QuotientTokRule() {
		return getUnqualOp_QuotientTokAccess().getRule();
	}

	//UnqualOp_TimesTok hidden(WS, KW_NEWLINE):
	//	TimesTok {TimesTok};
	public UnqualOp_TimesTokElements getUnqualOp_TimesTokAccess() {
		return (pUnqualOp_TimesTok != null) ? pUnqualOp_TimesTok : (pUnqualOp_TimesTok = new UnqualOp_TimesTokElements());
	}
	
	public ParserRule getUnqualOp_TimesTokRule() {
		return getUnqualOp_TimesTokAccess().getRule();
	}

	//UnqualOp_PowerTok hidden(WS, KW_NEWLINE):
	//	PowerTok {PowerTok};
	public UnqualOp_PowerTokElements getUnqualOp_PowerTokAccess() {
		return (pUnqualOp_PowerTok != null) ? pUnqualOp_PowerTok : (pUnqualOp_PowerTok = new UnqualOp_PowerTokElements());
	}
	
	public ParserRule getUnqualOp_PowerTokRule() {
		return getUnqualOp_PowerTokAccess().getRule();
	}

	/// * Substituted Rules in Xtext:
	// * QualOp(ArrowTok)
	// * QualOp(LatticeTok)
	// * QualOp(RelationTok)
	// * QualOp(SegTok)
	// * QualOp(PlusTok)
	// * QualOp(QuotientTok)
	// * QualOp(TimesTok)
	// * QualOp(PowerTok)
	// * QualOp(op)
	// * : op
	// * { $$ = abNewOfToken(AB_Id, $1); }
	// * | op KW_DOLLAR OpQualTail
	// * { $$ = abNewQualify(TPOS($1), abNewOfToken(AB_Id, $1), $3); }
	// * ;
	// * / QualOp_ArrowTok hidden(WS, KW_NEWLINE):
	//	{QualOp_ArrowTok} ArrowTok => (KW_DOLLAR oqt=OpQualTail)?;
	public QualOp_ArrowTokElements getQualOp_ArrowTokAccess() {
		return (pQualOp_ArrowTok != null) ? pQualOp_ArrowTok : (pQualOp_ArrowTok = new QualOp_ArrowTokElements());
	}
	
	public ParserRule getQualOp_ArrowTokRule() {
		return getQualOp_ArrowTokAccess().getRule();
	}

	//QualOp_LatticeTok hidden(WS, KW_NEWLINE):
	//	{QualOp_LatticeTok} LatticeTok => (KW_DOLLAR oqt=OpQualTail)?;
	public QualOp_LatticeTokElements getQualOp_LatticeTokAccess() {
		return (pQualOp_LatticeTok != null) ? pQualOp_LatticeTok : (pQualOp_LatticeTok = new QualOp_LatticeTokElements());
	}
	
	public ParserRule getQualOp_LatticeTokRule() {
		return getQualOp_LatticeTokAccess().getRule();
	}

	/// *InfixedExpr has non-LL(*) decision due to recursive rule
	// * invocations reachable from alts 1,2.  Resolve by left-factoring
	// * or using syntactic predicates or using backtrack=true option.
	// * 
	// * RelationTok is KW_EQ | KW_TILDEE | KW_HATE |
	// * KW_GE | KW_GT | KW_2GT |
	// * KW_LE | KW_LT | KW_2LT |
	// * 'is' | 'isnt' | 'case' ;
	// * / QualOp_RelationTok hidden(WS, KW_NEWLINE): //	'temp99'
	//	{QualOp_RelationTok} RelationTok (op+=KW_DOLLAR oqt=OpQualTail)?;
	public QualOp_RelationTokElements getQualOp_RelationTokAccess() {
		return (pQualOp_RelationTok != null) ? pQualOp_RelationTok : (pQualOp_RelationTok = new QualOp_RelationTokElements());
	}
	
	public ParserRule getQualOp_RelationTokRule() {
		return getQualOp_RelationTokAccess().getRule();
	}

	//QualOp_SegTok hidden(WS, KW_NEWLINE):
	//	{QualOp_SegTok} SegTok (KW_DOLLAR oqt=OpQualTail)?;
	public QualOp_SegTokElements getQualOp_SegTokAccess() {
		return (pQualOp_SegTok != null) ? pQualOp_SegTok : (pQualOp_SegTok = new QualOp_SegTokElements());
	}
	
	public ParserRule getQualOp_SegTokRule() {
		return getQualOp_SegTokAccess().getRule();
	}

	//QualOp_PlusTok hidden(WS, KW_NEWLINE):
	//	{QualOp_PlusTok} PlusTok (KW_DOLLAR oqt=OpQualTail)?;
	public QualOp_PlusTokElements getQualOp_PlusTokAccess() {
		return (pQualOp_PlusTok != null) ? pQualOp_PlusTok : (pQualOp_PlusTok = new QualOp_PlusTokElements());
	}
	
	public ParserRule getQualOp_PlusTokRule() {
		return getQualOp_PlusTokAccess().getRule();
	}

	//QualOp_QuotientTok hidden(WS, KW_NEWLINE):
	//	{QualOp_QuotientTok} QuotientTok (KW_DOLLAR oqt=OpQualTail)?;
	public QualOp_QuotientTokElements getQualOp_QuotientTokAccess() {
		return (pQualOp_QuotientTok != null) ? pQualOp_QuotientTok : (pQualOp_QuotientTok = new QualOp_QuotientTokElements());
	}
	
	public ParserRule getQualOp_QuotientTokRule() {
		return getQualOp_QuotientTokAccess().getRule();
	}

	//QualOp_TimesTok hidden(WS, KW_NEWLINE):
	//	{QualOp_TimesTok} TimesTok (KW_DOLLAR oqt=OpQualTail)?;
	public QualOp_TimesTokElements getQualOp_TimesTokAccess() {
		return (pQualOp_TimesTok != null) ? pQualOp_TimesTok : (pQualOp_TimesTok = new QualOp_TimesTokElements());
	}
	
	public ParserRule getQualOp_TimesTokRule() {
		return getQualOp_TimesTokAccess().getRule();
	}

	//QualOp_PowerTok hidden(WS, KW_NEWLINE):
	//	{QualOp_PowerTok} PowerTok (KW_DOLLAR oqt=OpQualTail)?;
	public QualOp_PowerTokElements getQualOp_PowerTokAccess() {
		return (pQualOp_PowerTok != null) ? pQualOp_PowerTok : (pQualOp_PowerTok = new QualOp_PowerTokElements());
	}
	
	public ParserRule getQualOp_PowerTokRule() {
		return getQualOp_PowerTokAccess().getRule();
	}

	/// * ++ Doc. * / / * Substituted Rules in Xtext:
	// * E is E from PileContents(E)
	// * / //Doc(E)
	////: PreDocument E PostDocument
	////{
	////$$ = $2;
	////if($3) $$ = abNewDocumented(APOS($3),$$,$3);
	////if($1) $$ = abNewDocumented(APOS($$),$$,$1);
	////}
	////;
	////PreDocument hidden(WS,KW_NEWLINE):
	////  PreDocumentList
	////;
	////PostDocument hidden(WS,KW_NEWLINE):
	////  PostDocumentList
	////;
	/// * list of lines starting with -- * / PreDocument hidden(WS, KW_NEWLINE):
	//	TK_PREDOC*;
	public PreDocumentElements getPreDocumentAccess() {
		return (pPreDocument != null) ? pPreDocument : (pPreDocument = new PreDocumentElements());
	}
	
	public ParserRule getPreDocumentRule() {
		return getPreDocumentAccess().getRule();
	}

	/// * list of lines starting with ++ * / PostDocument hidden(WS, KW_NEWLINE):
	//	TK_POSTDOC*;
	public PostDocumentElements getPostDocumentAccess() {
		return (pPostDocument != null) ? pPostDocument : (pPostDocument = new PostDocumentElements());
	}
	
	public ParserRule getPostDocumentRule() {
		return getPostDocumentAccess().getRule();
	}

	/// * CommaItem (',' CommaItem)*
	// * / enlist1_CommaItem_Comma_AB hidden(WS, KW_NEWLINE):
	//	enlister1_CommaItem_Comma;
	public Enlist1_CommaItem_Comma_ABElements getEnlist1_CommaItem_Comma_ABAccess() {
		return (pEnlist1_CommaItem_Comma_AB != null) ? pEnlist1_CommaItem_Comma_AB : (pEnlist1_CommaItem_Comma_AB = new Enlist1_CommaItem_Comma_ABElements());
	}
	
	public ParserRule getEnlist1_CommaItem_Comma_ABRule() {
		return getEnlist1_CommaItem_Comma_ABAccess().getRule();
	}

	/// * Infixed (',' Infixed)*
	// * / enlist1_Infixed_Comma_AB hidden(WS, KW_NEWLINE):
	//	enlister1_Infixed_Comma;
	public Enlist1_Infixed_Comma_ABElements getEnlist1_Infixed_Comma_ABAccess() {
		return (pEnlist1_Infixed_Comma_AB != null) ? pEnlist1_Infixed_Comma_AB : (pEnlist1_Infixed_Comma_AB = new Enlist1_Infixed_Comma_ABElements());
	}
	
	public ParserRule getEnlist1_Infixed_Comma_ABRule() {
		return getEnlist1_Infixed_Comma_ABAccess().getRule();
	}

	/// * InfixedExpr (',' InfixedExpr)*
	// * / enlist1_InfixedExpr_Comma_AB hidden(WS, KW_NEWLINE):
	//	enlister1_InfixedExpr_Comma;
	public Enlist1_InfixedExpr_Comma_ABElements getEnlist1_InfixedExpr_Comma_ABAccess() {
		return (pEnlist1_InfixedExpr_Comma_AB != null) ? pEnlist1_InfixedExpr_Comma_AB : (pEnlist1_InfixedExpr_Comma_AB = new Enlist1_InfixedExpr_Comma_ABElements());
	}
	
	public ParserRule getEnlist1_InfixedExpr_Comma_ABRule() {
		return getEnlist1_InfixedExpr_Comma_ABAccess().getRule();
	}

	/// * CommaItem (',' CommaItem)*
	// * / enlister1_CommaItem_Comma hidden(WS, KW_NEWLINE):
	//	CommaItem (KW_COMMA ci+=CommaItem)*;
	public Enlister1_CommaItem_CommaElements getEnlister1_CommaItem_CommaAccess() {
		return (pEnlister1_CommaItem_Comma != null) ? pEnlister1_CommaItem_Comma : (pEnlister1_CommaItem_Comma = new Enlister1_CommaItem_CommaElements());
	}
	
	public ParserRule getEnlister1_CommaItem_CommaRule() {
		return getEnlister1_CommaItem_CommaAccess().getRule();
	}

	/// * Infixed (',' Infixed)*
	// * / enlister1_Infixed_Comma hidden(WS, KW_NEWLINE):
	//	Infixed (KW_COMMA i2+=Infixed)*;
	public Enlister1_Infixed_CommaElements getEnlister1_Infixed_CommaAccess() {
		return (pEnlister1_Infixed_Comma != null) ? pEnlister1_Infixed_Comma : (pEnlister1_Infixed_Comma = new Enlister1_Infixed_CommaElements());
	}
	
	public ParserRule getEnlister1_Infixed_CommaRule() {
		return getEnlister1_Infixed_CommaAccess().getRule();
	}

	/// * InfixedExpr (',' InfixedExpr)*
	// * / enlister1_InfixedExpr_Comma hidden(WS, KW_NEWLINE):
	//	InfixedExpr (KW_COMMA ie+=InfixedExpr)*;
	public Enlister1_InfixedExpr_CommaElements getEnlister1_InfixedExpr_CommaAccess() {
		return (pEnlister1_InfixedExpr_Comma != null) ? pEnlister1_InfixedExpr_Comma : (pEnlister1_InfixedExpr_Comma = new Enlister1_InfixedExpr_CommaElements());
	}
	
	public ParserRule getEnlister1_InfixedExpr_CommaRule() {
		return getEnlister1_InfixedExpr_CommaAccess().getRule();
	}

	/// * A list of (at least one) statement(s)
	// * seperated by semicolons (one or more)  and optionally ending with
	// * a semicolon (zero or more)
	// * 
	// * AB_Sequence
	// * / enlist1a_Labeled_Semicolon_AB hidden(WS, KW_NEWLINE):
	//	enlister1a_Labeled_Semicolon;
	public Enlist1a_Labeled_Semicolon_ABElements getEnlist1a_Labeled_Semicolon_ABAccess() {
		return (pEnlist1a_Labeled_Semicolon_AB != null) ? pEnlist1a_Labeled_Semicolon_AB : (pEnlist1a_Labeled_Semicolon_AB = new Enlist1a_Labeled_Semicolon_ABElements());
	}
	
	public ParserRule getEnlist1a_Labeled_Semicolon_ABRule() {
		return getEnlist1a_Labeled_Semicolon_ABAccess().getRule();
	}

	/// * A list of (at least one) statement(s)
	// * seperated by (one or more) semicolons and optionally ending with
	// * a semicolon (zero or more)
	// * 
	// * Aldor axl.z grammar defines this in a left recursive way so
	// * we have to change to non-recursive structure here.
	// * / enlister1a_Labeled_Semicolon hidden(WS, KW_NEWLINE):
	//	statemnts+=Labeled (KW_SEMICOLON+ statemnts+=Labeled)* KW_SEMICOLON*;
	public Enlister1a_Labeled_SemicolonElements getEnlister1a_Labeled_SemicolonAccess() {
		return (pEnlister1a_Labeled_Semicolon != null) ? pEnlister1a_Labeled_Semicolon : (pEnlister1a_Labeled_Semicolon = new Enlister1a_Labeled_SemicolonElements());
	}
	
	public ParserRule getEnlister1a_Labeled_SemicolonRule() {
		return getEnlister1a_Labeled_SemicolonAccess().getRule();
	}

	/// * Substituted Rules in Xtext:
	// * Piled(Expression)
	// * 
	// * / / * Piled * / //Piled(E)
	////: KW_SetTab PileContents(E) KW_BackTab
	////{ $$ = abOneOrNewOfList(AB_Sequence,$2); listFree(AbSyn)($2); }
	////;
	/// * Substituted Rules in Xtext:
	// * Curly(Labeled)
	// * 
	// * / Curly_Labeled hidden(WS, KW_NEWLINE):
	//	KW_OCURLY CurlyContents_Labeled KW_CCURLY;
	public Curly_LabeledElements getCurly_LabeledAccess() {
		return (pCurly_Labeled != null) ? pCurly_Labeled : (pCurly_Labeled = new Curly_LabeledElements());
	}
	
	public ParserRule getCurly_LabeledRule() {
		return getCurly_LabeledAccess().getRule();
	}

	/// * A list of (at least one) statement(s)
	// * seperated by (one or more) semicolons and optionally ending with
	// * a semicolon (zero or more)
	// * 
	// * This is similar to enlister1a_Labeled_Semicolon;
	// * 
	// * statements can have pre or post comments
	// * 
	// * called by Curly_Labeled and Model
	// * / CurlyContents_Labeled hidden(WS, KW_NEWLINE):
	//	CurlyContentsList_Labeled;
	public CurlyContents_LabeledElements getCurlyContents_LabeledAccess() {
		return (pCurlyContents_Labeled != null) ? pCurlyContents_Labeled : (pCurlyContents_Labeled = new CurlyContents_LabeledElements());
	}
	
	public ParserRule getCurlyContents_LabeledRule() {
		return getCurlyContents_LabeledAccess().getRule();
	}

	/// * A list of (at least one) statement(s)
	// * seperated by (one or more) semicolons and optionally ending with
	// * a semicolon (zero or more)
	// * 
	// * This is similar to enlister1a_Labeled_Semicolon
	// * 
	// * statements can have pre or post comments
	// * / CurlyContentsList_Labeled hidden(WS, KW_NEWLINE):
	//	statemts+=CurlyContentB_Labeled //(statemts += CurlyContentB_Labeled?)
	//	(KW_SEMICOLON+ statemts+=CurlyContentB_Labeled)* // need to change this line to:
	//	//(KW_SEMICOLON* statemts += CurlyContentB_Labeled)*
	//	// that is make semicolons optional but that causes non-LL(*) grammar
	//	KW_SEMICOLON*;
	public CurlyContentsList_LabeledElements getCurlyContentsList_LabeledAccess() {
		return (pCurlyContentsList_Labeled != null) ? pCurlyContentsList_Labeled : (pCurlyContentsList_Labeled = new CurlyContentsList_LabeledElements());
	}
	
	public ParserRule getCurlyContentsList_LabeledRule() {
		return getCurlyContentsList_LabeledAccess().getRule();
	}

	/// * List of 'Labeled' each one is terminated by semicolon
	// * 
	// * This rule is left recursive in the Aldor grammar so I have
	// * to change it here.
	// * / //CurlyContent1_Labeled
	////: Nothing
	////| CurlyContent1_Labeled cca=CurlyContentA_Labeled
	////;
	/// * Substituted Rules in Xtext:
	// * CurlyContentA(E) E is from CurlyContent1(E)
	// * 
	// * / //CurlyContentA_Labeled
	////: CurlyContentB_Labeled KW_SEMICOLON pd=PostDocument
	////| error KW_SEMICOLON PostDocument
	////;
	/// * Substituted Rules in Xtext:
	// * CurlyContentB(E) E is from CurlyContentA(E)
	// * or CurlyContentsList(E)
	// * 
	// * / CurlyContentB_Labeled hidden(WS, KW_NEWLINE):
	//	pred=PreDocument l=Labeled pd=PostDocument;
	public CurlyContentB_LabeledElements getCurlyContentB_LabeledAccess() {
		return (pCurlyContentB_Labeled != null) ? pCurlyContentB_Labeled : (pCurlyContentB_Labeled = new CurlyContentB_LabeledElements());
	}
	
	public ParserRule getCurlyContentB_LabeledRule() {
		return getCurlyContentB_LabeledAccess().getRule();
	}
}
