/*
* generated by Xtext
*/

package com.euclideanspace.spad.services;

import com.google.inject.Singleton;
import com.google.inject.Inject;

import java.util.List;

import org.eclipse.xtext.*;
import org.eclipse.xtext.service.GrammarProvider;
import org.eclipse.xtext.service.AbstractElementFinder.*;


@Singleton
public class EditorGrammarAccess extends AbstractGrammarElementFinder {
	
	
	public class ModelElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Model");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cAbbrevKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final RuleCall cWSTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Alternatives cAlternatives_2 = (Alternatives)cGroup.eContents().get(2);
		private final Assignment cCAssignment_2_0 = (Assignment)cAlternatives_2.eContents().get(0);
		private final RuleCall cCCategoryDefParserRuleCall_2_0_0 = (RuleCall)cCAssignment_2_0.eContents().get(0);
		private final Assignment cPAssignment_2_1 = (Assignment)cAlternatives_2.eContents().get(1);
		private final RuleCall cPPackageDefParserRuleCall_2_1_0 = (RuleCall)cPAssignment_2_1.eContents().get(0);
		private final Assignment cDAssignment_2_2 = (Assignment)cAlternatives_2.eContents().get(2);
		private final RuleCall cDDomainDefParserRuleCall_2_2_0 = (RuleCall)cDAssignment_2_2.eContents().get(0);
		private final RuleCall cATTerminalRuleCall_3 = (RuleCall)cGroup.eContents().get(3);
		
		/// * Copyright 2012 Martin John Baker
		// * 
		// * This file is part of EuclideanSpace.
		// *
		// *  EuclideanSpace is free software: you can redistribute it and/or modify
		// *  it under the terms of the GNU Affero General Public License as published by
		// *  the Free Software Foundation, either version 3 of the License, or
		// *  (at your option) any later version.
		// *
		// *  EuclideanSpace is distributed in the hope that it will be useful,
		// *  but WITHOUT ANY WARRANTY; without even the implied warranty of
		// *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
		// *  GNU Affero General Public License for more details.
		// *
		// *  You should have received a copy of the GNU Affero General Public License
		// *  along with EuclideanSpace.  If not, see <http://www.gnu.org/licenses/>.
		// * / / * FriCAS does SPAD parsing by a type of parser known as a 'Pratt' parser.
		// * In this type of parser each operator has different binding powers for
		// * its left and right. The SPAD parser also has 'special handlers' for
		// * certain operators. In this type of parser there is less distinction made
		// * between expressions and statements, effectively everything is treated as
		// * an expression so in this context, not only are "+" and "*" operators
		// * but also other keywords such as "for" and "return".
		// * 
		// * Here we are using a LL(*) recursive-descent parser generator and this
		// * may not be able to exactly replicate the SPAD parser as described above
		// * 
		// * I have taken this information from s-parser.boot in src/interp
		// * so I suspect that it in valid only for the SPAD interpreter and not
		// * the compiler however I am hoping that this will be a close enough
		// * approximation for this purpose.
		// *
		// * So I will use the LED Table to approximate infix operator precedence
		// * and the NUD Table to approximate prefix operator precedence. So I
		// * have ordered both these tables in 
		// * 
		// * I have ordered the tables low (binds least tightly) to high (binds most tightly) as follows:
		// * 
		// * LED Table - infix operators
		// * ---------------------------
		// * ";", 81, 82, ["parse_SemiColon"]
		// * "|", 108, 111
		// * ",", 110, 111
		// * "when", 112, 190
		// * "otherwise", 119, 190, ["parse_Suffix"]
		// * "where", 121, 104
		// * "==>", "MDEF", 122, 121
		// * "==", "DEF", 122, 121
		// * "=>", 123, 103
		// * ":=", "LET", 125, 124]
		// * "\/", BACKSLASHSLASH 200, 201
		// * "/\", SLASHBACKSLASH 250, 251
		// * "or", 200, 201
		// * "and", 250, 251
		// * "has", 400, 400
		// * "add", 400, 120
		// * "case", 400, 400
		// * "in", 400, 400
		// * "~=", 400, 400
		// * "^=", 400, 400
		// * "=", 400, 400
		// * ">=", 400, 400
		// * "<=", 400, 400
		// * ">>", 400, 400
		// * "<<", 400, 400
		// * ">", 400, 400
		// * "<", 400, 400
		// * "isnt", 400, 400
		// * "is", 400, 400
		// * "..", "SEGMENT", 401, 699, ["parse_Seg"]
		// * "-", 700, 701
		// * "+", 700, 701
		// * "exquo", 800, 801
		// * "/", 800, 801
		// * "quo", 800, 801
		// * "mod", 800, 801
		// * "rem", 800, 801
		// * "*", 800, 801
		// * "^", 901, 900
		// * "**", 901, 900
		// * "+->", 995, 112
		// * "pretend", 995, 996
		// * "@", 996, 997
		// * "::", 996, 997
		// * ":", 996, 997
		// * "!", 1002, 1001
		// * "with", 2000, 400, ["parse_InfixWith"]
		// * "."
		// *
		// * NUD Table - prefix operators
		// * ----------------------------
		// *
		// * "catch", 0, 114
		// * "finally", 0, 114
		// * "then", 0, 114
		// * "else", 0, 114
		// * "|", 0, 190
		// * "import", 120, 0, ["parse_Import"]
		// * "<<", 122, 120, ["parse_LabelExpr"]
		// * ">>"
		// * "if", 130, 0, ["parse_Conditional"]
		// * "try", 130, 0, ["parse_Try"]
		// * "for", 130, 350, ["parse_Loop"
		// * "while", 130, 190, ["parse_Loop"]
		// * "until", 130, 190, ["parse_Loop"]
		// * "repeat", 130, 190, ["parse_Loop"]
		// * "return", 202, 201, ["parse_Return"]
		// * "leave", 202, 201, ["parse_Leave"]
		// * "exit", 202, 201, ["parse_Exit"]
		// * "~", 260, 259, nil
		// * ":", 194, 195
		// * "not", 260, 259, NIL
		// * "has", 400, 400
		// * "=", 400, 700
		// * "-", 701, 700
		// * "add", 900, 120
		// * "#", 999, 998
		// * "'", 999, 999, ["parse_Data"]
		// * "with", 1000, 300, ["parse_With"]
		// * "->", 1001, 1002
		// * "!", 1002, 1001
		// * "unless"
		// * "suchthat"
		// * "from"
		// * "iterate"
		// * "yield"
		// * 
		// * * / / *
		// * Parser starts here
		// * CategoryDef,PackageDef and DomainDef must end with newline to ensure that
		// * only an '@' at the start of a line will be taken as the end.
		// * 
		// * On this line whitespace (WS) is not hidden so is explicitly included.
		// * / Model:
		//	")abbrev" WS (c=CategoryDef | p=PackageDef | d=DomainDef) AT;
		public ParserRule getRule() { return rule; }

		//")abbrev" WS (c=CategoryDef | p=PackageDef | d=DomainDef) AT
		public Group getGroup() { return cGroup; }

		//")abbrev"
		public Keyword getAbbrevKeyword_0() { return cAbbrevKeyword_0; }

		//WS
		public RuleCall getWSTerminalRuleCall_1() { return cWSTerminalRuleCall_1; }

		//c=CategoryDef | p=PackageDef | d=DomainDef
		public Alternatives getAlternatives_2() { return cAlternatives_2; }

		//c=CategoryDef
		public Assignment getCAssignment_2_0() { return cCAssignment_2_0; }

		//CategoryDef
		public RuleCall getCCategoryDefParserRuleCall_2_0_0() { return cCCategoryDefParserRuleCall_2_0_0; }

		//p=PackageDef
		public Assignment getPAssignment_2_1() { return cPAssignment_2_1; }

		//PackageDef
		public RuleCall getPPackageDefParserRuleCall_2_1_0() { return cPPackageDefParserRuleCall_2_1_0; }

		//d=DomainDef
		public Assignment getDAssignment_2_2() { return cDAssignment_2_2; }

		//DomainDef
		public RuleCall getDDomainDefParserRuleCall_2_2_0() { return cDDomainDefParserRuleCall_2_2_0; }

		//AT
		public RuleCall getATTerminalRuleCall_3() { return cATTerminalRuleCall_3; }
	}

	public class CategoryDefElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "CategoryDef");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Keyword cNameCategoryKeyword_0_0 = (Keyword)cNameAssignment_0.eContents().get(0);
		private final Assignment cShortnameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cShortnameIDTerminalRuleCall_1_0 = (RuleCall)cShortnameAssignment_1.eContents().get(0);
		private final Assignment cLongnameAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cLongnameIDTerminalRuleCall_2_0 = (RuleCall)cLongnameAssignment_2.eContents().get(0);
		private final Assignment cLongname2Assignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cLongname2IDTerminalRuleCall_3_0 = (RuleCall)cLongname2Assignment_3.eContents().get(0);
		private final Assignment cCpAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cCpTypeParameterListParserRuleCall_4_0 = (RuleCall)cCpAssignment_4.eContents().get(0);
		private final RuleCall cCOLONTerminalRuleCall_5 = (RuleCall)cGroup.eContents().get(5);
		private final Keyword cCategoryKeyword_6 = (Keyword)cGroup.eContents().get(6);
		private final RuleCall cDEFTerminalRuleCall_7 = (RuleCall)cGroup.eContents().get(7);
		private final Assignment cImplNameAssignment_8 = (Assignment)cGroup.eContents().get(8);
		private final RuleCall cImplNameTypeArgumentsParserRuleCall_8_0 = (RuleCall)cImplNameAssignment_8.eContents().get(0);
		private final Alternatives cAlternatives_9 = (Alternatives)cGroup.eContents().get(9);
		private final Assignment cWAssignment_9_0 = (Assignment)cAlternatives_9.eContents().get(0);
		private final RuleCall cWWithPartParserRuleCall_9_0_0 = (RuleCall)cWAssignment_9_0.eContents().get(0);
		private final Assignment cWh5Assignment_9_1 = (Assignment)cAlternatives_9.eContents().get(1);
		private final RuleCall cWh5WherePartParserRuleCall_9_1_0 = (RuleCall)cWh5Assignment_9_1.eContents().get(0);
		
		//////////// end of lexer rules ///////////////
		/// *
		// * longname and longname2 should both be ID and have the same value. Since the
		// * runtime values can't be checked by the parser this must be checked later.
		// * / CategoryDef hidden(WS, NL, SL_COMMENT):
		//	name="category" shortname=ID longname=ID longname2= / *[CategoryDef]* / ID cp=TypeParameterList? COLON "Category" DEF
		//	implName=TypeArguments (w=WithPart / * | wh2=WithImplied* / | wh5=WherePart);
		public ParserRule getRule() { return rule; }

		//name="category" shortname=ID longname=ID longname2= / *[CategoryDef]* / ID cp=TypeParameterList? COLON "Category" DEF
		//implName=TypeArguments (w=WithPart / * | wh2=WithImplied* / | wh5=WherePart)
		public Group getGroup() { return cGroup; }

		//name="category"
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }

		//"category"
		public Keyword getNameCategoryKeyword_0_0() { return cNameCategoryKeyword_0_0; }

		//shortname=ID
		public Assignment getShortnameAssignment_1() { return cShortnameAssignment_1; }

		//ID
		public RuleCall getShortnameIDTerminalRuleCall_1_0() { return cShortnameIDTerminalRuleCall_1_0; }

		//longname=ID
		public Assignment getLongnameAssignment_2() { return cLongnameAssignment_2; }

		//ID
		public RuleCall getLongnameIDTerminalRuleCall_2_0() { return cLongnameIDTerminalRuleCall_2_0; }

		//longname2= / *[CategoryDef]* / ID
		public Assignment getLongname2Assignment_3() { return cLongname2Assignment_3; }

		/// *[CategoryDef]* / ID
		public RuleCall getLongname2IDTerminalRuleCall_3_0() { return cLongname2IDTerminalRuleCall_3_0; }

		//cp=TypeParameterList?
		public Assignment getCpAssignment_4() { return cCpAssignment_4; }

		//TypeParameterList
		public RuleCall getCpTypeParameterListParserRuleCall_4_0() { return cCpTypeParameterListParserRuleCall_4_0; }

		//COLON
		public RuleCall getCOLONTerminalRuleCall_5() { return cCOLONTerminalRuleCall_5; }

		//"Category"
		public Keyword getCategoryKeyword_6() { return cCategoryKeyword_6; }

		//DEF
		public RuleCall getDEFTerminalRuleCall_7() { return cDEFTerminalRuleCall_7; }

		//implName=TypeArguments
		public Assignment getImplNameAssignment_8() { return cImplNameAssignment_8; }

		//TypeArguments
		public RuleCall getImplNameTypeArgumentsParserRuleCall_8_0() { return cImplNameTypeArgumentsParserRuleCall_8_0; }

		//w=WithPart / * | wh2=WithImplied* / | wh5=WherePart
		public Alternatives getAlternatives_9() { return cAlternatives_9; }

		//w=WithPart
		public Assignment getWAssignment_9_0() { return cWAssignment_9_0; }

		//WithPart
		public RuleCall getWWithPartParserRuleCall_9_0_0() { return cWWithPartParserRuleCall_9_0_0; }

		//wh5=WherePart
		public Assignment getWh5Assignment_9_1() { return cWh5Assignment_9_1; }

		//WherePart
		public RuleCall getWh5WherePartParserRuleCall_9_1_0() { return cWh5WherePartParserRuleCall_9_1_0; }
	}

	public class PackageDefElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PackageDef");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Keyword cNamePackageKeyword_0_0 = (Keyword)cNameAssignment_0.eContents().get(0);
		private final Assignment cShortnameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cShortnameIDTerminalRuleCall_1_0 = (RuleCall)cShortnameAssignment_1.eContents().get(0);
		private final Assignment cLongnameAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cLongnameIDTerminalRuleCall_2_0 = (RuleCall)cLongnameAssignment_2.eContents().get(0);
		private final Assignment cLongname2Assignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cLongname2IDTerminalRuleCall_3_0 = (RuleCall)cLongname2Assignment_3.eContents().get(0);
		private final Assignment cCpAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cCpTypeParameterListParserRuleCall_4_0 = (RuleCall)cCpAssignment_4.eContents().get(0);
		private final RuleCall cCOLONTerminalRuleCall_5 = (RuleCall)cGroup.eContents().get(5);
		private final Assignment cExportNameAssignment_6 = (Assignment)cGroup.eContents().get(6);
		private final RuleCall cExportNameIDTerminalRuleCall_6_0 = (RuleCall)cExportNameAssignment_6.eContents().get(0);
		private final RuleCall cDEFTerminalRuleCall_7 = (RuleCall)cGroup.eContents().get(7);
		private final Assignment cImplNameAssignment_8 = (Assignment)cGroup.eContents().get(8);
		private final RuleCall cImplNameIDTerminalRuleCall_8_0 = (RuleCall)cImplNameAssignment_8.eContents().get(0);
		private final Alternatives cAlternatives_9 = (Alternatives)cGroup.eContents().get(9);
		private final Assignment cWAssignment_9_0 = (Assignment)cAlternatives_9.eContents().get(0);
		private final RuleCall cWWithPartParserRuleCall_9_0_0 = (RuleCall)cWAssignment_9_0.eContents().get(0);
		private final Assignment cWh5Assignment_9_1 = (Assignment)cAlternatives_9.eContents().get(1);
		private final RuleCall cWh5WherePartParserRuleCall_9_1_0 = (RuleCall)cWh5Assignment_9_1.eContents().get(0);
		
		/// *
		// * longname and longname2 should both be ID and have the same value. Since the
		// * runtime values can't be checked by the parser this must be checked later.
		// * / PackageDef hidden(WS, NL, SL_COMMENT):
		//	name="package" shortname=ID longname=ID longname2= / *[PackageDef]* / ID cp=TypeParameterList? COLON exportName=ID DEF
		//	implName=ID (w=WithPart | wh5=WherePart);
		public ParserRule getRule() { return rule; }

		//name="package" shortname=ID longname=ID longname2= / *[PackageDef]* / ID cp=TypeParameterList? COLON exportName=ID DEF
		//implName=ID (w=WithPart | wh5=WherePart)
		public Group getGroup() { return cGroup; }

		//name="package"
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }

		//"package"
		public Keyword getNamePackageKeyword_0_0() { return cNamePackageKeyword_0_0; }

		//shortname=ID
		public Assignment getShortnameAssignment_1() { return cShortnameAssignment_1; }

		//ID
		public RuleCall getShortnameIDTerminalRuleCall_1_0() { return cShortnameIDTerminalRuleCall_1_0; }

		//longname=ID
		public Assignment getLongnameAssignment_2() { return cLongnameAssignment_2; }

		//ID
		public RuleCall getLongnameIDTerminalRuleCall_2_0() { return cLongnameIDTerminalRuleCall_2_0; }

		//longname2= / *[PackageDef]* / ID
		public Assignment getLongname2Assignment_3() { return cLongname2Assignment_3; }

		/// *[PackageDef]* / ID
		public RuleCall getLongname2IDTerminalRuleCall_3_0() { return cLongname2IDTerminalRuleCall_3_0; }

		//cp=TypeParameterList?
		public Assignment getCpAssignment_4() { return cCpAssignment_4; }

		//TypeParameterList
		public RuleCall getCpTypeParameterListParserRuleCall_4_0() { return cCpTypeParameterListParserRuleCall_4_0; }

		//COLON
		public RuleCall getCOLONTerminalRuleCall_5() { return cCOLONTerminalRuleCall_5; }

		//exportName=ID
		public Assignment getExportNameAssignment_6() { return cExportNameAssignment_6; }

		//ID
		public RuleCall getExportNameIDTerminalRuleCall_6_0() { return cExportNameIDTerminalRuleCall_6_0; }

		//DEF
		public RuleCall getDEFTerminalRuleCall_7() { return cDEFTerminalRuleCall_7; }

		//implName=ID
		public Assignment getImplNameAssignment_8() { return cImplNameAssignment_8; }

		//ID
		public RuleCall getImplNameIDTerminalRuleCall_8_0() { return cImplNameIDTerminalRuleCall_8_0; }

		//w=WithPart | wh5=WherePart
		public Alternatives getAlternatives_9() { return cAlternatives_9; }

		//w=WithPart
		public Assignment getWAssignment_9_0() { return cWAssignment_9_0; }

		//WithPart
		public RuleCall getWWithPartParserRuleCall_9_0_0() { return cWWithPartParserRuleCall_9_0_0; }

		//wh5=WherePart
		public Assignment getWh5Assignment_9_1() { return cWh5Assignment_9_1; }

		//WherePart
		public RuleCall getWh5WherePartParserRuleCall_9_1_0() { return cWh5WherePartParserRuleCall_9_1_0; }
	}

	public class DomainDefElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "DomainDef");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Keyword cNameDomainKeyword_0_0 = (Keyword)cNameAssignment_0.eContents().get(0);
		private final Assignment cShortname5Assignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cShortname5IDTerminalRuleCall_1_0 = (RuleCall)cShortname5Assignment_1.eContents().get(0);
		private final Assignment cLongname5Assignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cLongname5IDTerminalRuleCall_2_0 = (RuleCall)cLongname5Assignment_2.eContents().get(0);
		private final Assignment cLongname6Assignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cLongname6IDTerminalRuleCall_3_0 = (RuleCall)cLongname6Assignment_3.eContents().get(0);
		private final Assignment cCp5Assignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cCp5TypeParameterListParserRuleCall_4_0 = (RuleCall)cCp5Assignment_4.eContents().get(0);
		private final RuleCall cCOLONTerminalRuleCall_5 = (RuleCall)cGroup.eContents().get(5);
		private final Assignment cExportNameAssignment_6 = (Assignment)cGroup.eContents().get(6);
		private final RuleCall cExportNameIDTerminalRuleCall_6_0 = (RuleCall)cExportNameAssignment_6.eContents().get(0);
		private final RuleCall cDEFTerminalRuleCall_7 = (RuleCall)cGroup.eContents().get(7);
		private final Assignment cImplName5Assignment_8 = (Assignment)cGroup.eContents().get(8);
		private final RuleCall cImplName5IDTerminalRuleCall_8_0 = (RuleCall)cImplName5Assignment_8.eContents().get(0);
		private final Alternatives cAlternatives_9 = (Alternatives)cGroup.eContents().get(9);
		private final Assignment cWAssignment_9_0 = (Assignment)cAlternatives_9.eContents().get(0);
		private final RuleCall cWWithPartParserRuleCall_9_0_0 = (RuleCall)cWAssignment_9_0.eContents().get(0);
		private final Assignment cWh5Assignment_9_1 = (Assignment)cAlternatives_9.eContents().get(1);
		private final RuleCall cWh5WherePartParserRuleCall_9_1_0 = (RuleCall)cWh5Assignment_9_1.eContents().get(0);
		
		/// *
		// * longname and longname2 should both be ID and have the same value. Since the
		// * runtime values can't be checked by the parser this must be checked later.
		// * / DomainDef hidden(WS, NL, SL_COMMENT):
		//	name="domain" shortname5=ID longname5=ID longname6= / *[DomainDef]* / ID cp5=TypeParameterList? COLON exportName=ID DEF
		//	implName5=ID (w=WithPart | wh5=WherePart);
		public ParserRule getRule() { return rule; }

		//name="domain" shortname5=ID longname5=ID longname6= / *[DomainDef]* / ID cp5=TypeParameterList? COLON exportName=ID DEF
		//implName5=ID (w=WithPart | wh5=WherePart)
		public Group getGroup() { return cGroup; }

		//name="domain"
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }

		//"domain"
		public Keyword getNameDomainKeyword_0_0() { return cNameDomainKeyword_0_0; }

		//shortname5=ID
		public Assignment getShortname5Assignment_1() { return cShortname5Assignment_1; }

		//ID
		public RuleCall getShortname5IDTerminalRuleCall_1_0() { return cShortname5IDTerminalRuleCall_1_0; }

		//longname5=ID
		public Assignment getLongname5Assignment_2() { return cLongname5Assignment_2; }

		//ID
		public RuleCall getLongname5IDTerminalRuleCall_2_0() { return cLongname5IDTerminalRuleCall_2_0; }

		//longname6= / *[DomainDef]* / ID
		public Assignment getLongname6Assignment_3() { return cLongname6Assignment_3; }

		/// *[DomainDef]* / ID
		public RuleCall getLongname6IDTerminalRuleCall_3_0() { return cLongname6IDTerminalRuleCall_3_0; }

		//cp5=TypeParameterList?
		public Assignment getCp5Assignment_4() { return cCp5Assignment_4; }

		//TypeParameterList
		public RuleCall getCp5TypeParameterListParserRuleCall_4_0() { return cCp5TypeParameterListParserRuleCall_4_0; }

		//COLON
		public RuleCall getCOLONTerminalRuleCall_5() { return cCOLONTerminalRuleCall_5; }

		//exportName=ID
		public Assignment getExportNameAssignment_6() { return cExportNameAssignment_6; }

		//ID
		public RuleCall getExportNameIDTerminalRuleCall_6_0() { return cExportNameIDTerminalRuleCall_6_0; }

		//DEF
		public RuleCall getDEFTerminalRuleCall_7() { return cDEFTerminalRuleCall_7; }

		//implName5=ID
		public Assignment getImplName5Assignment_8() { return cImplName5Assignment_8; }

		//ID
		public RuleCall getImplName5IDTerminalRuleCall_8_0() { return cImplName5IDTerminalRuleCall_8_0; }

		//w=WithPart | wh5=WherePart
		public Alternatives getAlternatives_9() { return cAlternatives_9; }

		//w=WithPart
		public Assignment getWAssignment_9_0() { return cWAssignment_9_0; }

		//WithPart
		public RuleCall getWWithPartParserRuleCall_9_0_0() { return cWWithPartParserRuleCall_9_0_0; }

		//wh5=WherePart
		public Assignment getWh5Assignment_9_1() { return cWh5Assignment_9_1; }

		//WherePart
		public RuleCall getWh5WherePartParserRuleCall_9_1_0() { return cWh5WherePartParserRuleCall_9_1_0; }
	}

	public class WherePartElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "WherePart");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Keyword cNameWhereKeyword_0_0 = (Keyword)cNameAssignment_0.eContents().get(0);
		private final RuleCall cNLTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final RuleCall cLBRACETerminalRuleCall_2 = (RuleCall)cGroup.eContents().get(2);
		private final RuleCall cNLTerminalRuleCall_3 = (RuleCall)cGroup.eContents().get(3);
		private final Group cGroup_4 = (Group)cGroup.eContents().get(4);
		private final Assignment cWhereAssigAssignment_4_0 = (Assignment)cGroup_4.eContents().get(0);
		private final RuleCall cWhereAssigWhereAssignmentsParserRuleCall_4_0_0 = (RuleCall)cWhereAssigAssignment_4_0.eContents().get(0);
		private final Alternatives cAlternatives_4_1 = (Alternatives)cGroup_4.eContents().get(1);
		private final RuleCall cNLTerminalRuleCall_4_1_0 = (RuleCall)cAlternatives_4_1.eContents().get(0);
		private final RuleCall cSEMICOLONTerminalRuleCall_4_1_1 = (RuleCall)cAlternatives_4_1.eContents().get(1);
		private final Group cGroup_5 = (Group)cGroup.eContents().get(5);
		private final Assignment cLongname8Assignment_5_0 = (Assignment)cGroup_5.eContents().get(0);
		private final RuleCall cLongname8IDTerminalRuleCall_5_0_0 = (RuleCall)cLongname8Assignment_5_0.eContents().get(0);
		private final Group cGroup_5_1 = (Group)cGroup_5.eContents().get(1);
		private final Alternatives cAlternatives_5_1_0 = (Alternatives)cGroup_5_1.eContents().get(0);
		private final RuleCall cDEFTerminalRuleCall_5_1_0_0 = (RuleCall)cAlternatives_5_1_0.eContents().get(0);
		private final RuleCall cMDEFTerminalRuleCall_5_1_0_1 = (RuleCall)cAlternatives_5_1_0.eContents().get(1);
		private final Assignment cImpAssignment_5_1_1 = (Assignment)cGroup_5_1.eContents().get(1);
		private final RuleCall cImpTypeExpressionParserRuleCall_5_1_1_0 = (RuleCall)cImpAssignment_5_1_1.eContents().get(0);
		private final Assignment cW8Assignment_5_2 = (Assignment)cGroup_5.eContents().get(2);
		private final RuleCall cW8WithPartParserRuleCall_5_2_0 = (RuleCall)cW8Assignment_5_2.eContents().get(0);
		private final Group cGroup_6 = (Group)cGroup.eContents().get(6);
		private final Assignment cLongname9Assignment_6_0 = (Assignment)cGroup_6.eContents().get(0);
		private final RuleCall cLongname9IDTerminalRuleCall_6_0_0 = (RuleCall)cLongname9Assignment_6_0.eContents().get(0);
		private final Alternatives cAlternatives_6_1 = (Alternatives)cGroup_6.eContents().get(1);
		private final RuleCall cDEFTerminalRuleCall_6_1_0 = (RuleCall)cAlternatives_6_1.eContents().get(0);
		private final RuleCall cMDEFTerminalRuleCall_6_1_1 = (RuleCall)cAlternatives_6_1.eContents().get(1);
		private final Assignment cAddAssignment_6_2 = (Assignment)cGroup_6.eContents().get(2);
		private final RuleCall cAddAddPartParserRuleCall_6_2_0 = (RuleCall)cAddAssignment_6_2.eContents().get(0);
		private final RuleCall cRBRACETerminalRuleCall_7 = (RuleCall)cGroup.eContents().get(7);
		private final RuleCall cNLTerminalRuleCall_8 = (RuleCall)cGroup.eContents().get(8);
		
		/// *
		// * both category and domain can have 'where' part which holds overall information
		// * such as category/domain parameter information and general macros. This is
		// * followed by export('with') and import ('add') information.
		// * Forms allowed include:
		// * Exports == PlottablePlaneCurveCategory with {
		// * Exports ==> PlottablePlaneCurveCategory with {
		// * Exports ==> with {
		// * / WherePart hidden(WS, SL_COMMENT):
		//	name="where" NL* LBRACE NL* (whereAssig+=WhereAssignments (NL | SEMICOLON)+)* (longname8=ID ((DEF | MDEF)
		//	imp=TypeExpression?)? w8=WithPart)? (longname9=ID (DEF | MDEF)? add=AddPart)? RBRACE NL+;
		public ParserRule getRule() { return rule; }

		//name="where" NL* LBRACE NL* (whereAssig+=WhereAssignments (NL | SEMICOLON)+)* (longname8=ID ((DEF | MDEF)
		//imp=TypeExpression?)? w8=WithPart)? (longname9=ID (DEF | MDEF)? add=AddPart)? RBRACE NL+
		public Group getGroup() { return cGroup; }

		//name="where"
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }

		//"where"
		public Keyword getNameWhereKeyword_0_0() { return cNameWhereKeyword_0_0; }

		//NL*
		public RuleCall getNLTerminalRuleCall_1() { return cNLTerminalRuleCall_1; }

		//LBRACE
		public RuleCall getLBRACETerminalRuleCall_2() { return cLBRACETerminalRuleCall_2; }

		//NL*
		public RuleCall getNLTerminalRuleCall_3() { return cNLTerminalRuleCall_3; }

		//(whereAssig+=WhereAssignments (NL | SEMICOLON)+)*
		public Group getGroup_4() { return cGroup_4; }

		//whereAssig+=WhereAssignments
		public Assignment getWhereAssigAssignment_4_0() { return cWhereAssigAssignment_4_0; }

		//WhereAssignments
		public RuleCall getWhereAssigWhereAssignmentsParserRuleCall_4_0_0() { return cWhereAssigWhereAssignmentsParserRuleCall_4_0_0; }

		//(NL | SEMICOLON)+
		public Alternatives getAlternatives_4_1() { return cAlternatives_4_1; }

		//NL
		public RuleCall getNLTerminalRuleCall_4_1_0() { return cNLTerminalRuleCall_4_1_0; }

		//SEMICOLON
		public RuleCall getSEMICOLONTerminalRuleCall_4_1_1() { return cSEMICOLONTerminalRuleCall_4_1_1; }

		//(longname8=ID ((DEF | MDEF) imp=TypeExpression?)? w8=WithPart)?
		public Group getGroup_5() { return cGroup_5; }

		//longname8=ID
		public Assignment getLongname8Assignment_5_0() { return cLongname8Assignment_5_0; }

		//ID
		public RuleCall getLongname8IDTerminalRuleCall_5_0_0() { return cLongname8IDTerminalRuleCall_5_0_0; }

		//((DEF | MDEF) imp=TypeExpression?)?
		public Group getGroup_5_1() { return cGroup_5_1; }

		//DEF | MDEF
		public Alternatives getAlternatives_5_1_0() { return cAlternatives_5_1_0; }

		//DEF
		public RuleCall getDEFTerminalRuleCall_5_1_0_0() { return cDEFTerminalRuleCall_5_1_0_0; }

		//MDEF
		public RuleCall getMDEFTerminalRuleCall_5_1_0_1() { return cMDEFTerminalRuleCall_5_1_0_1; }

		//imp=TypeExpression?
		public Assignment getImpAssignment_5_1_1() { return cImpAssignment_5_1_1; }

		//TypeExpression
		public RuleCall getImpTypeExpressionParserRuleCall_5_1_1_0() { return cImpTypeExpressionParserRuleCall_5_1_1_0; }

		//w8=WithPart
		public Assignment getW8Assignment_5_2() { return cW8Assignment_5_2; }

		//WithPart
		public RuleCall getW8WithPartParserRuleCall_5_2_0() { return cW8WithPartParserRuleCall_5_2_0; }

		//(longname9=ID (DEF | MDEF)? add=AddPart)?
		public Group getGroup_6() { return cGroup_6; }

		//longname9=ID
		public Assignment getLongname9Assignment_6_0() { return cLongname9Assignment_6_0; }

		//ID
		public RuleCall getLongname9IDTerminalRuleCall_6_0_0() { return cLongname9IDTerminalRuleCall_6_0_0; }

		//(DEF | MDEF)?
		public Alternatives getAlternatives_6_1() { return cAlternatives_6_1; }

		//DEF
		public RuleCall getDEFTerminalRuleCall_6_1_0() { return cDEFTerminalRuleCall_6_1_0; }

		//MDEF
		public RuleCall getMDEFTerminalRuleCall_6_1_1() { return cMDEFTerminalRuleCall_6_1_1; }

		//add=AddPart
		public Assignment getAddAssignment_6_2() { return cAddAssignment_6_2; }

		//AddPart
		public RuleCall getAddAddPartParserRuleCall_6_2_0() { return cAddAddPartParserRuleCall_6_2_0; }

		//RBRACE
		public RuleCall getRBRACETerminalRuleCall_7() { return cRBRACETerminalRuleCall_7; }

		//NL+
		public RuleCall getNLTerminalRuleCall_8() { return cNLTerminalRuleCall_8; }
	}

	public class WhereAssignmentsElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "WhereAssignments");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cVariableDeclarationParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cMacroDefParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cImportParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		/// * each one must be on a separate line or separated by ';'
		// * need to add name=
		// * / WhereAssignments hidden(WS):
		//	VariableDeclaration | MacroDef | Import;
		public ParserRule getRule() { return rule; }

		//VariableDeclaration | MacroDef | Import
		public Alternatives getAlternatives() { return cAlternatives; }

		//VariableDeclaration
		public RuleCall getVariableDeclarationParserRuleCall_0() { return cVariableDeclarationParserRuleCall_0; }

		//MacroDef
		public RuleCall getMacroDefParserRuleCall_1() { return cMacroDefParserRuleCall_1; }

		//Import
		public RuleCall getImportParserRuleCall_2() { return cImportParserRuleCall_2; }
	}

	public class WithPartElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "WithPart");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Keyword cNameWithKeyword_0_0 = (Keyword)cNameAssignment_0.eContents().get(0);
		private final RuleCall cNLTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final RuleCall cLBRACETerminalRuleCall_2 = (RuleCall)cGroup.eContents().get(2);
		private final RuleCall cNLTerminalRuleCall_3 = (RuleCall)cGroup.eContents().get(3);
		private final Group cGroup_4 = (Group)cGroup.eContents().get(4);
		private final Assignment cFundecAssignment_4_0 = (Assignment)cGroup_4.eContents().get(0);
		private final RuleCall cFundecVariableDeclarationParserRuleCall_4_0_0 = (RuleCall)cFundecAssignment_4_0.eContents().get(0);
		private final Alternatives cAlternatives_4_1 = (Alternatives)cGroup_4.eContents().get(1);
		private final RuleCall cNLTerminalRuleCall_4_1_0 = (RuleCall)cAlternatives_4_1.eContents().get(0);
		private final RuleCall cSEMICOLONTerminalRuleCall_4_1_1 = (RuleCall)cAlternatives_4_1.eContents().get(1);
		private final RuleCall cRBRACETerminalRuleCall_5 = (RuleCall)cGroup.eContents().get(5);
		private final RuleCall cNLTerminalRuleCall_6 = (RuleCall)cGroup.eContents().get(6);
		
		/// *
		// * the 'where' part contains a 'with' part which holds export information
		// * such as function signatures (function declarations) but not function definitions.
		// * / WithPart hidden(WS, SL_COMMENT):
		//	name="with" NL* LBRACE NL* (fundec+=VariableDeclaration (NL | SEMICOLON)+)* RBRACE NL*;
		public ParserRule getRule() { return rule; }

		//name="with" NL* LBRACE NL* (fundec+=VariableDeclaration (NL | SEMICOLON)+)* RBRACE NL*
		public Group getGroup() { return cGroup; }

		//name="with"
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }

		//"with"
		public Keyword getNameWithKeyword_0_0() { return cNameWithKeyword_0_0; }

		//NL*
		public RuleCall getNLTerminalRuleCall_1() { return cNLTerminalRuleCall_1; }

		//LBRACE
		public RuleCall getLBRACETerminalRuleCall_2() { return cLBRACETerminalRuleCall_2; }

		//NL*
		public RuleCall getNLTerminalRuleCall_3() { return cNLTerminalRuleCall_3; }

		//(fundec+=VariableDeclaration (NL | SEMICOLON)+)*
		public Group getGroup_4() { return cGroup_4; }

		//fundec+=VariableDeclaration
		public Assignment getFundecAssignment_4_0() { return cFundecAssignment_4_0; }

		//VariableDeclaration
		public RuleCall getFundecVariableDeclarationParserRuleCall_4_0_0() { return cFundecVariableDeclarationParserRuleCall_4_0_0; }

		//(NL | SEMICOLON)+
		public Alternatives getAlternatives_4_1() { return cAlternatives_4_1; }

		//NL
		public RuleCall getNLTerminalRuleCall_4_1_0() { return cNLTerminalRuleCall_4_1_0; }

		//SEMICOLON
		public RuleCall getSEMICOLONTerminalRuleCall_4_1_1() { return cSEMICOLONTerminalRuleCall_4_1_1; }

		//RBRACE
		public RuleCall getRBRACETerminalRuleCall_5() { return cRBRACETerminalRuleCall_5; }

		//NL*
		public RuleCall getNLTerminalRuleCall_6() { return cNLTerminalRuleCall_6; }
	}

	public class AddPartElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "AddPart");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Keyword cNameAddKeyword_0_0 = (Keyword)cNameAssignment_0.eContents().get(0);
		private final RuleCall cNLTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final RuleCall cLBRACETerminalRuleCall_2 = (RuleCall)cGroup.eContents().get(2);
		private final RuleCall cNLTerminalRuleCall_3 = (RuleCall)cGroup.eContents().get(3);
		private final Group cGroup_4 = (Group)cGroup.eContents().get(4);
		private final Assignment cTAssignment_4_0 = (Assignment)cGroup_4.eContents().get(0);
		private final RuleCall cTAddStatementsParserRuleCall_4_0_0 = (RuleCall)cTAssignment_4_0.eContents().get(0);
		private final Alternatives cAlternatives_4_1 = (Alternatives)cGroup_4.eContents().get(1);
		private final RuleCall cNLTerminalRuleCall_4_1_0 = (RuleCall)cAlternatives_4_1.eContents().get(0);
		private final RuleCall cSEMICOLONTerminalRuleCall_4_1_1 = (RuleCall)cAlternatives_4_1.eContents().get(1);
		private final RuleCall cRBRACETerminalRuleCall_5 = (RuleCall)cGroup.eContents().get(5);
		private final RuleCall cNLTerminalRuleCall_6 = (RuleCall)cGroup.eContents().get(6);
		
		/// *
		// * In a category, if we don't combine with an existing type then the
		// * 'with' keyword is not needed.
		//WithImplied hidden(WS,SL_COMMENT):
		//	NL* b=LBRACE NL*
		//    (fundec += VariableDeclaration (NL|SEMICOLON)+)*
		//    RBRACE NL*
		//;
		// * / / *
		// * the 'where' part contains a 'add' part which holds function and other
		// * declarations.
		// * / AddPart hidden(WS, SL_COMMENT):
		//	name="add" NL* LBRACE NL* (t+=AddStatements (NL | SEMICOLON)+)* RBRACE NL*;
		public ParserRule getRule() { return rule; }

		//name="add" NL* LBRACE NL* (t+=AddStatements (NL | SEMICOLON)+)* RBRACE NL*
		public Group getGroup() { return cGroup; }

		//name="add"
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }

		//"add"
		public Keyword getNameAddKeyword_0_0() { return cNameAddKeyword_0_0; }

		//NL*
		public RuleCall getNLTerminalRuleCall_1() { return cNLTerminalRuleCall_1; }

		//LBRACE
		public RuleCall getLBRACETerminalRuleCall_2() { return cLBRACETerminalRuleCall_2; }

		//NL*
		public RuleCall getNLTerminalRuleCall_3() { return cNLTerminalRuleCall_3; }

		//(t+=AddStatements (NL | SEMICOLON)+)*
		public Group getGroup_4() { return cGroup_4; }

		//t+=AddStatements
		public Assignment getTAssignment_4_0() { return cTAssignment_4_0; }

		//AddStatements
		public RuleCall getTAddStatementsParserRuleCall_4_0_0() { return cTAddStatementsParserRuleCall_4_0_0; }

		//(NL | SEMICOLON)+
		public Alternatives getAlternatives_4_1() { return cAlternatives_4_1; }

		//NL
		public RuleCall getNLTerminalRuleCall_4_1_0() { return cNLTerminalRuleCall_4_1_0; }

		//SEMICOLON
		public RuleCall getSEMICOLONTerminalRuleCall_4_1_1() { return cSEMICOLONTerminalRuleCall_4_1_1; }

		//RBRACE
		public RuleCall getRBRACETerminalRuleCall_5() { return cRBRACETerminalRuleCall_5; }

		//NL*
		public RuleCall getNLTerminalRuleCall_6() { return cNLTerminalRuleCall_6; }
	}

	public class AddStatementsElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "AddStatements");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cVariableDeclarationAssignParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cFunctionDefinitionParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cMacroDefParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cImportParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		
		/// *
		// * The add section of domain or package may contain multiple lines
		// * / AddStatements hidden(WS, SL_COMMENT):
		//	VariableDeclarationAssign | FunctionDefinition | MacroDef | Import;
		public ParserRule getRule() { return rule; }

		//VariableDeclarationAssign | FunctionDefinition | MacroDef | Import
		public Alternatives getAlternatives() { return cAlternatives; }

		//VariableDeclarationAssign
		public RuleCall getVariableDeclarationAssignParserRuleCall_0() { return cVariableDeclarationAssignParserRuleCall_0; }

		//FunctionDefinition
		public RuleCall getFunctionDefinitionParserRuleCall_1() { return cFunctionDefinitionParserRuleCall_1; }

		//MacroDef
		public RuleCall getMacroDefParserRuleCall_2() { return cMacroDefParserRuleCall_2; }

		//Import
		public RuleCall getImportParserRuleCall_3() { return cImportParserRuleCall_3; }
	}

	public class FunctionDefinitionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "FunctionDefinition");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cFunctionSignatureParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final RuleCall cCOLONTerminalRuleCall_1_0 = (RuleCall)cGroup_1.eContents().get(0);
		private final Assignment cPar4Assignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cPar4TypeExpressionParserRuleCall_1_1_0 = (RuleCall)cPar4Assignment_1_1.eContents().get(0);
		private final RuleCall cDEFTerminalRuleCall_2 = (RuleCall)cGroup.eContents().get(2);
		private final Assignment cPar5Assignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cPar5StatementParserRuleCall_3_0 = (RuleCall)cPar5Assignment_3.eContents().get(0);
		
		/// * function definition in add part
		// * has a form like:
		// * name(params) == statement
		// * or, for infix operators,
		// * a = b == statement
		// * or, for multiple statements,
		// * name(params) == {
		// *     statement
		// *     statement
		// * }
		// * / FunctionDefinition hidden(WS):
		//	FunctionSignature (COLON par4=TypeExpression)? DEF par5=Statement;
		public ParserRule getRule() { return rule; }

		//FunctionSignature (COLON par4=TypeExpression)? DEF par5=Statement
		public Group getGroup() { return cGroup; }

		//FunctionSignature
		public RuleCall getFunctionSignatureParserRuleCall_0() { return cFunctionSignatureParserRuleCall_0; }

		//(COLON par4=TypeExpression)?
		public Group getGroup_1() { return cGroup_1; }

		//COLON
		public RuleCall getCOLONTerminalRuleCall_1_0() { return cCOLONTerminalRuleCall_1_0; }

		//par4=TypeExpression
		public Assignment getPar4Assignment_1_1() { return cPar4Assignment_1_1; }

		//TypeExpression
		public RuleCall getPar4TypeExpressionParserRuleCall_1_1_0() { return cPar4TypeExpressionParserRuleCall_1_1_0; }

		//DEF
		public RuleCall getDEFTerminalRuleCall_2() { return cDEFTerminalRuleCall_2; }

		//par5=Statement
		public Assignment getPar5Assignment_3() { return cPar5Assignment_3; }

		//Statement
		public RuleCall getPar5StatementParserRuleCall_3_0() { return cPar5StatementParserRuleCall_3_0; }
	}

	public class FunctionSignatureElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "FunctionSignature");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Assignment cFnNamAssignment_0_0 = (Assignment)cGroup_0.eContents().get(0);
		private final RuleCall cFnNamIDTerminalRuleCall_0_0_0 = (RuleCall)cFnNamAssignment_0_0.eContents().get(0);
		private final RuleCall cLPARENTerminalRuleCall_0_1 = (RuleCall)cGroup_0.eContents().get(1);
		private final Assignment cPar2Assignment_0_2 = (Assignment)cGroup_0.eContents().get(2);
		private final RuleCall cPar2VariableDeclarationParserRuleCall_0_2_0 = (RuleCall)cPar2Assignment_0_2.eContents().get(0);
		private final Group cGroup_0_3 = (Group)cGroup_0.eContents().get(3);
		private final RuleCall cCOMMATerminalRuleCall_0_3_0 = (RuleCall)cGroup_0_3.eContents().get(0);
		private final Assignment cPar3Assignment_0_3_1 = (Assignment)cGroup_0_3.eContents().get(1);
		private final RuleCall cPar3VariableDeclarationParserRuleCall_0_3_1_0 = (RuleCall)cPar3Assignment_0_3_1.eContents().get(0);
		private final RuleCall cRPARENTerminalRuleCall_0_4 = (RuleCall)cGroup_0.eContents().get(4);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Assignment cFnNamAssignment_1_0 = (Assignment)cGroup_1.eContents().get(0);
		private final RuleCall cFnNamIDTerminalRuleCall_1_0_0 = (RuleCall)cFnNamAssignment_1_0.eContents().get(0);
		private final Assignment cParAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cParIDTerminalRuleCall_1_1_0 = (RuleCall)cParAssignment_1_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cAlternatives.eContents().get(2);
		private final Assignment cT4Assignment_2_0 = (Assignment)cGroup_2.eContents().get(0);
		private final RuleCall cT4IDTerminalRuleCall_2_0_0 = (RuleCall)cT4Assignment_2_0.eContents().get(0);
		private final Alternatives cAlternatives_2_1 = (Alternatives)cGroup_2.eContents().get(1);
		private final Assignment cB1Assignment_2_1_0 = (Assignment)cAlternatives_2_1.eContents().get(0);
		private final RuleCall cB1EQUALTerminalRuleCall_2_1_0_0 = (RuleCall)cB1Assignment_2_1_0.eContents().get(0);
		private final Assignment cB1Assignment_2_1_1 = (Assignment)cAlternatives_2_1.eContents().get(1);
		private final RuleCall cB1LTTerminalRuleCall_2_1_1_0 = (RuleCall)cB1Assignment_2_1_1.eContents().get(0);
		private final Assignment cB1Assignment_2_1_2 = (Assignment)cAlternatives_2_1.eContents().get(2);
		private final RuleCall cB1GTTerminalRuleCall_2_1_2_0 = (RuleCall)cB1Assignment_2_1_2.eContents().get(0);
		private final Assignment cB1Assignment_2_1_3 = (Assignment)cAlternatives_2_1.eContents().get(3);
		private final RuleCall cB1LETerminalRuleCall_2_1_3_0 = (RuleCall)cB1Assignment_2_1_3.eContents().get(0);
		private final Assignment cB1Assignment_2_1_4 = (Assignment)cAlternatives_2_1.eContents().get(4);
		private final RuleCall cB1GETerminalRuleCall_2_1_4_0 = (RuleCall)cB1Assignment_2_1_4.eContents().get(0);
		private final Assignment cB1Assignment_2_1_5 = (Assignment)cAlternatives_2_1.eContents().get(5);
		private final RuleCall cB1PLUSTerminalRuleCall_2_1_5_0 = (RuleCall)cB1Assignment_2_1_5.eContents().get(0);
		private final Assignment cB1Assignment_2_1_6 = (Assignment)cAlternatives_2_1.eContents().get(6);
		private final RuleCall cB1MINUSTerminalRuleCall_2_1_6_0 = (RuleCall)cB1Assignment_2_1_6.eContents().get(0);
		private final Assignment cB1Assignment_2_1_7 = (Assignment)cAlternatives_2_1.eContents().get(7);
		private final RuleCall cB1TIMESTerminalRuleCall_2_1_7_0 = (RuleCall)cB1Assignment_2_1_7.eContents().get(0);
		private final Assignment cB1Assignment_2_1_8 = (Assignment)cAlternatives_2_1.eContents().get(8);
		private final RuleCall cB1SLASHTerminalRuleCall_2_1_8_0 = (RuleCall)cB1Assignment_2_1_8.eContents().get(0);
		private final Assignment cB1Assignment_2_1_9 = (Assignment)cAlternatives_2_1.eContents().get(9);
		private final RuleCall cB1AMPERSANDTerminalRuleCall_2_1_9_0 = (RuleCall)cB1Assignment_2_1_9.eContents().get(0);
		private final Assignment cB1Assignment_2_1_10 = (Assignment)cAlternatives_2_1.eContents().get(10);
		private final RuleCall cB1BARTerminalRuleCall_2_1_10_0 = (RuleCall)cB1Assignment_2_1_10.eContents().get(0);
		private final Assignment cB1Assignment_2_1_11 = (Assignment)cAlternatives_2_1.eContents().get(11);
		private final RuleCall cB1CARATTerminalRuleCall_2_1_11_0 = (RuleCall)cB1Assignment_2_1_11.eContents().get(0);
		private final Assignment cT5Assignment_2_2 = (Assignment)cGroup_2.eContents().get(2);
		private final RuleCall cT5IDTerminalRuleCall_2_2_0 = (RuleCall)cT5Assignment_2_2.eContents().get(0);
		private final Group cGroup_3 = (Group)cAlternatives.eContents().get(3);
		private final Assignment cB2Assignment_3_0 = (Assignment)cGroup_3.eContents().get(0);
		private final RuleCall cB2MINUSTerminalRuleCall_3_0_0 = (RuleCall)cB2Assignment_3_0.eContents().get(0);
		private final Assignment cT6Assignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final RuleCall cT6IDTerminalRuleCall_3_1_0 = (RuleCall)cT6Assignment_3_1.eContents().get(0);
		
		/// * This is the first part of the function definition without the return type or
		// * the function implementation. Usually the function signature has a form like:
		// * name(params)
		// * We allow a single parameter to be given without brackets:
		// * name param
		// * We also allow some alternative forms to represent infix operators like:
		// * a = b to represent _=(a,b)
		// * or
		// * a > b to represent _>(a,b)
		// * 0 or 1 can be used as a function signature as a short form of
		// * _0() or _1()
		// * / // 0 or 1 can be used as a function signature as a short form of
		//// _0() or _1() but that confuses the parser
		//// | b3?='0' | b4?='1'
		//FunctionSignature hidden(WS):
		//	fnNam=ID LPAREN par2=VariableDeclaration? (COMMA par3+=VariableDeclaration)* RPAREN | // fnNam=ID par2=VariableDeclaration this causes recursive defintion
		//	fnNam=ID par=ID | t4=ID (b1=EQUAL | b1=LT | b1=GT | b1=LE | b1=GE | b1=PLUS | b1=MINUS | b1=TIMES | b1=SLASH |
		//	b1=AMPERSAND | b1=BAR | b1=CARAT) t5=ID | b2=MINUS t6=ID;
		public ParserRule getRule() { return rule; }

		//fnNam=ID LPAREN par2=VariableDeclaration? (COMMA par3+=VariableDeclaration)* RPAREN | // fnNam=ID par2=VariableDeclaration this causes recursive defintion
		//fnNam=ID par=ID | t4=ID (b1=EQUAL | b1=LT | b1=GT | b1=LE | b1=GE | b1=PLUS | b1=MINUS | b1=TIMES | b1=SLASH |
		//b1=AMPERSAND | b1=BAR | b1=CARAT) t5=ID | b2=MINUS t6=ID
		public Alternatives getAlternatives() { return cAlternatives; }

		//fnNam=ID LPAREN par2=VariableDeclaration? (COMMA par3+=VariableDeclaration)* RPAREN
		public Group getGroup_0() { return cGroup_0; }

		//fnNam=ID
		public Assignment getFnNamAssignment_0_0() { return cFnNamAssignment_0_0; }

		//ID
		public RuleCall getFnNamIDTerminalRuleCall_0_0_0() { return cFnNamIDTerminalRuleCall_0_0_0; }

		//LPAREN
		public RuleCall getLPARENTerminalRuleCall_0_1() { return cLPARENTerminalRuleCall_0_1; }

		//par2=VariableDeclaration?
		public Assignment getPar2Assignment_0_2() { return cPar2Assignment_0_2; }

		//VariableDeclaration
		public RuleCall getPar2VariableDeclarationParserRuleCall_0_2_0() { return cPar2VariableDeclarationParserRuleCall_0_2_0; }

		//(COMMA par3+=VariableDeclaration)*
		public Group getGroup_0_3() { return cGroup_0_3; }

		//COMMA
		public RuleCall getCOMMATerminalRuleCall_0_3_0() { return cCOMMATerminalRuleCall_0_3_0; }

		//par3+=VariableDeclaration
		public Assignment getPar3Assignment_0_3_1() { return cPar3Assignment_0_3_1; }

		//VariableDeclaration
		public RuleCall getPar3VariableDeclarationParserRuleCall_0_3_1_0() { return cPar3VariableDeclarationParserRuleCall_0_3_1_0; }

		//RPAREN
		public RuleCall getRPARENTerminalRuleCall_0_4() { return cRPARENTerminalRuleCall_0_4; }

		//// fnNam=ID par2=VariableDeclaration this causes recursive defintion
		//fnNam=ID par=ID
		public Group getGroup_1() { return cGroup_1; }

		//// fnNam=ID par2=VariableDeclaration this causes recursive defintion
		//fnNam=ID
		public Assignment getFnNamAssignment_1_0() { return cFnNamAssignment_1_0; }

		//ID
		public RuleCall getFnNamIDTerminalRuleCall_1_0_0() { return cFnNamIDTerminalRuleCall_1_0_0; }

		//par=ID
		public Assignment getParAssignment_1_1() { return cParAssignment_1_1; }

		//ID
		public RuleCall getParIDTerminalRuleCall_1_1_0() { return cParIDTerminalRuleCall_1_1_0; }

		//t4=ID (b1=EQUAL | b1=LT | b1=GT | b1=LE | b1=GE | b1=PLUS | b1=MINUS | b1=TIMES | b1=SLASH | b1=AMPERSAND | b1=BAR |
		//b1=CARAT) t5=ID
		public Group getGroup_2() { return cGroup_2; }

		//t4=ID
		public Assignment getT4Assignment_2_0() { return cT4Assignment_2_0; }

		//ID
		public RuleCall getT4IDTerminalRuleCall_2_0_0() { return cT4IDTerminalRuleCall_2_0_0; }

		//b1=EQUAL | b1=LT | b1=GT | b1=LE | b1=GE | b1=PLUS | b1=MINUS | b1=TIMES | b1=SLASH | b1=AMPERSAND | b1=BAR | b1=CARAT
		public Alternatives getAlternatives_2_1() { return cAlternatives_2_1; }

		//b1=EQUAL
		public Assignment getB1Assignment_2_1_0() { return cB1Assignment_2_1_0; }

		//EQUAL
		public RuleCall getB1EQUALTerminalRuleCall_2_1_0_0() { return cB1EQUALTerminalRuleCall_2_1_0_0; }

		//b1=LT
		public Assignment getB1Assignment_2_1_1() { return cB1Assignment_2_1_1; }

		//LT
		public RuleCall getB1LTTerminalRuleCall_2_1_1_0() { return cB1LTTerminalRuleCall_2_1_1_0; }

		//b1=GT
		public Assignment getB1Assignment_2_1_2() { return cB1Assignment_2_1_2; }

		//GT
		public RuleCall getB1GTTerminalRuleCall_2_1_2_0() { return cB1GTTerminalRuleCall_2_1_2_0; }

		//b1=LE
		public Assignment getB1Assignment_2_1_3() { return cB1Assignment_2_1_3; }

		//LE
		public RuleCall getB1LETerminalRuleCall_2_1_3_0() { return cB1LETerminalRuleCall_2_1_3_0; }

		//b1=GE
		public Assignment getB1Assignment_2_1_4() { return cB1Assignment_2_1_4; }

		//GE
		public RuleCall getB1GETerminalRuleCall_2_1_4_0() { return cB1GETerminalRuleCall_2_1_4_0; }

		//b1=PLUS
		public Assignment getB1Assignment_2_1_5() { return cB1Assignment_2_1_5; }

		//PLUS
		public RuleCall getB1PLUSTerminalRuleCall_2_1_5_0() { return cB1PLUSTerminalRuleCall_2_1_5_0; }

		//b1=MINUS
		public Assignment getB1Assignment_2_1_6() { return cB1Assignment_2_1_6; }

		//MINUS
		public RuleCall getB1MINUSTerminalRuleCall_2_1_6_0() { return cB1MINUSTerminalRuleCall_2_1_6_0; }

		//b1=TIMES
		public Assignment getB1Assignment_2_1_7() { return cB1Assignment_2_1_7; }

		//TIMES
		public RuleCall getB1TIMESTerminalRuleCall_2_1_7_0() { return cB1TIMESTerminalRuleCall_2_1_7_0; }

		//b1=SLASH
		public Assignment getB1Assignment_2_1_8() { return cB1Assignment_2_1_8; }

		//SLASH
		public RuleCall getB1SLASHTerminalRuleCall_2_1_8_0() { return cB1SLASHTerminalRuleCall_2_1_8_0; }

		//b1=AMPERSAND
		public Assignment getB1Assignment_2_1_9() { return cB1Assignment_2_1_9; }

		//AMPERSAND
		public RuleCall getB1AMPERSANDTerminalRuleCall_2_1_9_0() { return cB1AMPERSANDTerminalRuleCall_2_1_9_0; }

		//b1=BAR
		public Assignment getB1Assignment_2_1_10() { return cB1Assignment_2_1_10; }

		//BAR
		public RuleCall getB1BARTerminalRuleCall_2_1_10_0() { return cB1BARTerminalRuleCall_2_1_10_0; }

		//b1=CARAT
		public Assignment getB1Assignment_2_1_11() { return cB1Assignment_2_1_11; }

		//CARAT
		public RuleCall getB1CARATTerminalRuleCall_2_1_11_0() { return cB1CARATTerminalRuleCall_2_1_11_0; }

		//t5=ID
		public Assignment getT5Assignment_2_2() { return cT5Assignment_2_2; }

		//ID
		public RuleCall getT5IDTerminalRuleCall_2_2_0() { return cT5IDTerminalRuleCall_2_2_0; }

		//b2=MINUS t6=ID
		public Group getGroup_3() { return cGroup_3; }

		//b2=MINUS
		public Assignment getB2Assignment_3_0() { return cB2Assignment_3_0; }

		//MINUS
		public RuleCall getB2MINUSTerminalRuleCall_3_0_0() { return cB2MINUSTerminalRuleCall_3_0_0; }

		//t6=ID
		public Assignment getT6Assignment_3_1() { return cT6Assignment_3_1; }

		//ID
		public RuleCall getT6IDTerminalRuleCall_3_1_0() { return cT6IDTerminalRuleCall_3_1_0; }
	}

	public class MacroDefElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "MacroDef");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cMacronameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cMacronameIDTerminalRuleCall_0_0 = (RuleCall)cMacronameAssignment_0.eContents().get(0);
		private final RuleCall cMACROVALUETerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		
		/// * macros provide a general textual substitution
		// * there are two forms:
		// * name ==> body
		// * and
		// * name macro == body 	
		// * / //MACRO val=ID NL;
		//MacroDef:
		//	macroname=ID MACROVALUE;
		public ParserRule getRule() { return rule; }

		//macroname=ID MACROVALUE
		public Group getGroup() { return cGroup; }

		//macroname=ID
		public Assignment getMacronameAssignment_0() { return cMacronameAssignment_0; }

		//ID
		public RuleCall getMacronameIDTerminalRuleCall_0_0() { return cMacronameIDTerminalRuleCall_0_0; }

		//MACROVALUE
		public RuleCall getMACROVALUETerminalRuleCall_1() { return cMACROVALUETerminalRuleCall_1; }
	}

	public class ImportElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Import");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cImportKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cImpnameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cImpnameIDTerminalRuleCall_1_0 = (RuleCall)cImpnameAssignment_1.eContents().get(0);
		
		/// *
		// * import domain
		// * / Import hidden(WS):
		//	"import" impname+=ID+;
		public ParserRule getRule() { return rule; }

		//"import" impname+=ID+
		public Group getGroup() { return cGroup; }

		//"import"
		public Keyword getImportKeyword_0() { return cImportKeyword_0; }

		//impname+=ID+
		public Assignment getImpnameAssignment_1() { return cImpnameAssignment_1; }

		//ID
		public RuleCall getImpnameIDTerminalRuleCall_1_0() { return cImpnameIDTerminalRuleCall_1_0; }
	}

	public class VariableDeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "VariableDeclaration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cVarNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cVarNameIDTerminalRuleCall_0_0 = (RuleCall)cVarNameAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final RuleCall cCOLONTerminalRuleCall_1_0 = (RuleCall)cGroup_1.eContents().get(0);
		private final Assignment cTypAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cTypTypeExpressionParserRuleCall_1_1_0 = (RuleCall)cTypAssignment_1_1.eContents().get(0);
		
		/// * Variable declaration in where and with sections and function signature:
		// * A 'variable' can be simple like:
		// * x:Float
		// * or something more complicated like:
		// * x:Record(newPt: Pt,type:  String)
		// * or it can be a function like:
		// * x:(Float,Integer) -> Float
		// * / VariableDeclaration hidden(WS): // if I just use name=ID then, when the ui program is running, I get:
		//// Duplicate VariableDeclaration 'coerce' in WithPart 'with'
		//	varName=ID (COLON typ=TypeExpression)?;
		public ParserRule getRule() { return rule; }

		//// if I just use name=ID then, when the ui program is running, I get:
		//// Duplicate VariableDeclaration 'coerce' in WithPart 'with'
		//varName=ID (COLON typ=TypeExpression)?
		public Group getGroup() { return cGroup; }

		//// if I just use name=ID then, when the ui program is running, I get:
		//// Duplicate VariableDeclaration 'coerce' in WithPart 'with'
		//varName=ID
		public Assignment getVarNameAssignment_0() { return cVarNameAssignment_0; }

		//ID
		public RuleCall getVarNameIDTerminalRuleCall_0_0() { return cVarNameIDTerminalRuleCall_0_0; }

		//(COLON typ=TypeExpression)?
		public Group getGroup_1() { return cGroup_1; }

		//COLON
		public RuleCall getCOLONTerminalRuleCall_1_0() { return cCOLONTerminalRuleCall_1_0; }

		//typ=TypeExpression
		public Assignment getTypAssignment_1_1() { return cTypAssignment_1_1; }

		//TypeExpression
		public RuleCall getTypTypeExpressionParserRuleCall_1_1_0() { return cTypTypeExpressionParserRuleCall_1_1_0; }
	}

	public class VariableDeclarationAssignElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "VariableDeclarationAssign");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cVarNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cVarNameIDTerminalRuleCall_0_0 = (RuleCall)cVarNameAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final RuleCall cCOMMATerminalRuleCall_1_0 = (RuleCall)cGroup_1.eContents().get(0);
		private final Assignment cT2Assignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cT2IDTerminalRuleCall_1_1_0 = (RuleCall)cT2Assignment_1_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final RuleCall cCOLONTerminalRuleCall_2_0 = (RuleCall)cGroup_2.eContents().get(0);
		private final Assignment cTypAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cTypTypeExpressionParserRuleCall_2_1_0 = (RuleCall)cTypAssignment_2_1.eContents().get(0);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final RuleCall cBECOMESTerminalRuleCall_3_0 = (RuleCall)cGroup_3.eContents().get(0);
		private final Assignment cT4Assignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final RuleCall cT4ExpressionParserRuleCall_3_1_0 = (RuleCall)cT4Assignment_3_1.eContents().get(0);
		
		/// * in add part we can declare and assign in same part
		// * such as:
		// * a := 3
		// * a,b,c := 0@Integer
		// * a:Integer := 3
		// * a := sin(x)
		// * / VariableDeclarationAssign hidden(WS):
		//	varName= // name of variable
		//	ID // if I just use name=ID then, when the ui program is running, I get:
		//	// Duplicate xxx 'coerce' in yyy
		//	(COMMA t2+=ID)* // multiple declarations in same line
		//	(COLON typ=TypeExpression)? // option to explicitly define type
		//	(BECOMES t4=Expression)?;
		public ParserRule getRule() { return rule; }

		//varName= // name of variable
		//ID // if I just use name=ID then, when the ui program is running, I get:
		//// Duplicate xxx 'coerce' in yyy
		//(COMMA t2+=ID)* // multiple declarations in same line
		//(COLON typ=TypeExpression)? // option to explicitly define type
		//(BECOMES t4=Expression)?
		public Group getGroup() { return cGroup; }

		//varName= // name of variable
		//ID
		public Assignment getVarNameAssignment_0() { return cVarNameAssignment_0; }

		//// name of variable
		//ID
		public RuleCall getVarNameIDTerminalRuleCall_0_0() { return cVarNameIDTerminalRuleCall_0_0; }

		//(COMMA t2+=ID)*
		public Group getGroup_1() { return cGroup_1; }

		//COMMA
		public RuleCall getCOMMATerminalRuleCall_1_0() { return cCOMMATerminalRuleCall_1_0; }

		//t2+=ID
		public Assignment getT2Assignment_1_1() { return cT2Assignment_1_1; }

		//ID
		public RuleCall getT2IDTerminalRuleCall_1_1_0() { return cT2IDTerminalRuleCall_1_1_0; }

		//(COLON typ=TypeExpression)?
		public Group getGroup_2() { return cGroup_2; }

		//COLON
		public RuleCall getCOLONTerminalRuleCall_2_0() { return cCOLONTerminalRuleCall_2_0; }

		//typ=TypeExpression
		public Assignment getTypAssignment_2_1() { return cTypAssignment_2_1; }

		//TypeExpression
		public RuleCall getTypTypeExpressionParserRuleCall_2_1_0() { return cTypTypeExpressionParserRuleCall_2_1_0; }

		//(BECOMES t4=Expression)?
		public Group getGroup_3() { return cGroup_3; }

		//BECOMES
		public RuleCall getBECOMESTerminalRuleCall_3_0() { return cBECOMESTerminalRuleCall_3_0; }

		//t4=Expression
		public Assignment getT4Assignment_3_1() { return cT4Assignment_3_1; }

		//Expression
		public RuleCall getT4ExpressionParserRuleCall_3_1_0() { return cT4ExpressionParserRuleCall_3_1_0; }
	}

	public class FreeVariableElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "FreeVariable");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cFreeKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cVarAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cVarIDTerminalRuleCall_1_0 = (RuleCall)cVarAssignment_1.eContents().get(0);
		
		/// *
		// * free variable 	allows us to declare a variable that is global 
		// * / FreeVariable hidden(WS):
		//	"free" var=ID;
		public ParserRule getRule() { return rule; }

		//"free" var=ID
		public Group getGroup() { return cGroup; }

		//"free"
		public Keyword getFreeKeyword_0() { return cFreeKeyword_0; }

		//var=ID
		public Assignment getVarAssignment_1() { return cVarAssignment_1; }

		//ID
		public RuleCall getVarIDTerminalRuleCall_1_0() { return cVarIDTerminalRuleCall_1_0; }
	}

	public class LocalVariableElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "LocalVariable");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLocalKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cVarAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cVarIDTerminalRuleCall_1_0 = (RuleCall)cVarAssignment_1.eContents().get(0);
		
		/// *
		// * allows us to declare a variable that is not global  
		// * / LocalVariable hidden(WS):
		//	"local" var=ID;
		public ParserRule getRule() { return rule; }

		//"local" var=ID
		public Group getGroup() { return cGroup; }

		//"local"
		public Keyword getLocalKeyword_0() { return cLocalKeyword_0; }

		//var=ID
		public Assignment getVarAssignment_1() { return cVarAssignment_1; }

		//ID
		public RuleCall getVarIDTerminalRuleCall_1_0() { return cVarIDTerminalRuleCall_1_0; }
	}

	public class TypeExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "TypeExpression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Group cGroup_0_0 = (Group)cGroup_0.eContents().get(0);
		private final Assignment cT2Assignment_0_0_0 = (Assignment)cGroup_0_0.eContents().get(0);
		private final RuleCall cT2TypeArgumentsParserRuleCall_0_0_0_0 = (RuleCall)cT2Assignment_0_0_0.eContents().get(0);
		private final RuleCall cARROWTerminalRuleCall_0_0_1 = (RuleCall)cGroup_0_0.eContents().get(1);
		private final Assignment cT3Assignment_0_0_2 = (Assignment)cGroup_0_0.eContents().get(2);
		private final RuleCall cT3TypeResultParserRuleCall_0_0_2_0 = (RuleCall)cT3Assignment_0_0_2.eContents().get(0);
		private final RuleCall cTypePrimaryExpressionParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		/// *
		// * This is similar to Expression but known to be of type.
		// * (Expression can also be of type) but if we know that
		// * this is a type we can exclude some possibilities.
		// * 
		// * A 'typeExpression' can be simple like:
		// * Float
		// * or something more complicated like:
		// * Record(newPt: Pt,type:  String)
		// * or it can be a function like:
		// * (Float,Integer) -> Float
		// * 
		// * first we check for a function like: Integer -> Integer
		// * / TypeExpression hidden(WS):
		//	=> (t2=TypeArguments ARROW t3=TypeResult) | TypePrimaryExpression;
		public ParserRule getRule() { return rule; }

		//=> (t2=TypeArguments ARROW t3=TypeResult) | TypePrimaryExpression
		public Alternatives getAlternatives() { return cAlternatives; }

		//=> (t2=TypeArguments ARROW t3=TypeResult)
		public Group getGroup_0() { return cGroup_0; }

		//t2=TypeArguments ARROW t3=TypeResult
		public Group getGroup_0_0() { return cGroup_0_0; }

		//t2=TypeArguments
		public Assignment getT2Assignment_0_0_0() { return cT2Assignment_0_0_0; }

		//TypeArguments
		public RuleCall getT2TypeArgumentsParserRuleCall_0_0_0_0() { return cT2TypeArgumentsParserRuleCall_0_0_0_0; }

		//ARROW
		public RuleCall getARROWTerminalRuleCall_0_0_1() { return cARROWTerminalRuleCall_0_0_1; }

		//t3=TypeResult
		public Assignment getT3Assignment_0_0_2() { return cT3Assignment_0_0_2; }

		//TypeResult
		public RuleCall getT3TypeResultParserRuleCall_0_0_2_0() { return cT3TypeResultParserRuleCall_0_0_2_0; }

		//TypePrimaryExpression
		public RuleCall getTypePrimaryExpressionParserRuleCall_1() { return cTypePrimaryExpressionParserRuleCall_1; }
	}

	public class TypeParameterListElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "TypeParameterList");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cTynameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cTynameLPARENTerminalRuleCall_0_0 = (RuleCall)cTynameAssignment_0.eContents().get(0);
		private final Assignment cParAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cParIDTerminalRuleCall_1_0 = (RuleCall)cParAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final RuleCall cCOMMATerminalRuleCall_2_0 = (RuleCall)cGroup_2.eContents().get(0);
		private final Assignment cPar2Assignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cPar2IDTerminalRuleCall_2_1_0 = (RuleCall)cPar2Assignment_2_1.eContents().get(0);
		private final RuleCall cRPARENTerminalRuleCall_3 = (RuleCall)cGroup.eContents().get(3);
		
		/// *
		// * we use a type parameter list for parameters of category, package or domains
		// * 
		// * in this case parameters may be just ID or they may be nameID:typeID
		// * / TypeParameterList hidden(WS):
		//	tyname=LPAREN par=ID? (COMMA par2+=ID)* RPAREN;
		public ParserRule getRule() { return rule; }

		//tyname=LPAREN par=ID? (COMMA par2+=ID)* RPAREN
		public Group getGroup() { return cGroup; }

		//tyname=LPAREN
		public Assignment getTynameAssignment_0() { return cTynameAssignment_0; }

		//LPAREN
		public RuleCall getTynameLPARENTerminalRuleCall_0_0() { return cTynameLPARENTerminalRuleCall_0_0; }

		//par=ID?
		public Assignment getParAssignment_1() { return cParAssignment_1; }

		//ID
		public RuleCall getParIDTerminalRuleCall_1_0() { return cParIDTerminalRuleCall_1_0; }

		//(COMMA par2+=ID)*
		public Group getGroup_2() { return cGroup_2; }

		//COMMA
		public RuleCall getCOMMATerminalRuleCall_2_0() { return cCOMMATerminalRuleCall_2_0; }

		//par2+=ID
		public Assignment getPar2Assignment_2_1() { return cPar2Assignment_2_1; }

		//ID
		public RuleCall getPar2IDTerminalRuleCall_2_1_0() { return cPar2IDTerminalRuleCall_2_1_0; }

		//RPAREN
		public RuleCall getRPARENTerminalRuleCall_3() { return cRPARENTerminalRuleCall_3; }
	}

	public class TypeArgumentsElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "TypeArguments");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cTAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final RuleCall cTTypeLiteralParserRuleCall_0_0 = (RuleCall)cTAssignment_0.eContents().get(0);
		private final Assignment cT2Assignment_1 = (Assignment)cAlternatives.eContents().get(1);
		private final RuleCall cT2PERCENTTerminalRuleCall_1_0 = (RuleCall)cT2Assignment_1.eContents().get(0);
		private final Assignment cT3Assignment_2 = (Assignment)cAlternatives.eContents().get(2);
		private final Keyword cT3TypeKeyword_2_0 = (Keyword)cT3Assignment_2.eContents().get(0);
		private final Group cGroup_3 = (Group)cAlternatives.eContents().get(3);
		private final Assignment cB1Assignment_3_0 = (Assignment)cGroup_3.eContents().get(0);
		private final RuleCall cB1LPARENTerminalRuleCall_3_0_0 = (RuleCall)cB1Assignment_3_0.eContents().get(0);
		private final Assignment cT4Assignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final RuleCall cT4TypeExpressionParserRuleCall_3_1_0 = (RuleCall)cT4Assignment_3_1.eContents().get(0);
		private final Group cGroup_3_2 = (Group)cGroup_3.eContents().get(2);
		private final RuleCall cCOMMATerminalRuleCall_3_2_0 = (RuleCall)cGroup_3_2.eContents().get(0);
		private final Assignment cT16Assignment_3_2_1 = (Assignment)cGroup_3_2.eContents().get(1);
		private final RuleCall cT16TypeExpressionParserRuleCall_3_2_1_0 = (RuleCall)cT16Assignment_3_2_1.eContents().get(0);
		private final RuleCall cRPARENTerminalRuleCall_3_3 = (RuleCall)cGroup_3.eContents().get(3);
		private final Group cGroup_4 = (Group)cAlternatives.eContents().get(4);
		private final Assignment cT5Assignment_4_0 = (Assignment)cGroup_4.eContents().get(0);
		private final Keyword cT5RecordKeyword_4_0_0 = (Keyword)cT5Assignment_4_0.eContents().get(0);
		private final RuleCall cLPARENTerminalRuleCall_4_1 = (RuleCall)cGroup_4.eContents().get(1);
		private final Assignment cT6Assignment_4_2 = (Assignment)cGroup_4.eContents().get(2);
		private final RuleCall cT6TypeExpressionParserRuleCall_4_2_0 = (RuleCall)cT6Assignment_4_2.eContents().get(0);
		private final Group cGroup_4_3 = (Group)cGroup_4.eContents().get(3);
		private final RuleCall cCOLONTerminalRuleCall_4_3_0 = (RuleCall)cGroup_4_3.eContents().get(0);
		private final Assignment cT22Assignment_4_3_1 = (Assignment)cGroup_4_3.eContents().get(1);
		private final RuleCall cT22TypeExpressionParserRuleCall_4_3_1_0 = (RuleCall)cT22Assignment_4_3_1.eContents().get(0);
		private final Group cGroup_4_4 = (Group)cGroup_4.eContents().get(4);
		private final RuleCall cCOMMATerminalRuleCall_4_4_0 = (RuleCall)cGroup_4_4.eContents().get(0);
		private final Assignment cT21Assignment_4_4_1 = (Assignment)cGroup_4_4.eContents().get(1);
		private final RuleCall cT21TypeExpressionParserRuleCall_4_4_1_0 = (RuleCall)cT21Assignment_4_4_1.eContents().get(0);
		private final Group cGroup_4_4_2 = (Group)cGroup_4_4.eContents().get(2);
		private final RuleCall cCOLONTerminalRuleCall_4_4_2_0 = (RuleCall)cGroup_4_4_2.eContents().get(0);
		private final Assignment cT23Assignment_4_4_2_1 = (Assignment)cGroup_4_4_2.eContents().get(1);
		private final RuleCall cT23TypeExpressionParserRuleCall_4_4_2_1_0 = (RuleCall)cT23Assignment_4_4_2_1.eContents().get(0);
		private final RuleCall cRPARENTerminalRuleCall_4_5 = (RuleCall)cGroup_4.eContents().get(5);
		private final Group cGroup_5 = (Group)cAlternatives.eContents().get(5);
		private final Assignment cT9Assignment_5_0 = (Assignment)cGroup_5.eContents().get(0);
		private final Keyword cT9UnionKeyword_5_0_0 = (Keyword)cT9Assignment_5_0.eContents().get(0);
		private final RuleCall cLPARENTerminalRuleCall_5_1 = (RuleCall)cGroup_5.eContents().get(1);
		private final Assignment cT10Assignment_5_2 = (Assignment)cGroup_5.eContents().get(2);
		private final RuleCall cT10TypeExpressionParserRuleCall_5_2_0 = (RuleCall)cT10Assignment_5_2.eContents().get(0);
		private final Group cGroup_5_3 = (Group)cGroup_5.eContents().get(3);
		private final RuleCall cCOLONTerminalRuleCall_5_3_0 = (RuleCall)cGroup_5_3.eContents().get(0);
		private final Assignment cT25Assignment_5_3_1 = (Assignment)cGroup_5_3.eContents().get(1);
		private final RuleCall cT25TypeExpressionParserRuleCall_5_3_1_0 = (RuleCall)cT25Assignment_5_3_1.eContents().get(0);
		private final Group cGroup_5_4 = (Group)cGroup_5.eContents().get(4);
		private final RuleCall cCOMMATerminalRuleCall_5_4_0 = (RuleCall)cGroup_5_4.eContents().get(0);
		private final Assignment cT24Assignment_5_4_1 = (Assignment)cGroup_5_4.eContents().get(1);
		private final RuleCall cT24TypeExpressionParserRuleCall_5_4_1_0 = (RuleCall)cT24Assignment_5_4_1.eContents().get(0);
		private final Group cGroup_5_4_2 = (Group)cGroup_5_4.eContents().get(2);
		private final RuleCall cCOLONTerminalRuleCall_5_4_2_0 = (RuleCall)cGroup_5_4_2.eContents().get(0);
		private final Assignment cT26Assignment_5_4_2_1 = (Assignment)cGroup_5_4_2.eContents().get(1);
		private final RuleCall cT26TypeExpressionParserRuleCall_5_4_2_1_0 = (RuleCall)cT26Assignment_5_4_2_1.eContents().get(0);
		private final RuleCall cRPARENTerminalRuleCall_5_5 = (RuleCall)cGroup_5.eContents().get(5);
		private final Group cGroup_6 = (Group)cAlternatives.eContents().get(6);
		private final Assignment cT11Assignment_6_0 = (Assignment)cGroup_6.eContents().get(0);
		private final Keyword cT11JoinKeyword_6_0_0 = (Keyword)cT11Assignment_6_0.eContents().get(0);
		private final RuleCall cLPARENTerminalRuleCall_6_1 = (RuleCall)cGroup_6.eContents().get(1);
		private final Assignment cT12Assignment_6_2 = (Assignment)cGroup_6.eContents().get(2);
		private final RuleCall cT12TypeExpressionParserRuleCall_6_2_0 = (RuleCall)cT12Assignment_6_2.eContents().get(0);
		private final Group cGroup_6_3 = (Group)cGroup_6.eContents().get(3);
		private final RuleCall cCOMMATerminalRuleCall_6_3_0 = (RuleCall)cGroup_6_3.eContents().get(0);
		private final Assignment cT13Assignment_6_3_1 = (Assignment)cGroup_6_3.eContents().get(1);
		private final RuleCall cT13TypeExpressionParserRuleCall_6_3_1_0 = (RuleCall)cT13Assignment_6_3_1.eContents().get(0);
		private final RuleCall cRPARENTerminalRuleCall_6_4 = (RuleCall)cGroup_6.eContents().get(4);
		private final Assignment cT15Assignment_7 = (Assignment)cAlternatives.eContents().get(7);
		private final RuleCall cT15TypeNameOrFunctionCallParserRuleCall_7_0 = (RuleCall)cT15Assignment_7.eContents().get(0);
		
		/// *
		// * we use type arguments for first part of function type, that is
		// * x in x-> y
		// * usually this is enclosed in parenthesis
		// * (x) in (x)-> y
		// * but if x is a single argument (Including Record, Union, etc.) then it does
		// * not need to be in parenthesis.
		// * / TypeArguments hidden(WS):
		//	t=TypeLiteral | t2=PERCENT | t3="Type" | // usually, but not always type arguments are in parenthesis, and empty
		//	// parenthesis are allowed
		//	b1?=LPAREN t4=TypeExpression? (COMMA t16+=TypeExpression)* RPAREN | t5="Record" LPAREN t6=TypeExpression (COLON
		//	t22+=TypeExpression)? (COMMA t21+=TypeExpression (COLON t23+=TypeExpression)?)* RPAREN | t9="Union" LPAREN
		//	t10=TypeExpression (COLON t25+=TypeExpression)? (COMMA t24+=TypeExpression (COLON t26+=TypeExpression)?)* RPAREN |
		//	t11="Join" LPAREN t12=TypeExpression (COMMA t13+=TypeExpression)* RPAREN | t15=TypeNameOrFunctionCall;
		public ParserRule getRule() { return rule; }

		//t=TypeLiteral | t2=PERCENT | t3="Type" | // usually, but not always type arguments are in parenthesis, and empty
		//// parenthesis are allowed
		//b1?=LPAREN t4=TypeExpression? (COMMA t16+=TypeExpression)* RPAREN | t5="Record" LPAREN t6=TypeExpression (COLON
		//t22+=TypeExpression)? (COMMA t21+=TypeExpression (COLON t23+=TypeExpression)?)* RPAREN | t9="Union" LPAREN
		//t10=TypeExpression (COLON t25+=TypeExpression)? (COMMA t24+=TypeExpression (COLON t26+=TypeExpression)?)* RPAREN |
		//t11="Join" LPAREN t12=TypeExpression (COMMA t13+=TypeExpression)* RPAREN | t15=TypeNameOrFunctionCall
		public Alternatives getAlternatives() { return cAlternatives; }

		//t=TypeLiteral
		public Assignment getTAssignment_0() { return cTAssignment_0; }

		//TypeLiteral
		public RuleCall getTTypeLiteralParserRuleCall_0_0() { return cTTypeLiteralParserRuleCall_0_0; }

		//t2=PERCENT
		public Assignment getT2Assignment_1() { return cT2Assignment_1; }

		//PERCENT
		public RuleCall getT2PERCENTTerminalRuleCall_1_0() { return cT2PERCENTTerminalRuleCall_1_0; }

		//t3="Type"
		public Assignment getT3Assignment_2() { return cT3Assignment_2; }

		//"Type"
		public Keyword getT3TypeKeyword_2_0() { return cT3TypeKeyword_2_0; }

		//// usually, but not always type arguments are in parenthesis, and empty
		//// parenthesis are allowed
		//b1?=LPAREN t4=TypeExpression? (COMMA t16+=TypeExpression)* RPAREN
		public Group getGroup_3() { return cGroup_3; }

		//// usually, but not always type arguments are in parenthesis, and empty
		//// parenthesis are allowed
		//b1?=LPAREN
		public Assignment getB1Assignment_3_0() { return cB1Assignment_3_0; }

		//LPAREN
		public RuleCall getB1LPARENTerminalRuleCall_3_0_0() { return cB1LPARENTerminalRuleCall_3_0_0; }

		//t4=TypeExpression?
		public Assignment getT4Assignment_3_1() { return cT4Assignment_3_1; }

		//TypeExpression
		public RuleCall getT4TypeExpressionParserRuleCall_3_1_0() { return cT4TypeExpressionParserRuleCall_3_1_0; }

		//(COMMA t16+=TypeExpression)*
		public Group getGroup_3_2() { return cGroup_3_2; }

		//COMMA
		public RuleCall getCOMMATerminalRuleCall_3_2_0() { return cCOMMATerminalRuleCall_3_2_0; }

		//t16+=TypeExpression
		public Assignment getT16Assignment_3_2_1() { return cT16Assignment_3_2_1; }

		//TypeExpression
		public RuleCall getT16TypeExpressionParserRuleCall_3_2_1_0() { return cT16TypeExpressionParserRuleCall_3_2_1_0; }

		//RPAREN
		public RuleCall getRPARENTerminalRuleCall_3_3() { return cRPARENTerminalRuleCall_3_3; }

		//t5="Record" LPAREN t6=TypeExpression (COLON t22+=TypeExpression)? (COMMA t21+=TypeExpression (COLON
		//t23+=TypeExpression)?)* RPAREN
		public Group getGroup_4() { return cGroup_4; }

		//t5="Record"
		public Assignment getT5Assignment_4_0() { return cT5Assignment_4_0; }

		//"Record"
		public Keyword getT5RecordKeyword_4_0_0() { return cT5RecordKeyword_4_0_0; }

		//LPAREN
		public RuleCall getLPARENTerminalRuleCall_4_1() { return cLPARENTerminalRuleCall_4_1; }

		//t6=TypeExpression
		public Assignment getT6Assignment_4_2() { return cT6Assignment_4_2; }

		//TypeExpression
		public RuleCall getT6TypeExpressionParserRuleCall_4_2_0() { return cT6TypeExpressionParserRuleCall_4_2_0; }

		//(COLON t22+=TypeExpression)?
		public Group getGroup_4_3() { return cGroup_4_3; }

		//COLON
		public RuleCall getCOLONTerminalRuleCall_4_3_0() { return cCOLONTerminalRuleCall_4_3_0; }

		//t22+=TypeExpression
		public Assignment getT22Assignment_4_3_1() { return cT22Assignment_4_3_1; }

		//TypeExpression
		public RuleCall getT22TypeExpressionParserRuleCall_4_3_1_0() { return cT22TypeExpressionParserRuleCall_4_3_1_0; }

		//(COMMA t21+=TypeExpression (COLON t23+=TypeExpression)?)*
		public Group getGroup_4_4() { return cGroup_4_4; }

		//COMMA
		public RuleCall getCOMMATerminalRuleCall_4_4_0() { return cCOMMATerminalRuleCall_4_4_0; }

		//t21+=TypeExpression
		public Assignment getT21Assignment_4_4_1() { return cT21Assignment_4_4_1; }

		//TypeExpression
		public RuleCall getT21TypeExpressionParserRuleCall_4_4_1_0() { return cT21TypeExpressionParserRuleCall_4_4_1_0; }

		//(COLON t23+=TypeExpression)?
		public Group getGroup_4_4_2() { return cGroup_4_4_2; }

		//COLON
		public RuleCall getCOLONTerminalRuleCall_4_4_2_0() { return cCOLONTerminalRuleCall_4_4_2_0; }

		//t23+=TypeExpression
		public Assignment getT23Assignment_4_4_2_1() { return cT23Assignment_4_4_2_1; }

		//TypeExpression
		public RuleCall getT23TypeExpressionParserRuleCall_4_4_2_1_0() { return cT23TypeExpressionParserRuleCall_4_4_2_1_0; }

		//RPAREN
		public RuleCall getRPARENTerminalRuleCall_4_5() { return cRPARENTerminalRuleCall_4_5; }

		//t9="Union" LPAREN t10=TypeExpression (COLON t25+=TypeExpression)? (COMMA t24+=TypeExpression (COLON
		//t26+=TypeExpression)?)* RPAREN
		public Group getGroup_5() { return cGroup_5; }

		//t9="Union"
		public Assignment getT9Assignment_5_0() { return cT9Assignment_5_0; }

		//"Union"
		public Keyword getT9UnionKeyword_5_0_0() { return cT9UnionKeyword_5_0_0; }

		//LPAREN
		public RuleCall getLPARENTerminalRuleCall_5_1() { return cLPARENTerminalRuleCall_5_1; }

		//t10=TypeExpression
		public Assignment getT10Assignment_5_2() { return cT10Assignment_5_2; }

		//TypeExpression
		public RuleCall getT10TypeExpressionParserRuleCall_5_2_0() { return cT10TypeExpressionParserRuleCall_5_2_0; }

		//(COLON t25+=TypeExpression)?
		public Group getGroup_5_3() { return cGroup_5_3; }

		//COLON
		public RuleCall getCOLONTerminalRuleCall_5_3_0() { return cCOLONTerminalRuleCall_5_3_0; }

		//t25+=TypeExpression
		public Assignment getT25Assignment_5_3_1() { return cT25Assignment_5_3_1; }

		//TypeExpression
		public RuleCall getT25TypeExpressionParserRuleCall_5_3_1_0() { return cT25TypeExpressionParserRuleCall_5_3_1_0; }

		//(COMMA t24+=TypeExpression (COLON t26+=TypeExpression)?)*
		public Group getGroup_5_4() { return cGroup_5_4; }

		//COMMA
		public RuleCall getCOMMATerminalRuleCall_5_4_0() { return cCOMMATerminalRuleCall_5_4_0; }

		//t24+=TypeExpression
		public Assignment getT24Assignment_5_4_1() { return cT24Assignment_5_4_1; }

		//TypeExpression
		public RuleCall getT24TypeExpressionParserRuleCall_5_4_1_0() { return cT24TypeExpressionParserRuleCall_5_4_1_0; }

		//(COLON t26+=TypeExpression)?
		public Group getGroup_5_4_2() { return cGroup_5_4_2; }

		//COLON
		public RuleCall getCOLONTerminalRuleCall_5_4_2_0() { return cCOLONTerminalRuleCall_5_4_2_0; }

		//t26+=TypeExpression
		public Assignment getT26Assignment_5_4_2_1() { return cT26Assignment_5_4_2_1; }

		//TypeExpression
		public RuleCall getT26TypeExpressionParserRuleCall_5_4_2_1_0() { return cT26TypeExpressionParserRuleCall_5_4_2_1_0; }

		//RPAREN
		public RuleCall getRPARENTerminalRuleCall_5_5() { return cRPARENTerminalRuleCall_5_5; }

		//t11="Join" LPAREN t12=TypeExpression (COMMA t13+=TypeExpression)* RPAREN
		public Group getGroup_6() { return cGroup_6; }

		//t11="Join"
		public Assignment getT11Assignment_6_0() { return cT11Assignment_6_0; }

		//"Join"
		public Keyword getT11JoinKeyword_6_0_0() { return cT11JoinKeyword_6_0_0; }

		//LPAREN
		public RuleCall getLPARENTerminalRuleCall_6_1() { return cLPARENTerminalRuleCall_6_1; }

		//t12=TypeExpression
		public Assignment getT12Assignment_6_2() { return cT12Assignment_6_2; }

		//TypeExpression
		public RuleCall getT12TypeExpressionParserRuleCall_6_2_0() { return cT12TypeExpressionParserRuleCall_6_2_0; }

		//(COMMA t13+=TypeExpression)*
		public Group getGroup_6_3() { return cGroup_6_3; }

		//COMMA
		public RuleCall getCOMMATerminalRuleCall_6_3_0() { return cCOMMATerminalRuleCall_6_3_0; }

		//t13+=TypeExpression
		public Assignment getT13Assignment_6_3_1() { return cT13Assignment_6_3_1; }

		//TypeExpression
		public RuleCall getT13TypeExpressionParserRuleCall_6_3_1_0() { return cT13TypeExpressionParserRuleCall_6_3_1_0; }

		//RPAREN
		public RuleCall getRPARENTerminalRuleCall_6_4() { return cRPARENTerminalRuleCall_6_4; }

		//t15=TypeNameOrFunctionCall
		public Assignment getT15Assignment_7() { return cT15Assignment_7; }

		//TypeNameOrFunctionCall
		public RuleCall getT15TypeNameOrFunctionCallParserRuleCall_7_0() { return cT15TypeNameOrFunctionCallParserRuleCall_7_0; }
	}

	public class TypeResultElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "TypeResult");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cTAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final RuleCall cTTypeLiteralParserRuleCall_0_0 = (RuleCall)cTAssignment_0.eContents().get(0);
		private final Assignment cT2Assignment_1 = (Assignment)cAlternatives.eContents().get(1);
		private final RuleCall cT2PERCENTTerminalRuleCall_1_0 = (RuleCall)cT2Assignment_1.eContents().get(0);
		private final Assignment cTynameAssignment_2 = (Assignment)cAlternatives.eContents().get(2);
		private final Keyword cTynameTypeKeyword_2_0 = (Keyword)cTynameAssignment_2.eContents().get(0);
		private final Group cGroup_3 = (Group)cAlternatives.eContents().get(3);
		private final Assignment cNameAssignment_3_0 = (Assignment)cGroup_3.eContents().get(0);
		private final Keyword cNameRecordKeyword_3_0_0 = (Keyword)cNameAssignment_3_0.eContents().get(0);
		private final RuleCall cLPARENTerminalRuleCall_3_1 = (RuleCall)cGroup_3.eContents().get(1);
		private final Assignment cT7Assignment_3_2 = (Assignment)cGroup_3.eContents().get(2);
		private final RuleCall cT7TypeExpressionParserRuleCall_3_2_0 = (RuleCall)cT7Assignment_3_2.eContents().get(0);
		private final Group cGroup_3_3 = (Group)cGroup_3.eContents().get(3);
		private final RuleCall cCOLONTerminalRuleCall_3_3_0 = (RuleCall)cGroup_3_3.eContents().get(0);
		private final Assignment cT8Assignment_3_3_1 = (Assignment)cGroup_3_3.eContents().get(1);
		private final RuleCall cT8TypeExpressionParserRuleCall_3_3_1_0 = (RuleCall)cT8Assignment_3_3_1.eContents().get(0);
		private final Group cGroup_3_4 = (Group)cGroup_3.eContents().get(4);
		private final RuleCall cCOMMATerminalRuleCall_3_4_0 = (RuleCall)cGroup_3_4.eContents().get(0);
		private final Assignment cT21Assignment_3_4_1 = (Assignment)cGroup_3_4.eContents().get(1);
		private final RuleCall cT21TypeExpressionParserRuleCall_3_4_1_0 = (RuleCall)cT21Assignment_3_4_1.eContents().get(0);
		private final Group cGroup_3_4_2 = (Group)cGroup_3_4.eContents().get(2);
		private final RuleCall cCOLONTerminalRuleCall_3_4_2_0 = (RuleCall)cGroup_3_4_2.eContents().get(0);
		private final Assignment cT23Assignment_3_4_2_1 = (Assignment)cGroup_3_4_2.eContents().get(1);
		private final RuleCall cT23TypeExpressionParserRuleCall_3_4_2_1_0 = (RuleCall)cT23Assignment_3_4_2_1.eContents().get(0);
		private final RuleCall cRPARENTerminalRuleCall_3_5 = (RuleCall)cGroup_3.eContents().get(5);
		private final Group cGroup_4 = (Group)cAlternatives.eContents().get(4);
		private final Assignment cNameAssignment_4_0 = (Assignment)cGroup_4.eContents().get(0);
		private final Keyword cNameUnionKeyword_4_0_0 = (Keyword)cNameAssignment_4_0.eContents().get(0);
		private final RuleCall cLPARENTerminalRuleCall_4_1 = (RuleCall)cGroup_4.eContents().get(1);
		private final Assignment cT10Assignment_4_2 = (Assignment)cGroup_4.eContents().get(2);
		private final RuleCall cT10TypeExpressionParserRuleCall_4_2_0 = (RuleCall)cT10Assignment_4_2.eContents().get(0);
		private final Group cGroup_4_3 = (Group)cGroup_4.eContents().get(3);
		private final RuleCall cCOLONTerminalRuleCall_4_3_0 = (RuleCall)cGroup_4_3.eContents().get(0);
		private final Assignment cT11Assignment_4_3_1 = (Assignment)cGroup_4_3.eContents().get(1);
		private final RuleCall cT11TypeExpressionParserRuleCall_4_3_1_0 = (RuleCall)cT11Assignment_4_3_1.eContents().get(0);
		private final Group cGroup_4_4 = (Group)cGroup_4.eContents().get(4);
		private final RuleCall cCOMMATerminalRuleCall_4_4_0 = (RuleCall)cGroup_4_4.eContents().get(0);
		private final Assignment cT24Assignment_4_4_1 = (Assignment)cGroup_4_4.eContents().get(1);
		private final RuleCall cT24TypeExpressionParserRuleCall_4_4_1_0 = (RuleCall)cT24Assignment_4_4_1.eContents().get(0);
		private final Group cGroup_4_4_2 = (Group)cGroup_4_4.eContents().get(2);
		private final RuleCall cCOLONTerminalRuleCall_4_4_2_0 = (RuleCall)cGroup_4_4_2.eContents().get(0);
		private final Assignment cT26Assignment_4_4_2_1 = (Assignment)cGroup_4_4_2.eContents().get(1);
		private final RuleCall cT26TypeExpressionParserRuleCall_4_4_2_1_0 = (RuleCall)cT26Assignment_4_4_2_1.eContents().get(0);
		private final RuleCall cRPARENTerminalRuleCall_4_5 = (RuleCall)cGroup_4.eContents().get(5);
		private final Group cGroup_5 = (Group)cAlternatives.eContents().get(5);
		private final Assignment cNameAssignment_5_0 = (Assignment)cGroup_5.eContents().get(0);
		private final Keyword cNameJoinKeyword_5_0_0 = (Keyword)cNameAssignment_5_0.eContents().get(0);
		private final RuleCall cLPARENTerminalRuleCall_5_1 = (RuleCall)cGroup_5.eContents().get(1);
		private final Assignment cT12Assignment_5_2 = (Assignment)cGroup_5.eContents().get(2);
		private final RuleCall cT12TypeExpressionParserRuleCall_5_2_0 = (RuleCall)cT12Assignment_5_2.eContents().get(0);
		private final Group cGroup_5_3 = (Group)cGroup_5.eContents().get(3);
		private final RuleCall cCOMMATerminalRuleCall_5_3_0 = (RuleCall)cGroup_5_3.eContents().get(0);
		private final Assignment cT13Assignment_5_3_1 = (Assignment)cGroup_5_3.eContents().get(1);
		private final RuleCall cT13TypeExpressionParserRuleCall_5_3_1_0 = (RuleCall)cT13Assignment_5_3_1.eContents().get(0);
		private final RuleCall cRPARENTerminalRuleCall_5_4 = (RuleCall)cGroup_5.eContents().get(4);
		private final Assignment cT15Assignment_6 = (Assignment)cAlternatives.eContents().get(6);
		private final RuleCall cT15TypeNameOrFunctionCallParserRuleCall_6_0 = (RuleCall)cT15Assignment_6.eContents().get(0);
		
		/// *
		// * we use type arguments for final part of function type, that is
		// * y in x-> y
		// * / TypeResult hidden(WS):
		//	t=TypeLiteral | t2=PERCENT | tyname="Type" | // | LPAREN t4=TypePrimaryExpression ( COMMA t16 += TypePrimaryExpression)* RPAREN
		//	name="Record" LPAREN t7=TypeExpression (COLON t8+=TypeExpression)? (COMMA t21+=TypeExpression (COLON
		//	t23+=TypeExpression)?)* RPAREN | name="Union" LPAREN t10=TypeExpression (COLON t11+=TypeExpression)? (COMMA
		//	t24+=TypeExpression (COLON t26+=TypeExpression)?)* RPAREN | name="Join" LPAREN t12=TypeExpression (COMMA
		//	t13+=TypeExpression)* RPAREN | t15=TypeNameOrFunctionCall;
		public ParserRule getRule() { return rule; }

		//t=TypeLiteral | t2=PERCENT | tyname="Type" | // | LPAREN t4=TypePrimaryExpression ( COMMA t16 += TypePrimaryExpression)* RPAREN
		//name="Record" LPAREN t7=TypeExpression (COLON t8+=TypeExpression)? (COMMA t21+=TypeExpression (COLON
		//t23+=TypeExpression)?)* RPAREN | name="Union" LPAREN t10=TypeExpression (COLON t11+=TypeExpression)? (COMMA
		//t24+=TypeExpression (COLON t26+=TypeExpression)?)* RPAREN | name="Join" LPAREN t12=TypeExpression (COMMA
		//t13+=TypeExpression)* RPAREN | t15=TypeNameOrFunctionCall
		public Alternatives getAlternatives() { return cAlternatives; }

		//t=TypeLiteral
		public Assignment getTAssignment_0() { return cTAssignment_0; }

		//TypeLiteral
		public RuleCall getTTypeLiteralParserRuleCall_0_0() { return cTTypeLiteralParserRuleCall_0_0; }

		//t2=PERCENT
		public Assignment getT2Assignment_1() { return cT2Assignment_1; }

		//PERCENT
		public RuleCall getT2PERCENTTerminalRuleCall_1_0() { return cT2PERCENTTerminalRuleCall_1_0; }

		//tyname="Type"
		public Assignment getTynameAssignment_2() { return cTynameAssignment_2; }

		//"Type"
		public Keyword getTynameTypeKeyword_2_0() { return cTynameTypeKeyword_2_0; }

		//// | LPAREN t4=TypePrimaryExpression ( COMMA t16 += TypePrimaryExpression)* RPAREN
		//name="Record" LPAREN t7=TypeExpression (COLON t8+=TypeExpression)? (COMMA t21+=TypeExpression (COLON
		//t23+=TypeExpression)?)* RPAREN
		public Group getGroup_3() { return cGroup_3; }

		//// | LPAREN t4=TypePrimaryExpression ( COMMA t16 += TypePrimaryExpression)* RPAREN
		//name="Record"
		public Assignment getNameAssignment_3_0() { return cNameAssignment_3_0; }

		//"Record"
		public Keyword getNameRecordKeyword_3_0_0() { return cNameRecordKeyword_3_0_0; }

		//LPAREN
		public RuleCall getLPARENTerminalRuleCall_3_1() { return cLPARENTerminalRuleCall_3_1; }

		//t7=TypeExpression
		public Assignment getT7Assignment_3_2() { return cT7Assignment_3_2; }

		//TypeExpression
		public RuleCall getT7TypeExpressionParserRuleCall_3_2_0() { return cT7TypeExpressionParserRuleCall_3_2_0; }

		//(COLON t8+=TypeExpression)?
		public Group getGroup_3_3() { return cGroup_3_3; }

		//COLON
		public RuleCall getCOLONTerminalRuleCall_3_3_0() { return cCOLONTerminalRuleCall_3_3_0; }

		//t8+=TypeExpression
		public Assignment getT8Assignment_3_3_1() { return cT8Assignment_3_3_1; }

		//TypeExpression
		public RuleCall getT8TypeExpressionParserRuleCall_3_3_1_0() { return cT8TypeExpressionParserRuleCall_3_3_1_0; }

		//(COMMA t21+=TypeExpression (COLON t23+=TypeExpression)?)*
		public Group getGroup_3_4() { return cGroup_3_4; }

		//COMMA
		public RuleCall getCOMMATerminalRuleCall_3_4_0() { return cCOMMATerminalRuleCall_3_4_0; }

		//t21+=TypeExpression
		public Assignment getT21Assignment_3_4_1() { return cT21Assignment_3_4_1; }

		//TypeExpression
		public RuleCall getT21TypeExpressionParserRuleCall_3_4_1_0() { return cT21TypeExpressionParserRuleCall_3_4_1_0; }

		//(COLON t23+=TypeExpression)?
		public Group getGroup_3_4_2() { return cGroup_3_4_2; }

		//COLON
		public RuleCall getCOLONTerminalRuleCall_3_4_2_0() { return cCOLONTerminalRuleCall_3_4_2_0; }

		//t23+=TypeExpression
		public Assignment getT23Assignment_3_4_2_1() { return cT23Assignment_3_4_2_1; }

		//TypeExpression
		public RuleCall getT23TypeExpressionParserRuleCall_3_4_2_1_0() { return cT23TypeExpressionParserRuleCall_3_4_2_1_0; }

		//RPAREN
		public RuleCall getRPARENTerminalRuleCall_3_5() { return cRPARENTerminalRuleCall_3_5; }

		//name="Union" LPAREN t10=TypeExpression (COLON t11+=TypeExpression)? (COMMA t24+=TypeExpression (COLON
		//t26+=TypeExpression)?)* RPAREN
		public Group getGroup_4() { return cGroup_4; }

		//name="Union"
		public Assignment getNameAssignment_4_0() { return cNameAssignment_4_0; }

		//"Union"
		public Keyword getNameUnionKeyword_4_0_0() { return cNameUnionKeyword_4_0_0; }

		//LPAREN
		public RuleCall getLPARENTerminalRuleCall_4_1() { return cLPARENTerminalRuleCall_4_1; }

		//t10=TypeExpression
		public Assignment getT10Assignment_4_2() { return cT10Assignment_4_2; }

		//TypeExpression
		public RuleCall getT10TypeExpressionParserRuleCall_4_2_0() { return cT10TypeExpressionParserRuleCall_4_2_0; }

		//(COLON t11+=TypeExpression)?
		public Group getGroup_4_3() { return cGroup_4_3; }

		//COLON
		public RuleCall getCOLONTerminalRuleCall_4_3_0() { return cCOLONTerminalRuleCall_4_3_0; }

		//t11+=TypeExpression
		public Assignment getT11Assignment_4_3_1() { return cT11Assignment_4_3_1; }

		//TypeExpression
		public RuleCall getT11TypeExpressionParserRuleCall_4_3_1_0() { return cT11TypeExpressionParserRuleCall_4_3_1_0; }

		//(COMMA t24+=TypeExpression (COLON t26+=TypeExpression)?)*
		public Group getGroup_4_4() { return cGroup_4_4; }

		//COMMA
		public RuleCall getCOMMATerminalRuleCall_4_4_0() { return cCOMMATerminalRuleCall_4_4_0; }

		//t24+=TypeExpression
		public Assignment getT24Assignment_4_4_1() { return cT24Assignment_4_4_1; }

		//TypeExpression
		public RuleCall getT24TypeExpressionParserRuleCall_4_4_1_0() { return cT24TypeExpressionParserRuleCall_4_4_1_0; }

		//(COLON t26+=TypeExpression)?
		public Group getGroup_4_4_2() { return cGroup_4_4_2; }

		//COLON
		public RuleCall getCOLONTerminalRuleCall_4_4_2_0() { return cCOLONTerminalRuleCall_4_4_2_0; }

		//t26+=TypeExpression
		public Assignment getT26Assignment_4_4_2_1() { return cT26Assignment_4_4_2_1; }

		//TypeExpression
		public RuleCall getT26TypeExpressionParserRuleCall_4_4_2_1_0() { return cT26TypeExpressionParserRuleCall_4_4_2_1_0; }

		//RPAREN
		public RuleCall getRPARENTerminalRuleCall_4_5() { return cRPARENTerminalRuleCall_4_5; }

		//name="Join" LPAREN t12=TypeExpression (COMMA t13+=TypeExpression)* RPAREN
		public Group getGroup_5() { return cGroup_5; }

		//name="Join"
		public Assignment getNameAssignment_5_0() { return cNameAssignment_5_0; }

		//"Join"
		public Keyword getNameJoinKeyword_5_0_0() { return cNameJoinKeyword_5_0_0; }

		//LPAREN
		public RuleCall getLPARENTerminalRuleCall_5_1() { return cLPARENTerminalRuleCall_5_1; }

		//t12=TypeExpression
		public Assignment getT12Assignment_5_2() { return cT12Assignment_5_2; }

		//TypeExpression
		public RuleCall getT12TypeExpressionParserRuleCall_5_2_0() { return cT12TypeExpressionParserRuleCall_5_2_0; }

		//(COMMA t13+=TypeExpression)*
		public Group getGroup_5_3() { return cGroup_5_3; }

		//COMMA
		public RuleCall getCOMMATerminalRuleCall_5_3_0() { return cCOMMATerminalRuleCall_5_3_0; }

		//t13+=TypeExpression
		public Assignment getT13Assignment_5_3_1() { return cT13Assignment_5_3_1; }

		//TypeExpression
		public RuleCall getT13TypeExpressionParserRuleCall_5_3_1_0() { return cT13TypeExpressionParserRuleCall_5_3_1_0; }

		//RPAREN
		public RuleCall getRPARENTerminalRuleCall_5_4() { return cRPARENTerminalRuleCall_5_4; }

		//t15=TypeNameOrFunctionCall
		public Assignment getT15Assignment_6() { return cT15Assignment_6; }

		//TypeNameOrFunctionCall
		public RuleCall getT15TypeNameOrFunctionCallParserRuleCall_6_0() { return cT15TypeNameOrFunctionCallParserRuleCall_6_0; }
	}

	public class TypePrimaryExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "TypePrimaryExpression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cTypeLiteralParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Action cTypePrimaryExpressionAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cT32Assignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cT32PERCENTTerminalRuleCall_1_1_0 = (RuleCall)cT32Assignment_1_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cAlternatives.eContents().get(2);
		private final Action cTypePrimaryExpressionAction_2_0 = (Action)cGroup_2.eContents().get(0);
		private final Assignment cTynameAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final Keyword cTynameTypeKeyword_2_1_0 = (Keyword)cTynameAssignment_2_1.eContents().get(0);
		private final Group cGroup_3 = (Group)cAlternatives.eContents().get(3);
		private final Action cTypePrimaryExpressionAction_3_0 = (Action)cGroup_3.eContents().get(0);
		private final Assignment cTynameAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final Keyword cTynameLispKeyword_3_1_0 = (Keyword)cTynameAssignment_3_1.eContents().get(0);
		private final Group cGroup_4 = (Group)cAlternatives.eContents().get(4);
		private final Action cTypePrimaryExpressionAction_4_0 = (Action)cGroup_4.eContents().get(0);
		private final RuleCall cLPARENTerminalRuleCall_4_1 = (RuleCall)cGroup_4.eContents().get(1);
		private final Assignment cT5Assignment_4_2 = (Assignment)cGroup_4.eContents().get(2);
		private final RuleCall cT5TypeExpressionParserRuleCall_4_2_0 = (RuleCall)cT5Assignment_4_2.eContents().get(0);
		private final RuleCall cRPARENTerminalRuleCall_4_3 = (RuleCall)cGroup_4.eContents().get(3);
		private final Group cGroup_5 = (Group)cAlternatives.eContents().get(5);
		private final Action cTypePrimaryExpressionAction_5_0 = (Action)cGroup_5.eContents().get(0);
		private final Assignment cTynameAssignment_5_1 = (Assignment)cGroup_5.eContents().get(1);
		private final Keyword cTynameRecordKeyword_5_1_0 = (Keyword)cTynameAssignment_5_1.eContents().get(0);
		private final RuleCall cLPARENTerminalRuleCall_5_2 = (RuleCall)cGroup_5.eContents().get(2);
		private final Assignment cT7Assignment_5_3 = (Assignment)cGroup_5.eContents().get(3);
		private final RuleCall cT7TypeExpressionParserRuleCall_5_3_0 = (RuleCall)cT7Assignment_5_3.eContents().get(0);
		private final Group cGroup_5_4 = (Group)cGroup_5.eContents().get(4);
		private final RuleCall cCOLONTerminalRuleCall_5_4_0 = (RuleCall)cGroup_5_4.eContents().get(0);
		private final Assignment cT8Assignment_5_4_1 = (Assignment)cGroup_5_4.eContents().get(1);
		private final RuleCall cT8TypeExpressionParserRuleCall_5_4_1_0 = (RuleCall)cT8Assignment_5_4_1.eContents().get(0);
		private final Group cGroup_5_5 = (Group)cGroup_5.eContents().get(5);
		private final RuleCall cCOMMATerminalRuleCall_5_5_0 = (RuleCall)cGroup_5_5.eContents().get(0);
		private final Assignment cT21Assignment_5_5_1 = (Assignment)cGroup_5_5.eContents().get(1);
		private final RuleCall cT21TypeExpressionParserRuleCall_5_5_1_0 = (RuleCall)cT21Assignment_5_5_1.eContents().get(0);
		private final Group cGroup_5_5_2 = (Group)cGroup_5_5.eContents().get(2);
		private final RuleCall cCOLONTerminalRuleCall_5_5_2_0 = (RuleCall)cGroup_5_5_2.eContents().get(0);
		private final Assignment cT23Assignment_5_5_2_1 = (Assignment)cGroup_5_5_2.eContents().get(1);
		private final RuleCall cT23TypeExpressionParserRuleCall_5_5_2_1_0 = (RuleCall)cT23Assignment_5_5_2_1.eContents().get(0);
		private final RuleCall cRPARENTerminalRuleCall_5_6 = (RuleCall)cGroup_5.eContents().get(6);
		private final Group cGroup_6 = (Group)cAlternatives.eContents().get(6);
		private final Action cTypePrimaryExpressionAction_6_0 = (Action)cGroup_6.eContents().get(0);
		private final Assignment cTynameAssignment_6_1 = (Assignment)cGroup_6.eContents().get(1);
		private final Keyword cTynameUnionKeyword_6_1_0 = (Keyword)cTynameAssignment_6_1.eContents().get(0);
		private final RuleCall cLPARENTerminalRuleCall_6_2 = (RuleCall)cGroup_6.eContents().get(2);
		private final Assignment cT10Assignment_6_3 = (Assignment)cGroup_6.eContents().get(3);
		private final RuleCall cT10TypeExpressionParserRuleCall_6_3_0 = (RuleCall)cT10Assignment_6_3.eContents().get(0);
		private final Group cGroup_6_4 = (Group)cGroup_6.eContents().get(4);
		private final RuleCall cCOLONTerminalRuleCall_6_4_0 = (RuleCall)cGroup_6_4.eContents().get(0);
		private final Assignment cT11Assignment_6_4_1 = (Assignment)cGroup_6_4.eContents().get(1);
		private final RuleCall cT11TypeExpressionParserRuleCall_6_4_1_0 = (RuleCall)cT11Assignment_6_4_1.eContents().get(0);
		private final Group cGroup_6_5 = (Group)cGroup_6.eContents().get(5);
		private final RuleCall cCOMMATerminalRuleCall_6_5_0 = (RuleCall)cGroup_6_5.eContents().get(0);
		private final Assignment cT24Assignment_6_5_1 = (Assignment)cGroup_6_5.eContents().get(1);
		private final RuleCall cT24TypeExpressionParserRuleCall_6_5_1_0 = (RuleCall)cT24Assignment_6_5_1.eContents().get(0);
		private final Group cGroup_6_5_2 = (Group)cGroup_6_5.eContents().get(2);
		private final RuleCall cCOLONTerminalRuleCall_6_5_2_0 = (RuleCall)cGroup_6_5_2.eContents().get(0);
		private final Assignment cT26Assignment_6_5_2_1 = (Assignment)cGroup_6_5_2.eContents().get(1);
		private final RuleCall cT26TypeExpressionParserRuleCall_6_5_2_1_0 = (RuleCall)cT26Assignment_6_5_2_1.eContents().get(0);
		private final RuleCall cRPARENTerminalRuleCall_6_6 = (RuleCall)cGroup_6.eContents().get(6);
		private final Group cGroup_7 = (Group)cAlternatives.eContents().get(7);
		private final Action cTypePrimaryExpressionAction_7_0 = (Action)cGroup_7.eContents().get(0);
		private final Assignment cTynameAssignment_7_1 = (Assignment)cGroup_7.eContents().get(1);
		private final Keyword cTynameJoinKeyword_7_1_0 = (Keyword)cTynameAssignment_7_1.eContents().get(0);
		private final RuleCall cLPARENTerminalRuleCall_7_2 = (RuleCall)cGroup_7.eContents().get(2);
		private final Assignment cT13Assignment_7_3 = (Assignment)cGroup_7.eContents().get(3);
		private final RuleCall cT13TypeExpressionParserRuleCall_7_3_0 = (RuleCall)cT13Assignment_7_3.eContents().get(0);
		private final Group cGroup_7_4 = (Group)cGroup_7.eContents().get(4);
		private final RuleCall cCOMMATerminalRuleCall_7_4_0 = (RuleCall)cGroup_7_4.eContents().get(0);
		private final Assignment cT14Assignment_7_4_1 = (Assignment)cGroup_7_4.eContents().get(1);
		private final RuleCall cT14TypeExpressionParserRuleCall_7_4_1_0 = (RuleCall)cT14Assignment_7_4_1.eContents().get(0);
		private final RuleCall cRPARENTerminalRuleCall_7_5 = (RuleCall)cGroup_7.eContents().get(5);
		private final RuleCall cTypeNameOrFunctionCallParserRuleCall_8 = (RuleCall)cAlternatives.eContents().get(8);
		private final RuleCall cTupleDefinitionParserRuleCall_9 = (RuleCall)cAlternatives.eContents().get(9);
		
		//TypePrimaryExpression hidden(WS):
		//	TypeLiteral // 'Type' is top of the category hierarchy
		//	// 'Lisp' is used for native lisp function calls such as Say$Lisp
		//	| {TypePrimaryExpression} t32=PERCENT | {TypePrimaryExpression} tyname="Type" | {TypePrimaryExpression} tyname="Lisp" |
		//	{TypePrimaryExpression} LPAREN t5=TypeExpression RPAREN | {TypePrimaryExpression} tyname="Record" LPAREN
		//	t7=TypeExpression (COLON t8+=TypeExpression)? (COMMA t21+=TypeExpression (COLON t23+=TypeExpression)?)* RPAREN |
		//	{TypePrimaryExpression} tyname="Union" LPAREN t10=TypeExpression (COLON t11+=TypeExpression)? (COMMA
		//	t24+=TypeExpression (COLON t26+=TypeExpression)?)* RPAREN | {TypePrimaryExpression} tyname="Join" LPAREN
		//	t13=TypeExpression (COMMA t14+=TypeExpression)* RPAREN | TypeNameOrFunctionCall | => TupleDefinition;
		public ParserRule getRule() { return rule; }

		//TypeLiteral // 'Type' is top of the category hierarchy
		//// 'Lisp' is used for native lisp function calls such as Say$Lisp
		//| {TypePrimaryExpression} t32=PERCENT | {TypePrimaryExpression} tyname="Type" | {TypePrimaryExpression} tyname="Lisp" |
		//{TypePrimaryExpression} LPAREN t5=TypeExpression RPAREN | {TypePrimaryExpression} tyname="Record" LPAREN
		//t7=TypeExpression (COLON t8+=TypeExpression)? (COMMA t21+=TypeExpression (COLON t23+=TypeExpression)?)* RPAREN |
		//{TypePrimaryExpression} tyname="Union" LPAREN t10=TypeExpression (COLON t11+=TypeExpression)? (COMMA
		//t24+=TypeExpression (COLON t26+=TypeExpression)?)* RPAREN | {TypePrimaryExpression} tyname="Join" LPAREN
		//t13=TypeExpression (COMMA t14+=TypeExpression)* RPAREN | TypeNameOrFunctionCall | => TupleDefinition
		public Alternatives getAlternatives() { return cAlternatives; }

		//TypeLiteral
		public RuleCall getTypeLiteralParserRuleCall_0() { return cTypeLiteralParserRuleCall_0; }

		//{TypePrimaryExpression} t32=PERCENT
		public Group getGroup_1() { return cGroup_1; }

		//{TypePrimaryExpression}
		public Action getTypePrimaryExpressionAction_1_0() { return cTypePrimaryExpressionAction_1_0; }

		//t32=PERCENT
		public Assignment getT32Assignment_1_1() { return cT32Assignment_1_1; }

		//PERCENT
		public RuleCall getT32PERCENTTerminalRuleCall_1_1_0() { return cT32PERCENTTerminalRuleCall_1_1_0; }

		//{TypePrimaryExpression} tyname="Type"
		public Group getGroup_2() { return cGroup_2; }

		//{TypePrimaryExpression}
		public Action getTypePrimaryExpressionAction_2_0() { return cTypePrimaryExpressionAction_2_0; }

		//tyname="Type"
		public Assignment getTynameAssignment_2_1() { return cTynameAssignment_2_1; }

		//"Type"
		public Keyword getTynameTypeKeyword_2_1_0() { return cTynameTypeKeyword_2_1_0; }

		//{TypePrimaryExpression} tyname="Lisp"
		public Group getGroup_3() { return cGroup_3; }

		//{TypePrimaryExpression}
		public Action getTypePrimaryExpressionAction_3_0() { return cTypePrimaryExpressionAction_3_0; }

		//tyname="Lisp"
		public Assignment getTynameAssignment_3_1() { return cTynameAssignment_3_1; }

		//"Lisp"
		public Keyword getTynameLispKeyword_3_1_0() { return cTynameLispKeyword_3_1_0; }

		//{TypePrimaryExpression} LPAREN t5=TypeExpression RPAREN
		public Group getGroup_4() { return cGroup_4; }

		//{TypePrimaryExpression}
		public Action getTypePrimaryExpressionAction_4_0() { return cTypePrimaryExpressionAction_4_0; }

		//LPAREN
		public RuleCall getLPARENTerminalRuleCall_4_1() { return cLPARENTerminalRuleCall_4_1; }

		//t5=TypeExpression
		public Assignment getT5Assignment_4_2() { return cT5Assignment_4_2; }

		//TypeExpression
		public RuleCall getT5TypeExpressionParserRuleCall_4_2_0() { return cT5TypeExpressionParserRuleCall_4_2_0; }

		//RPAREN
		public RuleCall getRPARENTerminalRuleCall_4_3() { return cRPARENTerminalRuleCall_4_3; }

		//{TypePrimaryExpression} tyname="Record" LPAREN t7=TypeExpression (COLON t8+=TypeExpression)? (COMMA t21+=TypeExpression
		//(COLON t23+=TypeExpression)?)* RPAREN
		public Group getGroup_5() { return cGroup_5; }

		//{TypePrimaryExpression}
		public Action getTypePrimaryExpressionAction_5_0() { return cTypePrimaryExpressionAction_5_0; }

		//tyname="Record"
		public Assignment getTynameAssignment_5_1() { return cTynameAssignment_5_1; }

		//"Record"
		public Keyword getTynameRecordKeyword_5_1_0() { return cTynameRecordKeyword_5_1_0; }

		//LPAREN
		public RuleCall getLPARENTerminalRuleCall_5_2() { return cLPARENTerminalRuleCall_5_2; }

		//t7=TypeExpression
		public Assignment getT7Assignment_5_3() { return cT7Assignment_5_3; }

		//TypeExpression
		public RuleCall getT7TypeExpressionParserRuleCall_5_3_0() { return cT7TypeExpressionParserRuleCall_5_3_0; }

		//(COLON t8+=TypeExpression)?
		public Group getGroup_5_4() { return cGroup_5_4; }

		//COLON
		public RuleCall getCOLONTerminalRuleCall_5_4_0() { return cCOLONTerminalRuleCall_5_4_0; }

		//t8+=TypeExpression
		public Assignment getT8Assignment_5_4_1() { return cT8Assignment_5_4_1; }

		//TypeExpression
		public RuleCall getT8TypeExpressionParserRuleCall_5_4_1_0() { return cT8TypeExpressionParserRuleCall_5_4_1_0; }

		//(COMMA t21+=TypeExpression (COLON t23+=TypeExpression)?)*
		public Group getGroup_5_5() { return cGroup_5_5; }

		//COMMA
		public RuleCall getCOMMATerminalRuleCall_5_5_0() { return cCOMMATerminalRuleCall_5_5_0; }

		//t21+=TypeExpression
		public Assignment getT21Assignment_5_5_1() { return cT21Assignment_5_5_1; }

		//TypeExpression
		public RuleCall getT21TypeExpressionParserRuleCall_5_5_1_0() { return cT21TypeExpressionParserRuleCall_5_5_1_0; }

		//(COLON t23+=TypeExpression)?
		public Group getGroup_5_5_2() { return cGroup_5_5_2; }

		//COLON
		public RuleCall getCOLONTerminalRuleCall_5_5_2_0() { return cCOLONTerminalRuleCall_5_5_2_0; }

		//t23+=TypeExpression
		public Assignment getT23Assignment_5_5_2_1() { return cT23Assignment_5_5_2_1; }

		//TypeExpression
		public RuleCall getT23TypeExpressionParserRuleCall_5_5_2_1_0() { return cT23TypeExpressionParserRuleCall_5_5_2_1_0; }

		//RPAREN
		public RuleCall getRPARENTerminalRuleCall_5_6() { return cRPARENTerminalRuleCall_5_6; }

		//{TypePrimaryExpression} tyname="Union" LPAREN t10=TypeExpression (COLON t11+=TypeExpression)? (COMMA t24+=TypeExpression
		//(COLON t26+=TypeExpression)?)* RPAREN
		public Group getGroup_6() { return cGroup_6; }

		//{TypePrimaryExpression}
		public Action getTypePrimaryExpressionAction_6_0() { return cTypePrimaryExpressionAction_6_0; }

		//tyname="Union"
		public Assignment getTynameAssignment_6_1() { return cTynameAssignment_6_1; }

		//"Union"
		public Keyword getTynameUnionKeyword_6_1_0() { return cTynameUnionKeyword_6_1_0; }

		//LPAREN
		public RuleCall getLPARENTerminalRuleCall_6_2() { return cLPARENTerminalRuleCall_6_2; }

		//t10=TypeExpression
		public Assignment getT10Assignment_6_3() { return cT10Assignment_6_3; }

		//TypeExpression
		public RuleCall getT10TypeExpressionParserRuleCall_6_3_0() { return cT10TypeExpressionParserRuleCall_6_3_0; }

		//(COLON t11+=TypeExpression)?
		public Group getGroup_6_4() { return cGroup_6_4; }

		//COLON
		public RuleCall getCOLONTerminalRuleCall_6_4_0() { return cCOLONTerminalRuleCall_6_4_0; }

		//t11+=TypeExpression
		public Assignment getT11Assignment_6_4_1() { return cT11Assignment_6_4_1; }

		//TypeExpression
		public RuleCall getT11TypeExpressionParserRuleCall_6_4_1_0() { return cT11TypeExpressionParserRuleCall_6_4_1_0; }

		//(COMMA t24+=TypeExpression (COLON t26+=TypeExpression)?)*
		public Group getGroup_6_5() { return cGroup_6_5; }

		//COMMA
		public RuleCall getCOMMATerminalRuleCall_6_5_0() { return cCOMMATerminalRuleCall_6_5_0; }

		//t24+=TypeExpression
		public Assignment getT24Assignment_6_5_1() { return cT24Assignment_6_5_1; }

		//TypeExpression
		public RuleCall getT24TypeExpressionParserRuleCall_6_5_1_0() { return cT24TypeExpressionParserRuleCall_6_5_1_0; }

		//(COLON t26+=TypeExpression)?
		public Group getGroup_6_5_2() { return cGroup_6_5_2; }

		//COLON
		public RuleCall getCOLONTerminalRuleCall_6_5_2_0() { return cCOLONTerminalRuleCall_6_5_2_0; }

		//t26+=TypeExpression
		public Assignment getT26Assignment_6_5_2_1() { return cT26Assignment_6_5_2_1; }

		//TypeExpression
		public RuleCall getT26TypeExpressionParserRuleCall_6_5_2_1_0() { return cT26TypeExpressionParserRuleCall_6_5_2_1_0; }

		//RPAREN
		public RuleCall getRPARENTerminalRuleCall_6_6() { return cRPARENTerminalRuleCall_6_6; }

		//{TypePrimaryExpression} tyname="Join" LPAREN t13=TypeExpression (COMMA t14+=TypeExpression)* RPAREN
		public Group getGroup_7() { return cGroup_7; }

		//{TypePrimaryExpression}
		public Action getTypePrimaryExpressionAction_7_0() { return cTypePrimaryExpressionAction_7_0; }

		//tyname="Join"
		public Assignment getTynameAssignment_7_1() { return cTynameAssignment_7_1; }

		//"Join"
		public Keyword getTynameJoinKeyword_7_1_0() { return cTynameJoinKeyword_7_1_0; }

		//LPAREN
		public RuleCall getLPARENTerminalRuleCall_7_2() { return cLPARENTerminalRuleCall_7_2; }

		//t13=TypeExpression
		public Assignment getT13Assignment_7_3() { return cT13Assignment_7_3; }

		//TypeExpression
		public RuleCall getT13TypeExpressionParserRuleCall_7_3_0() { return cT13TypeExpressionParserRuleCall_7_3_0; }

		//(COMMA t14+=TypeExpression)*
		public Group getGroup_7_4() { return cGroup_7_4; }

		//COMMA
		public RuleCall getCOMMATerminalRuleCall_7_4_0() { return cCOMMATerminalRuleCall_7_4_0; }

		//t14+=TypeExpression
		public Assignment getT14Assignment_7_4_1() { return cT14Assignment_7_4_1; }

		//TypeExpression
		public RuleCall getT14TypeExpressionParserRuleCall_7_4_1_0() { return cT14TypeExpressionParserRuleCall_7_4_1_0; }

		//RPAREN
		public RuleCall getRPARENTerminalRuleCall_7_5() { return cRPARENTerminalRuleCall_7_5; }

		//TypeNameOrFunctionCall
		public RuleCall getTypeNameOrFunctionCallParserRuleCall_8() { return cTypeNameOrFunctionCallParserRuleCall_8; }

		//=> TupleDefinition
		public RuleCall getTupleDefinitionParserRuleCall_9() { return cTupleDefinitionParserRuleCall_9; }
	}

	public class TypeNameOrFunctionCallElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "TypeNameOrFunctionCall");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cTfnnameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cTfnnameIDTerminalRuleCall_0_0 = (RuleCall)cTfnnameAssignment_0.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final Group cGroup_1_0 = (Group)cAlternatives_1.eContents().get(0);
		private final RuleCall cLPARENTerminalRuleCall_1_0_0 = (RuleCall)cGroup_1_0.eContents().get(0);
		private final Assignment cT4Assignment_1_0_1 = (Assignment)cGroup_1_0.eContents().get(1);
		private final RuleCall cT4TypeExpressionParserRuleCall_1_0_1_0 = (RuleCall)cT4Assignment_1_0_1.eContents().get(0);
		private final Group cGroup_1_0_2 = (Group)cGroup_1_0.eContents().get(2);
		private final RuleCall cCOMMATerminalRuleCall_1_0_2_0 = (RuleCall)cGroup_1_0_2.eContents().get(0);
		private final Assignment cT25Assignment_1_0_2_1 = (Assignment)cGroup_1_0_2.eContents().get(1);
		private final RuleCall cT25TypeExpressionParserRuleCall_1_0_2_1_0 = (RuleCall)cT25Assignment_1_0_2_1.eContents().get(0);
		private final RuleCall cRPARENTerminalRuleCall_1_0_3 = (RuleCall)cGroup_1_0.eContents().get(3);
		private final Assignment cT6Assignment_1_1 = (Assignment)cAlternatives_1.eContents().get(1);
		private final RuleCall cT6TypePrimaryExpressionParserRuleCall_1_1_0 = (RuleCall)cT6Assignment_1_1.eContents().get(0);
		
		/// * Will match with ID on its own like:
		// * Integer
		// * or type function call such as List(Integer)
		// * known as a parameterised type or functor (not necessarily a true functor since
		// * it may not obey the axioms of a functor)
		// * if there is only one parameter then the parenthesis are optional
		// * 
		// * function binds most tightly
		// * / TypeNameOrFunctionCall hidden(WS):
		//	tfnname=ID (LPAREN t4=TypeExpression? (COMMA t25+=TypeExpression)* RPAREN // option of no parenthesis for single parameter
		//	| => t6=TypePrimaryExpression)?;
		public ParserRule getRule() { return rule; }

		//tfnname=ID (LPAREN t4=TypeExpression? (COMMA t25+=TypeExpression)* RPAREN // option of no parenthesis for single parameter
		//| => t6=TypePrimaryExpression)?
		public Group getGroup() { return cGroup; }

		//tfnname=ID
		public Assignment getTfnnameAssignment_0() { return cTfnnameAssignment_0; }

		//ID
		public RuleCall getTfnnameIDTerminalRuleCall_0_0() { return cTfnnameIDTerminalRuleCall_0_0; }

		//(LPAREN t4=TypeExpression? (COMMA t25+=TypeExpression)* RPAREN // option of no parenthesis for single parameter
		//| => t6=TypePrimaryExpression)?
		public Alternatives getAlternatives_1() { return cAlternatives_1; }

		//LPAREN t4=TypeExpression? (COMMA t25+=TypeExpression)* RPAREN
		public Group getGroup_1_0() { return cGroup_1_0; }

		//LPAREN
		public RuleCall getLPARENTerminalRuleCall_1_0_0() { return cLPARENTerminalRuleCall_1_0_0; }

		//t4=TypeExpression?
		public Assignment getT4Assignment_1_0_1() { return cT4Assignment_1_0_1; }

		//TypeExpression
		public RuleCall getT4TypeExpressionParserRuleCall_1_0_1_0() { return cT4TypeExpressionParserRuleCall_1_0_1_0; }

		//(COMMA t25+=TypeExpression)*
		public Group getGroup_1_0_2() { return cGroup_1_0_2; }

		//COMMA
		public RuleCall getCOMMATerminalRuleCall_1_0_2_0() { return cCOMMATerminalRuleCall_1_0_2_0; }

		//t25+=TypeExpression
		public Assignment getT25Assignment_1_0_2_1() { return cT25Assignment_1_0_2_1; }

		//TypeExpression
		public RuleCall getT25TypeExpressionParserRuleCall_1_0_2_1_0() { return cT25TypeExpressionParserRuleCall_1_0_2_1_0; }

		//RPAREN
		public RuleCall getRPARENTerminalRuleCall_1_0_3() { return cRPARENTerminalRuleCall_1_0_3; }

		//=> t6=TypePrimaryExpression
		public Assignment getT6Assignment_1_1() { return cT6Assignment_1_1; }

		//TypePrimaryExpression
		public RuleCall getT6TypePrimaryExpressionParserRuleCall_1_1_0() { return cT6TypePrimaryExpressionParserRuleCall_1_1_0; }
	}

	public class TupleDefinitionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "TupleDefinition");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cLPARENTerminalRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Assignment cT4Assignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cT4TypeExpressionParserRuleCall_1_0 = (RuleCall)cT4Assignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final RuleCall cCOMMATerminalRuleCall_2_0 = (RuleCall)cGroup_2.eContents().get(0);
		private final Assignment cT25Assignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cT25TypeExpressionParserRuleCall_2_1_0 = (RuleCall)cT25Assignment_2_1.eContents().get(0);
		private final RuleCall cRPARENTerminalRuleCall_3 = (RuleCall)cGroup.eContents().get(3);
		
		/// * This has a form like: (Integer,Float,String)
		// * like an array where each entry can be of a different type
		// * / TupleDefinition hidden(WS):
		//	LPAREN t4=TypeExpression (COMMA t25+=TypeExpression)* RPAREN;
		public ParserRule getRule() { return rule; }

		//LPAREN t4=TypeExpression (COMMA t25+=TypeExpression)* RPAREN
		public Group getGroup() { return cGroup; }

		//LPAREN
		public RuleCall getLPARENTerminalRuleCall_0() { return cLPARENTerminalRuleCall_0; }

		//t4=TypeExpression
		public Assignment getT4Assignment_1() { return cT4Assignment_1; }

		//TypeExpression
		public RuleCall getT4TypeExpressionParserRuleCall_1_0() { return cT4TypeExpressionParserRuleCall_1_0; }

		//(COMMA t25+=TypeExpression)*
		public Group getGroup_2() { return cGroup_2; }

		//COMMA
		public RuleCall getCOMMATerminalRuleCall_2_0() { return cCOMMATerminalRuleCall_2_0; }

		//t25+=TypeExpression
		public Assignment getT25Assignment_2_1() { return cT25Assignment_2_1; }

		//TypeExpression
		public RuleCall getT25TypeExpressionParserRuleCall_2_1_0() { return cT25TypeExpressionParserRuleCall_2_1_0; }

		//RPAREN
		public RuleCall getRPARENTerminalRuleCall_3() { return cRPARENTerminalRuleCall_3; }
	}

	public class TypeLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "TypeLiteral");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cT1Assignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final RuleCall cT1INTTerminalRuleCall_0_0 = (RuleCall)cT1Assignment_0.eContents().get(0);
		private final Assignment cT22Assignment_1 = (Assignment)cAlternatives.eContents().get(1);
		private final RuleCall cT22STRINGTerminalRuleCall_1_0 = (RuleCall)cT22Assignment_1.eContents().get(0);
		private final Assignment cT34Assignment_2 = (Assignment)cAlternatives.eContents().get(2);
		private final RuleCall cT34CharacterLiteralParserRuleCall_2_0 = (RuleCall)cT34Assignment_2.eContents().get(0);
		private final Assignment cT35Assignment_3 = (Assignment)cAlternatives.eContents().get(3);
		private final RuleCall cT35BooleanLiteralParserRuleCall_3_0 = (RuleCall)cT35Assignment_3.eContents().get(0);
		
		/// * Since SPAD supports dependent types then numbers and strings can occur here.
		// * Outstanding issues:
		// * 1) Float literals are parsed as elt(Int,Int) so we need to recognise this
		// *    and convert to float literal
		// * 2) We need to be able to recognise exponent notation for floats
		// * 3) Integers without '-' prefix can be converted to PI or NNI
		// * 4) need to add hex or octal notation for integers (0xhhhh)
		// * 5) String and Character literals need to have backslash "\" doubled to
		// *    "\\" otherwise xtext will interpret backslash as an escape character.
		// * 6) values following immediately after string literal such as "abc"d should
		// *    represent an implied concat: concat("abc",d)
		// * / TypeLiteral hidden(WS):
		//	t1=INT | t22=STRING | // t3=FloatLiteral |
		//	t34=CharacterLiteral | t35=BooleanLiteral;
		public ParserRule getRule() { return rule; }

		//t1=INT | t22=STRING | // t3=FloatLiteral |
		//t34=CharacterLiteral | t35=BooleanLiteral
		public Alternatives getAlternatives() { return cAlternatives; }

		//t1=INT
		public Assignment getT1Assignment_0() { return cT1Assignment_0; }

		//INT
		public RuleCall getT1INTTerminalRuleCall_0_0() { return cT1INTTerminalRuleCall_0_0; }

		//t22=STRING
		public Assignment getT22Assignment_1() { return cT22Assignment_1; }

		//STRING
		public RuleCall getT22STRINGTerminalRuleCall_1_0() { return cT22STRINGTerminalRuleCall_1_0; }

		//// t3=FloatLiteral |
		//t34=CharacterLiteral
		public Assignment getT34Assignment_2() { return cT34Assignment_2; }

		//CharacterLiteral
		public RuleCall getT34CharacterLiteralParserRuleCall_2_0() { return cT34CharacterLiteralParserRuleCall_2_0; }

		//t35=BooleanLiteral
		public Assignment getT35Assignment_3() { return cT35Assignment_3; }

		//BooleanLiteral
		public RuleCall getT35BooleanLiteralParserRuleCall_3_0() { return cT35BooleanLiteralParserRuleCall_3_0; }
	}

	public class StatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Statement");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cS1Assignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final RuleCall cS1BlockParserRuleCall_0_0 = (RuleCall)cS1Assignment_0.eContents().get(0);
		private final Assignment cS3Assignment_1 = (Assignment)cAlternatives.eContents().get(1);
		private final RuleCall cS3StatementExpressionParserRuleCall_1_0 = (RuleCall)cS3Assignment_1.eContents().get(0);
		private final Assignment cS4Assignment_2 = (Assignment)cAlternatives.eContents().get(2);
		private final RuleCall cS4IfStatementParserRuleCall_2_0 = (RuleCall)cS4Assignment_2.eContents().get(0);
		private final Assignment cS5Assignment_3 = (Assignment)cAlternatives.eContents().get(3);
		private final RuleCall cS5WhileStatementParserRuleCall_3_0 = (RuleCall)cS5Assignment_3.eContents().get(0);
		private final Assignment cS6Assignment_4 = (Assignment)cAlternatives.eContents().get(4);
		private final RuleCall cS6DoStatementParserRuleCall_4_0 = (RuleCall)cS6Assignment_4.eContents().get(0);
		private final Assignment cS7Assignment_5 = (Assignment)cAlternatives.eContents().get(5);
		private final RuleCall cS7ForStatementParserRuleCall_5_0 = (RuleCall)cS7Assignment_5.eContents().get(0);
		private final Assignment cS8Assignment_6 = (Assignment)cAlternatives.eContents().get(6);
		private final RuleCall cS8BreakStatementParserRuleCall_6_0 = (RuleCall)cS8Assignment_6.eContents().get(0);
		private final Assignment cS9Assignment_7 = (Assignment)cAlternatives.eContents().get(7);
		private final RuleCall cS9IterateStatementParserRuleCall_7_0 = (RuleCall)cS9Assignment_7.eContents().get(0);
		private final Assignment cS10Assignment_8 = (Assignment)cAlternatives.eContents().get(8);
		private final RuleCall cS10ReturnStatementParserRuleCall_8_0 = (RuleCall)cS10Assignment_8.eContents().get(0);
		
		/// * In FunctionDefinition the algorithm is defined by a sequence of the
		// * following statements:
		// * / Statement hidden(WS, SL_COMMENT):
		//	s1=Block // 'if' can occur in an expression or in
		//	| => s3=StatementExpression | // a statement so we use '=>' to choose
		//	// expression if there is any ambiguity
		//	s4=IfStatement | s5=WhileStatement | s6=DoStatement | s7=ForStatement | s8=BreakStatement | s9=IterateStatement | //    s1= ContinueStatement|
		//	s10=ReturnStatement;
		public ParserRule getRule() { return rule; }

		//s1=Block // 'if' can occur in an expression or in
		//| => s3=StatementExpression | // a statement so we use '=>' to choose
		//// expression if there is any ambiguity
		//s4=IfStatement | s5=WhileStatement | s6=DoStatement | s7=ForStatement | s8=BreakStatement | s9=IterateStatement | //    s1= ContinueStatement|
		//s10=ReturnStatement
		public Alternatives getAlternatives() { return cAlternatives; }

		//s1=Block
		public Assignment getS1Assignment_0() { return cS1Assignment_0; }

		//Block
		public RuleCall getS1BlockParserRuleCall_0_0() { return cS1BlockParserRuleCall_0_0; }

		//=> s3=StatementExpression
		public Assignment getS3Assignment_1() { return cS3Assignment_1; }

		//StatementExpression
		public RuleCall getS3StatementExpressionParserRuleCall_1_0() { return cS3StatementExpressionParserRuleCall_1_0; }

		//// a statement so we use '=>' to choose
		//// expression if there is any ambiguity
		//s4=IfStatement
		public Assignment getS4Assignment_2() { return cS4Assignment_2; }

		//IfStatement
		public RuleCall getS4IfStatementParserRuleCall_2_0() { return cS4IfStatementParserRuleCall_2_0; }

		//s5=WhileStatement
		public Assignment getS5Assignment_3() { return cS5Assignment_3; }

		//WhileStatement
		public RuleCall getS5WhileStatementParserRuleCall_3_0() { return cS5WhileStatementParserRuleCall_3_0; }

		//s6=DoStatement
		public Assignment getS6Assignment_4() { return cS6Assignment_4; }

		//DoStatement
		public RuleCall getS6DoStatementParserRuleCall_4_0() { return cS6DoStatementParserRuleCall_4_0; }

		//s7=ForStatement
		public Assignment getS7Assignment_5() { return cS7Assignment_5; }

		//ForStatement
		public RuleCall getS7ForStatementParserRuleCall_5_0() { return cS7ForStatementParserRuleCall_5_0; }

		//s8=BreakStatement
		public Assignment getS8Assignment_6() { return cS8Assignment_6; }

		//BreakStatement
		public RuleCall getS8BreakStatementParserRuleCall_6_0() { return cS8BreakStatementParserRuleCall_6_0; }

		//s9=IterateStatement
		public Assignment getS9Assignment_7() { return cS9Assignment_7; }

		//IterateStatement
		public RuleCall getS9IterateStatementParserRuleCall_7_0() { return cS9IterateStatementParserRuleCall_7_0; }

		////    s1= ContinueStatement|
		//s10=ReturnStatement
		public Assignment getS10Assignment_8() { return cS10Assignment_8; }

		//ReturnStatement
		public RuleCall getS10ReturnStatementParserRuleCall_8_0() { return cS10ReturnStatementParserRuleCall_8_0; }
	}

	public class BlockElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Block");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cStnameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cStnameLBRACETerminalRuleCall_0_0 = (RuleCall)cStnameAssignment_0.eContents().get(0);
		private final RuleCall cNLTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Assignment cStatemBlAssignment_2_0 = (Assignment)cGroup_2.eContents().get(0);
		private final RuleCall cStatemBlStatementParserRuleCall_2_0_0 = (RuleCall)cStatemBlAssignment_2_0.eContents().get(0);
		private final Alternatives cAlternatives_2_1 = (Alternatives)cGroup_2.eContents().get(1);
		private final RuleCall cNLTerminalRuleCall_2_1_0 = (RuleCall)cAlternatives_2_1.eContents().get(0);
		private final RuleCall cSEMICOLONTerminalRuleCall_2_1_1 = (RuleCall)cAlternatives_2_1.eContents().get(1);
		private final RuleCall cRBRACETerminalRuleCall_3 = (RuleCall)cGroup.eContents().get(3);
		
		/// * allows multiple statements which are grouped by wrapping in curly brackets * / Block hidden(WS, SL_COMMENT):
		//	stname=LBRACE NL* (statemBl+=Statement (NL | SEMICOLON)+)* RBRACE;
		public ParserRule getRule() { return rule; }

		//stname=LBRACE NL* (statemBl+=Statement (NL | SEMICOLON)+)* RBRACE
		public Group getGroup() { return cGroup; }

		//stname=LBRACE
		public Assignment getStnameAssignment_0() { return cStnameAssignment_0; }

		//LBRACE
		public RuleCall getStnameLBRACETerminalRuleCall_0_0() { return cStnameLBRACETerminalRuleCall_0_0; }

		//NL*
		public RuleCall getNLTerminalRuleCall_1() { return cNLTerminalRuleCall_1; }

		//(statemBl+=Statement (NL | SEMICOLON)+)*
		public Group getGroup_2() { return cGroup_2; }

		//statemBl+=Statement
		public Assignment getStatemBlAssignment_2_0() { return cStatemBlAssignment_2_0; }

		//Statement
		public RuleCall getStatemBlStatementParserRuleCall_2_0_0() { return cStatemBlStatementParserRuleCall_2_0_0; }

		//(NL | SEMICOLON)+
		public Alternatives getAlternatives_2_1() { return cAlternatives_2_1; }

		//NL
		public RuleCall getNLTerminalRuleCall_2_1_0() { return cNLTerminalRuleCall_2_1_0; }

		//SEMICOLON
		public RuleCall getSEMICOLONTerminalRuleCall_2_1_1() { return cSEMICOLONTerminalRuleCall_2_1_1; }

		//RBRACE
		public RuleCall getRBRACETerminalRuleCall_3() { return cRBRACETerminalRuleCall_3; }
	}

	public class StatementExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "StatementExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cTAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cTExpressionParserRuleCall_0_0 = (RuleCall)cTAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final RuleCall cCOLONTerminalRuleCall_1_0 = (RuleCall)cGroup_1.eContents().get(0);
		private final Assignment cT2Assignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cT2TypeExpressionParserRuleCall_1_1_0 = (RuleCall)cT2Assignment_1_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final RuleCall cBECOMESTerminalRuleCall_2_0 = (RuleCall)cGroup_2.eContents().get(0);
		private final Assignment cT3Assignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cT3ExpressionParserRuleCall_2_1_0 = (RuleCall)cT3Assignment_2_1.eContents().get(0);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final RuleCall cEXITTerminalRuleCall_3_0 = (RuleCall)cGroup_3.eContents().get(0);
		private final Assignment cT4Assignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final RuleCall cT4ExpressionParserRuleCall_3_1_0 = (RuleCall)cT4Assignment_3_1.eContents().get(0);
		
		/// *
		// * gives a value or assigns a value to a variable
		// * / StatementExpression hidden(WS, SL_COMMENT):
		//	t=Expression (COLON t2=TypeExpression)? (BECOMES t3=Expression)? // breaks out of a block if predicate before '=>' is true then program
		//	// control leaves the block.
		//	// Put it here so that it can only occur at the top level of an expression
		//	// not inside some complicated expression.
		//	(EXIT t4=Expression)?;
		public ParserRule getRule() { return rule; }

		//t=Expression (COLON t2=TypeExpression)? (BECOMES t3=Expression)? // breaks out of a block if predicate before '=>' is true then program
		//// control leaves the block.
		//// Put it here so that it can only occur at the top level of an expression
		//// not inside some complicated expression.
		//(EXIT t4=Expression)?
		public Group getGroup() { return cGroup; }

		//t=Expression
		public Assignment getTAssignment_0() { return cTAssignment_0; }

		//Expression
		public RuleCall getTExpressionParserRuleCall_0_0() { return cTExpressionParserRuleCall_0_0; }

		//(COLON t2=TypeExpression)?
		public Group getGroup_1() { return cGroup_1; }

		//COLON
		public RuleCall getCOLONTerminalRuleCall_1_0() { return cCOLONTerminalRuleCall_1_0; }

		//t2=TypeExpression
		public Assignment getT2Assignment_1_1() { return cT2Assignment_1_1; }

		//TypeExpression
		public RuleCall getT2TypeExpressionParserRuleCall_1_1_0() { return cT2TypeExpressionParserRuleCall_1_1_0; }

		//(BECOMES t3=Expression)?
		public Group getGroup_2() { return cGroup_2; }

		//BECOMES
		public RuleCall getBECOMESTerminalRuleCall_2_0() { return cBECOMESTerminalRuleCall_2_0; }

		//t3=Expression
		public Assignment getT3Assignment_2_1() { return cT3Assignment_2_1; }

		//Expression
		public RuleCall getT3ExpressionParserRuleCall_2_1_0() { return cT3ExpressionParserRuleCall_2_1_0; }

		//(EXIT t4=Expression)?
		public Group getGroup_3() { return cGroup_3; }

		//EXIT
		public RuleCall getEXITTerminalRuleCall_3_0() { return cEXITTerminalRuleCall_3_0; }

		//t4=Expression
		public Assignment getT4Assignment_3_1() { return cT4Assignment_3_1; }

		//Expression
		public RuleCall getT4ExpressionParserRuleCall_3_1_0() { return cT4ExpressionParserRuleCall_3_1_0; }
	}

	public class ForStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ForStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cForKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Assignment cStnameAssignment_1_0 = (Assignment)cGroup_1.eContents().get(0);
		private final RuleCall cStnameIDTerminalRuleCall_1_0_0 = (RuleCall)cStnameAssignment_1_0.eContents().get(0);
		private final Keyword cInKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cT1Assignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cT1ExpressionParserRuleCall_1_2_0 = (RuleCall)cT1Assignment_1_2.eContents().get(0);
		private final Keyword cRepeatKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final RuleCall cNLTerminalRuleCall_3 = (RuleCall)cGroup.eContents().get(3);
		private final Assignment cS1Assignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cS1StatementParserRuleCall_4_0 = (RuleCall)cS1Assignment_4.eContents().get(0);
		
		/// *
		// * for i in n..m repeat ... is 1
		// * for i in n..m by s repeat ...
		// * for i in list repeat ...
		// * for j in n..m repeat loopBody
		// * for j in n..m | odd? j repeat 
		// * / ForStatement hidden(WS, SL_COMMENT):
		//	"for" (stname=ID "in" t1= //(=> '..' t2=Expression)?
		//	Expression) //       (=> BAR t2=PredicateOr)? // condition
		//	"repeat" NL? s1= //('is' s2=Statement)?
		//	Statement;
		public ParserRule getRule() { return rule; }

		//"for" (stname=ID "in" t1= //(=> '..' t2=Expression)?
		//Expression) //       (=> BAR t2=PredicateOr)? // condition
		//"repeat" NL? s1= //('is' s2=Statement)?
		//Statement
		public Group getGroup() { return cGroup; }

		//"for"
		public Keyword getForKeyword_0() { return cForKeyword_0; }

		//stname=ID "in" t1= //(=> '..' t2=Expression)?
		//Expression
		public Group getGroup_1() { return cGroup_1; }

		//stname=ID
		public Assignment getStnameAssignment_1_0() { return cStnameAssignment_1_0; }

		//ID
		public RuleCall getStnameIDTerminalRuleCall_1_0_0() { return cStnameIDTerminalRuleCall_1_0_0; }

		//"in"
		public Keyword getInKeyword_1_1() { return cInKeyword_1_1; }

		//t1= //(=> '..' t2=Expression)?
		//Expression
		public Assignment getT1Assignment_1_2() { return cT1Assignment_1_2; }

		////(=> '..' t2=Expression)?
		//Expression
		public RuleCall getT1ExpressionParserRuleCall_1_2_0() { return cT1ExpressionParserRuleCall_1_2_0; }

		//"repeat"
		public Keyword getRepeatKeyword_2() { return cRepeatKeyword_2; }

		//NL?
		public RuleCall getNLTerminalRuleCall_3() { return cNLTerminalRuleCall_3; }

		//s1= //('is' s2=Statement)?
		//Statement
		public Assignment getS1Assignment_4() { return cS1Assignment_4; }

		////('is' s2=Statement)?
		//Statement
		public RuleCall getS1StatementParserRuleCall_4_0() { return cS1StatementParserRuleCall_4_0; }
	}

	public class WhileStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "WhileStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cStnameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Keyword cStnameWhileKeyword_0_0 = (Keyword)cStnameAssignment_0.eContents().get(0);
		private final Assignment cT2Assignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cT2PredicateOrParserRuleCall_1_0 = (RuleCall)cT2Assignment_1.eContents().get(0);
		private final Keyword cRepeatKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final RuleCall cNLTerminalRuleCall_3 = (RuleCall)cGroup.eContents().get(3);
		private final Assignment cS1Assignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cS1StatementParserRuleCall_4_0 = (RuleCall)cS1Assignment_4.eContents().get(0);
		
		/// *
		// * while BoolExpr repeat loopBody
		// * / WhileStatement hidden(WS, SL_COMMENT):
		//	stname="while" t2=PredicateOr "repeat" NL? s1=Statement;
		public ParserRule getRule() { return rule; }

		//stname="while" t2=PredicateOr "repeat" NL? s1=Statement
		public Group getGroup() { return cGroup; }

		//stname="while"
		public Assignment getStnameAssignment_0() { return cStnameAssignment_0; }

		//"while"
		public Keyword getStnameWhileKeyword_0_0() { return cStnameWhileKeyword_0_0; }

		//t2=PredicateOr
		public Assignment getT2Assignment_1() { return cT2Assignment_1; }

		//PredicateOr
		public RuleCall getT2PredicateOrParserRuleCall_1_0() { return cT2PredicateOrParserRuleCall_1_0; }

		//"repeat"
		public Keyword getRepeatKeyword_2() { return cRepeatKeyword_2; }

		//NL?
		public RuleCall getNLTerminalRuleCall_3() { return cNLTerminalRuleCall_3; }

		//s1=Statement
		public Assignment getS1Assignment_4() { return cS1Assignment_4; }

		//Statement
		public RuleCall getS1StatementParserRuleCall_4_0() { return cS1StatementParserRuleCall_4_0; }
	}

	public class DoStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "DoStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cStnameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Keyword cStnameDoKeyword_0_0 = (Keyword)cStnameAssignment_0.eContents().get(0);
		private final Assignment cS1Assignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cS1StatementParserRuleCall_1_0 = (RuleCall)cS1Assignment_1.eContents().get(0);
		private final Keyword cWhileKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final RuleCall cNLTerminalRuleCall_3 = (RuleCall)cGroup.eContents().get(3);
		private final Assignment cT2Assignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cT2PredicateOrParserRuleCall_4_0 = (RuleCall)cT2Assignment_4.eContents().get(0);
		
		/// *
		// *  do loopBody while BoolExpr
		// * / DoStatement hidden(WS, SL_COMMENT):
		//	stname="do" s1=Statement "while" NL? t2=PredicateOr;
		public ParserRule getRule() { return rule; }

		//stname="do" s1=Statement "while" NL? t2=PredicateOr
		public Group getGroup() { return cGroup; }

		//stname="do"
		public Assignment getStnameAssignment_0() { return cStnameAssignment_0; }

		//"do"
		public Keyword getStnameDoKeyword_0_0() { return cStnameDoKeyword_0_0; }

		//s1=Statement
		public Assignment getS1Assignment_1() { return cS1Assignment_1; }

		//Statement
		public RuleCall getS1StatementParserRuleCall_1_0() { return cS1StatementParserRuleCall_1_0; }

		//"while"
		public Keyword getWhileKeyword_2() { return cWhileKeyword_2; }

		//NL?
		public RuleCall getNLTerminalRuleCall_3() { return cNLTerminalRuleCall_3; }

		//t2=PredicateOr
		public Assignment getT2Assignment_4() { return cT2Assignment_4; }

		//PredicateOr
		public RuleCall getT2PredicateOrParserRuleCall_4_0() { return cT2PredicateOrParserRuleCall_4_0; }
	}

	public class IterateStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "IterateStatement");
		private final Assignment cStnameAssignment = (Assignment)rule.eContents().get(1);
		private final Keyword cStnameIterateKeyword_0 = (Keyword)cStnameAssignment.eContents().get(0);
		
		/// *
		// * iterate ...
		// * skips over the remainder of a loop 
		// * / IterateStatement hidden(WS, SL_COMMENT):
		//	stname="iterate";
		public ParserRule getRule() { return rule; }

		//stname="iterate"
		public Assignment getStnameAssignment() { return cStnameAssignment; }

		//"iterate"
		public Keyword getStnameIterateKeyword_0() { return cStnameIterateKeyword_0; }
	}

	public class BreakStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "BreakStatement");
		private final Assignment cStnameAssignment = (Assignment)rule.eContents().get(1);
		private final Keyword cStnameBreakKeyword_0 = (Keyword)cStnameAssignment.eContents().get(0);
		
		/// *
		// * break 	leave current loop 
		// * / BreakStatement hidden(WS, SL_COMMENT):
		//	stname="break";
		public ParserRule getRule() { return rule; }

		//stname="break"
		public Assignment getStnameAssignment() { return cStnameAssignment; }

		//"break"
		public Keyword getStnameBreakKeyword_0() { return cStnameBreakKeyword_0; }
	}

	public class ReturnStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ReturnStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cStnameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Keyword cStnameReturnKeyword_0_0 = (Keyword)cStnameAssignment_0.eContents().get(0);
		private final Assignment cT2Assignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cT2ExpressionParserRuleCall_1_0 = (RuleCall)cT2Assignment_1.eContents().get(0);
		
		/// *
		// * return 	leave current function 
		// * / ReturnStatement hidden(WS):
		//	stname="return" t2=Expression;
		public ParserRule getRule() { return rule; }

		//stname="return" t2=Expression
		public Group getGroup() { return cGroup; }

		//stname="return"
		public Assignment getStnameAssignment_0() { return cStnameAssignment_0; }

		//"return"
		public Keyword getStnameReturnKeyword_0_0() { return cStnameReturnKeyword_0_0; }

		//t2=Expression
		public Assignment getT2Assignment_1() { return cT2Assignment_1; }

		//Expression
		public RuleCall getT2ExpressionParserRuleCall_1_0() { return cT2ExpressionParserRuleCall_1_0; }
	}

	public class IfStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "IfStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cIfKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cT2Assignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cT2PredicateOrParserRuleCall_1_0 = (RuleCall)cT2Assignment_1.eContents().get(0);
		private final Keyword cThenKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final RuleCall cNLTerminalRuleCall_3 = (RuleCall)cGroup.eContents().get(3);
		private final Assignment cS1Assignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cS1StatementParserRuleCall_4_0 = (RuleCall)cS1Assignment_4.eContents().get(0);
		private final Group cGroup_5 = (Group)cGroup.eContents().get(5);
		private final Keyword cElseKeyword_5_0 = (Keyword)cGroup_5.eContents().get(0);
		private final RuleCall cNLTerminalRuleCall_5_1 = (RuleCall)cGroup_5.eContents().get(1);
		private final Assignment cS2Assignment_5_2 = (Assignment)cGroup_5.eContents().get(2);
		private final RuleCall cS2StatementParserRuleCall_5_2_0 = (RuleCall)cS2Assignment_5_2.eContents().get(0);
		
		/// * 'if' statement allows program flow to be switched
		// * forms:
		// * if boolean then
		// * if equation then
		// * if ... not ... and ...or ... then
		// * if ... then ... else ...
		// * note1:
		// * if ... then ... else ... always returns a value so we can use this
		// * on the right hand side of an assignment
		// * note2:
		// * since there is an explicit 'then' keyword there is no need to put
		// * the condition in brackets
		// * 	
		// * examples:
		// * a:= if x >0 then x else -x
		// * if R has Field then ... 	  	 
		// * if myUnion case mtType then ...
		// * / IfStatement hidden(WS, SL_COMMENT):
		//	"if" t2=PredicateOr "then" NL? s1=Statement ("else" NL? s2=Statement)?;
		public ParserRule getRule() { return rule; }

		//"if" t2=PredicateOr "then" NL? s1=Statement ("else" NL? s2=Statement)?
		public Group getGroup() { return cGroup; }

		//"if"
		public Keyword getIfKeyword_0() { return cIfKeyword_0; }

		//t2=PredicateOr
		public Assignment getT2Assignment_1() { return cT2Assignment_1; }

		//PredicateOr
		public RuleCall getT2PredicateOrParserRuleCall_1_0() { return cT2PredicateOrParserRuleCall_1_0; }

		//"then"
		public Keyword getThenKeyword_2() { return cThenKeyword_2; }

		//NL?
		public RuleCall getNLTerminalRuleCall_3() { return cNLTerminalRuleCall_3; }

		//s1=Statement
		public Assignment getS1Assignment_4() { return cS1Assignment_4; }

		//Statement
		public RuleCall getS1StatementParserRuleCall_4_0() { return cS1StatementParserRuleCall_4_0; }

		//(=> "else" NL? s2=Statement)?
		public Group getGroup_5() { return cGroup_5; }

		//=> "else"
		public Keyword getElseKeyword_5_0() { return cElseKeyword_5_0; }

		//NL?
		public RuleCall getNLTerminalRuleCall_5_1() { return cNLTerminalRuleCall_5_1; }

		//s2=Statement
		public Assignment getS2Assignment_5_2() { return cS2Assignment_5_2; }

		//Statement
		public RuleCall getS2StatementParserRuleCall_5_2_0() { return cS2StatementParserRuleCall_5_2_0; }
	}

	public class PredicateOrElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PredicateOr");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cPredicateAndParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cPredicateOrLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cPrnameAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final Keyword cPrnameOrKeyword_1_1_0 = (Keyword)cPrnameAssignment_1_1.eContents().get(0);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightPredicateAndParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		/// *
		// * "or", precedence: 200, 201
		// *
		// * / PredicateOr returns Predicate hidden(WS):
		//	PredicateAnd ({PredicateOr.left=current} prname="or" right=PredicateAnd)*;
		public ParserRule getRule() { return rule; }

		//PredicateAnd ({PredicateOr.left=current} prname="or" right=PredicateAnd)*
		public Group getGroup() { return cGroup; }

		//PredicateAnd
		public RuleCall getPredicateAndParserRuleCall_0() { return cPredicateAndParserRuleCall_0; }

		//({PredicateOr.left=current} prname="or" right=PredicateAnd)*
		public Group getGroup_1() { return cGroup_1; }

		//{PredicateOr.left=current}
		public Action getPredicateOrLeftAction_1_0() { return cPredicateOrLeftAction_1_0; }

		//prname="or"
		public Assignment getPrnameAssignment_1_1() { return cPrnameAssignment_1_1; }

		//"or"
		public Keyword getPrnameOrKeyword_1_1_0() { return cPrnameOrKeyword_1_1_0; }

		//right=PredicateAnd
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }

		//PredicateAnd
		public RuleCall getRightPredicateAndParserRuleCall_1_2_0() { return cRightPredicateAndParserRuleCall_1_2_0; }
	}

	public class PredicateAndElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PredicateAnd");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cPredicateNotParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cPredicateAndLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cPrnameAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final Keyword cPrnameAndKeyword_1_1_0 = (Keyword)cPrnameAssignment_1_1.eContents().get(0);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightPredicateNotParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		/// *
		// *  "and", precedence: 250, 251
		// * / PredicateAnd returns Predicate hidden(WS):
		//	PredicateNot ({PredicateAnd.left=current} prname="and" right=PredicateNot)*;
		public ParserRule getRule() { return rule; }

		//PredicateNot ({PredicateAnd.left=current} prname="and" right=PredicateNot)*
		public Group getGroup() { return cGroup; }

		//PredicateNot
		public RuleCall getPredicateNotParserRuleCall_0() { return cPredicateNotParserRuleCall_0; }

		//({PredicateAnd.left=current} prname="and" right=PredicateNot)*
		public Group getGroup_1() { return cGroup_1; }

		//{PredicateAnd.left=current}
		public Action getPredicateAndLeftAction_1_0() { return cPredicateAndLeftAction_1_0; }

		//prname="and"
		public Assignment getPrnameAssignment_1_1() { return cPrnameAssignment_1_1; }

		//"and"
		public Keyword getPrnameAndKeyword_1_1_0() { return cPrnameAndKeyword_1_1_0; }

		//right=PredicateNot
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }

		//PredicateNot
		public RuleCall getRightPredicateNotParserRuleCall_1_2_0() { return cRightPredicateNotParserRuleCall_1_2_0; }
	}

	public class PredicateNotElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PredicateNot");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cPredicatePrimaryParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Action cPredicateNotAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cNotKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cT2Assignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cT2PredicatePrimaryParserRuleCall_1_2_0 = (RuleCall)cT2Assignment_1_2.eContents().get(0);
		
		/// *
		// * allow optional 'not' as prefix operator
		// * / PredicateNot returns Predicate hidden(WS):
		//	PredicatePrimary | {PredicateNot} "not" t2=PredicatePrimary;
		public ParserRule getRule() { return rule; }

		//PredicatePrimary | {PredicateNot} "not" t2=PredicatePrimary
		public Alternatives getAlternatives() { return cAlternatives; }

		//PredicatePrimary
		public RuleCall getPredicatePrimaryParserRuleCall_0() { return cPredicatePrimaryParserRuleCall_0; }

		//{PredicateNot} "not" t2=PredicatePrimary
		public Group getGroup_1() { return cGroup_1; }

		//{PredicateNot}
		public Action getPredicateNotAction_1_0() { return cPredicateNotAction_1_0; }

		//"not"
		public Keyword getNotKeyword_1_1() { return cNotKeyword_1_1; }

		//t2=PredicatePrimary
		public Assignment getT2Assignment_1_2() { return cT2Assignment_1_2; }

		//PredicatePrimary
		public RuleCall getT2PredicatePrimaryParserRuleCall_1_2_0() { return cT2PredicatePrimaryParserRuleCall_1_2_0; }
	}

	public class PredicatePrimaryElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PredicatePrimary");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Group cGroup_0_0 = (Group)cGroup_0.eContents().get(0);
		private final RuleCall cLPARENTerminalRuleCall_0_0_0 = (RuleCall)cGroup_0_0.eContents().get(0);
		private final Assignment cTAssignment_0_0_1 = (Assignment)cGroup_0_0.eContents().get(1);
		private final RuleCall cTPredicateOrParserRuleCall_0_0_1_0 = (RuleCall)cTAssignment_0_0_1.eContents().get(0);
		private final RuleCall cRPARENTerminalRuleCall_0_0_2 = (RuleCall)cGroup_0_0.eContents().get(2);
		private final Assignment cT2Assignment_1 = (Assignment)cAlternatives.eContents().get(1);
		private final RuleCall cT2EqualityExpressionParserRuleCall_1_0 = (RuleCall)cT2Assignment_1.eContents().get(0);
		
		/// *
		// * PredicatePrimary
		// * / PredicatePrimary hidden(WS):
		//	=> (LPAREN t=PredicateOr RPAREN) | t2=EqualityExpression;
		public ParserRule getRule() { return rule; }

		//=> (LPAREN t=PredicateOr RPAREN) | t2=EqualityExpression
		public Alternatives getAlternatives() { return cAlternatives; }

		//=> (LPAREN t=PredicateOr RPAREN)
		public Group getGroup_0() { return cGroup_0; }

		//LPAREN t=PredicateOr RPAREN
		public Group getGroup_0_0() { return cGroup_0_0; }

		//LPAREN
		public RuleCall getLPARENTerminalRuleCall_0_0_0() { return cLPARENTerminalRuleCall_0_0_0; }

		//t=PredicateOr
		public Assignment getTAssignment_0_0_1() { return cTAssignment_0_0_1; }

		//PredicateOr
		public RuleCall getTPredicateOrParserRuleCall_0_0_1_0() { return cTPredicateOrParserRuleCall_0_0_1_0; }

		//RPAREN
		public RuleCall getRPARENTerminalRuleCall_0_0_2() { return cRPARENTerminalRuleCall_0_0_2; }

		//t2=EqualityExpression
		public Assignment getT2Assignment_1() { return cT2Assignment_1; }

		//EqualityExpression
		public RuleCall getT2EqualityExpressionParserRuleCall_1_0() { return cT2EqualityExpressionParserRuleCall_1_0; }
	}

	public class ExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Expression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Assignment cIfnameAssignment_0_0 = (Assignment)cGroup_0.eContents().get(0);
		private final Keyword cIfnameIfKeyword_0_0_0 = (Keyword)cIfnameAssignment_0_0.eContents().get(0);
		private final Assignment cIfpredAssignment_0_1 = (Assignment)cGroup_0.eContents().get(1);
		private final RuleCall cIfpredPredicateOrParserRuleCall_0_1_0 = (RuleCall)cIfpredAssignment_0_1.eContents().get(0);
		private final Keyword cThenKeyword_0_2 = (Keyword)cGroup_0.eContents().get(2);
		private final Assignment cThenexpAssignment_0_3 = (Assignment)cGroup_0.eContents().get(3);
		private final RuleCall cThenexpExpressionParserRuleCall_0_3_0 = (RuleCall)cThenexpAssignment_0_3.eContents().get(0);
		private final Keyword cElseKeyword_0_4 = (Keyword)cGroup_0.eContents().get(4);
		private final Assignment cElseexpAssignment_0_5 = (Assignment)cGroup_0.eContents().get(5);
		private final RuleCall cElseexpExpressionParserRuleCall_0_5_0 = (RuleCall)cElseexpAssignment_0_5.eContents().get(0);
		private final RuleCall cConditionExpressionParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		/////////////// Expression syntax follows //////////////
		//// expressions contain no newlines unless preceded by underscore
		//// (which is handled by WS)
		//Expression returns Expr hidden(WS, SL_COMMENT):
		//	ifname="if" ifpred=PredicateOr "then" thenexp=Expression "else" elseexp=Expression / *
		// * This expansion has been written this way instead of:
		// *   Assignment() | ConditionalExpression()
		// * for performance reasons.
		// * However, it is a weakening of the grammar for it allows the LHS of
		// * assignments to be any conditional expression whereas it can only be
		// * a primary expression.  Consider adding a semantic predicate to work
		// * around this.
		// * / | ConditionExpression;
		public ParserRule getRule() { return rule; }

		//ifname="if" ifpred=PredicateOr "then" thenexp=Expression "else" elseexp=Expression / *
		// * This expansion has been written this way instead of:
		// *   Assignment() | ConditionalExpression()
		// * for performance reasons.
		// * However, it is a weakening of the grammar for it allows the LHS of
		// * assignments to be any conditional expression whereas it can only be
		// * a primary expression.  Consider adding a semantic predicate to work
		// * around this.
		// * / | ConditionExpression
		public Alternatives getAlternatives() { return cAlternatives; }

		//ifname="if" ifpred=PredicateOr "then" thenexp=Expression "else" elseexp=Expression
		public Group getGroup_0() { return cGroup_0; }

		//ifname="if"
		public Assignment getIfnameAssignment_0_0() { return cIfnameAssignment_0_0; }

		//"if"
		public Keyword getIfnameIfKeyword_0_0_0() { return cIfnameIfKeyword_0_0_0; }

		//ifpred=PredicateOr
		public Assignment getIfpredAssignment_0_1() { return cIfpredAssignment_0_1; }

		//PredicateOr
		public RuleCall getIfpredPredicateOrParserRuleCall_0_1_0() { return cIfpredPredicateOrParserRuleCall_0_1_0; }

		//"then"
		public Keyword getThenKeyword_0_2() { return cThenKeyword_0_2; }

		//thenexp=Expression
		public Assignment getThenexpAssignment_0_3() { return cThenexpAssignment_0_3; }

		//Expression
		public RuleCall getThenexpExpressionParserRuleCall_0_3_0() { return cThenexpExpressionParserRuleCall_0_3_0; }

		//"else"
		public Keyword getElseKeyword_0_4() { return cElseKeyword_0_4; }

		//elseexp=Expression
		public Assignment getElseexpAssignment_0_5() { return cElseexpAssignment_0_5; }

		//Expression
		public RuleCall getElseexpExpressionParserRuleCall_0_5_0() { return cElseexpExpressionParserRuleCall_0_5_0; }

		//ConditionExpression
		public RuleCall getConditionExpressionParserRuleCall_1() { return cConditionExpressionParserRuleCall_1; }
	}

	public class ConditionExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ConditionExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cInnerProdExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cConditionExpressionLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOpAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOpBARTerminalRuleCall_1_1_0 = (RuleCall)cOpAssignment_1_1.eContents().get(0);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightPredicateOrParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		/// * 
		// * BAR "|" precedence: 108, 111
		// * / ConditionExpression returns Expr hidden(WS, SL_COMMENT):
		//	InnerProdExpression ({ConditionExpression.left=current} op=BAR right=PredicateOr)*;
		public ParserRule getRule() { return rule; }

		//InnerProdExpression ({ConditionExpression.left=current} op=BAR right=PredicateOr)*
		public Group getGroup() { return cGroup; }

		//InnerProdExpression
		public RuleCall getInnerProdExpressionParserRuleCall_0() { return cInnerProdExpressionParserRuleCall_0; }

		//({ConditionExpression.left=current} op=BAR right=PredicateOr)*
		public Group getGroup_1() { return cGroup_1; }

		//{ConditionExpression.left=current}
		public Action getConditionExpressionLeftAction_1_0() { return cConditionExpressionLeftAction_1_0; }

		//op=BAR
		public Assignment getOpAssignment_1_1() { return cOpAssignment_1_1; }

		//BAR
		public RuleCall getOpBARTerminalRuleCall_1_1_0() { return cOpBARTerminalRuleCall_1_1_0; }

		//right=PredicateOr
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }

		//PredicateOr
		public RuleCall getRightPredicateOrParserRuleCall_1_2_0() { return cRightPredicateOrParserRuleCall_1_2_0; }
	}

	public class InnerProdExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "InnerProdExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cOuterProdExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cInnerProdExpressionLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOpAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOpBACKSLASHSLASHTerminalRuleCall_1_1_0 = (RuleCall)cOpAssignment_1_1.eContents().get(0);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightOuterProdExpressionParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		/// * 
		// * COMMA"," precedence: 110, 111
		// * / //CommaExpression returns Expr hidden(WS,SL_COMMENT):
		////  ConditionalAndExpression
		////  ({ConditionExpression.left=current} op=BAR right = ConditionalAndExpression )*
		////;
		/// *
		// * This has multiple uses such as inner product and logical or.
		// * 
		// * "\/", BACKSLASHSLASH precedence: 200, 201
		// * 
		// * the backslash is duplicated here because it is the escape character for
		// * strings, it will not be duplicated when used. 
		// * / InnerProdExpression returns Expr hidden(WS, SL_COMMENT):
		//	OuterProdExpression ({InnerProdExpression.left=current} op=BACKSLASHSLASH right=OuterProdExpression)*;
		public ParserRule getRule() { return rule; }

		//OuterProdExpression ({InnerProdExpression.left=current} op=BACKSLASHSLASH right=OuterProdExpression)*
		public Group getGroup() { return cGroup; }

		//OuterProdExpression
		public RuleCall getOuterProdExpressionParserRuleCall_0() { return cOuterProdExpressionParserRuleCall_0; }

		//({InnerProdExpression.left=current} op=BACKSLASHSLASH right=OuterProdExpression)*
		public Group getGroup_1() { return cGroup_1; }

		//{InnerProdExpression.left=current}
		public Action getInnerProdExpressionLeftAction_1_0() { return cInnerProdExpressionLeftAction_1_0; }

		//op=BACKSLASHSLASH
		public Assignment getOpAssignment_1_1() { return cOpAssignment_1_1; }

		//BACKSLASHSLASH
		public RuleCall getOpBACKSLASHSLASHTerminalRuleCall_1_1_0() { return cOpBACKSLASHSLASHTerminalRuleCall_1_1_0; }

		//right=OuterProdExpression
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }

		//OuterProdExpression
		public RuleCall getRightOuterProdExpressionParserRuleCall_1_2_0() { return cRightOuterProdExpressionParserRuleCall_1_2_0; }
	}

	public class OuterProdExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "OuterProdExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cHasExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cOuterProdExpressionLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOpAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOpSLASHBACKSLASHTerminalRuleCall_1_1_0 = (RuleCall)cOpAssignment_1_1.eContents().get(0);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightHasExpressionParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		/// *
		// * This has multiple uses such as outer product and logical and.
		// * 
		// * "/\", SLASHBACKSLASH precedence: 250, 251
		// * 
		// * the backslash is duplicated here because it is the escape character for
		// * strings, it will not be duplicated when used. 
		// * / OuterProdExpression returns Expr hidden(WS, SL_COMMENT):
		//	HasExpression ({OuterProdExpression.left=current} op=SLASHBACKSLASH right=HasExpression)*;
		public ParserRule getRule() { return rule; }

		//HasExpression ({OuterProdExpression.left=current} op=SLASHBACKSLASH right=HasExpression)*
		public Group getGroup() { return cGroup; }

		//HasExpression
		public RuleCall getHasExpressionParserRuleCall_0() { return cHasExpressionParserRuleCall_0; }

		//({OuterProdExpression.left=current} op=SLASHBACKSLASH right=HasExpression)*
		public Group getGroup_1() { return cGroup_1; }

		//{OuterProdExpression.left=current}
		public Action getOuterProdExpressionLeftAction_1_0() { return cOuterProdExpressionLeftAction_1_0; }

		//op=SLASHBACKSLASH
		public Assignment getOpAssignment_1_1() { return cOpAssignment_1_1; }

		//SLASHBACKSLASH
		public RuleCall getOpSLASHBACKSLASHTerminalRuleCall_1_1_0() { return cOpSLASHBACKSLASHTerminalRuleCall_1_1_0; }

		//right=HasExpression
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }

		//HasExpression
		public RuleCall getRightHasExpressionParserRuleCall_1_2_0() { return cRightHasExpressionParserRuleCall_1_2_0; }
	}

	public class HasExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "HasExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cCaseExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cHasExpressionLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOpAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final Keyword cOpHasKeyword_1_1_0 = (Keyword)cOpAssignment_1_1.eContents().get(0);
		private final Assignment cRightTypeAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightTypeTypeExpressionParserRuleCall_1_2_0 = (RuleCall)cRightTypeAssignment_1_2.eContents().get(0);
		
		/// * Predicate which returns true if preceding value is of a given type
		// * example:
		// * if R has Field then ..
		// * 
		// * "has", precedence: 400, 400
		// * / HasExpression returns Expr hidden(WS, SL_COMMENT):
		//	CaseExpression ({HasExpression.left=current} op="has" rightType=TypeExpression)*;
		public ParserRule getRule() { return rule; }

		//CaseExpression ({HasExpression.left=current} op="has" rightType=TypeExpression)*
		public Group getGroup() { return cGroup; }

		//CaseExpression
		public RuleCall getCaseExpressionParserRuleCall_0() { return cCaseExpressionParserRuleCall_0; }

		//({HasExpression.left=current} op="has" rightType=TypeExpression)*
		public Group getGroup_1() { return cGroup_1; }

		//{HasExpression.left=current}
		public Action getHasExpressionLeftAction_1_0() { return cHasExpressionLeftAction_1_0; }

		//op="has"
		public Assignment getOpAssignment_1_1() { return cOpAssignment_1_1; }

		//"has"
		public Keyword getOpHasKeyword_1_1_0() { return cOpHasKeyword_1_1_0; }

		//rightType=TypeExpression
		public Assignment getRightTypeAssignment_1_2() { return cRightTypeAssignment_1_2; }

		//TypeExpression
		public RuleCall getRightTypeTypeExpressionParserRuleCall_1_2_0() { return cRightTypeTypeExpressionParserRuleCall_1_2_0; }
	}

	public class CaseExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "CaseExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cEqualityExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cCaseExpressionLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOpAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final Keyword cOpCaseKeyword_1_1_0 = (Keyword)cOpAssignment_1_1.eContents().get(0);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightEqualityExpressionParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		/// * Select from Union values 
		// * example:
		// * if myUnion case mtType then ... 	
		// * 
		// * "case", precedence: 400, 400
		// * / CaseExpression returns Expr hidden(WS, SL_COMMENT):
		//	EqualityExpression ({CaseExpression.left=current} op="case" right=EqualityExpression)?;
		public ParserRule getRule() { return rule; }

		//EqualityExpression ({CaseExpression.left=current} op="case" right=EqualityExpression)?
		public Group getGroup() { return cGroup; }

		//EqualityExpression
		public RuleCall getEqualityExpressionParserRuleCall_0() { return cEqualityExpressionParserRuleCall_0; }

		//({CaseExpression.left=current} op="case" right=EqualityExpression)?
		public Group getGroup_1() { return cGroup_1; }

		//{CaseExpression.left=current}
		public Action getCaseExpressionLeftAction_1_0() { return cCaseExpressionLeftAction_1_0; }

		//op="case"
		public Assignment getOpAssignment_1_1() { return cOpAssignment_1_1; }

		//"case"
		public Keyword getOpCaseKeyword_1_1_0() { return cOpCaseKeyword_1_1_0; }

		//right=EqualityExpression
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }

		//EqualityExpression
		public RuleCall getRightEqualityExpressionParserRuleCall_1_2_0() { return cRightEqualityExpressionParserRuleCall_1_2_0; }
	}

	public class EqualityExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "EqualityExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cRelationalExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cEqualityExpressionLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Alternatives cAlternatives_1_1 = (Alternatives)cGroup_1.eContents().get(1);
		private final Assignment cOpAssignment_1_1_0 = (Assignment)cAlternatives_1_1.eContents().get(0);
		private final RuleCall cOpEQUALTerminalRuleCall_1_1_0_0 = (RuleCall)cOpAssignment_1_1_0.eContents().get(0);
		private final Assignment cOpAssignment_1_1_1 = (Assignment)cAlternatives_1_1.eContents().get(1);
		private final RuleCall cOpNOTEQUALTerminalRuleCall_1_1_1_0 = (RuleCall)cOpAssignment_1_1_1.eContents().get(0);
		private final Assignment cOpAssignment_1_1_2 = (Assignment)cAlternatives_1_1.eContents().get(2);
		private final Keyword cOpCircumflexAccentEqualsSignKeyword_1_1_2_0 = (Keyword)cOpAssignment_1_1_2.eContents().get(0);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightRelationalExpressionParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		/// * used in list comprehension
		// * 
		// * "in", precedence: 400, 400
		// * / / *InExpression returns Expr hidden(WS,SL_COMMENT):
		//  RelationalExpression
		//  ( {CaseExpression.left=current} op='in' right = RelationalExpression)?
		//;* / / * 
		// * "~=", precedence: 400, 400
		// * "^=", precedence: 400, 400
		// * "=", precedence: 400, 400
		// * / EqualityExpression returns Expr hidden(WS, SL_COMMENT):
		//	RelationalExpression // ambigous because EQ can be in top level expression
		//	({EqualityExpression.left=current} (op=EQUAL | op=NOTEQUAL | op="^=") right=RelationalExpression)*;
		public ParserRule getRule() { return rule; }

		//RelationalExpression // ambigous because EQ can be in top level expression
		//({EqualityExpression.left=current} (op=EQUAL | op=NOTEQUAL | op="^=") right=RelationalExpression)*
		public Group getGroup() { return cGroup; }

		//RelationalExpression
		public RuleCall getRelationalExpressionParserRuleCall_0() { return cRelationalExpressionParserRuleCall_0; }

		//({EqualityExpression.left=current} (op=EQUAL | op=NOTEQUAL | op="^=") right=RelationalExpression)*
		public Group getGroup_1() { return cGroup_1; }

		//{EqualityExpression.left=current}
		public Action getEqualityExpressionLeftAction_1_0() { return cEqualityExpressionLeftAction_1_0; }

		//op=EQUAL | op=NOTEQUAL | op="^="
		public Alternatives getAlternatives_1_1() { return cAlternatives_1_1; }

		//op=EQUAL
		public Assignment getOpAssignment_1_1_0() { return cOpAssignment_1_1_0; }

		//EQUAL
		public RuleCall getOpEQUALTerminalRuleCall_1_1_0_0() { return cOpEQUALTerminalRuleCall_1_1_0_0; }

		//op=NOTEQUAL
		public Assignment getOpAssignment_1_1_1() { return cOpAssignment_1_1_1; }

		//NOTEQUAL
		public RuleCall getOpNOTEQUALTerminalRuleCall_1_1_1_0() { return cOpNOTEQUALTerminalRuleCall_1_1_1_0; }

		//op="^="
		public Assignment getOpAssignment_1_1_2() { return cOpAssignment_1_1_2; }

		//"^="
		public Keyword getOpCircumflexAccentEqualsSignKeyword_1_1_2_0() { return cOpCircumflexAccentEqualsSignKeyword_1_1_2_0; }

		//right=RelationalExpression
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }

		//RelationalExpression
		public RuleCall getRightRelationalExpressionParserRuleCall_1_2_0() { return cRightRelationalExpressionParserRuleCall_1_2_0; }
	}

	public class RelationalExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "RelationalExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cIsExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cRelationalExpressionLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Alternatives cAlternatives_1_1 = (Alternatives)cGroup_1.eContents().get(1);
		private final Assignment cOpAssignment_1_1_0 = (Assignment)cAlternatives_1_1.eContents().get(0);
		private final RuleCall cOpLTTerminalRuleCall_1_1_0_0 = (RuleCall)cOpAssignment_1_1_0.eContents().get(0);
		private final Assignment cOpAssignment_1_1_1 = (Assignment)cAlternatives_1_1.eContents().get(1);
		private final RuleCall cOpGTTerminalRuleCall_1_1_1_0 = (RuleCall)cOpAssignment_1_1_1.eContents().get(0);
		private final Assignment cOpAssignment_1_1_2 = (Assignment)cAlternatives_1_1.eContents().get(2);
		private final RuleCall cOpLETerminalRuleCall_1_1_2_0 = (RuleCall)cOpAssignment_1_1_2.eContents().get(0);
		private final Assignment cOpAssignment_1_1_3 = (Assignment)cAlternatives_1_1.eContents().get(3);
		private final RuleCall cOpGETerminalRuleCall_1_1_3_0 = (RuleCall)cOpAssignment_1_1_3.eContents().get(0);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightIsExpressionParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		/// * 
		// * ">=", precedence: 400, 400
		// * "<=", precedence: 400, 400
		// * ">>", precedence: 400, 400
		// * "<<", precedence: 400, 400
		// * ">", precedence: 400, 400
		// * "<", precedence: 400, 400
		// * / RelationalExpression returns Expr hidden(WS, SL_COMMENT):
		//	IsExpression ({RelationalExpression.left=current} (op=LT | op=GT | op=LE | op=GE) right=IsExpression)?;
		public ParserRule getRule() { return rule; }

		//IsExpression ({RelationalExpression.left=current} (op=LT | op=GT | op=LE | op=GE) right=IsExpression)?
		public Group getGroup() { return cGroup; }

		//IsExpression
		public RuleCall getIsExpressionParserRuleCall_0() { return cIsExpressionParserRuleCall_0; }

		//({RelationalExpression.left=current} (op=LT | op=GT | op=LE | op=GE) right=IsExpression)?
		public Group getGroup_1() { return cGroup_1; }

		//{RelationalExpression.left=current}
		public Action getRelationalExpressionLeftAction_1_0() { return cRelationalExpressionLeftAction_1_0; }

		//op=LT | op=GT | op=LE | op=GE
		public Alternatives getAlternatives_1_1() { return cAlternatives_1_1; }

		//op=LT
		public Assignment getOpAssignment_1_1_0() { return cOpAssignment_1_1_0; }

		//LT
		public RuleCall getOpLTTerminalRuleCall_1_1_0_0() { return cOpLTTerminalRuleCall_1_1_0_0; }

		//op=GT
		public Assignment getOpAssignment_1_1_1() { return cOpAssignment_1_1_1; }

		//GT
		public RuleCall getOpGTTerminalRuleCall_1_1_1_0() { return cOpGTTerminalRuleCall_1_1_1_0; }

		//op=LE
		public Assignment getOpAssignment_1_1_2() { return cOpAssignment_1_1_2; }

		//LE
		public RuleCall getOpLETerminalRuleCall_1_1_2_0() { return cOpLETerminalRuleCall_1_1_2_0; }

		//op=GE
		public Assignment getOpAssignment_1_1_3() { return cOpAssignment_1_1_3; }

		//GE
		public RuleCall getOpGETerminalRuleCall_1_1_3_0() { return cOpGETerminalRuleCall_1_1_3_0; }

		//right=IsExpression
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }

		//IsExpression
		public RuleCall getRightIsExpressionParserRuleCall_1_2_0() { return cRightIsExpressionParserRuleCall_1_2_0; }
	}

	public class IsExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "IsExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cSegmentExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cIsExpressionLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Alternatives cAlternatives_1_1 = (Alternatives)cGroup_1.eContents().get(1);
		private final Assignment cOpAssignment_1_1_0 = (Assignment)cAlternatives_1_1.eContents().get(0);
		private final Keyword cOpIsKeyword_1_1_0_0 = (Keyword)cOpAssignment_1_1_0.eContents().get(0);
		private final Assignment cOpAssignment_1_1_1 = (Assignment)cAlternatives_1_1.eContents().get(1);
		private final Keyword cOpIsntKeyword_1_1_1_0 = (Keyword)cOpAssignment_1_1_1.eContents().get(0);
		private final Assignment cRightTypeAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightTypeTypeExpressionParserRuleCall_1_2_0 = (RuleCall)cRightTypeAssignment_1_2.eContents().get(0);
		
		/// * 
		// * 
		// * "isnt", precedence: 400, 400
		// * "is", precedence: 400, 400
		// * / IsExpression returns Expr hidden(WS, SL_COMMENT):
		//	SegmentExpression ({IsExpression.left=current} (op="is" | op="isnt") rightType=TypeExpression)*;
		public ParserRule getRule() { return rule; }

		//SegmentExpression ({IsExpression.left=current} (op="is" | op="isnt") rightType=TypeExpression)*
		public Group getGroup() { return cGroup; }

		//SegmentExpression
		public RuleCall getSegmentExpressionParserRuleCall_0() { return cSegmentExpressionParserRuleCall_0; }

		//({IsExpression.left=current} (op="is" | op="isnt") rightType=TypeExpression)*
		public Group getGroup_1() { return cGroup_1; }

		//{IsExpression.left=current}
		public Action getIsExpressionLeftAction_1_0() { return cIsExpressionLeftAction_1_0; }

		//op="is" | op="isnt"
		public Alternatives getAlternatives_1_1() { return cAlternatives_1_1; }

		//op="is"
		public Assignment getOpAssignment_1_1_0() { return cOpAssignment_1_1_0; }

		//"is"
		public Keyword getOpIsKeyword_1_1_0_0() { return cOpIsKeyword_1_1_0_0; }

		//op="isnt"
		public Assignment getOpAssignment_1_1_1() { return cOpAssignment_1_1_1; }

		//"isnt"
		public Keyword getOpIsntKeyword_1_1_1_0() { return cOpIsntKeyword_1_1_1_0; }

		//rightType=TypeExpression
		public Assignment getRightTypeAssignment_1_2() { return cRightTypeAssignment_1_2; }

		//TypeExpression
		public RuleCall getRightTypeTypeExpressionParserRuleCall_1_2_0() { return cRightTypeTypeExpressionParserRuleCall_1_2_0; }
	}

	public class SegmentExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "SegmentExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cAdditiveExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cSegmentExpressionLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOpAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOpSEGTerminalRuleCall_1_1_0 = (RuleCall)cOpAssignment_1_1.eContents().get(0);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightAdditiveExpressionParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		/// * 
		// * "..", "SEGMENT",  precedence: 401, 699, ["parse_Seg"]
		// * / SegmentExpression returns Expr hidden(WS, SL_COMMENT):
		//	AdditiveExpression ({SegmentExpression.left=current} op=SEG right=AdditiveExpression)*;
		public ParserRule getRule() { return rule; }

		//AdditiveExpression ({SegmentExpression.left=current} op=SEG right=AdditiveExpression)*
		public Group getGroup() { return cGroup; }

		//AdditiveExpression
		public RuleCall getAdditiveExpressionParserRuleCall_0() { return cAdditiveExpressionParserRuleCall_0; }

		//({SegmentExpression.left=current} op=SEG right=AdditiveExpression)*
		public Group getGroup_1() { return cGroup_1; }

		//{SegmentExpression.left=current}
		public Action getSegmentExpressionLeftAction_1_0() { return cSegmentExpressionLeftAction_1_0; }

		//op=SEG
		public Assignment getOpAssignment_1_1() { return cOpAssignment_1_1; }

		//SEG
		public RuleCall getOpSEGTerminalRuleCall_1_1_0() { return cOpSEGTerminalRuleCall_1_1_0; }

		//right=AdditiveExpression
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }

		//AdditiveExpression
		public RuleCall getRightAdditiveExpressionParserRuleCall_1_2_0() { return cRightAdditiveExpressionParserRuleCall_1_2_0; }
	}

	public class AdditiveExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "AdditiveExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cExquoExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cAdditiveExpressionLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Alternatives cAlternatives_1_1 = (Alternatives)cGroup_1.eContents().get(1);
		private final Assignment cOpAssignment_1_1_0 = (Assignment)cAlternatives_1_1.eContents().get(0);
		private final RuleCall cOpPLUSTerminalRuleCall_1_1_0_0 = (RuleCall)cOpAssignment_1_1_0.eContents().get(0);
		private final Assignment cOpAssignment_1_1_1 = (Assignment)cAlternatives_1_1.eContents().get(1);
		private final RuleCall cOpMINUSTerminalRuleCall_1_1_1_0 = (RuleCall)cOpAssignment_1_1_1.eContents().get(0);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightExquoExpressionParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		/// *
		// * add expression
		// * we include both '+' and '-' in the same case as this allows a
		// * multiple sequence like:
		// * a + b + c - d + e -f
		// * 
		// * "-",  precedence: 700, 701
		// * "+",  precedence: 700, 701
		// 
		// * / AdditiveExpression returns Expr hidden(WS, SL_COMMENT):
		//	ExquoExpression ({AdditiveExpression.left=current} (op=PLUS | op=MINUS) right=ExquoExpression)*;
		public ParserRule getRule() { return rule; }

		//ExquoExpression ({AdditiveExpression.left=current} (op=PLUS | op=MINUS) right=ExquoExpression)*
		public Group getGroup() { return cGroup; }

		//ExquoExpression
		public RuleCall getExquoExpressionParserRuleCall_0() { return cExquoExpressionParserRuleCall_0; }

		//({AdditiveExpression.left=current} (op=PLUS | op=MINUS) right=ExquoExpression)*
		public Group getGroup_1() { return cGroup_1; }

		//{AdditiveExpression.left=current}
		public Action getAdditiveExpressionLeftAction_1_0() { return cAdditiveExpressionLeftAction_1_0; }

		//op=PLUS | op=MINUS
		public Alternatives getAlternatives_1_1() { return cAlternatives_1_1; }

		//op=PLUS
		public Assignment getOpAssignment_1_1_0() { return cOpAssignment_1_1_0; }

		//PLUS
		public RuleCall getOpPLUSTerminalRuleCall_1_1_0_0() { return cOpPLUSTerminalRuleCall_1_1_0_0; }

		//op=MINUS
		public Assignment getOpAssignment_1_1_1() { return cOpAssignment_1_1_1; }

		//MINUS
		public RuleCall getOpMINUSTerminalRuleCall_1_1_1_0() { return cOpMINUSTerminalRuleCall_1_1_1_0; }

		//right=ExquoExpression
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }

		//ExquoExpression
		public RuleCall getRightExquoExpressionParserRuleCall_1_2_0() { return cRightExquoExpressionParserRuleCall_1_2_0; }
	}

	public class ExquoExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ExquoExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cDivisionExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cExquoExpressionLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOpAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final Keyword cOpExquoKeyword_1_1_0 = (Keyword)cOpAssignment_1_1.eContents().get(0);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightDivisionExpressionParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		/// * 
		// * "exquo",  precedence: 800, 801
		// * / ExquoExpression returns Expr hidden(WS, SL_COMMENT):
		//	DivisionExpression ({ExquoExpression.left=current} op="exquo" right=DivisionExpression)*;
		public ParserRule getRule() { return rule; }

		//DivisionExpression ({ExquoExpression.left=current} op="exquo" right=DivisionExpression)*
		public Group getGroup() { return cGroup; }

		//DivisionExpression
		public RuleCall getDivisionExpressionParserRuleCall_0() { return cDivisionExpressionParserRuleCall_0; }

		//({ExquoExpression.left=current} op="exquo" right=DivisionExpression)*
		public Group getGroup_1() { return cGroup_1; }

		//{ExquoExpression.left=current}
		public Action getExquoExpressionLeftAction_1_0() { return cExquoExpressionLeftAction_1_0; }

		//op="exquo"
		public Assignment getOpAssignment_1_1() { return cOpAssignment_1_1; }

		//"exquo"
		public Keyword getOpExquoKeyword_1_1_0() { return cOpExquoKeyword_1_1_0; }

		//right=DivisionExpression
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }

		//DivisionExpression
		public RuleCall getRightDivisionExpressionParserRuleCall_1_2_0() { return cRightDivisionExpressionParserRuleCall_1_2_0; }
	}

	public class DivisionExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "DivisionExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cQuoExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cDivisionExpressionLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOpAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOpSLASHTerminalRuleCall_1_1_0 = (RuleCall)cOpAssignment_1_1.eContents().get(0);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightQuoExpressionParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		/// *
		// * division expression
		// * "/",  precedence: 800, 801
		// * / DivisionExpression returns Expr hidden(WS, SL_COMMENT):
		//	QuoExpression ({DivisionExpression.left=current} op=SLASH right=QuoExpression)*;
		public ParserRule getRule() { return rule; }

		//QuoExpression ({DivisionExpression.left=current} op=SLASH right=QuoExpression)*
		public Group getGroup() { return cGroup; }

		//QuoExpression
		public RuleCall getQuoExpressionParserRuleCall_0() { return cQuoExpressionParserRuleCall_0; }

		//({DivisionExpression.left=current} op=SLASH right=QuoExpression)*
		public Group getGroup_1() { return cGroup_1; }

		//{DivisionExpression.left=current}
		public Action getDivisionExpressionLeftAction_1_0() { return cDivisionExpressionLeftAction_1_0; }

		//op=SLASH
		public Assignment getOpAssignment_1_1() { return cOpAssignment_1_1; }

		//SLASH
		public RuleCall getOpSLASHTerminalRuleCall_1_1_0() { return cOpSLASHTerminalRuleCall_1_1_0; }

		//right=QuoExpression
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }

		//QuoExpression
		public RuleCall getRightQuoExpressionParserRuleCall_1_2_0() { return cRightQuoExpressionParserRuleCall_1_2_0; }
	}

	public class QuoExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "QuoExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cModExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cQuoExpressionLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOpAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final Keyword cOpQuoKeyword_1_1_0 = (Keyword)cOpAssignment_1_1.eContents().get(0);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightModExpressionParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		/// * 
		// *"quo",  precedence: 800, 801
		// * / QuoExpression returns Expr hidden(WS, SL_COMMENT):
		//	ModExpression ({QuoExpression.left=current} op="quo" right=ModExpression)*;
		public ParserRule getRule() { return rule; }

		//ModExpression ({QuoExpression.left=current} op="quo" right=ModExpression)*
		public Group getGroup() { return cGroup; }

		//ModExpression
		public RuleCall getModExpressionParserRuleCall_0() { return cModExpressionParserRuleCall_0; }

		//({QuoExpression.left=current} op="quo" right=ModExpression)*
		public Group getGroup_1() { return cGroup_1; }

		//{QuoExpression.left=current}
		public Action getQuoExpressionLeftAction_1_0() { return cQuoExpressionLeftAction_1_0; }

		//op="quo"
		public Assignment getOpAssignment_1_1() { return cOpAssignment_1_1; }

		//"quo"
		public Keyword getOpQuoKeyword_1_1_0() { return cOpQuoKeyword_1_1_0; }

		//right=ModExpression
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }

		//ModExpression
		public RuleCall getRightModExpressionParserRuleCall_1_2_0() { return cRightModExpressionParserRuleCall_1_2_0; }
	}

	public class ModExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ModExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cRemExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cModExpressionLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOpAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final Keyword cOpModKeyword_1_1_0 = (Keyword)cOpAssignment_1_1.eContents().get(0);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightRemExpressionParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		/// * 
		// *"mod",  precedence: 800, 801
		// * / ModExpression returns Expr hidden(WS, SL_COMMENT):
		//	RemExpression ({ModExpression.left=current} op="mod" right=RemExpression)*;
		public ParserRule getRule() { return rule; }

		//RemExpression ({ModExpression.left=current} op="mod" right=RemExpression)*
		public Group getGroup() { return cGroup; }

		//RemExpression
		public RuleCall getRemExpressionParserRuleCall_0() { return cRemExpressionParserRuleCall_0; }

		//({ModExpression.left=current} op="mod" right=RemExpression)*
		public Group getGroup_1() { return cGroup_1; }

		//{ModExpression.left=current}
		public Action getModExpressionLeftAction_1_0() { return cModExpressionLeftAction_1_0; }

		//op="mod"
		public Assignment getOpAssignment_1_1() { return cOpAssignment_1_1; }

		//"mod"
		public Keyword getOpModKeyword_1_1_0() { return cOpModKeyword_1_1_0; }

		//right=RemExpression
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }

		//RemExpression
		public RuleCall getRightRemExpressionParserRuleCall_1_2_0() { return cRightRemExpressionParserRuleCall_1_2_0; }
	}

	public class RemExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "RemExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cMultiplicativeExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cRemExpressionLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOpAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final Keyword cOpRemKeyword_1_1_0 = (Keyword)cOpAssignment_1_1.eContents().get(0);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightMultiplicativeExpressionParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		/// * 
		// *"rem", precedence: 800, 801
		// * / RemExpression returns Expr hidden(WS, SL_COMMENT):
		//	MultiplicativeExpression ({RemExpression.left=current} op="rem" right=MultiplicativeExpression)*;
		public ParserRule getRule() { return rule; }

		//MultiplicativeExpression ({RemExpression.left=current} op="rem" right=MultiplicativeExpression)*
		public Group getGroup() { return cGroup; }

		//MultiplicativeExpression
		public RuleCall getMultiplicativeExpressionParserRuleCall_0() { return cMultiplicativeExpressionParserRuleCall_0; }

		//({RemExpression.left=current} op="rem" right=MultiplicativeExpression)*
		public Group getGroup_1() { return cGroup_1; }

		//{RemExpression.left=current}
		public Action getRemExpressionLeftAction_1_0() { return cRemExpressionLeftAction_1_0; }

		//op="rem"
		public Assignment getOpAssignment_1_1() { return cOpAssignment_1_1; }

		//"rem"
		public Keyword getOpRemKeyword_1_1_0() { return cOpRemKeyword_1_1_0; }

		//right=MultiplicativeExpression
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }

		//MultiplicativeExpression
		public RuleCall getRightMultiplicativeExpressionParserRuleCall_1_2_0() { return cRightMultiplicativeExpressionParserRuleCall_1_2_0; }
	}

	public class MultiplicativeExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "MultiplicativeExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cExponentExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cMultiplicativeExpressionLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOpAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOpTIMESTerminalRuleCall_1_1_0 = (RuleCall)cOpAssignment_1_1.eContents().get(0);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightExponentExpressionParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		/// *
		// * multiplication expression
		// * a * b * c
		// * 
		// * "*", precedence: 800, 801
		// * / MultiplicativeExpression returns Expr hidden(WS, SL_COMMENT):
		//	ExponentExpression ({MultiplicativeExpression.left=current} op=TIMES right=ExponentExpression)*;
		public ParserRule getRule() { return rule; }

		//ExponentExpression ({MultiplicativeExpression.left=current} op=TIMES right=ExponentExpression)*
		public Group getGroup() { return cGroup; }

		//ExponentExpression
		public RuleCall getExponentExpressionParserRuleCall_0() { return cExponentExpressionParserRuleCall_0; }

		//({MultiplicativeExpression.left=current} op=TIMES right=ExponentExpression)*
		public Group getGroup_1() { return cGroup_1; }

		//{MultiplicativeExpression.left=current}
		public Action getMultiplicativeExpressionLeftAction_1_0() { return cMultiplicativeExpressionLeftAction_1_0; }

		//op=TIMES
		public Assignment getOpAssignment_1_1() { return cOpAssignment_1_1; }

		//TIMES
		public RuleCall getOpTIMESTerminalRuleCall_1_1_0() { return cOpTIMESTerminalRuleCall_1_1_0; }

		//right=ExponentExpression
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }

		//ExponentExpression
		public RuleCall getRightExponentExpressionParserRuleCall_1_2_0() { return cRightExponentExpressionParserRuleCall_1_2_0; }
	}

	public class ExponentExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ExponentExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cMapDefinitionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cExponentExpressionLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Alternatives cAlternatives_1_1 = (Alternatives)cGroup_1.eContents().get(1);
		private final Assignment cOpAssignment_1_1_0 = (Assignment)cAlternatives_1_1.eContents().get(0);
		private final RuleCall cOpCARATTerminalRuleCall_1_1_0_0 = (RuleCall)cOpAssignment_1_1_0.eContents().get(0);
		private final Assignment cOpAssignment_1_1_1 = (Assignment)cAlternatives_1_1.eContents().get(1);
		private final RuleCall cOpPOWERTerminalRuleCall_1_1_1_0 = (RuleCall)cOpAssignment_1_1_1.eContents().get(0);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightMapDefinitionParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		/// * 
		// *
		// * "^", precedence: 901, 900
		// * "**", precedence: 901, 900
		// * / ExponentExpression returns Expr hidden(WS, SL_COMMENT):
		//	MapDefinition ({ExponentExpression.left=current} (op=CARAT | op=POWER) right=MapDefinition)*;
		public ParserRule getRule() { return rule; }

		//MapDefinition ({ExponentExpression.left=current} (op=CARAT | op=POWER) right=MapDefinition)*
		public Group getGroup() { return cGroup; }

		//MapDefinition
		public RuleCall getMapDefinitionParserRuleCall_0() { return cMapDefinitionParserRuleCall_0; }

		//({ExponentExpression.left=current} (op=CARAT | op=POWER) right=MapDefinition)*
		public Group getGroup_1() { return cGroup_1; }

		//{ExponentExpression.left=current}
		public Action getExponentExpressionLeftAction_1_0() { return cExponentExpressionLeftAction_1_0; }

		//op=CARAT | op=POWER
		public Alternatives getAlternatives_1_1() { return cAlternatives_1_1; }

		//op=CARAT
		public Assignment getOpAssignment_1_1_0() { return cOpAssignment_1_1_0; }

		//CARAT
		public RuleCall getOpCARATTerminalRuleCall_1_1_0_0() { return cOpCARATTerminalRuleCall_1_1_0_0; }

		//op=POWER
		public Assignment getOpAssignment_1_1_1() { return cOpAssignment_1_1_1; }

		//POWER
		public RuleCall getOpPOWERTerminalRuleCall_1_1_1_0() { return cOpPOWERTerminalRuleCall_1_1_1_0; }

		//right=MapDefinition
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }

		//MapDefinition
		public RuleCall getRightMapDefinitionParserRuleCall_1_2_0() { return cRightMapDefinitionParserRuleCall_1_2_0; }
	}

	public class MapDefinitionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "MapDefinition");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cPretendExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cMapDefinitionLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOpAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOpGIVESTerminalRuleCall_1_1_0 = (RuleCall)cOpAssignment_1_1.eContents().get(0);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightPretendExpressionParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		/// * Map or Lambda expression
		// * var +-> function 	
		// * 
		// * +-> is an infix operator meaning 'maps-to'
		// * It can be used to create a function literal (an anonymous function), so
		// * instead of:
		// * myFunct(x:Type):Type == if x >0 then x else -x
		// * we can have:
		// * x +-> if x >0 then x else -x
		// * 
		// *  * "+->", precedence: 995, 112
		// * / MapDefinition returns Expr hidden(WS, SL_COMMENT):
		//	PretendExpression ({MapDefinition.left=current} op=GIVES right=PretendExpression)*;
		public ParserRule getRule() { return rule; }

		//PretendExpression ({MapDefinition.left=current} op=GIVES right=PretendExpression)*
		public Group getGroup() { return cGroup; }

		//PretendExpression
		public RuleCall getPretendExpressionParserRuleCall_0() { return cPretendExpressionParserRuleCall_0; }

		//({MapDefinition.left=current} op=GIVES right=PretendExpression)*
		public Group getGroup_1() { return cGroup_1; }

		//{MapDefinition.left=current}
		public Action getMapDefinitionLeftAction_1_0() { return cMapDefinitionLeftAction_1_0; }

		//op=GIVES
		public Assignment getOpAssignment_1_1() { return cOpAssignment_1_1; }

		//GIVES
		public RuleCall getOpGIVESTerminalRuleCall_1_1_0() { return cOpGIVESTerminalRuleCall_1_1_0; }

		//right=PretendExpression
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }

		//PretendExpression
		public RuleCall getRightPretendExpressionParserRuleCall_1_2_0() { return cRightPretendExpressionParserRuleCall_1_2_0; }
	}

	public class PretendExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PretendExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cHintTypeExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cPretendExpressionLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOpAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final Keyword cOpPretendKeyword_1_1_0 = (Keyword)cOpAssignment_1_1.eContents().get(0);
		private final Assignment cRightTypeAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightTypeTypeExpressionParserRuleCall_1_2_0 = (RuleCall)cRightTypeAssignment_1_2.eContents().get(0);
		
		/// *MapDefinition hidden(WS):
		//	fnSig=FunctionSignature
		//    (COLON par4=TypeExpression)?
		//    GIVES par5=Statement
		//;* / / *
		// * pretend Type: treat one type as another,
		// * only works if they have the same internal structure.
		// * 
		// * Not very safe and should be avoided, if possible, unfortunately
		// * its not always possible to avoid.
		// * 
		// * "pretend", precedence: 995, 996
		// * / PretendExpression returns Expr hidden(WS, SL_COMMENT):
		//	HintTypeExpression ({PretendExpression.left=current} op="pretend" rightType=TypeExpression)*;
		public ParserRule getRule() { return rule; }

		//HintTypeExpression ({PretendExpression.left=current} op="pretend" rightType=TypeExpression)*
		public Group getGroup() { return cGroup; }

		//HintTypeExpression
		public RuleCall getHintTypeExpressionParserRuleCall_0() { return cHintTypeExpressionParserRuleCall_0; }

		//({PretendExpression.left=current} op="pretend" rightType=TypeExpression)*
		public Group getGroup_1() { return cGroup_1; }

		//{PretendExpression.left=current}
		public Action getPretendExpressionLeftAction_1_0() { return cPretendExpressionLeftAction_1_0; }

		//op="pretend"
		public Assignment getOpAssignment_1_1() { return cOpAssignment_1_1; }

		//"pretend"
		public Keyword getOpPretendKeyword_1_1_0() { return cOpPretendKeyword_1_1_0; }

		//rightType=TypeExpression
		public Assignment getRightTypeAssignment_1_2() { return cRightTypeAssignment_1_2; }

		//TypeExpression
		public RuleCall getRightTypeTypeExpressionParserRuleCall_1_2_0() { return cRightTypeTypeExpressionParserRuleCall_1_2_0; }
	}

	public class HintTypeExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "HintTypeExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cCoerceExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cHintTypeExpressionLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOpAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOpATTerminalRuleCall_1_1_0 = (RuleCall)cOpAssignment_1_1.eContents().get(0);
		private final Assignment cRightTypeAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightTypeTypeExpressionParserRuleCall_1_2_0 = (RuleCall)cRightTypeAssignment_1_2.eContents().get(0);
		
		/// * 
		// * "@", precedence: 996, 997
		// * / HintTypeExpression returns Expr hidden(WS, SL_COMMENT):
		//	CoerceExpression ({HintTypeExpression.left=current} op=AT rightType=TypeExpression)?;
		public ParserRule getRule() { return rule; }

		//CoerceExpression ({HintTypeExpression.left=current} op=AT rightType=TypeExpression)?
		public Group getGroup() { return cGroup; }

		//CoerceExpression
		public RuleCall getCoerceExpressionParserRuleCall_0() { return cCoerceExpressionParserRuleCall_0; }

		//({HintTypeExpression.left=current} op=AT rightType=TypeExpression)?
		public Group getGroup_1() { return cGroup_1; }

		//{HintTypeExpression.left=current}
		public Action getHintTypeExpressionLeftAction_1_0() { return cHintTypeExpressionLeftAction_1_0; }

		//op=AT
		public Assignment getOpAssignment_1_1() { return cOpAssignment_1_1; }

		//AT
		public RuleCall getOpATTerminalRuleCall_1_1_0() { return cOpATTerminalRuleCall_1_1_0; }

		//rightType=TypeExpression
		public Assignment getRightTypeAssignment_1_2() { return cRightTypeAssignment_1_2; }

		//TypeExpression
		public RuleCall getRightTypeTypeExpressionParserRuleCall_1_2_0() { return cRightTypeTypeExpressionParserRuleCall_1_2_0; }
	}

	public class CoerceExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "CoerceExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cEltExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cCoerceExpressionLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOpAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOpCOERCETerminalRuleCall_1_1_0 = (RuleCall)cOpAssignment_1_1.eContents().get(0);
		private final Assignment cRightTypeAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightTypeTypeExpressionParserRuleCall_1_2_0 = (RuleCall)cRightTypeAssignment_1_2.eContents().get(0);
		
		/// * 
		// * "::", precedence: 996, 997
		// * / CoerceExpression returns Expr hidden(WS, SL_COMMENT):
		//	EltExpression ({CoerceExpression.left=current} op=COERCE rightType=TypeExpression)*;
		public ParserRule getRule() { return rule; }

		//EltExpression ({CoerceExpression.left=current} op=COERCE rightType=TypeExpression)*
		public Group getGroup() { return cGroup; }

		//EltExpression
		public RuleCall getEltExpressionParserRuleCall_0() { return cEltExpressionParserRuleCall_0; }

		//({CoerceExpression.left=current} op=COERCE rightType=TypeExpression)*
		public Group getGroup_1() { return cGroup_1; }

		//{CoerceExpression.left=current}
		public Action getCoerceExpressionLeftAction_1_0() { return cCoerceExpressionLeftAction_1_0; }

		//op=COERCE
		public Assignment getOpAssignment_1_1() { return cOpAssignment_1_1; }

		//COERCE
		public RuleCall getOpCOERCETerminalRuleCall_1_1_0() { return cOpCOERCETerminalRuleCall_1_1_0; }

		//rightType=TypeExpression
		public Assignment getRightTypeAssignment_1_2() { return cRightTypeAssignment_1_2; }

		//TypeExpression
		public RuleCall getRightTypeTypeExpressionParserRuleCall_1_2_0() { return cRightTypeTypeExpressionParserRuleCall_1_2_0; }
	}

	public class EltExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "EltExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cExplicitTypeExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cEltExpressionLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOpAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOpDOTTerminalRuleCall_1_1_0 = (RuleCall)cOpAssignment_1_1.eContents().get(0);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightExplicitTypeExpressionParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		/// * We treat these as part of the language
		// * : indicates type
		// * ! is part of name to indicate mutable
		// * 
		// * ":", precedence: 996, 997
		// * "!", precedence: 1002, 1001
		// *
		// * / / *BangExpression returns Expr hidden(WS,SL_COMMENT):
		//  EqualityExpression
		//  ({AndExpression.left=current} op=AMPERSAND right = EqualityExpression)*
		//;* / / * 
		// * "with",  precedence: 2000, 400, ["parse_InfixWith"]
		// *
		// * / / *WithExpression returns Expr hidden(WS,SL_COMMENT):
		//  EqualityExpression
		//  ({AndExpression.left=current} op='with' right = EqualityExpression)*
		//;* / / * Elt is Lisp terminology for the use of '.' to select parameters
		// * the left expression is something that has selectable elements such as
		// * a list, array, string, Record or union, the right element should be a
		// * non-negative integer.
		// * / EltExpression returns Expr hidden(WS, SL_COMMENT):
		//	ExplicitTypeExpression ({EltExpression.left=current} op=DOT right=ExplicitTypeExpression)*;
		public ParserRule getRule() { return rule; }

		//ExplicitTypeExpression ({EltExpression.left=current} op=DOT right=ExplicitTypeExpression)*
		public Group getGroup() { return cGroup; }

		//ExplicitTypeExpression
		public RuleCall getExplicitTypeExpressionParserRuleCall_0() { return cExplicitTypeExpressionParserRuleCall_0; }

		//({EltExpression.left=current} op=DOT right=ExplicitTypeExpression)*
		public Group getGroup_1() { return cGroup_1; }

		//{EltExpression.left=current}
		public Action getEltExpressionLeftAction_1_0() { return cEltExpressionLeftAction_1_0; }

		//op=DOT
		public Assignment getOpAssignment_1_1() { return cOpAssignment_1_1; }

		//DOT
		public RuleCall getOpDOTTerminalRuleCall_1_1_0() { return cOpDOTTerminalRuleCall_1_1_0; }

		//right=ExplicitTypeExpression
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }

		//ExplicitTypeExpression
		public RuleCall getRightExplicitTypeExpressionParserRuleCall_1_2_0() { return cRightExplicitTypeExpressionParserRuleCall_1_2_0; }
	}

	public class ExplicitTypeExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ExplicitTypeExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cUnaryExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cExplicitTypeExpressionLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOpAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOpDOLARTerminalRuleCall_1_1_0 = (RuleCall)cOpAssignment_1_1.eContents().get(0);
		private final Assignment cRightTypeAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightTypeTypeExpressionParserRuleCall_1_2_0 = (RuleCall)cRightTypeAssignment_1_2.eContents().get(0);
		
		//////////////// unary expressions ////////////////////
		/// * 
		// * '$'
		// * / ExplicitTypeExpression returns Expr hidden(WS, SL_COMMENT):
		//	UnaryExpression ({ExplicitTypeExpression.left=current} op=DOLAR rightType=TypeExpression)?;
		public ParserRule getRule() { return rule; }

		//UnaryExpression ({ExplicitTypeExpression.left=current} op=DOLAR rightType=TypeExpression)?
		public Group getGroup() { return cGroup; }

		//UnaryExpression
		public RuleCall getUnaryExpressionParserRuleCall_0() { return cUnaryExpressionParserRuleCall_0; }

		//({ExplicitTypeExpression.left=current} op=DOLAR rightType=TypeExpression)?
		public Group getGroup_1() { return cGroup_1; }

		//{ExplicitTypeExpression.left=current}
		public Action getExplicitTypeExpressionLeftAction_1_0() { return cExplicitTypeExpressionLeftAction_1_0; }

		//op=DOLAR
		public Assignment getOpAssignment_1_1() { return cOpAssignment_1_1; }

		//DOLAR
		public RuleCall getOpDOLARTerminalRuleCall_1_1_0() { return cOpDOLARTerminalRuleCall_1_1_0; }

		//rightType=TypeExpression
		public Assignment getRightTypeAssignment_1_2() { return cRightTypeAssignment_1_2; }

		//TypeExpression
		public RuleCall getRightTypeTypeExpressionParserRuleCall_1_2_0() { return cRightTypeTypeExpressionParserRuleCall_1_2_0; }
	}

	public class UnaryExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "UnaryExpression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cPrimaryExpressionParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Action cUnaryExpressionAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cUopAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cUopTILDETerminalRuleCall_1_1_0 = (RuleCall)cUopAssignment_1_1.eContents().get(0);
		private final Assignment cExprAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cExprUnaryExpressionParserRuleCall_1_2_0 = (RuleCall)cExprAssignment_1_2.eContents().get(0);
		private final Group cGroup_2 = (Group)cAlternatives.eContents().get(2);
		private final Action cUnaryExpressionAction_2_0 = (Action)cGroup_2.eContents().get(0);
		private final Assignment cUopAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cUopCOLONTerminalRuleCall_2_1_0 = (RuleCall)cUopAssignment_2_1.eContents().get(0);
		private final Assignment cExprAssignment_2_2 = (Assignment)cGroup_2.eContents().get(2);
		private final RuleCall cExprUnaryExpressionParserRuleCall_2_2_0 = (RuleCall)cExprAssignment_2_2.eContents().get(0);
		private final Group cGroup_3 = (Group)cAlternatives.eContents().get(3);
		private final Action cUnaryExpressionAction_3_0 = (Action)cGroup_3.eContents().get(0);
		private final Assignment cUopAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final RuleCall cUopMINUSTerminalRuleCall_3_1_0 = (RuleCall)cUopAssignment_3_1.eContents().get(0);
		private final Assignment cExprAssignment_3_2 = (Assignment)cGroup_3.eContents().get(2);
		private final RuleCall cExprUnaryExpressionParserRuleCall_3_2_0 = (RuleCall)cExprAssignment_3_2.eContents().get(0);
		private final Group cGroup_4 = (Group)cAlternatives.eContents().get(4);
		private final Action cUnaryExpressionAction_4_0 = (Action)cGroup_4.eContents().get(0);
		private final Assignment cUopAssignment_4_1 = (Assignment)cGroup_4.eContents().get(1);
		private final RuleCall cUopHASHTerminalRuleCall_4_1_0 = (RuleCall)cUopAssignment_4_1.eContents().get(0);
		private final Assignment cExprAssignment_4_2 = (Assignment)cGroup_4.eContents().get(2);
		private final RuleCall cExprUnaryExpressionParserRuleCall_4_2_0 = (RuleCall)cExprAssignment_4_2.eContents().get(0);
		private final Assignment cE2Assignment_5 = (Assignment)cAlternatives.eContents().get(5);
		private final RuleCall cE2PERCENTTerminalRuleCall_5_0 = (RuleCall)cE2Assignment_5.eContents().get(0);
		private final Assignment cE3Assignment_6 = (Assignment)cAlternatives.eContents().get(6);
		private final Keyword cE3TypeKeyword_6_0 = (Keyword)cE3Assignment_6.eContents().get(0);
		private final Group cGroup_7 = (Group)cAlternatives.eContents().get(7);
		private final Assignment cE5Assignment_7_0 = (Assignment)cGroup_7.eContents().get(0);
		private final Keyword cE5RecordKeyword_7_0_0 = (Keyword)cE5Assignment_7_0.eContents().get(0);
		private final RuleCall cLPARENTerminalRuleCall_7_1 = (RuleCall)cGroup_7.eContents().get(1);
		private final Assignment cE6Assignment_7_2 = (Assignment)cGroup_7.eContents().get(2);
		private final RuleCall cE6TypeExpressionParserRuleCall_7_2_0 = (RuleCall)cE6Assignment_7_2.eContents().get(0);
		private final Group cGroup_7_3 = (Group)cGroup_7.eContents().get(3);
		private final RuleCall cCOLONTerminalRuleCall_7_3_0 = (RuleCall)cGroup_7_3.eContents().get(0);
		private final Assignment cE22Assignment_7_3_1 = (Assignment)cGroup_7_3.eContents().get(1);
		private final RuleCall cE22TypeExpressionParserRuleCall_7_3_1_0 = (RuleCall)cE22Assignment_7_3_1.eContents().get(0);
		private final Group cGroup_7_4 = (Group)cGroup_7.eContents().get(4);
		private final RuleCall cCOMMATerminalRuleCall_7_4_0 = (RuleCall)cGroup_7_4.eContents().get(0);
		private final Assignment cE21Assignment_7_4_1 = (Assignment)cGroup_7_4.eContents().get(1);
		private final RuleCall cE21TypeExpressionParserRuleCall_7_4_1_0 = (RuleCall)cE21Assignment_7_4_1.eContents().get(0);
		private final Group cGroup_7_4_2 = (Group)cGroup_7_4.eContents().get(2);
		private final RuleCall cCOLONTerminalRuleCall_7_4_2_0 = (RuleCall)cGroup_7_4_2.eContents().get(0);
		private final Assignment cE23Assignment_7_4_2_1 = (Assignment)cGroup_7_4_2.eContents().get(1);
		private final RuleCall cE23TypeExpressionParserRuleCall_7_4_2_1_0 = (RuleCall)cE23Assignment_7_4_2_1.eContents().get(0);
		private final RuleCall cRPARENTerminalRuleCall_7_5 = (RuleCall)cGroup_7.eContents().get(5);
		private final Group cGroup_8 = (Group)cAlternatives.eContents().get(8);
		private final Assignment cE9Assignment_8_0 = (Assignment)cGroup_8.eContents().get(0);
		private final Keyword cE9UnionKeyword_8_0_0 = (Keyword)cE9Assignment_8_0.eContents().get(0);
		private final RuleCall cLPARENTerminalRuleCall_8_1 = (RuleCall)cGroup_8.eContents().get(1);
		private final Assignment cE10Assignment_8_2 = (Assignment)cGroup_8.eContents().get(2);
		private final RuleCall cE10TypeExpressionParserRuleCall_8_2_0 = (RuleCall)cE10Assignment_8_2.eContents().get(0);
		private final Group cGroup_8_3 = (Group)cGroup_8.eContents().get(3);
		private final RuleCall cCOLONTerminalRuleCall_8_3_0 = (RuleCall)cGroup_8_3.eContents().get(0);
		private final Assignment cE25Assignment_8_3_1 = (Assignment)cGroup_8_3.eContents().get(1);
		private final RuleCall cE25TypeExpressionParserRuleCall_8_3_1_0 = (RuleCall)cE25Assignment_8_3_1.eContents().get(0);
		private final Group cGroup_8_4 = (Group)cGroup_8.eContents().get(4);
		private final RuleCall cCOMMATerminalRuleCall_8_4_0 = (RuleCall)cGroup_8_4.eContents().get(0);
		private final Assignment cE24Assignment_8_4_1 = (Assignment)cGroup_8_4.eContents().get(1);
		private final RuleCall cE24TypeExpressionParserRuleCall_8_4_1_0 = (RuleCall)cE24Assignment_8_4_1.eContents().get(0);
		private final Group cGroup_8_4_2 = (Group)cGroup_8_4.eContents().get(2);
		private final RuleCall cCOLONTerminalRuleCall_8_4_2_0 = (RuleCall)cGroup_8_4_2.eContents().get(0);
		private final Assignment cE26Assignment_8_4_2_1 = (Assignment)cGroup_8_4_2.eContents().get(1);
		private final RuleCall cE26TypeExpressionParserRuleCall_8_4_2_1_0 = (RuleCall)cE26Assignment_8_4_2_1.eContents().get(0);
		private final RuleCall cRPARENTerminalRuleCall_8_5 = (RuleCall)cGroup_8.eContents().get(5);
		private final Group cGroup_9 = (Group)cAlternatives.eContents().get(9);
		private final Assignment cE11Assignment_9_0 = (Assignment)cGroup_9.eContents().get(0);
		private final Keyword cE11JoinKeyword_9_0_0 = (Keyword)cE11Assignment_9_0.eContents().get(0);
		private final RuleCall cLPARENTerminalRuleCall_9_1 = (RuleCall)cGroup_9.eContents().get(1);
		private final Assignment cE12Assignment_9_2 = (Assignment)cGroup_9.eContents().get(2);
		private final RuleCall cE12TypeExpressionParserRuleCall_9_2_0 = (RuleCall)cE12Assignment_9_2.eContents().get(0);
		private final Group cGroup_9_3 = (Group)cGroup_9.eContents().get(3);
		private final RuleCall cCOMMATerminalRuleCall_9_3_0 = (RuleCall)cGroup_9_3.eContents().get(0);
		private final Assignment cE13Assignment_9_3_1 = (Assignment)cGroup_9_3.eContents().get(1);
		private final RuleCall cE13TypeExpressionParserRuleCall_9_3_1_0 = (RuleCall)cE13Assignment_9_3_1.eContents().get(0);
		private final RuleCall cRPARENTerminalRuleCall_9_4 = (RuleCall)cGroup_9.eContents().get(4);
		
		/// * UnaryExpression
		// * "~" TILDE : precedence  260, 259, nil
		// * ":" COLON : precedence  194, 195
		// * "-" MINUS : precedence  701, 700
		// * "#" HASH : precedence  999, 998
		// * "'" : precedence  999, 999, ["parse_Data"]
		// * / UnaryExpression returns Expr hidden(WS, SL_COMMENT):
		//	PrimaryExpression | {UnaryExpression} uop=TILDE expr=UnaryExpression | {UnaryExpression} uop=COLON
		//	expr=UnaryExpression | {UnaryExpression} uop=MINUS expr=UnaryExpression | {UnaryExpression} uop=HASH
		//	expr=UnaryExpression | e2=PERCENT | e3="Type" | e5="Record" LPAREN e6=TypeExpression (COLON e22+=TypeExpression)?
		//	(COMMA e21+=TypeExpression (COLON e23+=TypeExpression)?)* RPAREN | e9="Union" LPAREN e10=TypeExpression (COLON
		//	e25+=TypeExpression)? (COMMA e24+=TypeExpression (COLON e26+=TypeExpression)?)* RPAREN | e11="Join" LPAREN
		//	e12=TypeExpression (COMMA e13+=TypeExpression)* RPAREN;
		public ParserRule getRule() { return rule; }

		//PrimaryExpression | {UnaryExpression} uop=TILDE expr=UnaryExpression | {UnaryExpression} uop=COLON expr=UnaryExpression
		//| {UnaryExpression} uop=MINUS expr=UnaryExpression | {UnaryExpression} uop=HASH expr=UnaryExpression | e2=PERCENT |
		//e3="Type" | e5="Record" LPAREN e6=TypeExpression (COLON e22+=TypeExpression)? (COMMA e21+=TypeExpression (COLON
		//e23+=TypeExpression)?)* RPAREN | e9="Union" LPAREN e10=TypeExpression (COLON e25+=TypeExpression)? (COMMA
		//e24+=TypeExpression (COLON e26+=TypeExpression)?)* RPAREN | e11="Join" LPAREN e12=TypeExpression (COMMA
		//e13+=TypeExpression)* RPAREN
		public Alternatives getAlternatives() { return cAlternatives; }

		//PrimaryExpression
		public RuleCall getPrimaryExpressionParserRuleCall_0() { return cPrimaryExpressionParserRuleCall_0; }

		//{UnaryExpression} uop=TILDE expr=UnaryExpression
		public Group getGroup_1() { return cGroup_1; }

		//{UnaryExpression}
		public Action getUnaryExpressionAction_1_0() { return cUnaryExpressionAction_1_0; }

		//uop=TILDE
		public Assignment getUopAssignment_1_1() { return cUopAssignment_1_1; }

		//TILDE
		public RuleCall getUopTILDETerminalRuleCall_1_1_0() { return cUopTILDETerminalRuleCall_1_1_0; }

		//expr=UnaryExpression
		public Assignment getExprAssignment_1_2() { return cExprAssignment_1_2; }

		//UnaryExpression
		public RuleCall getExprUnaryExpressionParserRuleCall_1_2_0() { return cExprUnaryExpressionParserRuleCall_1_2_0; }

		//{UnaryExpression} uop=COLON expr=UnaryExpression
		public Group getGroup_2() { return cGroup_2; }

		//{UnaryExpression}
		public Action getUnaryExpressionAction_2_0() { return cUnaryExpressionAction_2_0; }

		//uop=COLON
		public Assignment getUopAssignment_2_1() { return cUopAssignment_2_1; }

		//COLON
		public RuleCall getUopCOLONTerminalRuleCall_2_1_0() { return cUopCOLONTerminalRuleCall_2_1_0; }

		//expr=UnaryExpression
		public Assignment getExprAssignment_2_2() { return cExprAssignment_2_2; }

		//UnaryExpression
		public RuleCall getExprUnaryExpressionParserRuleCall_2_2_0() { return cExprUnaryExpressionParserRuleCall_2_2_0; }

		//{UnaryExpression} uop=MINUS expr=UnaryExpression
		public Group getGroup_3() { return cGroup_3; }

		//{UnaryExpression}
		public Action getUnaryExpressionAction_3_0() { return cUnaryExpressionAction_3_0; }

		//uop=MINUS
		public Assignment getUopAssignment_3_1() { return cUopAssignment_3_1; }

		//MINUS
		public RuleCall getUopMINUSTerminalRuleCall_3_1_0() { return cUopMINUSTerminalRuleCall_3_1_0; }

		//expr=UnaryExpression
		public Assignment getExprAssignment_3_2() { return cExprAssignment_3_2; }

		//UnaryExpression
		public RuleCall getExprUnaryExpressionParserRuleCall_3_2_0() { return cExprUnaryExpressionParserRuleCall_3_2_0; }

		//{UnaryExpression} uop=HASH expr=UnaryExpression
		public Group getGroup_4() { return cGroup_4; }

		//{UnaryExpression}
		public Action getUnaryExpressionAction_4_0() { return cUnaryExpressionAction_4_0; }

		//uop=HASH
		public Assignment getUopAssignment_4_1() { return cUopAssignment_4_1; }

		//HASH
		public RuleCall getUopHASHTerminalRuleCall_4_1_0() { return cUopHASHTerminalRuleCall_4_1_0; }

		//expr=UnaryExpression
		public Assignment getExprAssignment_4_2() { return cExprAssignment_4_2; }

		//UnaryExpression
		public RuleCall getExprUnaryExpressionParserRuleCall_4_2_0() { return cExprUnaryExpressionParserRuleCall_4_2_0; }

		//e2=PERCENT
		public Assignment getE2Assignment_5() { return cE2Assignment_5; }

		//PERCENT
		public RuleCall getE2PERCENTTerminalRuleCall_5_0() { return cE2PERCENTTerminalRuleCall_5_0; }

		//e3="Type"
		public Assignment getE3Assignment_6() { return cE3Assignment_6; }

		//"Type"
		public Keyword getE3TypeKeyword_6_0() { return cE3TypeKeyword_6_0; }

		//e5="Record" LPAREN e6=TypeExpression (COLON e22+=TypeExpression)? (COMMA e21+=TypeExpression (COLON
		//e23+=TypeExpression)?)* RPAREN
		public Group getGroup_7() { return cGroup_7; }

		//e5="Record"
		public Assignment getE5Assignment_7_0() { return cE5Assignment_7_0; }

		//"Record"
		public Keyword getE5RecordKeyword_7_0_0() { return cE5RecordKeyword_7_0_0; }

		//LPAREN
		public RuleCall getLPARENTerminalRuleCall_7_1() { return cLPARENTerminalRuleCall_7_1; }

		//e6=TypeExpression
		public Assignment getE6Assignment_7_2() { return cE6Assignment_7_2; }

		//TypeExpression
		public RuleCall getE6TypeExpressionParserRuleCall_7_2_0() { return cE6TypeExpressionParserRuleCall_7_2_0; }

		//(COLON e22+=TypeExpression)?
		public Group getGroup_7_3() { return cGroup_7_3; }

		//COLON
		public RuleCall getCOLONTerminalRuleCall_7_3_0() { return cCOLONTerminalRuleCall_7_3_0; }

		//e22+=TypeExpression
		public Assignment getE22Assignment_7_3_1() { return cE22Assignment_7_3_1; }

		//TypeExpression
		public RuleCall getE22TypeExpressionParserRuleCall_7_3_1_0() { return cE22TypeExpressionParserRuleCall_7_3_1_0; }

		//(COMMA e21+=TypeExpression (COLON e23+=TypeExpression)?)*
		public Group getGroup_7_4() { return cGroup_7_4; }

		//COMMA
		public RuleCall getCOMMATerminalRuleCall_7_4_0() { return cCOMMATerminalRuleCall_7_4_0; }

		//e21+=TypeExpression
		public Assignment getE21Assignment_7_4_1() { return cE21Assignment_7_4_1; }

		//TypeExpression
		public RuleCall getE21TypeExpressionParserRuleCall_7_4_1_0() { return cE21TypeExpressionParserRuleCall_7_4_1_0; }

		//(COLON e23+=TypeExpression)?
		public Group getGroup_7_4_2() { return cGroup_7_4_2; }

		//COLON
		public RuleCall getCOLONTerminalRuleCall_7_4_2_0() { return cCOLONTerminalRuleCall_7_4_2_0; }

		//e23+=TypeExpression
		public Assignment getE23Assignment_7_4_2_1() { return cE23Assignment_7_4_2_1; }

		//TypeExpression
		public RuleCall getE23TypeExpressionParserRuleCall_7_4_2_1_0() { return cE23TypeExpressionParserRuleCall_7_4_2_1_0; }

		//RPAREN
		public RuleCall getRPARENTerminalRuleCall_7_5() { return cRPARENTerminalRuleCall_7_5; }

		//e9="Union" LPAREN e10=TypeExpression (COLON e25+=TypeExpression)? (COMMA e24+=TypeExpression (COLON
		//e26+=TypeExpression)?)* RPAREN
		public Group getGroup_8() { return cGroup_8; }

		//e9="Union"
		public Assignment getE9Assignment_8_0() { return cE9Assignment_8_0; }

		//"Union"
		public Keyword getE9UnionKeyword_8_0_0() { return cE9UnionKeyword_8_0_0; }

		//LPAREN
		public RuleCall getLPARENTerminalRuleCall_8_1() { return cLPARENTerminalRuleCall_8_1; }

		//e10=TypeExpression
		public Assignment getE10Assignment_8_2() { return cE10Assignment_8_2; }

		//TypeExpression
		public RuleCall getE10TypeExpressionParserRuleCall_8_2_0() { return cE10TypeExpressionParserRuleCall_8_2_0; }

		//(COLON e25+=TypeExpression)?
		public Group getGroup_8_3() { return cGroup_8_3; }

		//COLON
		public RuleCall getCOLONTerminalRuleCall_8_3_0() { return cCOLONTerminalRuleCall_8_3_0; }

		//e25+=TypeExpression
		public Assignment getE25Assignment_8_3_1() { return cE25Assignment_8_3_1; }

		//TypeExpression
		public RuleCall getE25TypeExpressionParserRuleCall_8_3_1_0() { return cE25TypeExpressionParserRuleCall_8_3_1_0; }

		//(COMMA e24+=TypeExpression (COLON e26+=TypeExpression)?)*
		public Group getGroup_8_4() { return cGroup_8_4; }

		//COMMA
		public RuleCall getCOMMATerminalRuleCall_8_4_0() { return cCOMMATerminalRuleCall_8_4_0; }

		//e24+=TypeExpression
		public Assignment getE24Assignment_8_4_1() { return cE24Assignment_8_4_1; }

		//TypeExpression
		public RuleCall getE24TypeExpressionParserRuleCall_8_4_1_0() { return cE24TypeExpressionParserRuleCall_8_4_1_0; }

		//(COLON e26+=TypeExpression)?
		public Group getGroup_8_4_2() { return cGroup_8_4_2; }

		//COLON
		public RuleCall getCOLONTerminalRuleCall_8_4_2_0() { return cCOLONTerminalRuleCall_8_4_2_0; }

		//e26+=TypeExpression
		public Assignment getE26Assignment_8_4_2_1() { return cE26Assignment_8_4_2_1; }

		//TypeExpression
		public RuleCall getE26TypeExpressionParserRuleCall_8_4_2_1_0() { return cE26TypeExpressionParserRuleCall_8_4_2_1_0; }

		//RPAREN
		public RuleCall getRPARENTerminalRuleCall_8_5() { return cRPARENTerminalRuleCall_8_5; }

		//e11="Join" LPAREN e12=TypeExpression (COMMA e13+=TypeExpression)* RPAREN
		public Group getGroup_9() { return cGroup_9; }

		//e11="Join"
		public Assignment getE11Assignment_9_0() { return cE11Assignment_9_0; }

		//"Join"
		public Keyword getE11JoinKeyword_9_0_0() { return cE11JoinKeyword_9_0_0; }

		//LPAREN
		public RuleCall getLPARENTerminalRuleCall_9_1() { return cLPARENTerminalRuleCall_9_1; }

		//e12=TypeExpression
		public Assignment getE12Assignment_9_2() { return cE12Assignment_9_2; }

		//TypeExpression
		public RuleCall getE12TypeExpressionParserRuleCall_9_2_0() { return cE12TypeExpressionParserRuleCall_9_2_0; }

		//(COMMA e13+=TypeExpression)*
		public Group getGroup_9_3() { return cGroup_9_3; }

		//COMMA
		public RuleCall getCOMMATerminalRuleCall_9_3_0() { return cCOMMATerminalRuleCall_9_3_0; }

		//e13+=TypeExpression
		public Assignment getE13Assignment_9_3_1() { return cE13Assignment_9_3_1; }

		//TypeExpression
		public RuleCall getE13TypeExpressionParserRuleCall_9_3_1_0() { return cE13TypeExpressionParserRuleCall_9_3_1_0; }

		//RPAREN
		public RuleCall getRPARENTerminalRuleCall_9_4() { return cRPARENTerminalRuleCall_9_4; }
	}

	public class PrimaryExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PrimaryExpression");
		private final RuleCall cPrimaryPrefixParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		/// * 
		// *
		// * / / *UnaryExpressionHash returns Expr hidden(WS,SL_COMMENT):
		////  HASH? PrimaryExpression
		//  PrimaryExpression | ({UnaryExpressionHash} uop=HASH expr=UnaryExpressionHash)
		//;* / / * 
		// *
		// * / PrimaryExpression returns Expr hidden(WS, SL_COMMENT): / * ( t2+=PrimarySuffix )*    * / PrimaryPrefix;
		public ParserRule getRule() { return rule; }

		/// * ( t2+=PrimarySuffix )*    * / PrimaryPrefix
		public RuleCall getPrimaryPrefixParserRuleCall() { return cPrimaryPrefixParserRuleCall; }
	}

	public class PrimaryPrefixElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PrimaryPrefix");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cLiteralParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final RuleCall cLPARENTerminalRuleCall_1_0 = (RuleCall)cGroup_1.eContents().get(0);
		private final Assignment cT4Assignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cT4ExpressionParserRuleCall_1_1_0 = (RuleCall)cT4Assignment_1_1.eContents().get(0);
		private final RuleCall cRPARENTerminalRuleCall_1_2 = (RuleCall)cGroup_1.eContents().get(2);
		private final Assignment cT7Assignment_2 = (Assignment)cAlternatives.eContents().get(2);
		private final RuleCall cT7NameOrFunctionCallParserRuleCall_2_0 = (RuleCall)cT7Assignment_2.eContents().get(0);
		
		/// * 
		// *
		// * / // | t8=FunctionCall
		//PrimaryPrefix hidden(WS, SL_COMMENT):
		//	Literal // | t2='this'
		//	// | 'super' DOT t3 = ID
		//	// | t5=AllocationExpression // constructor (new ...)
		//	// | DOT 'class' t4=ResultType DOT 'class'
		//	| LPAREN t4=Expression RPAREN | t7=NameOrFunctionCall;
		public ParserRule getRule() { return rule; }

		//Literal // | t2='this'
		//// | 'super' DOT t3 = ID
		//// | t5=AllocationExpression // constructor (new ...)
		//// | DOT 'class' t4=ResultType DOT 'class'
		//| LPAREN t4=Expression RPAREN | t7=NameOrFunctionCall
		public Alternatives getAlternatives() { return cAlternatives; }

		//Literal
		public RuleCall getLiteralParserRuleCall_0() { return cLiteralParserRuleCall_0; }

		//LPAREN t4=Expression RPAREN
		public Group getGroup_1() { return cGroup_1; }

		//LPAREN
		public RuleCall getLPARENTerminalRuleCall_1_0() { return cLPARENTerminalRuleCall_1_0; }

		//t4=Expression
		public Assignment getT4Assignment_1_1() { return cT4Assignment_1_1; }

		//Expression
		public RuleCall getT4ExpressionParserRuleCall_1_1_0() { return cT4ExpressionParserRuleCall_1_1_0; }

		//RPAREN
		public RuleCall getRPARENTerminalRuleCall_1_2() { return cRPARENTerminalRuleCall_1_2; }

		//t7=NameOrFunctionCall
		public Assignment getT7Assignment_2() { return cT7Assignment_2; }

		//NameOrFunctionCall
		public RuleCall getT7NameOrFunctionCallParserRuleCall_2_0() { return cT7NameOrFunctionCallParserRuleCall_2_0; }
	}

	public class NameOrFunctionCallElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "NameOrFunctionCall");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cFnnameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cFnnameIDTerminalRuleCall_0_0 = (RuleCall)cFnnameAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Assignment cLspAssignment_1_0 = (Assignment)cGroup_1.eContents().get(0);
		private final RuleCall cLspDOLARTerminalRuleCall_1_0_0 = (RuleCall)cLspAssignment_1_0.eContents().get(0);
		private final Keyword cLispKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Alternatives cAlternatives_2 = (Alternatives)cGroup.eContents().get(2);
		private final Group cGroup_2_0 = (Group)cAlternatives_2.eContents().get(0);
		private final RuleCall cLPARENTerminalRuleCall_2_0_0 = (RuleCall)cGroup_2_0.eContents().get(0);
		private final Assignment cT4Assignment_2_0_1 = (Assignment)cGroup_2_0.eContents().get(1);
		private final RuleCall cT4ExpressionParserRuleCall_2_0_1_0 = (RuleCall)cT4Assignment_2_0_1.eContents().get(0);
		private final Group cGroup_2_0_2 = (Group)cGroup_2_0.eContents().get(2);
		private final RuleCall cCOMMATerminalRuleCall_2_0_2_0 = (RuleCall)cGroup_2_0_2.eContents().get(0);
		private final Assignment cT5Assignment_2_0_2_1 = (Assignment)cGroup_2_0_2.eContents().get(1);
		private final RuleCall cT5ExpressionParserRuleCall_2_0_2_1_0 = (RuleCall)cT5Assignment_2_0_2_1.eContents().get(0);
		private final RuleCall cRPARENTerminalRuleCall_2_0_3 = (RuleCall)cGroup_2_0.eContents().get(3);
		private final Assignment cT6Assignment_2_1 = (Assignment)cAlternatives_2.eContents().get(1);
		private final RuleCall cT6PrimaryExpressionParserRuleCall_2_1_0 = (RuleCall)cT6Assignment_2_1.eContents().get(0);
		
		/// * function call such as List(Integer)
		// * known as a parameterised type or functor (not necessarily a true functor since
		// * it may not obey the axioms of a functor)
		// * if there is only one parameter then the parenthesis are optional
		// * 
		// * function binds most tightly
		// * / NameOrFunctionCall hidden(WS, SL_COMMENT):
		//	fnname=ID (=> lsp=DOLAR "Lisp")? / *t2=TypeExpression* / (LPAREN t4=Expression? (COMMA t5+=Expression)* RPAREN //  option for parameters in parenthesis
		//	// option of no parenthesis for single parameter
		//	| => t6=PrimaryExpression)?;
		public ParserRule getRule() { return rule; }

		//fnname=ID (=> lsp=DOLAR "Lisp")? / *t2=TypeExpression* / (LPAREN t4=Expression? (COMMA t5+=Expression)* RPAREN //  option for parameters in parenthesis
		//// option of no parenthesis for single parameter
		//| => t6=PrimaryExpression)?
		public Group getGroup() { return cGroup; }

		//fnname=ID
		public Assignment getFnnameAssignment_0() { return cFnnameAssignment_0; }

		//ID
		public RuleCall getFnnameIDTerminalRuleCall_0_0() { return cFnnameIDTerminalRuleCall_0_0; }

		//(=> lsp=DOLAR "Lisp")?
		public Group getGroup_1() { return cGroup_1; }

		//=> lsp=DOLAR
		public Assignment getLspAssignment_1_0() { return cLspAssignment_1_0; }

		//DOLAR
		public RuleCall getLspDOLARTerminalRuleCall_1_0_0() { return cLspDOLARTerminalRuleCall_1_0_0; }

		//"Lisp"
		public Keyword getLispKeyword_1_1() { return cLispKeyword_1_1; }

		//(LPAREN t4=Expression? (COMMA t5+=Expression)* RPAREN //  option for parameters in parenthesis
		//// option of no parenthesis for single parameter
		//| => t6=PrimaryExpression)?
		public Alternatives getAlternatives_2() { return cAlternatives_2; }

		//LPAREN t4=Expression? (COMMA t5+=Expression)* RPAREN
		public Group getGroup_2_0() { return cGroup_2_0; }

		//LPAREN
		public RuleCall getLPARENTerminalRuleCall_2_0_0() { return cLPARENTerminalRuleCall_2_0_0; }

		//t4=Expression?
		public Assignment getT4Assignment_2_0_1() { return cT4Assignment_2_0_1; }

		//Expression
		public RuleCall getT4ExpressionParserRuleCall_2_0_1_0() { return cT4ExpressionParserRuleCall_2_0_1_0; }

		//(COMMA t5+=Expression)*
		public Group getGroup_2_0_2() { return cGroup_2_0_2; }

		//COMMA
		public RuleCall getCOMMATerminalRuleCall_2_0_2_0() { return cCOMMATerminalRuleCall_2_0_2_0; }

		//t5+=Expression
		public Assignment getT5Assignment_2_0_2_1() { return cT5Assignment_2_0_2_1; }

		//Expression
		public RuleCall getT5ExpressionParserRuleCall_2_0_2_1_0() { return cT5ExpressionParserRuleCall_2_0_2_1_0; }

		//RPAREN
		public RuleCall getRPARENTerminalRuleCall_2_0_3() { return cRPARENTerminalRuleCall_2_0_3; }

		//=> t6=PrimaryExpression
		public Assignment getT6Assignment_2_1() { return cT6Assignment_2_1; }

		//PrimaryExpression
		public RuleCall getT6PrimaryExpressionParserRuleCall_2_1_0() { return cT6PrimaryExpressionParserRuleCall_2_1_0; }
	}

	public class LiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Literal");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cValueAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final RuleCall cValueINTTerminalRuleCall_0_0 = (RuleCall)cValueAssignment_0.eContents().get(0);
		private final Assignment cT2Assignment_1 = (Assignment)cAlternatives.eContents().get(1);
		private final RuleCall cT2STRINGTerminalRuleCall_1_0 = (RuleCall)cT2Assignment_1.eContents().get(0);
		private final RuleCall cListLiteralParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cCharacterLiteralParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cBooleanLiteralParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		
		/// * Literals are actual values of a given type 
		// * Outstanding issues:
		// * 1) Float literals are parsed as elt(Int,Int) so we need to recognise this
		// *    and convert to float literal
		// * 2) We need to be able to recognise exponent notation for floats
		// * 3) Integers without '-' prefix can be converted to PI or NNI
		// * 4) need to add hex or octal notation for integers (0xhhhh)
		// * 5) String and Character literals need to have backslash "\" doubled to
		// *    "\\" otherwise xtext will interpret backslash as an escape character.
		// * 6) values following immediately after string literal such as "abc"d should
		// *    represent an implied concat: concat("abc",d)
		// * / Literal hidden(WS, SL_COMMENT):
		//	value=INT //  | t3=FloatLiteral // conflicts with use of '.' for elt
		//	| t2=STRING | ListLiteral | CharacterLiteral | BooleanLiteral;
		public ParserRule getRule() { return rule; }

		//value=INT //  | t3=FloatLiteral // conflicts with use of '.' for elt
		//| t2=STRING | ListLiteral | CharacterLiteral | BooleanLiteral
		public Alternatives getAlternatives() { return cAlternatives; }

		//value=INT
		public Assignment getValueAssignment_0() { return cValueAssignment_0; }

		//INT
		public RuleCall getValueINTTerminalRuleCall_0_0() { return cValueINTTerminalRuleCall_0_0; }

		//t2=STRING
		public Assignment getT2Assignment_1() { return cT2Assignment_1; }

		//STRING
		public RuleCall getT2STRINGTerminalRuleCall_1_0() { return cT2STRINGTerminalRuleCall_1_0; }

		//ListLiteral
		public RuleCall getListLiteralParserRuleCall_2() { return cListLiteralParserRuleCall_2; }

		//CharacterLiteral
		public RuleCall getCharacterLiteralParserRuleCall_3() { return cCharacterLiteralParserRuleCall_3; }

		//BooleanLiteral
		public RuleCall getBooleanLiteralParserRuleCall_4() { return cBooleanLiteralParserRuleCall_4; }
	}

	public class CharacterLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "CharacterLiteral");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cApostropheKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cC1Assignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cC1ANY_OTHERTerminalRuleCall_1_0 = (RuleCall)cC1Assignment_1.eContents().get(0);
		private final Keyword cApostropheKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		/// * Contains a single character whereas a string contains multiple
		// * characters.
		// * / CharacterLiteral hidden(WS, SL_COMMENT):
		//	"\'" c1=ANY_OTHER "\'";
		public ParserRule getRule() { return rule; }

		//"\'" c1=ANY_OTHER "\'"
		public Group getGroup() { return cGroup; }

		//"\'"
		public Keyword getApostropheKeyword_0() { return cApostropheKeyword_0; }

		//c1=ANY_OTHER
		public Assignment getC1Assignment_1() { return cC1Assignment_1; }

		//ANY_OTHER
		public RuleCall getC1ANY_OTHERTerminalRuleCall_1_0() { return cC1ANY_OTHERTerminalRuleCall_1_0; }

		//"\'"
		public Keyword getApostropheKeyword_2() { return cApostropheKeyword_2; }
	}

	public class BooleanLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "BooleanLiteral");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cLitnameAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final Keyword cLitnameTrueKeyword_0_0 = (Keyword)cLitnameAssignment_0.eContents().get(0);
		private final Assignment cLitnameAssignment_1 = (Assignment)cAlternatives.eContents().get(1);
		private final Keyword cLitnameFalseKeyword_1_0 = (Keyword)cLitnameAssignment_1.eContents().get(0);
		
		/// * This may not need to be specified here at the syntax level. Perhaps we
		// * should treat boolean as any other library defined type.
		// * / BooleanLiteral hidden(WS, SL_COMMENT):
		//	litname="true" | litname="false";
		public ParserRule getRule() { return rule; }

		//litname="true" | litname="false"
		public Alternatives getAlternatives() { return cAlternatives; }

		//litname="true"
		public Assignment getLitnameAssignment_0() { return cLitnameAssignment_0; }

		//"true"
		public Keyword getLitnameTrueKeyword_0_0() { return cLitnameTrueKeyword_0_0; }

		//litname="false"
		public Assignment getLitnameAssignment_1() { return cLitnameAssignment_1; }

		//"false"
		public Keyword getLitnameFalseKeyword_1_0() { return cLitnameFalseKeyword_1_0; }
	}

	public class ListLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ListLiteral");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cLitnameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cLitnameLBRACKETTerminalRuleCall_0_0 = (RuleCall)cLitnameAssignment_0.eContents().get(0);
		private final Assignment cL2Assignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cL2ExpressionParserRuleCall_1_0 = (RuleCall)cL2Assignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final RuleCall cCOMMATerminalRuleCall_2_0 = (RuleCall)cGroup_2.eContents().get(0);
		private final Assignment cT3Assignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cT3ExpressionParserRuleCall_2_1_0 = (RuleCall)cT3Assignment_2_1.eContents().get(0);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Keyword cForKeyword_3_0 = (Keyword)cGroup_3.eContents().get(0);
		private final Assignment cT14Assignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final RuleCall cT14ExpressionParserRuleCall_3_1_0 = (RuleCall)cT14Assignment_3_1.eContents().get(0);
		private final Keyword cInKeyword_3_2 = (Keyword)cGroup_3.eContents().get(2);
		private final Assignment cL5Assignment_3_3 = (Assignment)cGroup_3.eContents().get(3);
		private final RuleCall cL5ExpressionParserRuleCall_3_3_0 = (RuleCall)cL5Assignment_3_3.eContents().get(0);
		private final RuleCall cRBRACKETTerminalRuleCall_4 = (RuleCall)cGroup.eContents().get(4);
		
		/// *
		// * a list literal may consist of:
		// * [] an empty list
		// * [a] a single element
		// * [a,b] multiple elements
		// * [a for b in c] a list comprehension
		// * / ListLiteral hidden(WS, SL_COMMENT):
		//	litname=LBRACKET l2=Expression? (COMMA t3+=Expression)* ("for" t14+=Expression "in" l5+=Expression)? RBRACKET;
		public ParserRule getRule() { return rule; }

		//litname=LBRACKET l2=Expression? (COMMA t3+=Expression)* ("for" t14+=Expression "in" l5+=Expression)? RBRACKET
		public Group getGroup() { return cGroup; }

		//litname=LBRACKET
		public Assignment getLitnameAssignment_0() { return cLitnameAssignment_0; }

		//LBRACKET
		public RuleCall getLitnameLBRACKETTerminalRuleCall_0_0() { return cLitnameLBRACKETTerminalRuleCall_0_0; }

		//l2=Expression?
		public Assignment getL2Assignment_1() { return cL2Assignment_1; }

		//Expression
		public RuleCall getL2ExpressionParserRuleCall_1_0() { return cL2ExpressionParserRuleCall_1_0; }

		//(COMMA t3+=Expression)*
		public Group getGroup_2() { return cGroup_2; }

		//COMMA
		public RuleCall getCOMMATerminalRuleCall_2_0() { return cCOMMATerminalRuleCall_2_0; }

		//t3+=Expression
		public Assignment getT3Assignment_2_1() { return cT3Assignment_2_1; }

		//Expression
		public RuleCall getT3ExpressionParserRuleCall_2_1_0() { return cT3ExpressionParserRuleCall_2_1_0; }

		//("for" t14+=Expression "in" l5+=Expression)?
		public Group getGroup_3() { return cGroup_3; }

		//"for"
		public Keyword getForKeyword_3_0() { return cForKeyword_3_0; }

		//t14+=Expression
		public Assignment getT14Assignment_3_1() { return cT14Assignment_3_1; }

		//Expression
		public RuleCall getT14ExpressionParserRuleCall_3_1_0() { return cT14ExpressionParserRuleCall_3_1_0; }

		//"in"
		public Keyword getInKeyword_3_2() { return cInKeyword_3_2; }

		//l5+=Expression
		public Assignment getL5Assignment_3_3() { return cL5Assignment_3_3; }

		//Expression
		public RuleCall getL5ExpressionParserRuleCall_3_3_0() { return cL5ExpressionParserRuleCall_3_3_0; }

		//RBRACKET
		public RuleCall getRBRACKETTerminalRuleCall_4() { return cRBRACKETTerminalRuleCall_4; }
	}
	
	
	private ModelElements pModel;
	private TerminalRule tID;
	private TerminalRule tWS;
	private TerminalRule tNL;
	private TerminalRule tSL_COMMENT;
	private TerminalRule tMACROVALUE;
	private TerminalRule tSTRING;
	private TerminalRule tINT;
	private TerminalRule tLPAREN;
	private TerminalRule tRPAREN;
	private TerminalRule tLBRACE;
	private TerminalRule tRBRACE;
	private TerminalRule tLBRACKET;
	private TerminalRule tRBRACKET;
	private TerminalRule tOANGLE;
	private TerminalRule tCANGLE;
	private TerminalRule tMDEF;
	private TerminalRule tBAR;
	private TerminalRule tDOT;
	private TerminalRule tCOERCE;
	private TerminalRule tCOLON;
	private TerminalRule tCOLONDASH;
	private TerminalRule tAT;
	private TerminalRule tATAT;
	private TerminalRule tCOMMA;
	private TerminalRule tSEMICOLON;
	private TerminalRule tPOWER;
	private TerminalRule tTIMES;
	private TerminalRule tPLUS;
	private TerminalRule tMINUS;
	private TerminalRule tLT;
	private TerminalRule tGT;
	private TerminalRule tLE;
	private TerminalRule tGE;
	private TerminalRule tEQUAL;
	private TerminalRule tNOTEQUAL;
	private TerminalRule tTILDE;
	private TerminalRule tCARAT;
	private TerminalRule tSEG;
	private TerminalRule tHASH;
	private TerminalRule tAMPERSAND;
	private TerminalRule tDOLAR;
	private TerminalRule tSLASH;
	private TerminalRule tBACKSLASH;
	private TerminalRule tSLASHSLASH;
	private TerminalRule tBACKSLASHBACKSLASH;
	private TerminalRule tSLASHBACKSLASH;
	private TerminalRule tBACKSLASHSLASH;
	private TerminalRule tEXIT;
	private TerminalRule tBECOMES;
	private TerminalRule tDEF;
	private TerminalRule tARROW;
	private TerminalRule tLARROW;
	private TerminalRule tGIVES;
	private TerminalRule tPERCENT;
	private TerminalRule tELLIPSIS;
	private TerminalRule tANY_OTHER;
	private CategoryDefElements pCategoryDef;
	private PackageDefElements pPackageDef;
	private DomainDefElements pDomainDef;
	private WherePartElements pWherePart;
	private WhereAssignmentsElements pWhereAssignments;
	private WithPartElements pWithPart;
	private AddPartElements pAddPart;
	private AddStatementsElements pAddStatements;
	private FunctionDefinitionElements pFunctionDefinition;
	private FunctionSignatureElements pFunctionSignature;
	private MacroDefElements pMacroDef;
	private ImportElements pImport;
	private VariableDeclarationElements pVariableDeclaration;
	private VariableDeclarationAssignElements pVariableDeclarationAssign;
	private FreeVariableElements pFreeVariable;
	private LocalVariableElements pLocalVariable;
	private TypeExpressionElements pTypeExpression;
	private TypeParameterListElements pTypeParameterList;
	private TypeArgumentsElements pTypeArguments;
	private TypeResultElements pTypeResult;
	private TypePrimaryExpressionElements pTypePrimaryExpression;
	private TypeNameOrFunctionCallElements pTypeNameOrFunctionCall;
	private TupleDefinitionElements pTupleDefinition;
	private TypeLiteralElements pTypeLiteral;
	private StatementElements pStatement;
	private BlockElements pBlock;
	private StatementExpressionElements pStatementExpression;
	private ForStatementElements pForStatement;
	private WhileStatementElements pWhileStatement;
	private DoStatementElements pDoStatement;
	private IterateStatementElements pIterateStatement;
	private BreakStatementElements pBreakStatement;
	private ReturnStatementElements pReturnStatement;
	private IfStatementElements pIfStatement;
	private PredicateOrElements pPredicateOr;
	private PredicateAndElements pPredicateAnd;
	private PredicateNotElements pPredicateNot;
	private PredicatePrimaryElements pPredicatePrimary;
	private ExpressionElements pExpression;
	private ConditionExpressionElements pConditionExpression;
	private InnerProdExpressionElements pInnerProdExpression;
	private OuterProdExpressionElements pOuterProdExpression;
	private HasExpressionElements pHasExpression;
	private CaseExpressionElements pCaseExpression;
	private EqualityExpressionElements pEqualityExpression;
	private RelationalExpressionElements pRelationalExpression;
	private IsExpressionElements pIsExpression;
	private SegmentExpressionElements pSegmentExpression;
	private AdditiveExpressionElements pAdditiveExpression;
	private ExquoExpressionElements pExquoExpression;
	private DivisionExpressionElements pDivisionExpression;
	private QuoExpressionElements pQuoExpression;
	private ModExpressionElements pModExpression;
	private RemExpressionElements pRemExpression;
	private MultiplicativeExpressionElements pMultiplicativeExpression;
	private ExponentExpressionElements pExponentExpression;
	private MapDefinitionElements pMapDefinition;
	private PretendExpressionElements pPretendExpression;
	private HintTypeExpressionElements pHintTypeExpression;
	private CoerceExpressionElements pCoerceExpression;
	private EltExpressionElements pEltExpression;
	private ExplicitTypeExpressionElements pExplicitTypeExpression;
	private UnaryExpressionElements pUnaryExpression;
	private PrimaryExpressionElements pPrimaryExpression;
	private PrimaryPrefixElements pPrimaryPrefix;
	private NameOrFunctionCallElements pNameOrFunctionCall;
	private LiteralElements pLiteral;
	private CharacterLiteralElements pCharacterLiteral;
	private BooleanLiteralElements pBooleanLiteral;
	private ListLiteralElements pListLiteral;
	
	private final Grammar grammar;

	@Inject
	public EditorGrammarAccess(GrammarProvider grammarProvider) {
		this.grammar = internalFindGrammar(grammarProvider);
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("com.euclideanspace.spad.Editor".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	
	public Grammar getGrammar() {
		return grammar;
	}
	

	
	/// * Copyright 2012 Martin John Baker
	// * 
	// * This file is part of EuclideanSpace.
	// *
	// *  EuclideanSpace is free software: you can redistribute it and/or modify
	// *  it under the terms of the GNU Affero General Public License as published by
	// *  the Free Software Foundation, either version 3 of the License, or
	// *  (at your option) any later version.
	// *
	// *  EuclideanSpace is distributed in the hope that it will be useful,
	// *  but WITHOUT ANY WARRANTY; without even the implied warranty of
	// *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	// *  GNU Affero General Public License for more details.
	// *
	// *  You should have received a copy of the GNU Affero General Public License
	// *  along with EuclideanSpace.  If not, see <http://www.gnu.org/licenses/>.
	// * / / * FriCAS does SPAD parsing by a type of parser known as a 'Pratt' parser.
	// * In this type of parser each operator has different binding powers for
	// * its left and right. The SPAD parser also has 'special handlers' for
	// * certain operators. In this type of parser there is less distinction made
	// * between expressions and statements, effectively everything is treated as
	// * an expression so in this context, not only are "+" and "*" operators
	// * but also other keywords such as "for" and "return".
	// * 
	// * Here we are using a LL(*) recursive-descent parser generator and this
	// * may not be able to exactly replicate the SPAD parser as described above
	// * 
	// * I have taken this information from s-parser.boot in src/interp
	// * so I suspect that it in valid only for the SPAD interpreter and not
	// * the compiler however I am hoping that this will be a close enough
	// * approximation for this purpose.
	// *
	// * So I will use the LED Table to approximate infix operator precedence
	// * and the NUD Table to approximate prefix operator precedence. So I
	// * have ordered both these tables in 
	// * 
	// * I have ordered the tables low (binds least tightly) to high (binds most tightly) as follows:
	// * 
	// * LED Table - infix operators
	// * ---------------------------
	// * ";", 81, 82, ["parse_SemiColon"]
	// * "|", 108, 111
	// * ",", 110, 111
	// * "when", 112, 190
	// * "otherwise", 119, 190, ["parse_Suffix"]
	// * "where", 121, 104
	// * "==>", "MDEF", 122, 121
	// * "==", "DEF", 122, 121
	// * "=>", 123, 103
	// * ":=", "LET", 125, 124]
	// * "\/", BACKSLASHSLASH 200, 201
	// * "/\", SLASHBACKSLASH 250, 251
	// * "or", 200, 201
	// * "and", 250, 251
	// * "has", 400, 400
	// * "add", 400, 120
	// * "case", 400, 400
	// * "in", 400, 400
	// * "~=", 400, 400
	// * "^=", 400, 400
	// * "=", 400, 400
	// * ">=", 400, 400
	// * "<=", 400, 400
	// * ">>", 400, 400
	// * "<<", 400, 400
	// * ">", 400, 400
	// * "<", 400, 400
	// * "isnt", 400, 400
	// * "is", 400, 400
	// * "..", "SEGMENT", 401, 699, ["parse_Seg"]
	// * "-", 700, 701
	// * "+", 700, 701
	// * "exquo", 800, 801
	// * "/", 800, 801
	// * "quo", 800, 801
	// * "mod", 800, 801
	// * "rem", 800, 801
	// * "*", 800, 801
	// * "^", 901, 900
	// * "**", 901, 900
	// * "+->", 995, 112
	// * "pretend", 995, 996
	// * "@", 996, 997
	// * "::", 996, 997
	// * ":", 996, 997
	// * "!", 1002, 1001
	// * "with", 2000, 400, ["parse_InfixWith"]
	// * "."
	// *
	// * NUD Table - prefix operators
	// * ----------------------------
	// *
	// * "catch", 0, 114
	// * "finally", 0, 114
	// * "then", 0, 114
	// * "else", 0, 114
	// * "|", 0, 190
	// * "import", 120, 0, ["parse_Import"]
	// * "<<", 122, 120, ["parse_LabelExpr"]
	// * ">>"
	// * "if", 130, 0, ["parse_Conditional"]
	// * "try", 130, 0, ["parse_Try"]
	// * "for", 130, 350, ["parse_Loop"
	// * "while", 130, 190, ["parse_Loop"]
	// * "until", 130, 190, ["parse_Loop"]
	// * "repeat", 130, 190, ["parse_Loop"]
	// * "return", 202, 201, ["parse_Return"]
	// * "leave", 202, 201, ["parse_Leave"]
	// * "exit", 202, 201, ["parse_Exit"]
	// * "~", 260, 259, nil
	// * ":", 194, 195
	// * "not", 260, 259, NIL
	// * "has", 400, 400
	// * "=", 400, 700
	// * "-", 701, 700
	// * "add", 900, 120
	// * "#", 999, 998
	// * "'", 999, 999, ["parse_Data"]
	// * "with", 1000, 300, ["parse_With"]
	// * "->", 1001, 1002
	// * "!", 1002, 1001
	// * "unless"
	// * "suchthat"
	// * "from"
	// * "iterate"
	// * "yield"
	// * 
	// * * / / *
	// * Parser starts here
	// * CategoryDef,PackageDef and DomainDef must end with newline to ensure that
	// * only an '@' at the start of a line will be taken as the end.
	// * 
	// * On this line whitespace (WS) is not hidden so is explicitly included.
	// * / Model:
	//	")abbrev" WS (c=CategoryDef | p=PackageDef | d=DomainDef) AT;
	public ModelElements getModelAccess() {
		return (pModel != null) ? pModel : (pModel = new ModelElements());
	}
	
	public ParserRule getModelRule() {
		return getModelAccess().getRule();
	}

	//////////// start of lexer rules ///////////////
	/// * ID consists of alpha (upper or lower case) followed by alphanumeric
	// * any other character can stand in for alpha if prefixed by '_'
	// * for instance a multiply function is often named '_*'
	// * IDs can also end with ? or ! where:
	// * '?' indicates a function which returns a boolean value
	// * '!' indicates a function which changes an existing domain value
	// *     (in a mutable domain) * / terminal ID:
	//	("a".."z" | "A".."Z" | "_" .) ("a".."z" | "A".."Z" | "_" . | "0".."9")* "!"? "?"?;
	public TerminalRule getIDRule() {
		return (tID != null) ? tID : (tID = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "ID"));
	} 

	/// * whitespace on single line overrides default whitespace
	// * does not include newline unless it follows underscore.
	// * I would have liked to do this as follows:
	// * terminal WS : (' '|'\t'|'_'(('\r'|'\n')+))+;
	// * problem: unfortunately use of underscore in this way masks the use of underscore
	// * in ID. We therefore need to remove this type of underscore in a
	// * preprocessor
	// * / terminal WS:
	//	(" " | "\t")+;
	public TerminalRule getWSRule() {
		return (tWS != null) ? tWS : (tWS = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "WS"));
	} 

	/// * at least one newline or carrage return character.
	// * This is not included with WS because whitespace is significant in SPAD.
	// * We usually absorb newlines like this: NL+ which absorbs any number of
	// * blank lines and it also supports both the Linux and the Windows forms of
	// * newlines.
	// * / terminal NL:
	//	"\r" | "\n";
	public TerminalRule getNLRule() {
		return (tNL != null) ? tNL : (tNL = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "NL"));
	} 

	/// * overwriting SL_COMMENTS we do not want Java syntax (//) but spad syntax (--)
	// * This absorbs everthing from '--' or '++' to the end of the line (but not
	// * including the newline or carrage return characters)
	// * / //('\r'|'\n')?;
	//terminal SL_COMMENT:
	//	("--" | "++") !("\n" | "\r")*;
	public TerminalRule getSL_COMMENTRule() {
		return (tSL_COMMENT != null) ? tSL_COMMENT : (tSL_COMMENT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "SL_COMMENT"));
	} 

	/// * Macro value can be anything until the end of line
	// * Macro is really '==>' but the pre-processor inserts an extra '=' so
	// * that we can distinguish from where ==> is used in 'with' or 'add' parts
	// * It is difficult for a LL(*) parser to handle macros so we want to
	// * substitute the macro in a pre-processor * / terminal MACROVALUE:
	//	"===>" !("\n" | "\r")*;
	public TerminalRule getMACROVALUERule() {
		return (tMACROVALUE != null) ? tMACROVALUE : (tMACROVALUE = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "MACROVALUE"));
	} 

	/// * '==>' is used in 'with' or 'add' parts so is not really a macro?
	// * / //terminal MACRO:
	////	'==>'
	////;
	/// * string literals are enclosed in double quotes
	// * / terminal STRING:
	//	"\"" !"\""* "\"";
	public TerminalRule getSTRINGRule() {
		return (tSTRING != null) ? tSTRING : (tSTRING = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "STRING"));
	} 

	//terminal INT returns ecore::EInt:
	//	"0".."9"+;
	public TerminalRule getINTRule() {
		return (tINT != null) ? tINT : (tINT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "INT"));
	} 

	//// grouping
	//terminal LPAREN:
	//	"(";
	public TerminalRule getLPARENRule() {
		return (tLPAREN != null) ? tLPAREN : (tLPAREN = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "LPAREN"));
	} 

	//terminal RPAREN:
	//	")";
	public TerminalRule getRPARENRule() {
		return (tRPAREN != null) ? tRPAREN : (tRPAREN = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "RPAREN"));
	} 

	//terminal LBRACE:
	//	"{";
	public TerminalRule getLBRACERule() {
		return (tLBRACE != null) ? tLBRACE : (tLBRACE = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "LBRACE"));
	} 

	//terminal RBRACE:
	//	"}";
	public TerminalRule getRBRACERule() {
		return (tRBRACE != null) ? tRBRACE : (tRBRACE = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "RBRACE"));
	} 

	//terminal LBRACKET:
	//	"[";
	public TerminalRule getLBRACKETRule() {
		return (tLBRACKET != null) ? tLBRACKET : (tLBRACKET = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "LBRACKET"));
	} 

	//terminal RBRACKET:
	//	"]";
	public TerminalRule getRBRACKETRule() {
		return (tRBRACKET != null) ? tRBRACKET : (tRBRACKET = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "RBRACKET"));
	} 

	/// *
	//terminal LBANANA '(|';
	//terminal RBANANA '|)';
	//terminal EBRACKET '[__]';
	//terminal EBRACKET2 '[]';
	//terminal EBRACE '{__}';
	//terminal EBRACE2 '{}';
	//terminal LBANANABRACKET '[|';
	//terminal RBANANABRACKET '|]';
	//terminal EBANANABRACKET '[|__|]';
	//terminal EBANANABRACKET2 '[||]';
	//terminal LBANANABRACE '{|';
	//terminal RBANANABRACE '|}';
	//terminal EBANANABRACE '{|__|}';
	//terminal EBANANABRACE2 '{||}'; * / terminal OANGLE:
	//	"<<";
	public TerminalRule getOANGLERule() {
		return (tOANGLE != null) ? tOANGLE : (tOANGLE = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "OANGLE"));
	} 

	//terminal CANGLE:
	//	">>";
	public TerminalRule getCANGLERule() {
		return (tCANGLE != null) ? tCANGLE : (tCANGLE = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "CANGLE"));
	} 

	/// *terminal QUOTE "'";
	//terminal BACKQUOTE "`";* / // operators
	//terminal MDEF:
	//	"==>";
	public TerminalRule getMDEFRule() {
		return (tMDEF != null) ? tMDEF : (tMDEF = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "MDEF"));
	} 

	//terminal BAR:
	//	"|";
	public TerminalRule getBARRule() {
		return (tBAR != null) ? tBAR : (tBAR = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "BAR"));
	} 

	//terminal DOT:
	//	".";
	public TerminalRule getDOTRule() {
		return (tDOT != null) ? tDOT : (tDOT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "DOT"));
	} 

	//terminal COERCE:
	//	"::";
	public TerminalRule getCOERCERule() {
		return (tCOERCE != null) ? tCOERCE : (tCOERCE = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "COERCE"));
	} 

	//terminal COLON:
	//	":";
	public TerminalRule getCOLONRule() {
		return (tCOLON != null) ? tCOLON : (tCOLON = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "COLON"));
	} 

	//terminal COLONDASH:
	//	":-";
	public TerminalRule getCOLONDASHRule() {
		return (tCOLONDASH != null) ? tCOLONDASH : (tCOLONDASH = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "COLONDASH"));
	} 

	//terminal AT:
	//	"@";
	public TerminalRule getATRule() {
		return (tAT != null) ? tAT : (tAT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "AT"));
	} 

	//terminal ATAT:
	//	"@@";
	public TerminalRule getATATRule() {
		return (tATAT != null) ? tATAT : (tATAT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "ATAT"));
	} 

	//terminal COMMA:
	//	",";
	public TerminalRule getCOMMARule() {
		return (tCOMMA != null) ? tCOMMA : (tCOMMA = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "COMMA"));
	} 

	//terminal SEMICOLON:
	//	";";
	public TerminalRule getSEMICOLONRule() {
		return (tSEMICOLON != null) ? tSEMICOLON : (tSEMICOLON = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "SEMICOLON"));
	} 

	//terminal POWER:
	//	"**";
	public TerminalRule getPOWERRule() {
		return (tPOWER != null) ? tPOWER : (tPOWER = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "POWER"));
	} 

	//terminal TIMES:
	//	"*";
	public TerminalRule getTIMESRule() {
		return (tTIMES != null) ? tTIMES : (tTIMES = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "TIMES"));
	} 

	//terminal PLUS:
	//	"+";
	public TerminalRule getPLUSRule() {
		return (tPLUS != null) ? tPLUS : (tPLUS = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "PLUS"));
	} 

	//terminal MINUS:
	//	"-";
	public TerminalRule getMINUSRule() {
		return (tMINUS != null) ? tMINUS : (tMINUS = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "MINUS"));
	} 

	//terminal LT:
	//	"<";
	public TerminalRule getLTRule() {
		return (tLT != null) ? tLT : (tLT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "LT"));
	} 

	//terminal GT:
	//	">";
	public TerminalRule getGTRule() {
		return (tGT != null) ? tGT : (tGT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "GT"));
	} 

	//terminal LE:
	//	"<=";
	public TerminalRule getLERule() {
		return (tLE != null) ? tLE : (tLE = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "LE"));
	} 

	//terminal GE:
	//	">=";
	public TerminalRule getGERule() {
		return (tGE != null) ? tGE : (tGE = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "GE"));
	} 

	//terminal EQUAL:
	//	"=";
	public TerminalRule getEQUALRule() {
		return (tEQUAL != null) ? tEQUAL : (tEQUAL = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "EQUAL"));
	} 

	//terminal NOTEQUAL:
	//	"~=";
	public TerminalRule getNOTEQUALRule() {
		return (tNOTEQUAL != null) ? tNOTEQUAL : (tNOTEQUAL = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "NOTEQUAL"));
	} 

	//terminal TILDE:
	//	"~";
	public TerminalRule getTILDERule() {
		return (tTILDE != null) ? tTILDE : (tTILDE = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "TILDE"));
	} 

	//terminal CARAT:
	//	"^";
	public TerminalRule getCARATRule() {
		return (tCARAT != null) ? tCARAT : (tCARAT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "CARAT"));
	} 

	//terminal SEG:
	//	"..";
	public TerminalRule getSEGRule() {
		return (tSEG != null) ? tSEG : (tSEG = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "SEG"));
	} 

	//terminal HASH:
	//	"#";
	public TerminalRule getHASHRule() {
		return (tHASH != null) ? tHASH : (tHASH = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "HASH"));
	} 

	//terminal AMPERSAND:
	//	"&";
	public TerminalRule getAMPERSANDRule() {
		return (tAMPERSAND != null) ? tAMPERSAND : (tAMPERSAND = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "AMPERSAND"));
	} 

	//terminal DOLAR:
	//	"$";
	public TerminalRule getDOLARRule() {
		return (tDOLAR != null) ? tDOLAR : (tDOLAR = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "DOLAR"));
	} 

	//terminal SLASH:
	//	"/";
	public TerminalRule getSLASHRule() {
		return (tSLASH != null) ? tSLASH : (tSLASH = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "SLASH"));
	} 

	//terminal BACKSLASH:
	//	"\\";
	public TerminalRule getBACKSLASHRule() {
		return (tBACKSLASH != null) ? tBACKSLASH : (tBACKSLASH = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "BACKSLASH"));
	} 

	//terminal SLASHSLASH:
	//	"//";
	public TerminalRule getSLASHSLASHRule() {
		return (tSLASHSLASH != null) ? tSLASHSLASH : (tSLASHSLASH = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "SLASHSLASH"));
	} 

	//terminal BACKSLASHBACKSLASH:
	//	"\\\\";
	public TerminalRule getBACKSLASHBACKSLASHRule() {
		return (tBACKSLASHBACKSLASH != null) ? tBACKSLASHBACKSLASH : (tBACKSLASHBACKSLASH = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "BACKSLASHBACKSLASH"));
	} 

	//terminal SLASHBACKSLASH:
	//	"/\\";
	public TerminalRule getSLASHBACKSLASHRule() {
		return (tSLASHBACKSLASH != null) ? tSLASHBACKSLASH : (tSLASHBACKSLASH = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "SLASHBACKSLASH"));
	} 

	//terminal BACKSLASHSLASH:
	//	"\\/";
	public TerminalRule getBACKSLASHSLASHRule() {
		return (tBACKSLASHSLASH != null) ? tBACKSLASHSLASH : (tBACKSLASHSLASH = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "BACKSLASHSLASH"));
	} 

	//terminal EXIT:
	//	"=>";
	public TerminalRule getEXITRule() {
		return (tEXIT != null) ? tEXIT : (tEXIT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "EXIT"));
	} 

	//terminal BECOMES:
	//	":=";
	public TerminalRule getBECOMESRule() {
		return (tBECOMES != null) ? tBECOMES : (tBECOMES = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "BECOMES"));
	} 

	//terminal DEF:
	//	"==";
	public TerminalRule getDEFRule() {
		return (tDEF != null) ? tDEF : (tDEF = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "DEF"));
	} 

	//terminal ARROW:
	//	"->";
	public TerminalRule getARROWRule() {
		return (tARROW != null) ? tARROW : (tARROW = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "ARROW"));
	} 

	//terminal LARROW:
	//	"<-";
	public TerminalRule getLARROWRule() {
		return (tLARROW != null) ? tLARROW : (tLARROW = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "LARROW"));
	} 

	//terminal GIVES:
	//	"+->";
	public TerminalRule getGIVESRule() {
		return (tGIVES != null) ? tGIVES : (tGIVES = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "GIVES"));
	} 

	//terminal PERCENT:
	//	"%";
	public TerminalRule getPERCENTRule() {
		return (tPERCENT != null) ? tPERCENT : (tPERCENT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "PERCENT"));
	} 

	//terminal ELLIPSIS:
	//	"...";
	public TerminalRule getELLIPSISRule() {
		return (tELLIPSIS != null) ? tELLIPSIS : (tELLIPSIS = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "ELLIPSIS"));
	} 

	//terminal ANY_OTHER:
	//	.;
	public TerminalRule getANY_OTHERRule() {
		return (tANY_OTHER != null) ? tANY_OTHER : (tANY_OTHER = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "ANY_OTHER"));
	} 

	//////////// end of lexer rules ///////////////
	/// *
	// * longname and longname2 should both be ID and have the same value. Since the
	// * runtime values can't be checked by the parser this must be checked later.
	// * / CategoryDef hidden(WS, NL, SL_COMMENT):
	//	name="category" shortname=ID longname=ID longname2= / *[CategoryDef]* / ID cp=TypeParameterList? COLON "Category" DEF
	//	implName=TypeArguments (w=WithPart / * | wh2=WithImplied* / | wh5=WherePart);
	public CategoryDefElements getCategoryDefAccess() {
		return (pCategoryDef != null) ? pCategoryDef : (pCategoryDef = new CategoryDefElements());
	}
	
	public ParserRule getCategoryDefRule() {
		return getCategoryDefAccess().getRule();
	}

	/// *
	// * longname and longname2 should both be ID and have the same value. Since the
	// * runtime values can't be checked by the parser this must be checked later.
	// * / PackageDef hidden(WS, NL, SL_COMMENT):
	//	name="package" shortname=ID longname=ID longname2= / *[PackageDef]* / ID cp=TypeParameterList? COLON exportName=ID DEF
	//	implName=ID (w=WithPart | wh5=WherePart);
	public PackageDefElements getPackageDefAccess() {
		return (pPackageDef != null) ? pPackageDef : (pPackageDef = new PackageDefElements());
	}
	
	public ParserRule getPackageDefRule() {
		return getPackageDefAccess().getRule();
	}

	/// *
	// * longname and longname2 should both be ID and have the same value. Since the
	// * runtime values can't be checked by the parser this must be checked later.
	// * / DomainDef hidden(WS, NL, SL_COMMENT):
	//	name="domain" shortname5=ID longname5=ID longname6= / *[DomainDef]* / ID cp5=TypeParameterList? COLON exportName=ID DEF
	//	implName5=ID (w=WithPart | wh5=WherePart);
	public DomainDefElements getDomainDefAccess() {
		return (pDomainDef != null) ? pDomainDef : (pDomainDef = new DomainDefElements());
	}
	
	public ParserRule getDomainDefRule() {
		return getDomainDefAccess().getRule();
	}

	/// *
	// * both category and domain can have 'where' part which holds overall information
	// * such as category/domain parameter information and general macros. This is
	// * followed by export('with') and import ('add') information.
	// * Forms allowed include:
	// * Exports == PlottablePlaneCurveCategory with {
	// * Exports ==> PlottablePlaneCurveCategory with {
	// * Exports ==> with {
	// * / WherePart hidden(WS, SL_COMMENT):
	//	name="where" NL* LBRACE NL* (whereAssig+=WhereAssignments (NL | SEMICOLON)+)* (longname8=ID ((DEF | MDEF)
	//	imp=TypeExpression?)? w8=WithPart)? (longname9=ID (DEF | MDEF)? add=AddPart)? RBRACE NL+;
	public WherePartElements getWherePartAccess() {
		return (pWherePart != null) ? pWherePart : (pWherePart = new WherePartElements());
	}
	
	public ParserRule getWherePartRule() {
		return getWherePartAccess().getRule();
	}

	/// * each one must be on a separate line or separated by ';'
	// * need to add name=
	// * / WhereAssignments hidden(WS):
	//	VariableDeclaration | MacroDef | Import;
	public WhereAssignmentsElements getWhereAssignmentsAccess() {
		return (pWhereAssignments != null) ? pWhereAssignments : (pWhereAssignments = new WhereAssignmentsElements());
	}
	
	public ParserRule getWhereAssignmentsRule() {
		return getWhereAssignmentsAccess().getRule();
	}

	/// *
	// * the 'where' part contains a 'with' part which holds export information
	// * such as function signatures (function declarations) but not function definitions.
	// * / WithPart hidden(WS, SL_COMMENT):
	//	name="with" NL* LBRACE NL* (fundec+=VariableDeclaration (NL | SEMICOLON)+)* RBRACE NL*;
	public WithPartElements getWithPartAccess() {
		return (pWithPart != null) ? pWithPart : (pWithPart = new WithPartElements());
	}
	
	public ParserRule getWithPartRule() {
		return getWithPartAccess().getRule();
	}

	/// *
	// * In a category, if we don't combine with an existing type then the
	// * 'with' keyword is not needed.
	//WithImplied hidden(WS,SL_COMMENT):
	//	NL* b=LBRACE NL*
	//    (fundec += VariableDeclaration (NL|SEMICOLON)+)*
	//    RBRACE NL*
	//;
	// * / / *
	// * the 'where' part contains a 'add' part which holds function and other
	// * declarations.
	// * / AddPart hidden(WS, SL_COMMENT):
	//	name="add" NL* LBRACE NL* (t+=AddStatements (NL | SEMICOLON)+)* RBRACE NL*;
	public AddPartElements getAddPartAccess() {
		return (pAddPart != null) ? pAddPart : (pAddPart = new AddPartElements());
	}
	
	public ParserRule getAddPartRule() {
		return getAddPartAccess().getRule();
	}

	/// *
	// * The add section of domain or package may contain multiple lines
	// * / AddStatements hidden(WS, SL_COMMENT):
	//	VariableDeclarationAssign | FunctionDefinition | MacroDef | Import;
	public AddStatementsElements getAddStatementsAccess() {
		return (pAddStatements != null) ? pAddStatements : (pAddStatements = new AddStatementsElements());
	}
	
	public ParserRule getAddStatementsRule() {
		return getAddStatementsAccess().getRule();
	}

	/// * function definition in add part
	// * has a form like:
	// * name(params) == statement
	// * or, for infix operators,
	// * a = b == statement
	// * or, for multiple statements,
	// * name(params) == {
	// *     statement
	// *     statement
	// * }
	// * / FunctionDefinition hidden(WS):
	//	FunctionSignature (COLON par4=TypeExpression)? DEF par5=Statement;
	public FunctionDefinitionElements getFunctionDefinitionAccess() {
		return (pFunctionDefinition != null) ? pFunctionDefinition : (pFunctionDefinition = new FunctionDefinitionElements());
	}
	
	public ParserRule getFunctionDefinitionRule() {
		return getFunctionDefinitionAccess().getRule();
	}

	/// * This is the first part of the function definition without the return type or
	// * the function implementation. Usually the function signature has a form like:
	// * name(params)
	// * We allow a single parameter to be given without brackets:
	// * name param
	// * We also allow some alternative forms to represent infix operators like:
	// * a = b to represent _=(a,b)
	// * or
	// * a > b to represent _>(a,b)
	// * 0 or 1 can be used as a function signature as a short form of
	// * _0() or _1()
	// * / // 0 or 1 can be used as a function signature as a short form of
	//// _0() or _1() but that confuses the parser
	//// | b3?='0' | b4?='1'
	//FunctionSignature hidden(WS):
	//	fnNam=ID LPAREN par2=VariableDeclaration? (COMMA par3+=VariableDeclaration)* RPAREN | // fnNam=ID par2=VariableDeclaration this causes recursive defintion
	//	fnNam=ID par=ID | t4=ID (b1=EQUAL | b1=LT | b1=GT | b1=LE | b1=GE | b1=PLUS | b1=MINUS | b1=TIMES | b1=SLASH |
	//	b1=AMPERSAND | b1=BAR | b1=CARAT) t5=ID | b2=MINUS t6=ID;
	public FunctionSignatureElements getFunctionSignatureAccess() {
		return (pFunctionSignature != null) ? pFunctionSignature : (pFunctionSignature = new FunctionSignatureElements());
	}
	
	public ParserRule getFunctionSignatureRule() {
		return getFunctionSignatureAccess().getRule();
	}

	/// * macros provide a general textual substitution
	// * there are two forms:
	// * name ==> body
	// * and
	// * name macro == body 	
	// * / //MACRO val=ID NL;
	//MacroDef:
	//	macroname=ID MACROVALUE;
	public MacroDefElements getMacroDefAccess() {
		return (pMacroDef != null) ? pMacroDef : (pMacroDef = new MacroDefElements());
	}
	
	public ParserRule getMacroDefRule() {
		return getMacroDefAccess().getRule();
	}

	/// *
	// * import domain
	// * / Import hidden(WS):
	//	"import" impname+=ID+;
	public ImportElements getImportAccess() {
		return (pImport != null) ? pImport : (pImport = new ImportElements());
	}
	
	public ParserRule getImportRule() {
		return getImportAccess().getRule();
	}

	/// * Variable declaration in where and with sections and function signature:
	// * A 'variable' can be simple like:
	// * x:Float
	// * or something more complicated like:
	// * x:Record(newPt: Pt,type:  String)
	// * or it can be a function like:
	// * x:(Float,Integer) -> Float
	// * / VariableDeclaration hidden(WS): // if I just use name=ID then, when the ui program is running, I get:
	//// Duplicate VariableDeclaration 'coerce' in WithPart 'with'
	//	varName=ID (COLON typ=TypeExpression)?;
	public VariableDeclarationElements getVariableDeclarationAccess() {
		return (pVariableDeclaration != null) ? pVariableDeclaration : (pVariableDeclaration = new VariableDeclarationElements());
	}
	
	public ParserRule getVariableDeclarationRule() {
		return getVariableDeclarationAccess().getRule();
	}

	/// * in add part we can declare and assign in same part
	// * such as:
	// * a := 3
	// * a,b,c := 0@Integer
	// * a:Integer := 3
	// * a := sin(x)
	// * / VariableDeclarationAssign hidden(WS):
	//	varName= // name of variable
	//	ID // if I just use name=ID then, when the ui program is running, I get:
	//	// Duplicate xxx 'coerce' in yyy
	//	(COMMA t2+=ID)* // multiple declarations in same line
	//	(COLON typ=TypeExpression)? // option to explicitly define type
	//	(BECOMES t4=Expression)?;
	public VariableDeclarationAssignElements getVariableDeclarationAssignAccess() {
		return (pVariableDeclarationAssign != null) ? pVariableDeclarationAssign : (pVariableDeclarationAssign = new VariableDeclarationAssignElements());
	}
	
	public ParserRule getVariableDeclarationAssignRule() {
		return getVariableDeclarationAssignAccess().getRule();
	}

	/// *
	// * free variable 	allows us to declare a variable that is global 
	// * / FreeVariable hidden(WS):
	//	"free" var=ID;
	public FreeVariableElements getFreeVariableAccess() {
		return (pFreeVariable != null) ? pFreeVariable : (pFreeVariable = new FreeVariableElements());
	}
	
	public ParserRule getFreeVariableRule() {
		return getFreeVariableAccess().getRule();
	}

	/// *
	// * allows us to declare a variable that is not global  
	// * / LocalVariable hidden(WS):
	//	"local" var=ID;
	public LocalVariableElements getLocalVariableAccess() {
		return (pLocalVariable != null) ? pLocalVariable : (pLocalVariable = new LocalVariableElements());
	}
	
	public ParserRule getLocalVariableRule() {
		return getLocalVariableAccess().getRule();
	}

	/// *
	// * This is similar to Expression but known to be of type.
	// * (Expression can also be of type) but if we know that
	// * this is a type we can exclude some possibilities.
	// * 
	// * A 'typeExpression' can be simple like:
	// * Float
	// * or something more complicated like:
	// * Record(newPt: Pt,type:  String)
	// * or it can be a function like:
	// * (Float,Integer) -> Float
	// * 
	// * first we check for a function like: Integer -> Integer
	// * / TypeExpression hidden(WS):
	//	=> (t2=TypeArguments ARROW t3=TypeResult) | TypePrimaryExpression;
	public TypeExpressionElements getTypeExpressionAccess() {
		return (pTypeExpression != null) ? pTypeExpression : (pTypeExpression = new TypeExpressionElements());
	}
	
	public ParserRule getTypeExpressionRule() {
		return getTypeExpressionAccess().getRule();
	}

	/// *
	// * we use a type parameter list for parameters of category, package or domains
	// * 
	// * in this case parameters may be just ID or they may be nameID:typeID
	// * / TypeParameterList hidden(WS):
	//	tyname=LPAREN par=ID? (COMMA par2+=ID)* RPAREN;
	public TypeParameterListElements getTypeParameterListAccess() {
		return (pTypeParameterList != null) ? pTypeParameterList : (pTypeParameterList = new TypeParameterListElements());
	}
	
	public ParserRule getTypeParameterListRule() {
		return getTypeParameterListAccess().getRule();
	}

	/// *
	// * we use type arguments for first part of function type, that is
	// * x in x-> y
	// * usually this is enclosed in parenthesis
	// * (x) in (x)-> y
	// * but if x is a single argument (Including Record, Union, etc.) then it does
	// * not need to be in parenthesis.
	// * / TypeArguments hidden(WS):
	//	t=TypeLiteral | t2=PERCENT | t3="Type" | // usually, but not always type arguments are in parenthesis, and empty
	//	// parenthesis are allowed
	//	b1?=LPAREN t4=TypeExpression? (COMMA t16+=TypeExpression)* RPAREN | t5="Record" LPAREN t6=TypeExpression (COLON
	//	t22+=TypeExpression)? (COMMA t21+=TypeExpression (COLON t23+=TypeExpression)?)* RPAREN | t9="Union" LPAREN
	//	t10=TypeExpression (COLON t25+=TypeExpression)? (COMMA t24+=TypeExpression (COLON t26+=TypeExpression)?)* RPAREN |
	//	t11="Join" LPAREN t12=TypeExpression (COMMA t13+=TypeExpression)* RPAREN | t15=TypeNameOrFunctionCall;
	public TypeArgumentsElements getTypeArgumentsAccess() {
		return (pTypeArguments != null) ? pTypeArguments : (pTypeArguments = new TypeArgumentsElements());
	}
	
	public ParserRule getTypeArgumentsRule() {
		return getTypeArgumentsAccess().getRule();
	}

	/// *
	// * we use type arguments for final part of function type, that is
	// * y in x-> y
	// * / TypeResult hidden(WS):
	//	t=TypeLiteral | t2=PERCENT | tyname="Type" | // | LPAREN t4=TypePrimaryExpression ( COMMA t16 += TypePrimaryExpression)* RPAREN
	//	name="Record" LPAREN t7=TypeExpression (COLON t8+=TypeExpression)? (COMMA t21+=TypeExpression (COLON
	//	t23+=TypeExpression)?)* RPAREN | name="Union" LPAREN t10=TypeExpression (COLON t11+=TypeExpression)? (COMMA
	//	t24+=TypeExpression (COLON t26+=TypeExpression)?)* RPAREN | name="Join" LPAREN t12=TypeExpression (COMMA
	//	t13+=TypeExpression)* RPAREN | t15=TypeNameOrFunctionCall;
	public TypeResultElements getTypeResultAccess() {
		return (pTypeResult != null) ? pTypeResult : (pTypeResult = new TypeResultElements());
	}
	
	public ParserRule getTypeResultRule() {
		return getTypeResultAccess().getRule();
	}

	//TypePrimaryExpression hidden(WS):
	//	TypeLiteral // 'Type' is top of the category hierarchy
	//	// 'Lisp' is used for native lisp function calls such as Say$Lisp
	//	| {TypePrimaryExpression} t32=PERCENT | {TypePrimaryExpression} tyname="Type" | {TypePrimaryExpression} tyname="Lisp" |
	//	{TypePrimaryExpression} LPAREN t5=TypeExpression RPAREN | {TypePrimaryExpression} tyname="Record" LPAREN
	//	t7=TypeExpression (COLON t8+=TypeExpression)? (COMMA t21+=TypeExpression (COLON t23+=TypeExpression)?)* RPAREN |
	//	{TypePrimaryExpression} tyname="Union" LPAREN t10=TypeExpression (COLON t11+=TypeExpression)? (COMMA
	//	t24+=TypeExpression (COLON t26+=TypeExpression)?)* RPAREN | {TypePrimaryExpression} tyname="Join" LPAREN
	//	t13=TypeExpression (COMMA t14+=TypeExpression)* RPAREN | TypeNameOrFunctionCall | => TupleDefinition;
	public TypePrimaryExpressionElements getTypePrimaryExpressionAccess() {
		return (pTypePrimaryExpression != null) ? pTypePrimaryExpression : (pTypePrimaryExpression = new TypePrimaryExpressionElements());
	}
	
	public ParserRule getTypePrimaryExpressionRule() {
		return getTypePrimaryExpressionAccess().getRule();
	}

	/// * Will match with ID on its own like:
	// * Integer
	// * or type function call such as List(Integer)
	// * known as a parameterised type or functor (not necessarily a true functor since
	// * it may not obey the axioms of a functor)
	// * if there is only one parameter then the parenthesis are optional
	// * 
	// * function binds most tightly
	// * / TypeNameOrFunctionCall hidden(WS):
	//	tfnname=ID (LPAREN t4=TypeExpression? (COMMA t25+=TypeExpression)* RPAREN // option of no parenthesis for single parameter
	//	| => t6=TypePrimaryExpression)?;
	public TypeNameOrFunctionCallElements getTypeNameOrFunctionCallAccess() {
		return (pTypeNameOrFunctionCall != null) ? pTypeNameOrFunctionCall : (pTypeNameOrFunctionCall = new TypeNameOrFunctionCallElements());
	}
	
	public ParserRule getTypeNameOrFunctionCallRule() {
		return getTypeNameOrFunctionCallAccess().getRule();
	}

	/// * This has a form like: (Integer,Float,String)
	// * like an array where each entry can be of a different type
	// * / TupleDefinition hidden(WS):
	//	LPAREN t4=TypeExpression (COMMA t25+=TypeExpression)* RPAREN;
	public TupleDefinitionElements getTupleDefinitionAccess() {
		return (pTupleDefinition != null) ? pTupleDefinition : (pTupleDefinition = new TupleDefinitionElements());
	}
	
	public ParserRule getTupleDefinitionRule() {
		return getTupleDefinitionAccess().getRule();
	}

	/// * Since SPAD supports dependent types then numbers and strings can occur here.
	// * Outstanding issues:
	// * 1) Float literals are parsed as elt(Int,Int) so we need to recognise this
	// *    and convert to float literal
	// * 2) We need to be able to recognise exponent notation for floats
	// * 3) Integers without '-' prefix can be converted to PI or NNI
	// * 4) need to add hex or octal notation for integers (0xhhhh)
	// * 5) String and Character literals need to have backslash "\" doubled to
	// *    "\\" otherwise xtext will interpret backslash as an escape character.
	// * 6) values following immediately after string literal such as "abc"d should
	// *    represent an implied concat: concat("abc",d)
	// * / TypeLiteral hidden(WS):
	//	t1=INT | t22=STRING | // t3=FloatLiteral |
	//	t34=CharacterLiteral | t35=BooleanLiteral;
	public TypeLiteralElements getTypeLiteralAccess() {
		return (pTypeLiteral != null) ? pTypeLiteral : (pTypeLiteral = new TypeLiteralElements());
	}
	
	public ParserRule getTypeLiteralRule() {
		return getTypeLiteralAccess().getRule();
	}

	/// * In FunctionDefinition the algorithm is defined by a sequence of the
	// * following statements:
	// * / Statement hidden(WS, SL_COMMENT):
	//	s1=Block // 'if' can occur in an expression or in
	//	| => s3=StatementExpression | // a statement so we use '=>' to choose
	//	// expression if there is any ambiguity
	//	s4=IfStatement | s5=WhileStatement | s6=DoStatement | s7=ForStatement | s8=BreakStatement | s9=IterateStatement | //    s1= ContinueStatement|
	//	s10=ReturnStatement;
	public StatementElements getStatementAccess() {
		return (pStatement != null) ? pStatement : (pStatement = new StatementElements());
	}
	
	public ParserRule getStatementRule() {
		return getStatementAccess().getRule();
	}

	/// * allows multiple statements which are grouped by wrapping in curly brackets * / Block hidden(WS, SL_COMMENT):
	//	stname=LBRACE NL* (statemBl+=Statement (NL | SEMICOLON)+)* RBRACE;
	public BlockElements getBlockAccess() {
		return (pBlock != null) ? pBlock : (pBlock = new BlockElements());
	}
	
	public ParserRule getBlockRule() {
		return getBlockAccess().getRule();
	}

	/// *
	// * gives a value or assigns a value to a variable
	// * / StatementExpression hidden(WS, SL_COMMENT):
	//	t=Expression (COLON t2=TypeExpression)? (BECOMES t3=Expression)? // breaks out of a block if predicate before '=>' is true then program
	//	// control leaves the block.
	//	// Put it here so that it can only occur at the top level of an expression
	//	// not inside some complicated expression.
	//	(EXIT t4=Expression)?;
	public StatementExpressionElements getStatementExpressionAccess() {
		return (pStatementExpression != null) ? pStatementExpression : (pStatementExpression = new StatementExpressionElements());
	}
	
	public ParserRule getStatementExpressionRule() {
		return getStatementExpressionAccess().getRule();
	}

	/// *
	// * for i in n..m repeat ... is 1
	// * for i in n..m by s repeat ...
	// * for i in list repeat ...
	// * for j in n..m repeat loopBody
	// * for j in n..m | odd? j repeat 
	// * / ForStatement hidden(WS, SL_COMMENT):
	//	"for" (stname=ID "in" t1= //(=> '..' t2=Expression)?
	//	Expression) //       (=> BAR t2=PredicateOr)? // condition
	//	"repeat" NL? s1= //('is' s2=Statement)?
	//	Statement;
	public ForStatementElements getForStatementAccess() {
		return (pForStatement != null) ? pForStatement : (pForStatement = new ForStatementElements());
	}
	
	public ParserRule getForStatementRule() {
		return getForStatementAccess().getRule();
	}

	/// *
	// * while BoolExpr repeat loopBody
	// * / WhileStatement hidden(WS, SL_COMMENT):
	//	stname="while" t2=PredicateOr "repeat" NL? s1=Statement;
	public WhileStatementElements getWhileStatementAccess() {
		return (pWhileStatement != null) ? pWhileStatement : (pWhileStatement = new WhileStatementElements());
	}
	
	public ParserRule getWhileStatementRule() {
		return getWhileStatementAccess().getRule();
	}

	/// *
	// *  do loopBody while BoolExpr
	// * / DoStatement hidden(WS, SL_COMMENT):
	//	stname="do" s1=Statement "while" NL? t2=PredicateOr;
	public DoStatementElements getDoStatementAccess() {
		return (pDoStatement != null) ? pDoStatement : (pDoStatement = new DoStatementElements());
	}
	
	public ParserRule getDoStatementRule() {
		return getDoStatementAccess().getRule();
	}

	/// *
	// * iterate ...
	// * skips over the remainder of a loop 
	// * / IterateStatement hidden(WS, SL_COMMENT):
	//	stname="iterate";
	public IterateStatementElements getIterateStatementAccess() {
		return (pIterateStatement != null) ? pIterateStatement : (pIterateStatement = new IterateStatementElements());
	}
	
	public ParserRule getIterateStatementRule() {
		return getIterateStatementAccess().getRule();
	}

	/// *
	// * break 	leave current loop 
	// * / BreakStatement hidden(WS, SL_COMMENT):
	//	stname="break";
	public BreakStatementElements getBreakStatementAccess() {
		return (pBreakStatement != null) ? pBreakStatement : (pBreakStatement = new BreakStatementElements());
	}
	
	public ParserRule getBreakStatementRule() {
		return getBreakStatementAccess().getRule();
	}

	/// *
	// * return 	leave current function 
	// * / ReturnStatement hidden(WS):
	//	stname="return" t2=Expression;
	public ReturnStatementElements getReturnStatementAccess() {
		return (pReturnStatement != null) ? pReturnStatement : (pReturnStatement = new ReturnStatementElements());
	}
	
	public ParserRule getReturnStatementRule() {
		return getReturnStatementAccess().getRule();
	}

	/// * 'if' statement allows program flow to be switched
	// * forms:
	// * if boolean then
	// * if equation then
	// * if ... not ... and ...or ... then
	// * if ... then ... else ...
	// * note1:
	// * if ... then ... else ... always returns a value so we can use this
	// * on the right hand side of an assignment
	// * note2:
	// * since there is an explicit 'then' keyword there is no need to put
	// * the condition in brackets
	// * 	
	// * examples:
	// * a:= if x >0 then x else -x
	// * if R has Field then ... 	  	 
	// * if myUnion case mtType then ...
	// * / IfStatement hidden(WS, SL_COMMENT):
	//	"if" t2=PredicateOr "then" NL? s1=Statement ("else" NL? s2=Statement)?;
	public IfStatementElements getIfStatementAccess() {
		return (pIfStatement != null) ? pIfStatement : (pIfStatement = new IfStatementElements());
	}
	
	public ParserRule getIfStatementRule() {
		return getIfStatementAccess().getRule();
	}

	/// *
	// * "or", precedence: 200, 201
	// *
	// * / PredicateOr returns Predicate hidden(WS):
	//	PredicateAnd ({PredicateOr.left=current} prname="or" right=PredicateAnd)*;
	public PredicateOrElements getPredicateOrAccess() {
		return (pPredicateOr != null) ? pPredicateOr : (pPredicateOr = new PredicateOrElements());
	}
	
	public ParserRule getPredicateOrRule() {
		return getPredicateOrAccess().getRule();
	}

	/// *
	// *  "and", precedence: 250, 251
	// * / PredicateAnd returns Predicate hidden(WS):
	//	PredicateNot ({PredicateAnd.left=current} prname="and" right=PredicateNot)*;
	public PredicateAndElements getPredicateAndAccess() {
		return (pPredicateAnd != null) ? pPredicateAnd : (pPredicateAnd = new PredicateAndElements());
	}
	
	public ParserRule getPredicateAndRule() {
		return getPredicateAndAccess().getRule();
	}

	/// *
	// * allow optional 'not' as prefix operator
	// * / PredicateNot returns Predicate hidden(WS):
	//	PredicatePrimary | {PredicateNot} "not" t2=PredicatePrimary;
	public PredicateNotElements getPredicateNotAccess() {
		return (pPredicateNot != null) ? pPredicateNot : (pPredicateNot = new PredicateNotElements());
	}
	
	public ParserRule getPredicateNotRule() {
		return getPredicateNotAccess().getRule();
	}

	/// *
	// * PredicatePrimary
	// * / PredicatePrimary hidden(WS):
	//	=> (LPAREN t=PredicateOr RPAREN) | t2=EqualityExpression;
	public PredicatePrimaryElements getPredicatePrimaryAccess() {
		return (pPredicatePrimary != null) ? pPredicatePrimary : (pPredicatePrimary = new PredicatePrimaryElements());
	}
	
	public ParserRule getPredicatePrimaryRule() {
		return getPredicatePrimaryAccess().getRule();
	}

	/////////////// Expression syntax follows //////////////
	//// expressions contain no newlines unless preceded by underscore
	//// (which is handled by WS)
	//Expression returns Expr hidden(WS, SL_COMMENT):
	//	ifname="if" ifpred=PredicateOr "then" thenexp=Expression "else" elseexp=Expression / *
	// * This expansion has been written this way instead of:
	// *   Assignment() | ConditionalExpression()
	// * for performance reasons.
	// * However, it is a weakening of the grammar for it allows the LHS of
	// * assignments to be any conditional expression whereas it can only be
	// * a primary expression.  Consider adding a semantic predicate to work
	// * around this.
	// * / | ConditionExpression;
	public ExpressionElements getExpressionAccess() {
		return (pExpression != null) ? pExpression : (pExpression = new ExpressionElements());
	}
	
	public ParserRule getExpressionRule() {
		return getExpressionAccess().getRule();
	}

	/// * 
	// * BAR "|" precedence: 108, 111
	// * / ConditionExpression returns Expr hidden(WS, SL_COMMENT):
	//	InnerProdExpression ({ConditionExpression.left=current} op=BAR right=PredicateOr)*;
	public ConditionExpressionElements getConditionExpressionAccess() {
		return (pConditionExpression != null) ? pConditionExpression : (pConditionExpression = new ConditionExpressionElements());
	}
	
	public ParserRule getConditionExpressionRule() {
		return getConditionExpressionAccess().getRule();
	}

	/// * 
	// * COMMA"," precedence: 110, 111
	// * / //CommaExpression returns Expr hidden(WS,SL_COMMENT):
	////  ConditionalAndExpression
	////  ({ConditionExpression.left=current} op=BAR right = ConditionalAndExpression )*
	////;
	/// *
	// * This has multiple uses such as inner product and logical or.
	// * 
	// * "\/", BACKSLASHSLASH precedence: 200, 201
	// * 
	// * the backslash is duplicated here because it is the escape character for
	// * strings, it will not be duplicated when used. 
	// * / InnerProdExpression returns Expr hidden(WS, SL_COMMENT):
	//	OuterProdExpression ({InnerProdExpression.left=current} op=BACKSLASHSLASH right=OuterProdExpression)*;
	public InnerProdExpressionElements getInnerProdExpressionAccess() {
		return (pInnerProdExpression != null) ? pInnerProdExpression : (pInnerProdExpression = new InnerProdExpressionElements());
	}
	
	public ParserRule getInnerProdExpressionRule() {
		return getInnerProdExpressionAccess().getRule();
	}

	/// *
	// * This has multiple uses such as outer product and logical and.
	// * 
	// * "/\", SLASHBACKSLASH precedence: 250, 251
	// * 
	// * the backslash is duplicated here because it is the escape character for
	// * strings, it will not be duplicated when used. 
	// * / OuterProdExpression returns Expr hidden(WS, SL_COMMENT):
	//	HasExpression ({OuterProdExpression.left=current} op=SLASHBACKSLASH right=HasExpression)*;
	public OuterProdExpressionElements getOuterProdExpressionAccess() {
		return (pOuterProdExpression != null) ? pOuterProdExpression : (pOuterProdExpression = new OuterProdExpressionElements());
	}
	
	public ParserRule getOuterProdExpressionRule() {
		return getOuterProdExpressionAccess().getRule();
	}

	/// * Predicate which returns true if preceding value is of a given type
	// * example:
	// * if R has Field then ..
	// * 
	// * "has", precedence: 400, 400
	// * / HasExpression returns Expr hidden(WS, SL_COMMENT):
	//	CaseExpression ({HasExpression.left=current} op="has" rightType=TypeExpression)*;
	public HasExpressionElements getHasExpressionAccess() {
		return (pHasExpression != null) ? pHasExpression : (pHasExpression = new HasExpressionElements());
	}
	
	public ParserRule getHasExpressionRule() {
		return getHasExpressionAccess().getRule();
	}

	/// * Select from Union values 
	// * example:
	// * if myUnion case mtType then ... 	
	// * 
	// * "case", precedence: 400, 400
	// * / CaseExpression returns Expr hidden(WS, SL_COMMENT):
	//	EqualityExpression ({CaseExpression.left=current} op="case" right=EqualityExpression)?;
	public CaseExpressionElements getCaseExpressionAccess() {
		return (pCaseExpression != null) ? pCaseExpression : (pCaseExpression = new CaseExpressionElements());
	}
	
	public ParserRule getCaseExpressionRule() {
		return getCaseExpressionAccess().getRule();
	}

	/// * used in list comprehension
	// * 
	// * "in", precedence: 400, 400
	// * / / *InExpression returns Expr hidden(WS,SL_COMMENT):
	//  RelationalExpression
	//  ( {CaseExpression.left=current} op='in' right = RelationalExpression)?
	//;* / / * 
	// * "~=", precedence: 400, 400
	// * "^=", precedence: 400, 400
	// * "=", precedence: 400, 400
	// * / EqualityExpression returns Expr hidden(WS, SL_COMMENT):
	//	RelationalExpression // ambigous because EQ can be in top level expression
	//	({EqualityExpression.left=current} (op=EQUAL | op=NOTEQUAL | op="^=") right=RelationalExpression)*;
	public EqualityExpressionElements getEqualityExpressionAccess() {
		return (pEqualityExpression != null) ? pEqualityExpression : (pEqualityExpression = new EqualityExpressionElements());
	}
	
	public ParserRule getEqualityExpressionRule() {
		return getEqualityExpressionAccess().getRule();
	}

	/// * 
	// * ">=", precedence: 400, 400
	// * "<=", precedence: 400, 400
	// * ">>", precedence: 400, 400
	// * "<<", precedence: 400, 400
	// * ">", precedence: 400, 400
	// * "<", precedence: 400, 400
	// * / RelationalExpression returns Expr hidden(WS, SL_COMMENT):
	//	IsExpression ({RelationalExpression.left=current} (op=LT | op=GT | op=LE | op=GE) right=IsExpression)?;
	public RelationalExpressionElements getRelationalExpressionAccess() {
		return (pRelationalExpression != null) ? pRelationalExpression : (pRelationalExpression = new RelationalExpressionElements());
	}
	
	public ParserRule getRelationalExpressionRule() {
		return getRelationalExpressionAccess().getRule();
	}

	/// * 
	// * 
	// * "isnt", precedence: 400, 400
	// * "is", precedence: 400, 400
	// * / IsExpression returns Expr hidden(WS, SL_COMMENT):
	//	SegmentExpression ({IsExpression.left=current} (op="is" | op="isnt") rightType=TypeExpression)*;
	public IsExpressionElements getIsExpressionAccess() {
		return (pIsExpression != null) ? pIsExpression : (pIsExpression = new IsExpressionElements());
	}
	
	public ParserRule getIsExpressionRule() {
		return getIsExpressionAccess().getRule();
	}

	/// * 
	// * "..", "SEGMENT",  precedence: 401, 699, ["parse_Seg"]
	// * / SegmentExpression returns Expr hidden(WS, SL_COMMENT):
	//	AdditiveExpression ({SegmentExpression.left=current} op=SEG right=AdditiveExpression)*;
	public SegmentExpressionElements getSegmentExpressionAccess() {
		return (pSegmentExpression != null) ? pSegmentExpression : (pSegmentExpression = new SegmentExpressionElements());
	}
	
	public ParserRule getSegmentExpressionRule() {
		return getSegmentExpressionAccess().getRule();
	}

	/// *
	// * add expression
	// * we include both '+' and '-' in the same case as this allows a
	// * multiple sequence like:
	// * a + b + c - d + e -f
	// * 
	// * "-",  precedence: 700, 701
	// * "+",  precedence: 700, 701
	// 
	// * / AdditiveExpression returns Expr hidden(WS, SL_COMMENT):
	//	ExquoExpression ({AdditiveExpression.left=current} (op=PLUS | op=MINUS) right=ExquoExpression)*;
	public AdditiveExpressionElements getAdditiveExpressionAccess() {
		return (pAdditiveExpression != null) ? pAdditiveExpression : (pAdditiveExpression = new AdditiveExpressionElements());
	}
	
	public ParserRule getAdditiveExpressionRule() {
		return getAdditiveExpressionAccess().getRule();
	}

	/// * 
	// * "exquo",  precedence: 800, 801
	// * / ExquoExpression returns Expr hidden(WS, SL_COMMENT):
	//	DivisionExpression ({ExquoExpression.left=current} op="exquo" right=DivisionExpression)*;
	public ExquoExpressionElements getExquoExpressionAccess() {
		return (pExquoExpression != null) ? pExquoExpression : (pExquoExpression = new ExquoExpressionElements());
	}
	
	public ParserRule getExquoExpressionRule() {
		return getExquoExpressionAccess().getRule();
	}

	/// *
	// * division expression
	// * "/",  precedence: 800, 801
	// * / DivisionExpression returns Expr hidden(WS, SL_COMMENT):
	//	QuoExpression ({DivisionExpression.left=current} op=SLASH right=QuoExpression)*;
	public DivisionExpressionElements getDivisionExpressionAccess() {
		return (pDivisionExpression != null) ? pDivisionExpression : (pDivisionExpression = new DivisionExpressionElements());
	}
	
	public ParserRule getDivisionExpressionRule() {
		return getDivisionExpressionAccess().getRule();
	}

	/// * 
	// *"quo",  precedence: 800, 801
	// * / QuoExpression returns Expr hidden(WS, SL_COMMENT):
	//	ModExpression ({QuoExpression.left=current} op="quo" right=ModExpression)*;
	public QuoExpressionElements getQuoExpressionAccess() {
		return (pQuoExpression != null) ? pQuoExpression : (pQuoExpression = new QuoExpressionElements());
	}
	
	public ParserRule getQuoExpressionRule() {
		return getQuoExpressionAccess().getRule();
	}

	/// * 
	// *"mod",  precedence: 800, 801
	// * / ModExpression returns Expr hidden(WS, SL_COMMENT):
	//	RemExpression ({ModExpression.left=current} op="mod" right=RemExpression)*;
	public ModExpressionElements getModExpressionAccess() {
		return (pModExpression != null) ? pModExpression : (pModExpression = new ModExpressionElements());
	}
	
	public ParserRule getModExpressionRule() {
		return getModExpressionAccess().getRule();
	}

	/// * 
	// *"rem", precedence: 800, 801
	// * / RemExpression returns Expr hidden(WS, SL_COMMENT):
	//	MultiplicativeExpression ({RemExpression.left=current} op="rem" right=MultiplicativeExpression)*;
	public RemExpressionElements getRemExpressionAccess() {
		return (pRemExpression != null) ? pRemExpression : (pRemExpression = new RemExpressionElements());
	}
	
	public ParserRule getRemExpressionRule() {
		return getRemExpressionAccess().getRule();
	}

	/// *
	// * multiplication expression
	// * a * b * c
	// * 
	// * "*", precedence: 800, 801
	// * / MultiplicativeExpression returns Expr hidden(WS, SL_COMMENT):
	//	ExponentExpression ({MultiplicativeExpression.left=current} op=TIMES right=ExponentExpression)*;
	public MultiplicativeExpressionElements getMultiplicativeExpressionAccess() {
		return (pMultiplicativeExpression != null) ? pMultiplicativeExpression : (pMultiplicativeExpression = new MultiplicativeExpressionElements());
	}
	
	public ParserRule getMultiplicativeExpressionRule() {
		return getMultiplicativeExpressionAccess().getRule();
	}

	/// * 
	// *
	// * "^", precedence: 901, 900
	// * "**", precedence: 901, 900
	// * / ExponentExpression returns Expr hidden(WS, SL_COMMENT):
	//	MapDefinition ({ExponentExpression.left=current} (op=CARAT | op=POWER) right=MapDefinition)*;
	public ExponentExpressionElements getExponentExpressionAccess() {
		return (pExponentExpression != null) ? pExponentExpression : (pExponentExpression = new ExponentExpressionElements());
	}
	
	public ParserRule getExponentExpressionRule() {
		return getExponentExpressionAccess().getRule();
	}

	/// * Map or Lambda expression
	// * var +-> function 	
	// * 
	// * +-> is an infix operator meaning 'maps-to'
	// * It can be used to create a function literal (an anonymous function), so
	// * instead of:
	// * myFunct(x:Type):Type == if x >0 then x else -x
	// * we can have:
	// * x +-> if x >0 then x else -x
	// * 
	// *  * "+->", precedence: 995, 112
	// * / MapDefinition returns Expr hidden(WS, SL_COMMENT):
	//	PretendExpression ({MapDefinition.left=current} op=GIVES right=PretendExpression)*;
	public MapDefinitionElements getMapDefinitionAccess() {
		return (pMapDefinition != null) ? pMapDefinition : (pMapDefinition = new MapDefinitionElements());
	}
	
	public ParserRule getMapDefinitionRule() {
		return getMapDefinitionAccess().getRule();
	}

	/// *MapDefinition hidden(WS):
	//	fnSig=FunctionSignature
	//    (COLON par4=TypeExpression)?
	//    GIVES par5=Statement
	//;* / / *
	// * pretend Type: treat one type as another,
	// * only works if they have the same internal structure.
	// * 
	// * Not very safe and should be avoided, if possible, unfortunately
	// * its not always possible to avoid.
	// * 
	// * "pretend", precedence: 995, 996
	// * / PretendExpression returns Expr hidden(WS, SL_COMMENT):
	//	HintTypeExpression ({PretendExpression.left=current} op="pretend" rightType=TypeExpression)*;
	public PretendExpressionElements getPretendExpressionAccess() {
		return (pPretendExpression != null) ? pPretendExpression : (pPretendExpression = new PretendExpressionElements());
	}
	
	public ParserRule getPretendExpressionRule() {
		return getPretendExpressionAccess().getRule();
	}

	/// * 
	// * "@", precedence: 996, 997
	// * / HintTypeExpression returns Expr hidden(WS, SL_COMMENT):
	//	CoerceExpression ({HintTypeExpression.left=current} op=AT rightType=TypeExpression)?;
	public HintTypeExpressionElements getHintTypeExpressionAccess() {
		return (pHintTypeExpression != null) ? pHintTypeExpression : (pHintTypeExpression = new HintTypeExpressionElements());
	}
	
	public ParserRule getHintTypeExpressionRule() {
		return getHintTypeExpressionAccess().getRule();
	}

	/// * 
	// * "::", precedence: 996, 997
	// * / CoerceExpression returns Expr hidden(WS, SL_COMMENT):
	//	EltExpression ({CoerceExpression.left=current} op=COERCE rightType=TypeExpression)*;
	public CoerceExpressionElements getCoerceExpressionAccess() {
		return (pCoerceExpression != null) ? pCoerceExpression : (pCoerceExpression = new CoerceExpressionElements());
	}
	
	public ParserRule getCoerceExpressionRule() {
		return getCoerceExpressionAccess().getRule();
	}

	/// * We treat these as part of the language
	// * : indicates type
	// * ! is part of name to indicate mutable
	// * 
	// * ":", precedence: 996, 997
	// * "!", precedence: 1002, 1001
	// *
	// * / / *BangExpression returns Expr hidden(WS,SL_COMMENT):
	//  EqualityExpression
	//  ({AndExpression.left=current} op=AMPERSAND right = EqualityExpression)*
	//;* / / * 
	// * "with",  precedence: 2000, 400, ["parse_InfixWith"]
	// *
	// * / / *WithExpression returns Expr hidden(WS,SL_COMMENT):
	//  EqualityExpression
	//  ({AndExpression.left=current} op='with' right = EqualityExpression)*
	//;* / / * Elt is Lisp terminology for the use of '.' to select parameters
	// * the left expression is something that has selectable elements such as
	// * a list, array, string, Record or union, the right element should be a
	// * non-negative integer.
	// * / EltExpression returns Expr hidden(WS, SL_COMMENT):
	//	ExplicitTypeExpression ({EltExpression.left=current} op=DOT right=ExplicitTypeExpression)*;
	public EltExpressionElements getEltExpressionAccess() {
		return (pEltExpression != null) ? pEltExpression : (pEltExpression = new EltExpressionElements());
	}
	
	public ParserRule getEltExpressionRule() {
		return getEltExpressionAccess().getRule();
	}

	//////////////// unary expressions ////////////////////
	/// * 
	// * '$'
	// * / ExplicitTypeExpression returns Expr hidden(WS, SL_COMMENT):
	//	UnaryExpression ({ExplicitTypeExpression.left=current} op=DOLAR rightType=TypeExpression)?;
	public ExplicitTypeExpressionElements getExplicitTypeExpressionAccess() {
		return (pExplicitTypeExpression != null) ? pExplicitTypeExpression : (pExplicitTypeExpression = new ExplicitTypeExpressionElements());
	}
	
	public ParserRule getExplicitTypeExpressionRule() {
		return getExplicitTypeExpressionAccess().getRule();
	}

	/// * UnaryExpression
	// * "~" TILDE : precedence  260, 259, nil
	// * ":" COLON : precedence  194, 195
	// * "-" MINUS : precedence  701, 700
	// * "#" HASH : precedence  999, 998
	// * "'" : precedence  999, 999, ["parse_Data"]
	// * / UnaryExpression returns Expr hidden(WS, SL_COMMENT):
	//	PrimaryExpression | {UnaryExpression} uop=TILDE expr=UnaryExpression | {UnaryExpression} uop=COLON
	//	expr=UnaryExpression | {UnaryExpression} uop=MINUS expr=UnaryExpression | {UnaryExpression} uop=HASH
	//	expr=UnaryExpression | e2=PERCENT | e3="Type" | e5="Record" LPAREN e6=TypeExpression (COLON e22+=TypeExpression)?
	//	(COMMA e21+=TypeExpression (COLON e23+=TypeExpression)?)* RPAREN | e9="Union" LPAREN e10=TypeExpression (COLON
	//	e25+=TypeExpression)? (COMMA e24+=TypeExpression (COLON e26+=TypeExpression)?)* RPAREN | e11="Join" LPAREN
	//	e12=TypeExpression (COMMA e13+=TypeExpression)* RPAREN;
	public UnaryExpressionElements getUnaryExpressionAccess() {
		return (pUnaryExpression != null) ? pUnaryExpression : (pUnaryExpression = new UnaryExpressionElements());
	}
	
	public ParserRule getUnaryExpressionRule() {
		return getUnaryExpressionAccess().getRule();
	}

	/// * 
	// *
	// * / / *UnaryExpressionHash returns Expr hidden(WS,SL_COMMENT):
	////  HASH? PrimaryExpression
	//  PrimaryExpression | ({UnaryExpressionHash} uop=HASH expr=UnaryExpressionHash)
	//;* / / * 
	// *
	// * / PrimaryExpression returns Expr hidden(WS, SL_COMMENT): / * ( t2+=PrimarySuffix )*    * / PrimaryPrefix;
	public PrimaryExpressionElements getPrimaryExpressionAccess() {
		return (pPrimaryExpression != null) ? pPrimaryExpression : (pPrimaryExpression = new PrimaryExpressionElements());
	}
	
	public ParserRule getPrimaryExpressionRule() {
		return getPrimaryExpressionAccess().getRule();
	}

	/// * 
	// *
	// * / // | t8=FunctionCall
	//PrimaryPrefix hidden(WS, SL_COMMENT):
	//	Literal // | t2='this'
	//	// | 'super' DOT t3 = ID
	//	// | t5=AllocationExpression // constructor (new ...)
	//	// | DOT 'class' t4=ResultType DOT 'class'
	//	| LPAREN t4=Expression RPAREN | t7=NameOrFunctionCall;
	public PrimaryPrefixElements getPrimaryPrefixAccess() {
		return (pPrimaryPrefix != null) ? pPrimaryPrefix : (pPrimaryPrefix = new PrimaryPrefixElements());
	}
	
	public ParserRule getPrimaryPrefixRule() {
		return getPrimaryPrefixAccess().getRule();
	}

	/// * function call such as List(Integer)
	// * known as a parameterised type or functor (not necessarily a true functor since
	// * it may not obey the axioms of a functor)
	// * if there is only one parameter then the parenthesis are optional
	// * 
	// * function binds most tightly
	// * / NameOrFunctionCall hidden(WS, SL_COMMENT):
	//	fnname=ID (=> lsp=DOLAR "Lisp")? / *t2=TypeExpression* / (LPAREN t4=Expression? (COMMA t5+=Expression)* RPAREN //  option for parameters in parenthesis
	//	// option of no parenthesis for single parameter
	//	| => t6=PrimaryExpression)?;
	public NameOrFunctionCallElements getNameOrFunctionCallAccess() {
		return (pNameOrFunctionCall != null) ? pNameOrFunctionCall : (pNameOrFunctionCall = new NameOrFunctionCallElements());
	}
	
	public ParserRule getNameOrFunctionCallRule() {
		return getNameOrFunctionCallAccess().getRule();
	}

	/// * Literals are actual values of a given type 
	// * Outstanding issues:
	// * 1) Float literals are parsed as elt(Int,Int) so we need to recognise this
	// *    and convert to float literal
	// * 2) We need to be able to recognise exponent notation for floats
	// * 3) Integers without '-' prefix can be converted to PI or NNI
	// * 4) need to add hex or octal notation for integers (0xhhhh)
	// * 5) String and Character literals need to have backslash "\" doubled to
	// *    "\\" otherwise xtext will interpret backslash as an escape character.
	// * 6) values following immediately after string literal such as "abc"d should
	// *    represent an implied concat: concat("abc",d)
	// * / Literal hidden(WS, SL_COMMENT):
	//	value=INT //  | t3=FloatLiteral // conflicts with use of '.' for elt
	//	| t2=STRING | ListLiteral | CharacterLiteral | BooleanLiteral;
	public LiteralElements getLiteralAccess() {
		return (pLiteral != null) ? pLiteral : (pLiteral = new LiteralElements());
	}
	
	public ParserRule getLiteralRule() {
		return getLiteralAccess().getRule();
	}

	/// * Contains a single character whereas a string contains multiple
	// * characters.
	// * / CharacterLiteral hidden(WS, SL_COMMENT):
	//	"\'" c1=ANY_OTHER "\'";
	public CharacterLiteralElements getCharacterLiteralAccess() {
		return (pCharacterLiteral != null) ? pCharacterLiteral : (pCharacterLiteral = new CharacterLiteralElements());
	}
	
	public ParserRule getCharacterLiteralRule() {
		return getCharacterLiteralAccess().getRule();
	}

	/// * This may not need to be specified here at the syntax level. Perhaps we
	// * should treat boolean as any other library defined type.
	// * / BooleanLiteral hidden(WS, SL_COMMENT):
	//	litname="true" | litname="false";
	public BooleanLiteralElements getBooleanLiteralAccess() {
		return (pBooleanLiteral != null) ? pBooleanLiteral : (pBooleanLiteral = new BooleanLiteralElements());
	}
	
	public ParserRule getBooleanLiteralRule() {
		return getBooleanLiteralAccess().getRule();
	}

	/// *
	// * a list literal may consist of:
	// * [] an empty list
	// * [a] a single element
	// * [a,b] multiple elements
	// * [a for b in c] a list comprehension
	// * / ListLiteral hidden(WS, SL_COMMENT):
	//	litname=LBRACKET l2=Expression? (COMMA t3+=Expression)* ("for" t14+=Expression "in" l5+=Expression)? RBRACKET;
	public ListLiteralElements getListLiteralAccess() {
		return (pListLiteral != null) ? pListLiteral : (pListLiteral = new ListLiteralElements());
	}
	
	public ParserRule getListLiteralRule() {
		return getListLiteralAccess().getRule();
	}
}
