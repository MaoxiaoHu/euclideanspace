grammar com.euclideanspace.spad.Editor hidden ()

import "http://www.eclipse.org/emf/2002/Ecore" as ecore

generate editor "http://www.euclideanspace.com/spad/Editor"

/* Copyright 2012 Martin John Baker
 * 
 * This file is part of EuclideanSpace.
 *
 *  EuclideanSpace is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Affero General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  EuclideanSpace is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Affero General Public License for more details.
 *
 *  You should have received a copy of the GNU Affero General Public License
 *  along with EuclideanSpace.  If not, see <http://www.gnu.org/licenses/>.
 */

/* FriCAS parses SPAD using a type of parser known as a 'Pratt' parser.
 * In this type of parser each operator has different binding powers for
 * its left and right. The SPAD parser also has 'special handlers' for
 * certain operators. In this type of parser there is less distinction made
 * between expressions and statements, effectively everything is treated as
 * an expression so in this context, not only are "+" and "*" operators
 * but also other keywords such as "for" and "return".
 * 
 * Here we are using a LL(*) recursive-descent parser generator and this
 * may not be able to exactly replicate the SPAD parser as described above
 * 
 * I have taken this information from s-parser.boot in src/interp
 * so I suspect that it in valid only for the SPAD interpreter and not
 * the compiler however I am hoping that this will be a close enough
 * approximation for this purpose.
 *
 * So I will use the LED Table to approximate infix operator precedence
 * and the NUD Table to approximate prefix operator precedence. So I
 * have ordered both these tables in 
 * 
 * I have ordered the tables low (binds least tightly) to high (binds most tightly) as follows:
 * 
 * LED Table - infix operators
 * ---------------------------
 * ";", 81, 82, ["parse_SemiColon"]
 * "|", 108, 111
 * ",", 110, 111
 * "when", 112, 190
 * "otherwise", 119, 190, ["parse_Suffix"]
 * "where", 121, 104
 * "==>", "MDEF", 122, 121
 * "==", "DEF", 122, 121
 * "=>", 123, 103
 * ":=", "LET", 125, 124]
 * "\/", BACKSLASHSLASH 200, 201
 * "/\", SLASHBACKSLASH 250, 251
 * "or", 200, 201
 * "and", 250, 251
 * "has", 400, 400
 * "add", 400, 120
 * "case", 400, 400
 * "in", 400, 400
 * "~=", 400, 400
 * "^=", 400, 400
 * "=", 400, 400
 * ">=", 400, 400
 * "<=", 400, 400
 * ">>", 400, 400
 * "<<", 400, 400
 * ">", 400, 400
 * "<", 400, 400
 * "isnt", 400, 400
 * "is", 400, 400
 * "..", "SEGMENT", 401, 699, ["parse_Seg"]
 * "-", 700, 701
 * "+", 700, 701
 * "exquo", 800, 801
 * "/", 800, 801
 * "quo", 800, 801
 * "mod", 800, 801
 * "rem", 800, 801
 * "*", 800, 801
 * "^", 901, 900
 * "**", 901, 900
 * "+->", 995, 112
 * "pretend", 995, 996
 * "@", 996, 997
 * "::", 996, 997
 * ":", 996, 997
 * "!", 1002, 1001
 * "with", 2000, 400, ["parse_InfixWith"]
 * "."
 *
 * NUD Table - prefix operators
 * ----------------------------
 *
 * "catch", 0, 114
 * "finally", 0, 114
 * "then", 0, 114
 * "else", 0, 114
 * "|", 0, 190
 * "import", 120, 0, ["parse_Import"]
 * "<<", 122, 120, ["parse_LabelExpr"]
 * ">>"
 * "if", 130, 0, ["parse_Conditional"]
 * "try", 130, 0, ["parse_Try"]
 * "for", 130, 350, ["parse_Loop"
 * "while", 130, 190, ["parse_Loop"]
 * "until", 130, 190, ["parse_Loop"]
 * "repeat", 130, 190, ["parse_Loop"]
 * "return", 202, 201, ["parse_Return"]
 * "leave", 202, 201, ["parse_Leave"]
 * "exit", 202, 201, ["parse_Exit"]
 * "~", 260, 259, nil
 * ":", 194, 195
 * "not", 260, 259, NIL
 * "has", 400, 400
 * "=", 400, 700
 * "-", 701, 700
 * "add", 900, 120
 * "#", 999, 998
 * "'", 999, 999, ["parse_Data"]
 * "with", 1000, 300, ["parse_With"]
 * "->", 1001, 1002
 * "!", 1002, 1001
 * "unless"
 * "suchthat"
 * "from"
 * "iterate"
 * "yield"
 * 
 * */



/*
 * Parser starts here
 * CategoryDef,PackageDef and DomainDef must end with newline to ensure that
 * only an '@' at the start of a line will be taken as the end.
 * 
 * On this line whitespace (WS) is not hidden so is explicitly included.
 */
Model :
	')abbrev' WS (c=CategoryDef | p=PackageDef | d=DomainDef) AT
;

////////// start of lexer rules ///////////////

/* ID consists of alpha (upper or lower case) followed by alphanumeric
 * any other character can stand in for alpha if prefixed by '_'
 * for instance a multiply function is often named '_*'
 * IDs can also end with ? or ! where:
 * '?' indicates a function which returns a boolean value
 * '!' indicates a function which changes an existing domain value
 *     (in a mutable domain) */
terminal ID : ('a'..'z'|'A'..'Z'|('_'.)) ('a'..'z'|'A'..'Z'|('_'.)|'0'..'9')*'!'?'?'?;

/* whitespace on single line overrides default whitespace
 * does not include newline unless it follows underscore.
 * I would have liked to do this as follows:
 * terminal WS : (' '|'\t'|'_'(('\r'|'\n')+))+;
 * problem: unfortunately use of underscore in this way masks the use of underscore
 * in ID. We therefore need to remove this type of underscore in a
 * preprocessor
 */
terminal WS : (' '|'\t')+;

/* at least one newline or carriage return character.
 * This is not included with WS because whitespace is significant in SPAD.
 * We usually absorb newlines like this: NL+ which absorbs any number of
 * blank lines and it also supports both the Linux and the Windows forms of
 * newlines.
 */
terminal NL: ('\r'|'\n') ;

/* overwriting SL_COMMENTS we do not want Java syntax (//) but spad syntax (--)
 * This absorbs everything from '--' or '++' to the end of the line (but not
 * including the newline or carriage return characters)
 */
terminal SL_COMMENT :
  ('--'|'++') !('\n'|'\r')* ;//('\r'|'\n')?;

/* Macro value can be anything until the end of line
 * Macro is really '==>' but the pre-processor inserts an extra '=' so
 * that we can distinguish from where ==> is used in 'with' or 'add' parts
 * It is difficult for a LL(*) parser to handle macros so we want to
 * substitute the macro in a pre-processor */
terminal MACROVALUE :
  '===>' !('\n'|'\r')*;

/* '==>' is used in 'with' or 'add' parts so is not really a macro?
 */
//terminal MACRO:
//	'==>'
//;

/* string literals are enclosed in double quotes
*/
terminal STRING	: 
			'"' ( !('"') )* '"' 
		;
		 
terminal INT returns ecore::EInt: ('0'..'9')+;

// grouping
terminal LPAREN: '(';
terminal RPAREN: ')';
terminal LBRACE: '{';
terminal RBRACE: '}';
terminal LBRACKET: '[';
terminal RBRACKET: ']';
/*
terminal LBANANA '(|';
terminal RBANANA '|)';
terminal EBRACKET '[__]';
terminal EBRACKET2 '[]';
terminal EBRACE '{__}';
terminal EBRACE2 '{}';
terminal LBANANABRACKET '[|';
terminal RBANANABRACKET '|]';
terminal EBANANABRACKET '[|__|]';
terminal EBANANABRACKET2 '[||]';
terminal LBANANABRACE '{|';
terminal RBANANABRACE '|}';
terminal EBANANABRACE '{|__|}';
terminal EBANANABRACE2 '{||}'; */
/* << */
terminal OANGLE: '<<';
/* >> */
terminal CANGLE: '>>';
/*terminal QUOTE "'";
terminal BACKQUOTE "`";*/

// operators
/* ==> */
terminal MDEF: '==>';
/* | */
terminal BAR: '|';
/* . */
terminal DOT: '.';
/* :: */
terminal COERCE: '::';
/* : */
terminal COLON: ':';
/* @ */
terminal AT: '@';
/* , */
terminal COMMA: ',';
/* ; */
terminal SEMICOLON: ';';
/* ** */
terminal POWER: '**';
/* * */
terminal TIMES: '*';
/* + */
terminal PLUS: '+';
terminal MINUS: '-';
terminal LT: '<';
terminal GT: '>';
terminal LE: '<=';
terminal GE: '>=';
terminal EQUAL: '=';
terminal NOTEQUAL: '~=';
terminal TILDE: '~';
terminal CARAT: '^';
terminal SEG: '..';
terminal HASH: '#';
terminal AMPERSAND: '&';
terminal DOLAR: '$';
terminal SLASH: '/';
terminal BACKSLASH: '\\';
terminal SLASHSLASH: '//';
terminal BACKSLASHBACKSLASH: '\\\\';
terminal SLASHBACKSLASH: '/\\';
terminal BACKSLASHSLASH: '\\/';
terminal EXIT: '=>';
/* := */
terminal BECOMES: ':=';
/* == */
terminal DEF: '==';
/* -> */
terminal ARROW: '->';
terminal LARROW: '<-';
/* +-> */
terminal GIVES: '+->';

terminal PERCENT: '%';
terminal ELLIPSIS: '...';
terminal ANY_OTHER: .;

////////// end of lexer rules ///////////////

/*
 * longname and longname2 should both be ID and have the same value. Since the
 * runtime values can't be checked by the parser this must be checked later.
 */
CategoryDef hidden(WS,NL,SL_COMMENT):
	name='category' shortname=ID longname=ID
	longname2=ID /*[CategoryDef]*/
    (cp=TypeParameterList)?
    COLON 'Category'
    DEF 
    (
    implName=TypeArguments ((w=WithPart? a=AddPart?)| wh5=WherePart)
    | LBRACE NL*
      implName=TypeArguments ((w=WithPart? a=AddPart?)| wh5=WherePart)
      RBRACE NL*
    )
;

/*
 * longname and longname2 should both be ID and have the same value. Since the
 * runtime values can't be checked by the parser this must be checked later.
 */
PackageDef hidden(WS,NL,SL_COMMENT):
	name='package' shortname=ID longname=ID
	longname2=ID /*[PackageDef]*/
    (cp=TypeParameterList)? COLON exportName=ID DEF implName=ID
    (w=WithPart | wh5=WherePart)
;

/*
 * longname and longname2 should both be ID and have the same value. Since the
 * runtime values can't be checked by the parser this must be checked later.
 */
DomainDef hidden(WS,NL,SL_COMMENT):
	name='domain' shortname5=ID longname5=ID
	longname6=ID /*[DomainDef]*/
    (cp5=TypeParameterList)? COLON exportName=ID DEF implName5=ID
    (w=WithPart | wh5=WherePart)
;

/*
 * both category and domain can have 'where' part which holds overall information
 * such as category/domain parameter information and general macros. This is
 * followed by export('with') and import ('add') information.
 * Forms allowed include:
 * Exports == PlottablePlaneCurveCategory with {
 * Exports ==> PlottablePlaneCurveCategory with {
 * Exports ==> with {
 */
WherePart hidden(WS,SL_COMMENT):
	name='where' NL* LBRACE NL*
    (whereAssig +=WhereAssignments (NL|SEMICOLON)+)*
    (longname8=ID ((DEF | MDEF) (imp=TypeExpression)?)? w8=WithPart)?
    (longname9=ID (DEF | MDEF)? add=AddPart)?
    RBRACE NL+
;

/* each one must be on a separate line or separated by ';'
 * need to add name=
 */
WhereAssignments hidden(WS):
	VariableDeclaration | MacroDef |Import
;

/*
 * the 'where' part contains a 'with' part which holds export information
 * such as function signatures (function declarations) but not function definitions.
 */
WithPart hidden(WS,SL_COMMENT):
	name='with' NL* LBRACE NL*
    (fundec += VariableDeclaration (NL|SEMICOLON)+)*
    RBRACE NL*
;

/*
 * the 'where' part contains a 'add' part which holds function and other
 * declarations.
 */
AddPart hidden(WS,SL_COMMENT):
	name='add' NL* LBRACE NL*
    (t+=AddStatements (NL|SEMICOLON)+)* RBRACE NL*
;

/*
 * The add section of domain or package may contain multiple lines
 */
AddStatements hidden(WS,SL_COMMENT):
   VariableDeclarationAssign
   | FunctionDefinition
   | ('if' t1=Expression // expression has form 'x has y'
      'then' t13=FunctionDefinitionBlock)
   | MacroDef
   | Import
;

/* function definition in add part (called by AddStatements)
 * has a form like:
 * name(params) == statement
 * or, for infix operators,
 * a = b == statement
 * or, for multiple statements,
 * name(params) == {
 *     statement
 *     statement
 * }
 * some function definitions may be conditional like this:
 * if % has finiteAggregate then {
 * ... }
 */
FunctionDefinition hidden(WS,SL_COMMENT):
  (
	par3=FunctionSignature
    (COLON par4=TypeExpression)?
    DEF par5=Statement
   ) 
;

FunctionDefinitionBlock hidden(WS,SL_COMMENT):
    fnDecBr=LBRACE NL*
      (fnDecBk += FunctionDefinition (NL|SEMICOLON)+)*
      RBRACE	
;

/* This is the first part of the function definition without the return type or
 * the function implementation. Usually the function signature has a form like:
 * name(params)
 * We allow a single parameter to be given without brackets:
 * name param
 * We also allow some alternative forms to represent infix operators like:
 * a = b to represent _=(a,b)
 * or
 * a > b to represent _>(a,b)
 * 0 or 1 can be used as a function signature as a short form of
 * _0() or _1()
 */
FunctionSignature hidden(WS,SL_COMMENT):
  (
	fnNam=ID
    LPAREN
    par2=VariableTyped?
    (COMMA par3 += VariableTyped)*
    RPAREN
  ) | (
  	// fnNam=ID par2=VariableDeclaration causes recursive definition so use:
  	fnNam=ID par=ID
  ) | (
  	t4=ID ( b1=EQUAL | b1=LT | b1=GT | b1=LE | b1=GE |
            b1=PLUS | b1=MINUS | b1=TIMES | b1=SLASH | b1=AMPERSAND |
            b1=BAR | b1=CARAT)  t5=ID
  ) | (
  	b3=INT // allows special form of function signature using '0' or '1'
  	       // can't specify '0' or '1' explicitly as this would affect lex
  	       // order
  ) | (
  	b2=MINUS t6=ID
  )
;

/* macros provide a general textual substitution
 * there are two forms:
 * name ==> body
 * and
 * name macro == body 	
 */
MacroDef: macroname=ID MACROVALUE ; //MACRO val=ID NL;

/*
 * import domain
 */
Import hidden(WS):
	'import' (impname += ID)+
;

/* Variable declaration in where and with sections:
 * A 'variable' can be simple like:
 * x:Float
 * or something more complicated like:
 * x:Record(newPt: Pt,type:  String)
 * or it can be a function like:
 * x:(Float,Integer) -> Float
 * or it can be conditional like:
 * if 
 */
VariableDeclarationBlock hidden(WS,SL_COMMENT):
    vardecbr=LBRACE NL*
      (vardecBlk += VariableDeclaration (NL|SEMICOLON)+)*
      RBRACE	
;

/* Variable declaration in where and with sections:
 * A 'variable' can be simple like:
 * x:Float
 * or something more complicated like:
 * x:Record(newPt: Pt,type:  String)
 * or it can be a function like:
 * x:(Float,Integer) -> Float
 * or it can be conditional like:
 * if 
 */
VariableDeclaration hidden(WS,SL_COMMENT):
    ('if' t1=Expression 'then')? // expression has form 'x has y'
	(v1=VariableTyped | v2=VariableDeclarationBlock)
;

/* Variable name with optional type. This is used in function signature
 * and also by VariableDeclaration:
 * A 'variable' can be simple like:
 * x:Float
 * or something more complicated like:
 * x:Record(newPt: Pt,type:  String)
 * or it can be a function like:
 * x:(Float,Integer) -> Float
 */
VariableTyped hidden(WS,SL_COMMENT):
	(varName=ID | varNameSt=STRING) (COLON typ=TypeExpression)? 
;

/* in add part we can declare and assign in same part
 * such as:
 * a := 3
 * a:Integer := 3
 * a := sin(x)
 * 
 * There are two forms of multiple assignment:
 * a,b,c := 0@Integer
 * or:
 * a := b := c := 0@Integer
 */
VariableDeclarationAssign hidden(WS):
  varName=ID // name of variable
  // if I just use name=ID then, when the ui program is running, I get:
  // Duplicate xxx 'coerce' in yyy
  (
    (COMMA t2+=ID)* // multiple declarations in same line
    (COLON typ=TypeExpression)? // option to explicitly define type
    (BECOMES t4=Expression)?
  ) | (BECOMES t2+=ID)+ BECOMES t4=Expression
;

/*
 * free variable 	allows us to declare a variable that is global 
 */
FreeVariable hidden(WS):
	'free' var=ID
;

/*
 * allows us to declare a variable that is not global  
 */
LocalVariable hidden(WS):
	'local' var=ID
;

/*
 * This is similar to Expression but known to be of type.
 * (Expression can also be of type) but if we know that
 * this is a type we can exclude some possibilities.
 * 
 * A 'typeExpression' can be simple like:
 * Float
 * or something more complicated like:
 * Record(newPt: Pt,type:  String)
 * or it can be a function like:
 * (Float,Integer) -> Float
 * 
 * first we check for a function like: Integer -> Integer
 */
TypeExpression hidden(WS):
   =>(t2=TypeArguments ARROW t3=TypeResult)
   | TypePrimaryExpression
;

/*
 * we use a type parameter list for parameters of category, package or domains
 * Parameter list may be empty '()'.
 * in this case parameters may be just ID or they may be nameID:typeID
 * 
 * examples are:
 * ()
 * (String)
 * (s:String)
 * (String,Integer)
 * (s:String,i:Integer)
 */
TypeParameterList hidden(WS):
	tyname=LPAREN par=ID? 
	(COLON par22+=TypeExpression)?
	(COMMA par2 += ID (COLON par22+=TypeExpression)?)* RPAREN;

/*
 * we use type arguments for first part of function type, that is
 * x in x-> y
 * usually this is enclosed in parenthesis
 * (x) in (x)-> y
 * but if x is a single argument (Including Record, Union, etc.) then it does
 * not need to be in parenthesis.
 */
TypeArguments hidden(WS):
	t=TypeLiteral |
  t2=PERCENT |
  t3='Type' |
  // usually, but not always type arguments are in parenthesis, and empty
  // parenthesis are allowed
  b1 ?= LPAREN t4=TypeExpression? ( COMMA t16 += TypeExpression)* RPAREN |
  t5='Record' LPAREN t6=TypeExpression
               (COLON t22+=TypeExpression)?
               (COMMA t21+=TypeExpression (COLON t23+=TypeExpression)?)*
                RPAREN |
  t9='Union' LPAREN t10=TypeExpression
              (COLON t25+=TypeExpression)?
              (COMMA t24+=TypeExpression (COLON t26+=TypeExpression)?)*
              RPAREN |
  t11='Join' LPAREN t12=TypeExpression (COMMA t13+=TypeExpression)* RPAREN |
  t15=TypeNameOrFunctionCall
;

/*
 * we use type arguments for final part of function type, that is
 * y in x-> y
 */
TypeResult hidden(WS):
  t=TypeLiteral |
  t2=PERCENT |
  tyname='Type' |
// | LPAREN t4=TypePrimaryExpression ( COMMA t16 += TypePrimaryExpression)* RPAREN
  name='Record' LPAREN t7=TypeExpression
               (COLON t8+=TypeExpression)?
               (COMMA t21+=TypeExpression (COLON t23+=TypeExpression)?)*
                RPAREN |
  name='Union' LPAREN t10=TypeExpression
              (COLON t11+=TypeExpression)?
              (COMMA t24+=TypeExpression (COLON t26+=TypeExpression)?)*
              RPAREN |
  name='Join' LPAREN t12=TypeExpression (COMMA t13+=TypeExpression)* RPAREN |
  t15=TypeNameOrFunctionCall
;

TypePrimaryExpression hidden(WS):
 TypeLiteral
 | ({TypePrimaryExpression}t32=PERCENT)
 | ({TypePrimaryExpression}tyname='Type') // 'Type' is top of the category hierarchy
 | ({TypePrimaryExpression}tyname='Lisp') // 'Lisp' is used for native lisp function calls such as Say$Lisp
 | ({TypePrimaryExpression}LPAREN t5=TypeExpression RPAREN)
 | ({TypePrimaryExpression}tyname='Record' LPAREN t7=TypeExpression
               (COLON t8+=TypeExpression)?
               (COMMA t21+=TypeExpression (COLON t23+=TypeExpression)?)*
                RPAREN)
 | ({TypePrimaryExpression}tyname='Union' LPAREN t10=TypeExpression
              (COLON t11+=TypeExpression)?
              (COMMA t24+=TypeExpression (COLON t26+=TypeExpression)?)*
              RPAREN)
 | ({TypePrimaryExpression}tyname='Join'
    LPAREN t13=TypeExpression (COMMA t14+=TypeExpression)* RPAREN)
 | TypeNameOrFunctionCall
 | => TupleDefinition
;

/* Will match with ID on its own like:
 * Integer
 * or type function call such as List(Integer)
 * known as a parameterised type or functor (not necessarily a true functor since
 * it may not obey the axioms of a functor)
 * if there is only one parameter then the parenthesis are optional
 * 
 * function binds most tightly
 */
TypeNameOrFunctionCall hidden(WS):
  tfnname=ID
  ((LPAREN t4=TypeExpression? (COMMA t25+=TypeExpression)* RPAREN)
  // optional curried function:
  (LPAREN t44+=StatementExpression? (COMMA t45+=Expression)* RPAREN)*
  // option of no parenthesis for single parameter
  | => t6=TypePrimaryExpression)?
;

/* This has a form like: (Integer,Float,String)
 * like an array where each entry can be of a different type
 */
TupleDefinition hidden(WS):
  (LPAREN t4=TypeExpression (COMMA t25+=TypeExpression)* RPAREN)
;

/* Since SPAD supports dependent types then numbers and strings can occur here.
 * Outstanding issues:
 * 1) Float literals are parsed as elt(Int,Int) so we need to recognise this
 *    and convert to float literal
 * 2) We need to be able to recognise exponent notation for floats
 * 3) Integers without '-' prefix can be converted to PI or NNI
 * 4) need to add hex or octal notation for integers (0xhhhh)
 * 5) String and Character literals need to have backslash "\" doubled to
 *    "\\" otherwise xtext will interpret backslash as an escape character.
 * 6) values following immediately after string literal such as "abc"d should
 *    represent an implied concat: concat("abc",d)
 */
TypeLiteral hidden(WS):
  t1=INT |
  t22=STRING |
// t3=FloatLiteral |
  t34=CharacterLiteral |
  t35=BooleanLiteral
;

/* In FunctionDefinition the algorithm is defined by a sequence of the
 * following statements:
 */
Statement hidden(WS,SL_COMMENT):
    s1=Block |
    => s3= StatementExpression | // 'if' can occur in an expression or in
                                 // a statement so we use '=>' to choose
                                 // expression if there is any ambiguity
    s4=IfStatement |
    s4b=IfElseStatement |
    s5=WhileStatement |
    s6=DoStatement |
    s7=ForStatement |
    s8=BreakStatement |
    s12=RepeatStatement |
    s9= IterateStatement |
//    s11= ContinueStatement|
    s10= ReturnStatement
;

/* allows multiple statements which are grouped by wrapping in curly brackets */
Block hidden(WS,SL_COMMENT):
	stname=LBRACE NL*
    (statemBl += Statement (NL|SEMICOLON)+)*
    RBRACE
;

/*
 * gives a value or assigns a value to a variable
 */
StatementExpression hidden(WS,SL_COMMENT):
  t=Expression
    (COLON t2=TypeExpression)?
    (BECOMES t3=Expression (BECOMES t33+=Expression)*)?
    (BECOMES t5=Block)?
    // breaks out of a block if predicate before '=>' is true then program
    // control leaves the block.
    // Put it here so that it can only occur at the top level of an expression
    // not inside some complicated expression.
    (EXIT t4=Statement)?
;

/*
 * for i in n..m repeat ... is 1
 * for i in n..m by s repeat ...
 * for i in list repeat ...
 * for j in n..m repeat loopBody
 * for j in n..m | odd? j repeat 
 */
ForStatement hidden(WS,SL_COMMENT):
	'for' (
       stname=ID 'in' t1=Expression //(=> '..' t2=Expression)?
//       (=> BAR t2=PredicateOr)? // condition
	) 'repeat' NL? s1=Statement //('is' s2=Statement)?
;

/*
 * while BoolExpr repeat loopBody
 */
WhileStatement hidden(WS,SL_COMMENT):
	stname='while' (
       t2=Expression /*PredicateOr*/
	) 'repeat' NL? s1=Statement
;

/*
 *  do loopBody while BoolExpr
 */
DoStatement hidden(WS,SL_COMMENT):
	stname='do' (
       s1=Statement
	) 'while' NL? t2=Expression /*PredicateOr*/
;

/*
 *  will repeat until we jump out. For instance by calling return.
 */
RepeatStatement hidden(WS,SL_COMMENT):
	stname='repeat' (
       s1=Statement
	)
;

/*
 * iterate ...
 * skips over the remainder of a loop 
 */
IterateStatement hidden(WS,SL_COMMENT):
	stname='iterate'
;

/*
 * break 	leave current loop 
 */
BreakStatement hidden(WS,SL_COMMENT):
	stname='break'
;

/*
 * return 	leave current function 
 */
ReturnStatement hidden(WS):
	stname='return' t2=Expression
;

/* 'if' statement allows program flow to be switched
 * forms:
 * if boolean then
 * if equation then
 * if ... not ... and ...or ... then
 * if ... then ... else ...
 * note1:
 * if ... then ... else ... always returns a value so we can use this
 * on the right hand side of an assignment
 * note2:
 * since there is an explicit 'then' keyword there is no need to put
 * the condition in brackets
 * 	
 * examples:
 * a:= if x >0 then x else -x
 * if R has Field then ... 	  	 
 * if myUnion case mtType then ...
 */
IfStatement hidden(WS,SL_COMMENT):
	'if' t2=Expression
    'then' NL? s1=Statement
    // NL? we need to enable this but it will be matched multiple ways
    (=> 'else' NL? s2=Statement)?
;

IfElseStatement hidden(WS,SL_COMMENT):
	'else' NL? s2=Statement
;

///////////// Expression syntax follows //////////////

/* This is the top level for expressions
 * 
 * This level handles special cases such as:
 * if x then y else z
 * (x,y) +-> z
 * 
 * We can consider expressions as elements of statements 
 * expressions contain no newlines unless preceded by underscore
 * (which is handled by WS)
 */
Expression returns Expr hidden(WS,SL_COMMENT):
  (ifname='if' ifpred=Expression 'then' thenexp=Expression 'else' elseexp=Expression)
//  | LPAREN t24=ConditionExpression (COMMA t25+=Expression)+ RPAREN GIVES Expression
  | ConditionExpression
;

/* 
 * BAR "|" precedence: 108, 111
 */
ConditionExpression returns Expr hidden(WS,SL_COMMENT):
  OrExpression
  ({ConditionExpression.left=current} op=BAR right = OrExpression )*
;

/* 
 * COMMA"," precedence: 110, 111
 */
//CommaExpression returns Expr hidden(WS,SL_COMMENT):
//  ConditionalAndExpression
//  ({ConditionExpression.left=current} op=BAR right = ConditionalAndExpression )*
//;

/*
 * There is also another rule that looks for 'or' which is PredicateOr,
 * this version is used in a general expression and the other version is
 * used when we know we have a predicate.
 * "or", precedence: 200, 201
 */
OrExpression returns Expr hidden(WS,SL_COMMENT):
  AndExpression
  ( {AndExpression.left=current} op='or' right = AndExpression)*
;

/*
 * There is also another rule that looks for 'and' which is PredicateAnd,
 * this version is used in a general expression and the other version is
 * used when we know we have a predicate.
 * "and", precedence: 250, 251
 */
AndExpression returns Expr hidden(WS,SL_COMMENT):
  InnerProdExpression
  ( {InnerProdExpression.left=current} op='and' right = InnerProdExpression)*
;

/*
 * This has multiple uses such as inner product and logical or.
 * 
 * "\/", BACKSLASHSLASH precedence: 200, 201
 * 
 * the backslash is duplicated here because it is the escape character for
 * strings, it will not be duplicated when used. 
 */
InnerProdExpression returns Expr hidden(WS,SL_COMMENT):
  OuterProdExpression
  ( {InnerProdExpression.left=current} op=BACKSLASHSLASH right = OuterProdExpression)*
;

/*
 * This has multiple uses such as outer product and logical and.
 * 
 * "/\", SLASHBACKSLASH precedence: 250, 251
 * 
 * the backslash is duplicated here because it is the escape character for
 * strings, it will not be duplicated when used. 
 */
OuterProdExpression returns Expr  hidden(WS,SL_COMMENT):
  HasExpression
  ( {OuterProdExpression.left=current} op=SLASHBACKSLASH right = HasExpression)*
;

/* Predicate which returns true if preceding value is of a given type
 * example:
 * if R has Field then ..
 * 
 * "has", precedence: 400, 400
 */
HasExpression returns Expr hidden(WS,SL_COMMENT):
  CaseExpression
  ({HasExpression.left=current} op='has' rightType = TypeExpression)*
;

/* Select from Union values 
 * example:
 * if myUnion case mtType then ... 	
 * 
 * "case", precedence: 400, 400
 */
CaseExpression returns Expr hidden(WS,SL_COMMENT):
  EqualityExpression
  ( {CaseExpression.left=current} op='case' right = EqualityExpression)?
;

/* used in list comprehension
 * 
 * "in", precedence: 400, 400
 */
/*InExpression returns Expr hidden(WS,SL_COMMENT):
  RelationalExpression
  ( {CaseExpression.left=current} op='in' right = RelationalExpression)?
;*/

/* 
 * "~=", precedence: 400, 400
 * "^=", precedence: 400, 400
 * "=", precedence: 400, 400
 */
EqualityExpression returns Expr hidden(WS,SL_COMMENT):
  RelationalExpression
// ambiguous because EQ can be in top level expression
  ( {EqualityExpression.left=current}( op=EQUAL | op=NOTEQUAL | op='^=') right = RelationalExpression)*
;

/* 
 * ">=", precedence: 400, 400
 * "<=", precedence: 400, 400
 * ">>", precedence: 400, 400
 * "<<", precedence: 400, 400
 * ">", precedence: 400, 400
 * "<", precedence: 400, 400
 */
RelationalExpression returns Expr hidden(WS,SL_COMMENT):
  IsExpression
  ( {RelationalExpression.left=current}
  	( op=LT | op=GT | op=LE | op=GE )
      right = IsExpression
  )?
;

/* 
 * 
 * "isnt", precedence: 400, 400
 * "is", precedence: 400, 400
 */
IsExpression returns Expr hidden(WS,SL_COMMENT):
  SegmentExpression
  ({IsExpression.left=current} (op='is' | op='isnt') rightType = TypeExpression)*
;

/* 
 * "..", "SEGMENT",  precedence: 401, 699, ["parse_Seg"]
 */
SegmentExpression returns Expr hidden(WS,SL_COMMENT):
  AdditiveExpression
  ( {SegmentExpression.left=current} op=SEG right = AdditiveExpression)*
;

/*
 * add expression
 * we include both '+' and '-' in the same case as this allows a
 * multiple sequence like:
 * a + b + c - d + e -f
 * 
 * "-",  precedence: 700, 701
 * "+",  precedence: 700, 701
 */
AdditiveExpression returns Expr hidden(WS,SL_COMMENT):
  ExquoExpression
  ( {AdditiveExpression.left=current} ( op=PLUS | op=MINUS ) right = ExquoExpression)*
;

/* 
 * "exquo",  precedence: 800, 801
 */
ExquoExpression returns Expr hidden(WS,SL_COMMENT):
  DivisionExpression
  ({ExquoExpression.left=current} op='exquo' right = DivisionExpression)*
;

/*
 * division expression
 * "/",  precedence: 800, 801
 */
DivisionExpression returns Expr hidden(WS,SL_COMMENT):
  QuoExpression
  ( {DivisionExpression.left=current} op=SLASH right = QuoExpression)*
;

/* 
 *"quo",  precedence: 800, 801
 */
QuoExpression returns Expr hidden(WS,SL_COMMENT):
  ModExpression
  ({QuoExpression.left=current} op='quo' right = ModExpression)*
;

/* 
 *"mod",  precedence: 800, 801
 */
ModExpression returns Expr hidden(WS,SL_COMMENT):
  RemExpression
  ({ModExpression.left=current} op='mod' right = RemExpression)*
;

/* 
 *"rem", precedence: 800, 801
 */
RemExpression returns Expr hidden(WS,SL_COMMENT):
  MultiplicativeExpression
  ({RemExpression.left=current} op='rem' right = MultiplicativeExpression)*
;

/*
 * multiplication expression
 * a * b * c
 * 
 * "*", precedence: 800, 801
 */
MultiplicativeExpression returns Expr hidden(WS,SL_COMMENT):
  ExponentExpression
  ( {MultiplicativeExpression.left=current} op=TIMES  right = ExponentExpression)*
;

/* 
 *
 * "^", precedence: 901, 900
 * "**", precedence: 901, 900
 */
ExponentExpression returns Expr hidden(WS,SL_COMMENT):
  MapDefinition
  ({ExponentExpression.left=current} (op=CARAT | op=POWER) right = MapDefinition)*
;

/* Map or Lambda expression
 * var +-> function 	
 * 
 * +-> is an infix operator meaning 'maps-to'
 * It can be used to create a function literal (an anonymous function), so
 * instead of:
 * myFunct(x:Type):Type == if x >0 then x else -x
 * we can have forms such as:
 * x +-> if x >0 then x else -x
 * or:
 * (x,y) +-> if x >0 then y else -x
 * 
 * fricas compatibility:
 * "+->", precedence: 995, 112
 */
MapDefinition returns Expr hidden(WS,SL_COMMENT):
//  (PretendExpression | LPAREN PretendExpression (COMMA t25+=PretendExpression)+ RPAREN)
  PretendExpression
  ({MapDefinition.left=current} op=GIVES right = PretendExpression)*
;

/*
 * pretend Type: treat one type as another,
 * only works if they have the same internal structure.
 * 
 * Not very safe and should be avoided, if possible, unfortunately
 * its not always possible to avoid.
 * 
 * "pretend", precedence: 995, 996
 */
 PretendExpression returns Expr hidden(WS,SL_COMMENT):
  HintTypeExpression
  ({PretendExpression.left=current} op='pretend' rightType = TypeExpression)*
;

/* 
 * "@", precedence: 996, 997
 */
HintTypeExpression returns Expr hidden(WS,SL_COMMENT):
  CoerceExpression
  ( {HintTypeExpression.left=current} op=AT rightType = TypeExpression)?
;

/* 
 * "::", precedence: 996, 997
 */
CoerceExpression returns Expr hidden(WS,SL_COMMENT):
  EltExpression
  ({CoerceExpression.left=current} op=COERCE rightType = TypeExpression)*
;

/* We treat these as part of the language
 * : indicates type
 * ! is part of name to indicate mutable
 * 
 * ":", precedence: 996, 997
 * "!", precedence: 1002, 1001
 *
 */
/*BangExpression returns Expr hidden(WS,SL_COMMENT):
  EqualityExpression
  ({AndExpression.left=current} op=AMPERSAND right = EqualityExpression)*
;*/

/* 
 * "with",  precedence: 2000, 400, ["parse_InfixWith"]
 *
 */
/*WithExpression returns Expr hidden(WS,SL_COMMENT):
  EqualityExpression
  ({AndExpression.left=current} op='with' right = EqualityExpression)*
;*/


/* Elt is Lisp terminology for the use of '.' to select parameters
 * the left expression is something that has selectable elements such as
 * a list, array, string, Record or union, the right element should be a
 * non-negative integer.
 */
EltExpression returns Expr hidden(WS,SL_COMMENT):
  ExplicitTypeExpression
  ( {EltExpression.left=current}
  	 op=DOT right = ExplicitTypeExpression
  )*
;

////////////// unary expressions ////////////////////


/* 
 * '$'
 */
ExplicitTypeExpression returns Expr hidden(WS,SL_COMMENT):
  UnaryExpression
  ({ExplicitTypeExpression.left=current} op=DOLAR rightType = TypeExpression)?
;

/* UnaryExpression
 * "~" TILDE : precedence  260, 259, nil
 * ":" COLON : precedence  194, 195
 * "-" MINUS : precedence  701, 700
 * "#" HASH : precedence  999, 998
 * "'" : precedence  999, 999, ["parse_Data"]
 */
UnaryExpression returns Expr hidden(WS,SL_COMMENT):
  PrimaryExpression |
  ({UnaryExpression} uop=TILDE expr=UnaryExpression) |
  ({UnaryExpression} uop=COLON expr=UnaryExpression) |
  ({UnaryExpression} uop=MINUS expr=UnaryExpression) |
  ({UnaryExpression} uop=HASH expr=UnaryExpression) |
  ({UnaryExpression} uop='not' expr=PrimaryExpression) |
   e2=PERCENT |
  e3='Type' |
  e5='Record' LPAREN e6=TypeExpression
               (COLON e22+=TypeExpression)?
               (COMMA e21+=TypeExpression (COLON e23+=TypeExpression)?)*
                RPAREN |
  e9='Union' LPAREN e10=TypeExpression
              (COLON e25+=TypeExpression)?
              (COMMA e24+=TypeExpression (COLON e26+=TypeExpression)?)*
              RPAREN |
  e11='Join' LPAREN e12=TypeExpression (COMMA e13+=TypeExpression)* RPAREN
;

/* 
 *
 */
/*UnaryExpressionHash returns Expr hidden(WS,SL_COMMENT):
//  HASH? PrimaryExpression
  PrimaryExpression | ({UnaryExpressionHash} uop=HASH expr=UnaryExpressionHash)
;*/

/* 
 *
 */
PrimaryExpression returns Expr hidden(WS,SL_COMMENT):
  PrimaryPrefix /* ( t2+=PrimarySuffix )*    */
;

/* 
 * Can contain an expression in parenthesis, this expression is
 * 'StatementExpression' which means that it can contain an
 * inner assignment.
 * 
 * The comma option allows us to define a tuple
 */
PrimaryPrefix hidden(WS,SL_COMMENT):
 Literal
 | LPAREN t4=StatementExpression (COMMA t25+=Expression)* RPAREN
 | t7=NameOrFunctionCall
;

/* function call such as List(Integer)
 * known as a parameterised type or functor (not necessarily a true functor since
 * it may not obey the axioms of a functor)
 * if there is only one parameter then the parenthesis are optional
 * 
 * function binds most tightly
 */
NameOrFunctionCall hidden(WS,SL_COMMENT):
  fnname=ID (=> lsp=DOLAR 'Lisp'/*t2=TypeExpression*/)?
  //  option for parameters in parenthesis
  ((LPAREN t4=StatementExpression? (COMMA t5+=Expression)* RPAREN)
  // optional curried function:
  (LPAREN t14+=StatementExpression? (COMMA t15+=Expression)* RPAREN)*
  // option of no parenthesis for single parameter
  | => t6=PrimaryExpression)?
;

/* Literals are actual values of a given type 
 * Outstanding issues:
 * 1) Float literals are parsed as elt(Int,Int) so we need to recognise this
 *    and convert to float literal
 * 2) We need to be able to recognise exponent notation for floats
 * 3) Integers without '-' prefix can be converted to PI or NNI
 * 4) need to add hex or octal notation for integers (0xhhhh)
 * 5) String and Character literals need to have backslash "\" doubled to
 *    "\\" otherwise xtext will interpret backslash as an escape character.
 * 6) values following immediately after string literal such as "abc"d should
 *    represent an implied concat: concat("abc",d)
 */
Literal hidden(WS,SL_COMMENT):
  value=INT
  | t2=STRING
//  | t3=FloatLiteral // conflicts with use of '.' for elt
  | ListLiteral
  | CharacterLiteral
  | BooleanLiteral
;

/* Contains a single character whereas a string contains multiple
 * characters.
 */
CharacterLiteral hidden(WS,SL_COMMENT):
 "'" c1=ANY_OTHER "'"
;

/* This may not need to be specified here at the syntax level. Perhaps we
* should treat boolean as any other library defined type.
*/
BooleanLiteral hidden(WS,SL_COMMENT):
 litname = 'true' | litname = 'false'
;

/*
 * a list literal may consist of:
 * [] an empty list
 * [a] a single element
 * [a,b] multiple elements
 * [a for b in c] a list comprehension
 */
ListLiteral hidden(WS,SL_COMMENT):
 litname = LBRACKET l2=Expression?
     (COMMA t3+=Expression)*
     ('for' t14+=Expression 'in' l5+=Expression)?
     RBRACKET
;

